<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog</title>
  
  
  <link href="/Blog/atom.xml" rel="self"/>
  
  <link href="http://yexiaorain.github.io/Blog/"/>
  <updated>2022-06-28T02:50:31.934Z</updated>
  <id>http://yexiaorain.github.io/Blog/</id>
  
  <author>
    <name>Xiao Ye</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Atcoder arc143</title>
    <link href="http://yexiaorain.github.io/Blog/2022-06-27-ac_arc143/"/>
    <id>http://yexiaorain.github.io/Blog/2022-06-27-ac_arc143/</id>
    <published>2022-06-26T20:25:14.000Z</published>
    <updated>2022-06-28T02:50:31.934Z</updated>
    
    <content type="html"><![CDATA[<p>D(dfs,无向图无桥联通块,强连通分量)</p><p>哎 超时8min过了E,但这个D我还是不会</p><h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><p>评分2229</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://atcoder.jp/contests/arc143/tasks/arc143_d" target="_blank" rel="noopener">https://atcoder.jp/contests/arc143/tasks/arc143_d</a></p><p>左边1-n的点</p><p>右边1-n的点</p><p>左i-右i有边</p><p>给你m对数 (ai,bi), 你需要输出长度为m的0/1字符串</p><p>如果你要(左ai-右bi) 则第i个字符为0, 如果你要(左bi-右ai)则第i个字符是1</p><p>最终让图里的桥最少, 求一个字符串方案</p><h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h3><p>n 2e5</p><p>m 2e5</p><p>2s</p><p>1024mb</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h3><p>只想着贪心</p><p>首先如果一个边在任意环里那它就不是桥, 所以希望能贪心尽量让边进入环</p><p>统计给的m对数中, 每个值出现的次数</p><p>对于只出现一次的无药可救,先不管它</p><p>对于出现2次的,那就安排让它左右各连出一个</p><p>如果运算过程中某个点一侧被连了,另一侧没有连,还有关于这个点的数对,那么就去连另一测</p><p>已经两侧都连了的就不管</p><hr><p>但就写的来看似乎有问题, 还蛮多人过了这个题</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><blockquote><p>一句话 把它当成一个未定向的有向图， 然后在图上找环， 并定向即可</p></blockquote><p>首先考虑一个n个点, m边的无向图, 按照ai-bi的连接</p><p>如果有边在无向图中也是桥, 那么在题目问题中它只能是桥</p><p>对于无向图来说,移除了所有桥以后, 每个连通块可以单独独立处理</p><p>所以假设 拿到一个无向连通 无桥图</p><p>总有办法给所有边一个方向,让连通图变成强联通图</p><p>一个办法就是 直接做dfs树</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/arc143/submissions/32806181" target="_blank" rel="noopener">https://atcoder.jp/contests/arc143/submissions/32806181</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define pb push_backint read(){int r;scanf(&quot;%intd&quot;,&amp;r);return r;} // readint n;int m;char s[200010]; // answerpair&lt;int,int&gt; ab[200010];vector&lt;array&lt;int,3&gt;&gt; u2[200010]; // {v, ab idx, &#39;0&#39;,&#39;1&#39;}bool vis[200010];void dfs(int u){  vis[u] = true;  for(auto [v,i,o]:u2[u]){    if(s[i]) continue; // 边处理过    s[i] = (char)o;    if(!vis[v]) dfs(v);  }}int main(){  n = read();  m = read();  rep(i,0,m) ab[i].first = read();  rep(i,0,m){    int a = ab[i].first;    int b = ab[i].second = read();    u2[a].pb({b,i,(int)&#39;0&#39;});    u2[b].pb({a,i,(int)&#39;1&#39;});  }  rep(i,1,n+1){    if(vis[i])continue;    dfs(i);  }  rep(i,0,m){    if(!s[i]) s[i] = &#39;0&#39;;  }  printf(&quot;%s\n&quot;,s);  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>D</p><p>知道逻辑以后 10min 随便写了QAQ</p><p>我不知道应该怎么归类,信息提取,还是有向图无向图连通性质</p><p>我觉得有一点 算是 无向图的无桥联通块 能通过指定所有边 变成有向图的强连通分量这一点吧,但好像又是一个提炼性质</p><p>哎</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://atcoder.jp/contests/arc143/editorial/4210" target="_blank" rel="noopener">官方题解</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;D(dfs,无向图无桥联通块,强连通分量)&lt;/p&gt;
&lt;p&gt;哎 超时8min过了E,但这个D我还是不会&lt;/p&gt;
&lt;h1 id=&quot;D&quot;&gt;&lt;a href=&quot;#D&quot; class=&quot;headerlink&quot; title=&quot;D&quot;&gt;&lt;/a&gt;D&lt;/h1&gt;&lt;p&gt;评分2229&lt;/p&gt;
&lt;h2 i
      
    
    </summary>
    
      <category term="Atcoder" scheme="http://yexiaorain.github.io/Blog/categories/Atcoder/"/>
    
    
      <category term="dfs" scheme="http://yexiaorain.github.io/Blog/tags/dfs/"/>
    
      <category term="无向图无桥联通块" scheme="http://yexiaorain.github.io/Blog/tags/%E6%97%A0%E5%90%91%E5%9B%BE%E6%97%A0%E6%A1%A5%E8%81%94%E9%80%9A%E5%9D%97/"/>
    
      <category term="强连通分量" scheme="http://yexiaorain.github.io/Blog/tags/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 1696</title>
    <link href="http://yexiaorain.github.io/Blog/2022-06-26-CF1696/"/>
    <id>http://yexiaorain.github.io/Blog/2022-06-26-CF1696/</id>
    <published>2022-06-26T14:24:00.000Z</published>
    <updated>2022-06-28T02:50:31.934Z</updated>
    
    <content type="html"><![CDATA[<p>G(线性规划,对偶,dp,矩阵乘法,segtree)</p><h1 id="G"><a href="#G" class="headerlink" title="G"></a>G</h1><p><a href="https://codeforces.com/contest/1696/problem/G" target="_blank" rel="noopener">https://codeforces.com/contest/1696/problem/G</a></p><p>给一个长n数列</p><p>q个操作或询问</p><ol><li>操作修改 a[i] = v</li><li>询问[l,r] 区间上, 最小处理代价(不真实的修改区间)</li></ol><p>f(l,r) = 每次可以对 相邻元素,分别 (-xt,-yt) 或(-yt,-xt) 代价为t</p><p>问最小代价和让 a[l..r] 全部小于等于0</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>n 2e5</p><p>q 2e5</p><p>x,y [1,1e6]</p><p>ai, v [1,1e6]</p><p>6s</p><p>1024MB</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>因为对称,不妨设 ( x &lt; y)</p><p>开始没看到相邻以为任意,那么不就是维护区间和与区间最大值 = max(和/(x+y),最大值/y)</p><p>但是要相邻这样肯定不对了, 比如样例1, 不相邻可以3,相邻最少要3.5</p><hr><p>单次询问怎么做?</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><h3 id="线性规划对偶"><a href="#线性规划对偶" class="headerlink" title="线性规划对偶"></a>线性规划对偶</h3><p><a href="https://pic1.zhimg.com/80/v2-b780de4a3bd814944026ad22f51518f8_720w.jpg" target="_blank" rel="noopener">https://pic1.zhimg.com/80/v2-b780de4a3bd814944026ad22f51518f8_720w.jpg</a></p><p>$max \sum c_j x_j$</p><p>限制</p><p>$a_{ij} x_{j} \le b_i$</p><p>$x_j \ge 0$</p><p>$i=1\cdots m,j=1\cdots n$</p><p>它的对偶问题</p><p>$min \sum b_i y_i$</p><p>限制</p><p>$a_{ij} y_{i} \ge c_i$</p><p>$y_i \ge 0$</p><p>$i=1\cdots m,j=1\cdots n$</p><hr><p>我看了很多直觉的举例,反而没有理解,通过公式倒是理解了大流程, 下面youtube链接 感觉很清晰</p><p>小写字母表示列向量,大写字母表示矩阵</p><p>$max (c^Tx)$</p><p>$Ax \le b$</p><p>$x \ge 0$</p><p>对于任意$y \ge 0$满足</p><p>$c^Tx \le y^TAx$</p><p>有 $c^Tx \le y^TAx \le y^Tb$, 所以所有都满足,那么它的最大 = 右边的最小</p><p>所以对于所有$c^T \le y^TA$, $max(c^Tx) = min(y^Tb)$</p><p>$c^T \le y^TA$ 即是$Ay \ge c$</p><hr><p>更一般的转化</p><ol><li><p>min max 对换</p></li><li><p>列个数x 变成行个数y</p></li><li><p>右侧约束 和 表达式系数 兑换</p></li><li><p>偏序关系</p></li></ol><p>同偏序: max 变量(xi) 与 0关系 和 min 约束(不等式组xi) 左与右 关系</p><p>反偏序: min 变量(xi) 与 0关系 和 max 约束(不等式组xi) 左与右 关系</p><p>约束等于 对应 变量无约束</p><h2 id="回到题目"><a href="#回到题目" class="headerlink" title="回到题目"></a>回到题目</h2><p>线性规划 问题</p><p>原数组A</p><p>最小化  $\sum_{1\le i &lt; n} a_i+b_i $</p><p>限制</p><p>$Xa_1+Yb_1\ge A_1$</p><p>$Xa_i+Yb_i+Ya_{i-1}+Xb_{i-1}\ge A_i (2\le i &lt; n) $</p><p>$Ya_{n-1}+Xb_{n-1}\ge A_n $</p><p>$a_i,b_i\ge 0$</p><hr><p>那么对偶</p><p>最大化 $\sum_{1\le i \le n} A_iz_i $</p><p>限制</p><p>$xz_i + yz_{i+1} \le 1 (1 \le z &lt; n)$</p><p>$yz_i + xz_{i+1} \le 1 (1 \le z &lt; n)$</p><p>$z_i \ge 0$</p><p>很好的把上面要求的所有系数1变成了右侧的限制</p><hr><p>所以$z_i$ 可能取值$0,\frac{1}{y},\frac{1}{x+y}$</p><p>如果只有两个, 线性规划很明显 <a href="https://www.wolframalpha.com/input?i=2x%2B3y+%3C%3D+1%2C+2y%2B3x+%3C%3D+1" target="_blank" rel="noopener">https://www.wolframalpha.com/input?i=2x%2B3y+%3C%3D+1%2C+2y%2B3x+%3C%3D+1</a></p><p>去画3个的3d情况,你会发现,和2d一样虽然有些棱,但如果这个棱上最优,那么棱上的顶点也最优,但这些凸点的坐标都是这三个可能值中</p><hr><p>然后就可以dp了</p><p><code>dp[i][0/1/2]</code>, 即是算 $max \sum_{j \le i} A_jz_j$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>jiangly 的, 他整个G只花了15min??????</p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_back#define SEG_ROOT 1,0,n#define mid (l+r)/2#define SEG_L 2*p#define SEG_R 2*p+1#define SEG_L_CHILD SEG_L,l,mid#define SEG_R_CHILD SEG_R,mid,rll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readint n;int a[200010];template&lt;class Info,  class Merge = plus&lt;Info&gt; // 合并方法  &gt;  struct SegmentTree {    const int n;    const Merge merge;    vector&lt;Info&gt; info;    SegmentTree(int n) : n(n), merge(Merge()), info(4*n) {}    SegmentTree(vector&lt;Info&gt; init) : SegmentTree(init.size()) {      function&lt;void(int, int, int)&gt; build = [&amp;](int p, int l, int r) { // [l,r) 左闭右开        if (r - l == 1) { // 线段树叶子节点          info[p] = init[l];          return;        }        build(SEG_L_CHILD);        build(SEG_R_CHILD);        pull(p);      };      build(SEG_ROOT);    }    void pull(int p) {      info[p] = merge(info[SEG_L], info[SEG_R]);    }    void modify(int p, int l, int r, int x, const Info &amp;v) {      if (r - l == 1) {        info[p] = v;        return;      }      if (x &lt; mid) {        modify(SEG_L_CHILD, x, v);      } else {        modify(SEG_R_CHILD, x, v);      }      pull(p);    }    void modify(int p, const Info &amp;v) {      modify(SEG_ROOT, p, v);    }    Info rangeQuery(int p, int l, int r, int x, int y) {      if (l &gt;= y || r &lt;= x) return Info(); // 直接省去范围判断, 超过范围提前 返回可参与计算的空状态      if (l &gt;= x &amp;&amp; r &lt;= y) return info[p];      return merge(rangeQuery(SEG_L_CHILD, x, y), rangeQuery(SEG_R_CHILD, x, y));    }    Info rangeQuery(int l, int r) {      return rangeQuery(SEG_ROOT, l, r);    }  };int x, y;// 0: 0// 1: 1/(x+y)// 2: 1/y// 线段树每个节点struct Info {  double f[3][3];  Info(ll v = 0) {    rep(i,0,3){      rep(j,0,3){        if (i + j &gt; 2) {          f[i][j] = -1E18; // 不合法        } else { // 这里直接 值 * z_i(0,1/(x+y),1/y), 因为转移方程里始终要乘 值          f[i][j] = (j == 0 ? 0.0 : 1.0 * v / (j == 1 ? x + y : y));        }      }    }  }};// 实现合并方法Info operator+(const Info &amp;a, const Info &amp;b) {  Info c;  rep(i,0,3){    rep(j,0,3){      c.f[i][j] = -1E18; // 不合法      rep(k,0,3){        // max 矩阵乘法        c.f[i][j] = max(c.f[i][j], a.f[i][k] + b.f[k][j]);      }    }  }  return c;}int main() {  int n = read();  int q = read();  x = read();  y = read();  if (x &gt; y) swap(x, y); // 保证 x&lt;=y  vector&lt;int&gt; b(n);  rep(i,0,n) b[i] = read();  SegmentTree seg(vector&lt;Info&gt;(b.begin(), b.end())); // v =&gt; Info(v) =&gt; segtree(vector&lt;info()&gt;)  while(q--) {    int t = read();    if (t == 1) {      int k = read() - 1;      int v = read();      seg.modify(k, v);    } else {      int l = read() - 1;      int r = read();      auto info = seg.rangeQuery(l, r) + Info(); // + Info() 整合最大值,否则需要手动for 去取max      printf(&quot;%.15lf\n&quot;,info.f[0][0]);    }  }  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>G</p><p>低分题做多了, 太久没遇到线性规划了,很久以前学过, 但好像也是系数多限制多变量少的,</p><p>然后这个对偶学了一下, 希望下次能有用到的地方???</p><p>最后转化可以描述为矩阵max乘法,可以用segtree维护</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://codeforces.com/blog/entry/103479" target="_blank" rel="noopener">官方</a></p><p><a href="https://sites.math.washington.edu/~burke/crs/407/notes/section3.pdf" target="_blank" rel="noopener">https://sites.math.washington.edu/~burke/crs/407/notes/section3.pdf</a></p><p><a href="https://www.youtube.com/watch?v=yU8updOR87c" target="_blank" rel="noopener">https://www.youtube.com/watch?v=yU8updOR87c</a></p><p><a href="https://blog.csdn.net/qq_43539633/article/details/109150749" target="_blank" rel="noopener">https://blog.csdn.net/qq_43539633/article/details/109150749</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;G(线性规划,对偶,dp,矩阵乘法,segtree)&lt;/p&gt;
&lt;h1 id=&quot;G&quot;&gt;&lt;a href=&quot;#G&quot; class=&quot;headerlink&quot; title=&quot;G&quot;&gt;&lt;/a&gt;G&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/
      
    
    </summary>
    
      <category term="Codeforces" scheme="http://yexiaorain.github.io/Blog/categories/Codeforces/"/>
    
    
      <category term="dp" scheme="http://yexiaorain.github.io/Blog/tags/dp/"/>
    
      <category term="线性规划" scheme="http://yexiaorain.github.io/Blog/tags/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/"/>
    
      <category term="对偶" scheme="http://yexiaorain.github.io/Blog/tags/%E5%AF%B9%E5%81%B6/"/>
    
      <category term="矩阵乘法" scheme="http://yexiaorain.github.io/Blog/tags/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/"/>
    
      <category term="segtree" scheme="http://yexiaorain.github.io/Blog/tags/segtree/"/>
    
  </entry>
  
  <entry>
    <title>Atcoder abc257</title>
    <link href="http://yexiaorain.github.io/Blog/2022-06-25-ac_abc257/"/>
    <id>http://yexiaorain.github.io/Blog/2022-06-25-ac_abc257/</id>
    <published>2022-06-24T20:25:14.000Z</published>
    <updated>2022-06-28T02:50:31.934Z</updated>
    
    <content type="html"><![CDATA[<p>D(正确读题就能做)G(kmp+DP)Ex(TODO)</p><h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><p>天天卡D我服了,EF都过了就是卡D</p><p>题解这次出得好慢</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://atcoder.jp/contests/abc257/tasks/abc257_d" target="_blank" rel="noopener">https://atcoder.jp/contests/abc257/tasks/abc257_d</a></p><p>平面n个点</p><p>每个点一个倍率Pi</p><p>每个点可到达 PiS 曼哈顿距离以内的点</p><p>问最小的整数S让 可以选择某一点, 让其它点都可从此点跳跃到达,(不需要一次路径)</p><h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h3><p>n 200</p><p>坐标 x,y [-1e9,1e9]</p><p>p [1..1e9]</p><p>3s</p><p>1024mb</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h3><p>一眼 二分答案+tarjan+拓扑排序</p><p>关键这是abc的D题不应该,而且N也就200</p><p>不会这么难, 想不出啊,接近2k人比赛里过了,心态有点炸,还好跳了去做了EF,而且本来abc我也不算分了</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>不要读错题,</p><p>我读成选点 跳跃经过所有点</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>无</p><h1 id="G"><a href="#G" class="headerlink" title="G"></a>G</h1><p><a href="https://atcoder.jp/contests/abc257/tasks/abc257_g" target="_blank" rel="noopener">https://atcoder.jp/contests/abc257/tasks/abc257_g</a></p><p>两个只有小写字母的字符串S,T</p><p>让T 为 S的k个前缀的拼接</p><p>求最小的k 或报不可能</p><h2 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h2><p>|S| 5e5</p><p>|T| 5e5</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><h3 id="我的想法"><a href="#我的想法" class="headerlink" title="我的想法"></a>我的想法</h3><p>一眼像是kmp,但kmp写得真的少,</p><p>而且不确定kmp 怎么具体做,去计算t每个位置作为起始的最大长度</p><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>dp[i] = T[0..i] 和S匹配的答案</p><p>如果 T[i-p…i] == S[1..p], 那么有 dp[i] = min(dp[i-p]+1), p 可能有多种, 没有答案就INF</p><p>单调性</p><p>dp[i] &lt;= dp[i+1]</p><p>否则你把 dp[i+1]的方案中最后一个字符去掉,dp[i] 就能变小</p><p>因此你只需要关心最长的前缀匹配</p><hr><p>终究还是来到了kmp</p><p>经典的# 拼接</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p><a href="https://atcoder.jp/contests/abc257/submissions/32786655" target="_blank" rel="noopener">https://atcoder.jp/contests/abc257/submissions/32786655</a></p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 1000000007#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readclass KMP {  private :    vector&lt;int&gt; f; // 比它小的最长前缀的长度    char *s;    int sz;  public:    KMP(char *s,int sz):s(s),sz(sz){      f = vector&lt;int&gt;(sz,0);      int fa = 0;      rep(i,1,sz){        while (fa &amp;&amp; s[i] != s[fa]) fa = f[fa-1];        if (s[i] == s[fa]) fa++;        f[i] = fa;      }    }    vector&lt;int&gt; getPrefixLen(){      return f;    }    int posIn(char *t,int szt) {      int fa = 0;      rep(i,0,szt) {        while (fa &amp;&amp; t[i] != s[fa]) fa = f[fa-1];        if (t[i] == s[fa]) fa++;        if (fa == sz) return i-fa+1;      }      return -1;    }};char s[1000010];int ns;int nt;const int INF = 0x3f3f3f3f;int main(){  scanf(&quot;%s&quot;,s);  int ns = strlen(s);  s[ns] = &#39;#&#39;;  scanf(&quot;%s&quot;,s+ns+1);  int nt = strlen(s+ns+1);  int n = ns+1+nt;  vector&lt;int&gt; dp(nt+1,INF);  dp[0] = 0;  KMP kmp(s, n);  auto pl = kmp.getPrefixLen();  // rep(i,0,nt){  //   printf(&quot;%lld: %d\n&quot;,i,pl[i+ns+1]);  // }  rep(i,1,nt+1){    dp[i] = dp[i-pl[i+ns]]+1;    // printf(&quot;dp[%lld] = %d\n&quot;,i,dp[i]);  }  printf(&quot;%d\n&quot;, dp[nt] &gt;= INF?-1:dp[nt]);  return 0;}// k 个S前缀拼成 T// KMP?</code></pre><h1 id="Ex"><a href="#Ex" class="headerlink" title="Ex"></a>Ex</h1><p><a href="https://atcoder.jp/contests/abc257/tasks/abc257_h" target="_blank" rel="noopener">https://atcoder.jp/contests/abc257/tasks/abc257_h</a></p><p>n个6面dice,每个上面6个给定数字, 每个价格Ci</p><p>恰好买k个,</p><p>求期望sum(扔的数字)^2 - sum(价格) 最大</p><p>输出 mod 998244353</p><h2 id="范围-2"><a href="#范围-2" class="headerlink" title="范围"></a>范围</h2><p>n 1e3</p><p>k [1..N]</p><p>ci [1,1e5]</p><p>aij [1,1e5]</p><h2 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h3><p>先期望转化</p><p>E((?+xi)^2 - Ci) - E(?^2)</p><p>= E(?^2+2?xi+xi^2) - Ci - E(?^2)</p><p>= E(xi^2) - Ci + 2?E(xi)</p><p>看起来是?的线性函数, 不知道这个是否有局部性可以贪心, 或者<code>dp[前i][用了k] = {E(ans),E?}</code></p><h3 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h3><p>只有一个日文的 <a href="https://atcoder.jp/contests/abc257/editorial/4168" target="_blank" rel="noopener">https://atcoder.jp/contests/abc257/editorial/4168</a></p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>D</p><p>读错题好难受啊</p><p>G</p><p>然后我也更新了一下我的kmp板子多加了个外置函数</p><p>Ex</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://cp-algorithms.com/string/prefix-function.html" target="_blank" rel="noopener">KMP</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;D(正确读题就能做)G(kmp+DP)Ex(TODO)&lt;/p&gt;
&lt;h1 id=&quot;D&quot;&gt;&lt;a href=&quot;#D&quot; class=&quot;headerlink&quot; title=&quot;D&quot;&gt;&lt;/a&gt;D&lt;/h1&gt;&lt;p&gt;天天卡D我服了,EF都过了就是卡D&lt;/p&gt;
&lt;p&gt;题解这次出得好慢&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="Atcoder" scheme="http://yexiaorain.github.io/Blog/categories/Atcoder/"/>
    
    
      <category term="dp" scheme="http://yexiaorain.github.io/Blog/tags/dp/"/>
    
      <category term="kmp" scheme="http://yexiaorain.github.io/Blog/tags/kmp/"/>
    
  </entry>
  
  <entry>
    <title>Atcoder arc142</title>
    <link href="http://yexiaorain.github.io/Blog/2022-06-24-ac_arc142/"/>
    <id>http://yexiaorain.github.io/Blog/2022-06-24-ac_arc142/</id>
    <published>2022-06-23T20:25:14.000Z</published>
    <updated>2022-06-28T02:50:31.934Z</updated>
    
    <content type="html"><![CDATA[<p>D(树,dp)</p><h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><p>评分2900,远高于C的难度</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://atcoder.jp/contests/arc142/tasks/arc142_d" target="_blank" rel="noopener">https://atcoder.jp/contests/arc142/tasks/arc142_d</a></p><p>给你一个树,要上面放一些棋子</p><p>每个时间周期,所有棋子要向它相邻的任意一个点移动,确保移动时每条边最大负债1,移动后每个点最多棋子1个</p><p>且保证任意个时间周期的结果唯一</p><p>问所有合法放置方案数</p><h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h3><p>n 2e5</p><p>2s</p><p>1024mb</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h3><p>要唯一,考虑做树上dp</p><p><code>dp[from][to][tofa]</code> 每个点2x2x2=8 最多8个状态</p><p>from表示根原来有或没, to表示移动一次后有或没, tofa表示移动一次以后对父节点是否有贡献</p><p>但转移感觉只有手动推一推, 不知道自动怎么算</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>注意到是唯一的反复跳 <code>u-&gt;v-&gt;u-&gt;v</code></p><p>那么实际上树是由多个不相交的链组成的</p><p>如果分叉角度说</p><p>a-b a-c a-d</p><p>a总有一轮是1, 两轮都是0是不可能的(这样有多个摆放方案</p><p>那么移动一次后一是到b,c,d中的一个</p><p>而下一次会移动回来</p><p>说明a至多和两个位置跳来跳去剩下的就是和a不相关的链了</p><hr><p>那么<code>1110110</code>, 这样的看作两条链</p><p>问题就是如何划分链</p><p>potato167 的blog上画了很多方便理解的图</p><p>注意到每个独立的链都是 <code>111110</code> 的形式, 而不相交的相邻链是 1和0 相临的, 且独立的链最小长度为2</p><p>然后一条链的端点也不能和另一条链的中间点相邻, 但两条链的中点可以相邻</p><p>所以对于一个点来讲,它可以是头0,头1或者中间的1,</p><p>dp上 就考虑根的状态了</p><hr><p>0 端点 ( 另一个端点是这个端点的后代</p><p>1 端点 ( 另一个端点不是这个端点的后代</p><p>2 非端点, 且连接父节点</p><p>3 非端点, 且连接两个子节点</p><p>这里的状态划分也不再关心是端点是0还是1,因为你只需要保证端点之和端点相邻(相邻的端点相互决定),这样只用关心有多少自由端点的个数n即可, $2^n$</p><hr><p>手推4种状态</p><p>0: 1个子节点1/2, 剩余都是0</p><p>1: 所有子节点都是0</p><p>2: 1个子节点1/2, 剩余都是3</p><p>3: 2个子节点1/2, 剩余都是3</p><p>除了状态转移, 还需要统计自由度</p><p>中间的3 和 根的0 会让自由度+1</p><p>自由度+1, 相当于答案乘2, 所以直接统计答案比记录自由度更方便</p><hr><p>计算</p><p>0: </p><p>一种方案是</p><p><code>sum (dp[v][1]+dp[v][2]) * ((sum dp[..][0]) - dp[v][0])</code></p><p><code>sum (dp[v][1]+dp[v][2]) * (sum dp[..][0]) - sum (dp[v][1]+dp[v][2]) *  dp[v][0])</code></p><p><code>(sum1+sum2)*sum0 - sum( (v1+v2)(v0))</code></p><p>另一种按照循环增加的算法是</p><p><code>res = (res * dp[v][0]) + (dp[v][1] + dp[v][2])*(before all 0)</code></p><p>1: all0</p><p>2: 类似0的计算方法 采取循环子节点 的方法</p><p><code>res = (res * dp[v][3]) + (dp[v][1] + dp[v][2])*(before all 3)</code></p><p>3: 相当于双状态转移</p><p><code>res[2个满足子节点] = res[2] * dp3 + (dp1+dp2)*(before res[1])</code></p><p><code>res[1个满足子节点] = res[1] * dp3 + (dp1+dp2)*(before res[0] = before all 3)</code></p><p>最后记得3还要再乘2</p><p>当然注意到 1和2只有过程中的计算才是分开的, 父子之间处理是一起使用的, 还可以降低一个状态,虽然意义不大</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/arc142/submissions/32681890" target="_blank" rel="noopener">https://atcoder.jp/contests/arc142/submissions/32681890</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 998244353#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readvector&lt;int&gt; G[200010];int main() {  int n = read();  rep(i,1,n){    int u = read() - 1;    int v = read() - 1;    G[u].push_back(v);    G[v].push_back(u);  }  vector&lt;int&gt; fa(n,-1); // 父节点?  vector&lt;int&gt; order={0}; // 树上bfs 顺序, 反序就是树上dp  rep(i,0,n) {    int u = order[i];    for(auto v:G[u]){      if(v == fa[u]) continue;      fa[v] = u;      order.push_back(v);    }  }  vector&lt;vector&lt;ll&gt;&gt; dp(n,vector&lt;ll&gt;(4));  per(i,0,n){    int u = order[i];    ll all0 = 1;    ll all3 = 1;    ll pre1 = 0;    for(auto v:G[u]){      if(fa[v]!=u) continue;      ll s12 = (dp[v][1]+dp[v][2])%MOD;      // 0      dp[u][0] = (dp[u][0] * dp[v][0] % MOD + all0 * s12 % MOD)%MOD;      // 2      dp[u][2] = (dp[u][2] * dp[v][3] % MOD + all3 * s12 % MOD)%MOD;      // 3      dp[u][3] = (dp[u][3] * dp[v][3] % MOD + pre1 * s12 % MOD)%MOD;      pre1     = (pre1     * dp[v][3] % MOD + all3 * s12 % MOD)%MOD;      (all0 *= dp[v][0]) %= MOD;      (all3 *= dp[v][3]) %= MOD;    }    // 1    dp[u][1] = all0;    (dp[u][3] *= 2) %= MOD;  }  printf(&quot;%lld\n&quot;,(dp[0][0] * 2 % MOD + dp[0][3])%MOD);}</code></pre><p>如果再压缩1和2的状态</p><pre><code class="cpp">vector&lt;vector&lt;ll&gt;&gt; dp(n,vector&lt;ll&gt;(3)); // 0:0, 1:1&amp;2, 2:3per(i,0,n){  int u = order[i];  ll all0 = 1;  ll all3 = 1;  ll pre1 = 0;  for(auto v:G[u]){    if(fa[v]!=u) continue;    dp[u][0] = (dp[u][0] * dp[v][0] % MOD + all0 * dp[v][1] % MOD)%MOD; // 0    dp[u][1] = (dp[u][1] * dp[v][2] % MOD + all3 * dp[v][1] % MOD)%MOD; // 2    dp[u][2] = (dp[u][2] * dp[v][2] % MOD + pre1 * dp[v][1] % MOD)%MOD; // 3    pre1     = (pre1     * dp[v][2] % MOD + all3 * dp[v][1] % MOD)%MOD;    (all0 *= dp[v][0]) %= MOD;    (all3 *= dp[v][2]) %= MOD;  }  (dp[u][1] += all0) %= MOD; // 1 &amp; 2  (dp[u][2] *= 2) %= MOD;}printf(&quot;%lld\n&quot;,(dp[0][0] * 2 % MOD + dp[0][2])%MOD);</code></pre><h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><p>n 个巫师,</p><p>ai 能力</p><p>打败 bi 怪物</p><p>对任意巫师增加任意次1能力</p><p>(i,j) is good when (a[i] &gt;= bi and a[j] &gt;= bj) or (a[i] &gt;= b[j] and a[j] &gt;= b[i])</p><p>相当于直接打败或交叉打败</p><p>给你m 个 (x,y)</p><p>要最小增加能力, 让所有(x,y) 是good</p><h2 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h2><p>n 100</p><p>ai bi [1,100]</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>如果自己打败自己,那很好算,但是不一定是答案,但是答案上界至少是</p><p>考虑结果总有个每个巫师的大小顺序</p><p>如果<code>(a[i] - a[j])*(b[i]-b[j]) &gt;= 0</code> , 且存在限制 (x,y) = (i,j)</p><p>那么 必然<code>a[i] &gt;= b[i]</code> <code>a[j] &gt;= b[j]</code> , 如果</p><p>因为如果(i,j) good ,也就是 min(a[i],a[j]) &gt;= min(b[i],b[j]) , max(a[i],a[j]) &gt;= max(b[i],b[j]) </p><p>但是n是100 不可能去枚举顺序</p><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>首先, a[x],a[y] &gt;= min(a[x],a[y]) 这是必要的, 所以可以预处理掉这个</p><p>X 为 能力 小于 monter的 集合, 且在(x,y)中出现了的巫师</p><p>Y 是 其它的巫师</p><p>对于(x,y) 且 x属于X, y属于Y, 结果上期望 a[y] &gt;= b[x] 或 a[x] &gt;= b[x]</p><p>因为有预处理, 所以b[x] &gt; b[y], 因为如果 b[x] &lt;= b[y] 那么必然有 a[x] &gt;= min(b[x],b[y]) = b[x],  x不会属于X,</p><p>也就是X-Y的连接, 一定y中的b更小</p><p><code>b[x] &gt; a[x] &gt;= b[y]</code> 的顺序, <code>a[y] &gt;= b[y]</code></p><p>对于Y-Y的连接,不需要考虑,因为a只会增大,原来满足增加后还是满足</p><p>对于X-X的链接,不会存在,因为有了预处理, 这两个a大于min(b), 所以一定有一个属于Y</p><hr><p>回到X-Y</p><p><code>a[y] &gt;= b[x] &gt; a[x] &gt;= b[y]</code> 直接合法</p><p><code>b[x] &gt; (a[x],a[y]) &gt;= b[y]</code> 考虑上面是让<code>a[y] &gt;= b[x]</code> 还是 <code>a[x] &gt;= b[x]</code></p><hr><p>建图</p><p>点:</p><p>S源,T汇</p><p>X每个x一个点</p><p>Y每个y,100个点(y,i = 1..100)</p><p>边</p><p><code>S -&gt; x</code> 权重<code>b[x] - a[x]</code></p><p><code>(y,i) -&gt; T</code> 权重1</p><p><code>(y,i) -&gt; (y,i-1)</code> 权重无限大</p><p><code>x -&gt; (y,b[x] - a[y])</code> 权重无限大</p><hr><p>意义</p><p>先看假设只有一对</p><p><code>S-(bx-ax)-&gt;x-(无限)-&gt; (y, b[x]-a[y])-(1)-&gt; T</code>, 然后还有些<code>(y,i)-&gt;(y,i-1)</code>的边</p><p><code>S-&gt;X</code>这边限制了不会大于<code>bx-ax</code>, 右边限制了不会大于<code>bx-ay</code></p><p>最小割一定是 <code>S-&gt;x</code>和<code>(y,i)-&gt;T</code> 中的边,不会是那些无限的边</p><p>而如果<code>S-&gt;x</code> 不在最小割里,说明右侧对应的<code>(y,b[x]-a[y]) -&gt; T</code>, 以及更小的i的<code>(y,i)</code> 全部填满, 否则可至少可以再+1, 填满也就说明选择满足</p><hr><p>这个最小割的建图,我也是真不会啊(最大流,最小割还是会写)</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p><a href="https://atcoder.jp/contests/arc142/submissions/32759166" target="_blank" rel="noopener">https://atcoder.jp/contests/arc142/submissions/32759166</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // read#define N 100#define INF 0x3f3f3f3fint n,m;int a[N+10];int b[N+10];vector&lt;int&gt; p2[110]; // 双向关系int S = 0;int T = 1;// S,T,[2..101],[102...201][202..301][302..401]//int nodex(int x) {  assert(x &gt;=0 &amp;&amp; x&lt; 100);  return 2+x;}int nodey(int y,int value) {  assert(y &gt;=0 &amp;&amp; y&lt; 100);  assert(value &gt;=1 &amp;&amp; value &lt;= 100);  return 101 + y*100 + value;}class MinCut{  int sz ;  // TODO 优化成正反边下标  vector&lt;unordered_map&lt;int,ll&gt; &gt; G; // {idx,weight}  vector&lt;int&gt; d; // bfs 距离public:  MinCut(int n):sz(n){    G = vector&lt;unordered_map&lt;int,ll&gt; &gt;(sz);  }  void path(int u,int v,ll w){    assert(u != v);    G[u][v] += w;  }  int dfs(int u,int en, ll s){    if (u == en)return s;    for(auto [v,w]:G[u]){      if(w == 0) continue;      if(d[v] != d[u]+1) continue;      int r = dfs(v,en,min(s,w));      if(r){        G[u][v] -= r;        G[v][u] += r;        return r;      }    }    d[u] = 0; // 标记无效 替代vis    return 0;  }  bool bfs(int st,int en){    d = vector&lt;int&gt;(sz+10,-1);    vector&lt;int&gt; q = {st};    d[st] = 0;    rep(i,0,q.size()){      int u = q[i];      for(auto [v,w]: G[u]){ // u -&gt; v, weight =w        if(d[v] != -1) continue;        if(w == 0) continue;        d[v] = d[u] +1;        q.pb(v);      }    }    return d[en] &gt;= 0;  }  // 一次性计算  ll calc(int st,int en){    int ans = 0;    while (bfs(st, en)) ans += dfs(st, en, INF);    return ans;  }};int main(){  n = read();  S = 0;  T = 1;  rep(i,0,n){    a[i] = read();    b[i] = read();  }  m = read();  int ans = 0;  // 预处理 和 建边  rep(i,0,m){    int x = read() - 1;    int y = read() - 1;    int minv = min(b[x],b[y]);    ans += max(0,minv - a[x]);    a[x] = max(a[x],minv);    ans += max(0,minv - a[y]);    a[y] = max(a[y],minv);    p2[x].pb(y);    p2[y].pb(x);  }  MinCut mc(20000);  rep(i,0,n) {    if(a[i] &lt; b[i]){ // i in X      mc.path(S,nodex(i),b[i] - a[i]);      for(auto u:p2[i]){ // u in Y        if(a[u] &gt;= b[i]) continue;        mc.path(nodex(i),nodey(u,b[i]-a[u]),INF);      }    }else{ // i in Y      rep(j,1,101){        mc.path(nodey(i,j),T,1);        if(j &gt; 1){          mc.path(nodey(i,j),nodey(i,j-1),INF);        }      }    }  }  printf(&quot;%lld\n&quot;,ans + mc.calc(S,T) );  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>D</p><p>我突然觉得我的<code>dp[from][to][tofa]</code> 是不是也可能可以做?? 看起来是完全不同的思路</p><p>虽然想到反复横跳,但拆成链以及链的链接合法方式完全没想过</p><p>而且即使是拆成链,看了积分代码, 所做的树上dp也不相同, 能拆成这样四个也是很需要功力的</p><p>看potato167的代码学了一手非递归的树上dp, 通过先建立order,再逆序做</p><p>E</p><p>光是这个预处理就很厉害,解决了分类的问题, 能证明但完全没能自己挖掘出这个性质</p><p>然后这个建图我也是不会, 虽然学过最大流最小割,但是为啥这样想,没做过这种, 顺便整两个mincut板子</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://atcoder.jp/contests/arc142/editorial" target="_blank" rel="noopener">官方题解</a></p><p><a href="https://potato167.hatenablog.com/entry/2022/06/21/005732" target="_blank" rel="noopener">potato167 D</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;D(树,dp)&lt;/p&gt;
&lt;h1 id=&quot;D&quot;&gt;&lt;a href=&quot;#D&quot; class=&quot;headerlink&quot; title=&quot;D&quot;&gt;&lt;/a&gt;D&lt;/h1&gt;&lt;p&gt;评分2900,远高于C的难度&lt;/p&gt;
&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerl
      
    
    </summary>
    
      <category term="Atcoder" scheme="http://yexiaorain.github.io/Blog/categories/Atcoder/"/>
    
    
      <category term="dp" scheme="http://yexiaorain.github.io/Blog/tags/dp/"/>
    
      <category term="树" scheme="http://yexiaorain.github.io/Blog/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>June Lunchtime 2022 Division 1</title>
    <link href="http://yexiaorain.github.io/Blog/2022-06-22-LTIME109A/"/>
    <id>http://yexiaorain.github.io/Blog/2022-06-22-LTIME109A/</id>
    <published>2022-06-22T14:24:00.000Z</published>
    <updated>2022-06-28T02:50:31.934Z</updated>
    
    <content type="html"><![CDATA[<p>P5.MINXORSEG(XOR,fenwick)</p><h1 id="MINXORSEG"><a href="#MINXORSEG" class="headerlink" title="MINXORSEG"></a>MINXORSEG</h1><p>评分 3087, tourist 也没做出</p><p>给你长度n数组, q个询问,每次问区间[l,r]中任意两个数的异或的最小值</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>n 2e5</p><p>q 2e5</p><p>ai 2^30</p><p>3s</p><p>400MB</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>离线, 按查询的右端点排序</p><p>简单的扫描加入 是n方?</p><p>x=a[l]^a[r]</p><p>假设x最高位1在p位,那么高于p的bit,a[l]和a[r]一样</p><p>如果[l..r] 之间有同样的高于p的bit和它们一样的t,那么(l,r)这一对一定不是最小值,因为 (l,t) 或 (t,r) 比它小</p><p>如果区间有3个高w位一样,那么答案至少是高w位为0, 所以答案最小的只存两个高w一样,或者存在两个相等的数</p><p>这个观察很神奇,也就是说如果ai和aj高w位相同,那么要让它们可能是答案的必要条件是,它们中间没有高w位和它们相同的</p><p>换句话说, a[i]如果和它前面某个a[j]高w相同,贡献了最小xor,那么a[i]的w相同的前面最近的就是a[j]</p><p>所以直接记录每个数前面和它高0,1,2,3..位相同的最近的下标即可, 这可以简单的排序记录</p><hr><p>最后扫描+fenwick一下</p><p>其中把每对的左点为index,异或和为值,做后缀min fenwick 就可以了, 这样每次询问就是[l…  中的最小值</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://www.codechef.com/viewsolution/67421139" target="_blank" rel="noopener">https://www.codechef.com/viewsolution/67421139</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backconst ll INF = 0x3f3f3f3f3f3f;ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readll a[200010];int idxs[200010];struct fenwick_tree {  vector&lt;ll&gt; bit;  int n;  fenwick_tree(int n) : n(n) {    bit = vector&lt;ll&gt; (n + 1, INF); // 后缀min fenwick  }  void update(int u, ll v) {    for (u++; u &gt; 0; u -= u &amp; -u) bit[u] = min(bit[u], v);  }  int query(int u) {    ll r = INF;    for (u++; u &lt;= n; u += u &amp; -u) r = min(r, bit[u]);    return r;  }};int main() {  int n = read();  int q = read();  vector&lt;vector&lt;int&gt;&gt; lst(n);  vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; que(n);  rep(i,0,n) a[i] = read();  rep(b,0,30+1) { // 低位到高位    // 按高 30-p 位排序    iota(idxs,idxs+n,0);    sort(idxs,idxs+n,[=](int i,int j){return make_pair((a[i] &gt;&gt; b),i) &lt; make_pair((a[j] &gt;&gt; b),j); });    rep(i,1,n) {      if ((a[idxs[i]] &gt;&gt; b) == (a[idxs[i-1]] &gt;&gt; b)) { // 高位相同,建立可能对最小值贡献的关系        lst[idxs[i]].push_back(idxs[i-1]);      }    }  }  vector&lt;int&gt; ans(q);  rep(i,0,q) {    int l = read() - 1;    int r = read() - 1;    que[r].push_back({l, i});  }  fenwick_tree fen(n);  rep(i, 0, n) {    for (int v : lst[i]) fen.update(v, a[v] ^ a[i]);    for (auto [l, ind] : que[i]) ans[ind] = fen.query(l);  }  for(auto v:ans) printf(&quot;%d\n&quot;, v);}// n 2e5 个数// q询问,2e5// 查区间内 最小的两个值的 xor</code></pre><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote><p>MINXORSEG</p></blockquote><p>这个观察最小的可能贡献很厉害啊, 应该属于xor的一个神奇的知识点了?</p><p>另一个就是, 这种非统计的, 最大最小也是可以从”可能贡献”的角度去思考,这个我没有思路过,学到了</p><p>fenwick这个还有后缀写法,不需要做颠倒原数组的动作</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://discuss.codechef.com/search?q=tags%3Aeditorial%2BLTIME109" target="_blank" rel="noopener">官方</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;P5.MINXORSEG(XOR,fenwick)&lt;/p&gt;
&lt;h1 id=&quot;MINXORSEG&quot;&gt;&lt;a href=&quot;#MINXORSEG&quot; class=&quot;headerlink&quot; title=&quot;MINXORSEG&quot;&gt;&lt;/a&gt;MINXORSEG&lt;/h1&gt;&lt;p&gt;评分 3087, 
      
    
    </summary>
    
      <category term="CodeChef" scheme="http://yexiaorain.github.io/Blog/categories/CodeChef/"/>
    
    
      <category term="异或" scheme="http://yexiaorain.github.io/Blog/tags/%E5%BC%82%E6%88%96/"/>
    
      <category term="fenwick" scheme="http://yexiaorain.github.io/Blog/tags/fenwick/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 1700</title>
    <link href="http://yexiaorain.github.io/Blog/2022-06-21-CF1700/"/>
    <id>http://yexiaorain.github.io/Blog/2022-06-21-CF1700/</id>
    <published>2022-06-21T14:24:00.000Z</published>
    <updated>2022-06-28T02:50:31.934Z</updated>
    
    <content type="html"><![CDATA[<p>E(总体观察,数学),F(贪心)</p><h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><p><a href="https://codeforces.com/contest/1700/problem/E" target="_blank" rel="noopener">https://codeforces.com/contest/1700/problem/E</a></p><p>给你一个矩阵,每个数字都不相同</p><p>然后让你依次取1,2,3,4,… 取完所有</p><p>取的块需要和之前取过的至少一个4临</p><p>直接可取输出0</p><p>需要还是交换两个位置(可以不相邻)后可取,输出<code>1 方案数</code></p><p>还是都不行输出2</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>矩阵大小4e5</p><p>2s</p><p>256MB</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>0很好判断,vis染色+bfs</p><p>其实就是1的时候怎么算个数</p><p>不妨设按找上述方法最开始失败的是x</p><p>意味着, 小于x的连在一起了,</p><p>那么有两种方案</p><ol><li>交换x和小于x的外边界,这样小于等于x就连在一起了,</li><li>交换小于x的某一个和x的四临</li></ol><p>但是这两种如果一个一个检验是时间复杂度会炸掉的</p><hr><p>考虑可交换的,对于第一种没有什么思路</p><p>对于第二种,你可以考察每个依赖于它的是否仅依赖于它, 但也不一定</p><pre><code>1452.63?7.8.</code></pre><p>比如上面这样,7仅依赖于6,而6也可以移动</p><p>不知道怎么搞了</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>不要看一步一步,看总览性质</p><p>如果一个位置，它的四个邻居有比他小的，那么它就能连到小于它的数。矩阵为可遍历当且仅当所有点（除了1）的四个邻居都有比他小的。</p><p>这归纳法可证明</p><hr><p>所以判断可行,也不再需要vis+bfs, 而直接判断count(badpos)== 0</p><p>所以badpos 需要交换它或者它的邻居</p><p>两两不相同,显然badpos不相邻, 因为badpos需要小于4临, 说明4临都不是badpos</p><p>两两不同,说明交换以后的两个位置,一个比原来大,一个比原来小,</p><p>比原来大的位置4邻之前一定不是badpos, </p><p>比原来小的本身一定不是badpos</p><p>综上, badpos最多5个, 一个中心一个4临</p><p>5x5x4, 种</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>无</p><h1 id="F"><a href="#F" class="headerlink" title="F"></a>F</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://codeforces.com/contest/1700/problem/F" target="_blank" rel="noopener">https://codeforces.com/contest/1700/problem/F</a></p><p>2 * n 的01矩阵,两个</p><p>每次交换第一个中相邻位置的01,求最小次数得到第二个矩阵</p><h3 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h3><p>n 2e5</p><p>1s</p><p>256mb</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h3><p>写了个假的</p><p>两个变量记录未匹配的,然后进入则+,退出则-</p><p>发生 一正一负则消耗1抵消</p><p>竟然官方数据弱还过了system test</p><p>然后有错误样例</p><pre><code>0 1 01 0 00 1 00 0 1</code></pre><p>我的匹配会</p><pre><code>0 b 0a 0 00 a 00 0 b</code></pre><p>代价为4, 最小的是2</p><h3 id="官方"><a href="#官方" class="headerlink" title="官方"></a>官方</h3><p>直接可配消耗掉即可…….</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>无</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>E</p><p>这个总体观察没想到, 一直在想细节的步, 总体只想到vis+bfs 而不是这个充分性质</p><p>jiangly 也TLE了好像</p><p>F</p><p>贪心细节还是没想到啊</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://codeforces.com/blog/entry/103978" target="_blank" rel="noopener">官方</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;E(总体观察,数学),F(贪心)&lt;/p&gt;
&lt;h1 id=&quot;E&quot;&gt;&lt;a href=&quot;#E&quot; class=&quot;headerlink&quot; title=&quot;E&quot;&gt;&lt;/a&gt;E&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1700/probl
      
    
    </summary>
    
      <category term="Codeforces" scheme="http://yexiaorain.github.io/Blog/categories/Codeforces/"/>
    
    
      <category term="贪心" scheme="http://yexiaorain.github.io/Blog/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="数学" scheme="http://yexiaorain.github.io/Blog/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="总体观察" scheme="http://yexiaorain.github.io/Blog/tags/%E6%80%BB%E4%BD%93%E8%A7%82%E5%AF%9F/"/>
    
  </entry>
  
  <entry>
    <title>nowcoder 牛客挑战赛61 D</title>
    <link href="http://yexiaorain.github.io/Blog/2022-06-18-nowcoder-11201/"/>
    <id>http://yexiaorain.github.io/Blog/2022-06-18-nowcoder-11201/</id>
    <published>2022-06-18T02:37:14.000Z</published>
    <updated>2022-06-28T02:50:31.934Z</updated>
    
    <content type="html"><![CDATA[<p>D <a href="https://ac.nowcoder.com/acm/contest/11201/D" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/contest/11201/D</a></p><p>总思路没问题, dijkstra不能带log, 2s时间卡时限了</p><p>没有log的也800ms, 稍微一个3倍都过不了</p><p>所以需要的是点的值要么是初始的要么是推导(当前最大值-定值k)生成的, 双队列+指针实现</p><p>没过这题也能+3</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (int i=a;i&lt;(int)n;i++)#define per(i,a,n) for (int i=n;i--&gt;(int)a;)#define pb push_back#define c(a,b) ((a)*(m)+(b))int read(){int r; scanf(&quot;%d&quot;, &amp;r);return r;} // readint a[500010];int n,m,k;bool vis[500010];const int di[] = {-1,1,0,0,-1,1};const int dj[] = {0,0,-1,1,1,-1};vector&lt; array&lt;int,3&gt; &gt; startvij;ll cost(int diff){  fill(vis,vis + n*m,false);  vector&lt; array&lt;int,3&gt; &gt; vp = {}; // 优先队列等含有log的会TLE  ll sk = 0 ;  vp = {};  int i0 = 0;  int i1 = 0;  while(i0 &lt; startvij.size() || i1 &lt; vp.size()){    int v = 0;    int i = -1;    int j = -1;    if(i0 &lt; startvij.size() &amp;&amp; i1 &lt; vp.size()){      if(startvij[i0][0] &gt;= vp[i1][0]){        v = startvij[i0][0];        i = startvij[i0][1];        j = startvij[i0][2];        i0++;      }else{        v = vp[i1][0];        i = vp[i1][1];        j = vp[i1][2];        i1++;      }    }else if(i0 &lt; startvij.size()){      v = startvij[i0][0];      i = startvij[i0][1];      j = startvij[i0][2];      i0++;    }else {      v = vp[i1][0];      i = vp[i1][1];      j = vp[i1][2];      i1++;    }    if(vis[c(i,j)])continue;    vis[c(i,j)] = true;    sk += v - a[c(i,j)];    rep(w,0,6){      int ni = i + di[w];      int nj = j + dj[w];      if(ni &lt; 0 || ni &gt;= n || nj &lt; 0 || nj &gt;= m) continue;      if(a[c(ni,nj)] == -1) continue;      if(vis[c(ni,nj)]) continue;      if(v - diff &gt; a[c(ni,nj)]){        vp.pb({v - diff,ni,nj});      }    }  }  return sk;}int main(){  n = read();  m = read();  k = read();  rep(i,0,n){    rep(j,0,m){      a[c(i,j)] = read();      if(a[c(i,j)] != -1) startvij.pb({a[c(i,j)],i,j});    }  }  sort(startvij.begin(), startvij.end(), greater&lt;array&lt;int,3&gt;&gt;());  int l = 0;  int r = 1000;  int ans = 1000;  while(l &lt;= r){    int mid = (l+r)/2;    if(cost(mid) &lt;= k){      ans = mid;      r = mid - 1;    }else{      l = mid + 1;    }  }  cout&lt;&lt;ans&lt;&lt;endl;  return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;D &lt;a href=&quot;https://ac.nowcoder.com/acm/contest/11201/D&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ac.nowcoder.com/acm/contest/11201/D&lt;/a&gt;&lt;/p
      
    
    </summary>
    
      <category term="NowCoder" scheme="http://yexiaorain.github.io/Blog/categories/NowCoder/"/>
    
    
      <category term="dijkstra" scheme="http://yexiaorain.github.io/Blog/tags/dijkstra/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 1693 C D E</title>
    <link href="http://yexiaorain.github.io/Blog/2022-06-17-CF1693/"/>
    <id>http://yexiaorain.github.io/Blog/2022-06-17-CF1693/</id>
    <published>2022-06-17T14:24:00.000Z</published>
    <updated>2022-06-28T02:50:31.934Z</updated>
    
    <content type="html"><![CDATA[<p>C(反向dijkstra)D(DP,数学,贡献)E(标记,延后,贪心,树状数组)F(0/1串,数学)</p><h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><p><a href="https://codeforces.com/contest/1693/problem/D" target="_blank" rel="noopener">https://codeforces.com/contest/1693/problem/D</a></p><p>给你一个排列</p><p>问多少个子区间 可以表示成 增序列和减序列合成的, 称作Decinc</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>n 2e5</p><p>2s</p><p>512MB</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>如果是判断一个是否合法</p><p>考虑</p><p>inc[i] 表示i在增序列, 减序列的最大值</p><p>dec[i] 表示i在减序列, 增序列的最小值</p><p>然后dp一下O(n) 就做了</p><p>然后这里考虑有没有办法转移</p><p>因为如果[i..j] 是decinc的,那么它的所有子区间也是</p><p>考虑有没有办法dp然后做转移, 发现并没有办法转移</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><h3 id="AmShZ"><a href="#AmShZ" class="headerlink" title="AmShZ"></a>AmShZ</h3><p>一样的, 但是说是可以证明均摊更新是常数倍?</p><p>对于给定i, 找最大的j, 使得 j &lt; i, a[j] &gt; a[j+1]</p><p>注意到<code>a[j],a[j+1]</code> 不会都在增序列里,必定一个在减序列里</p><p>情况1 <code>a[j+1]</code> 在增序列的话 =&gt; <code>a[j]</code> 在减序列</p><p>情况2 <code>a[j+1]</code> 在减序列</p><p>且因为它是最大的j, 所以<code>a[j] &gt; a[j+1]</code>, 且<code>a[j+1] &lt; a[j+2] &lt; a[j+3] &lt; ... &lt; a[i]</code></p><p><code>inc[i] = a[j](情况1) or a[j+1](情况2) or 0</code></p><p>而对于<code>inc[i]</code>初始化是是<code>inf</code>, 而对于<code>a[j+1]..a[i]</code>这一段都是<code>inf</code></p><p>所以每个位置的值只会有4种情况</p><p>dec对称关系同理</p><hr><p>换句话说</p><p>l从大到小,</p><p>每轮从小到大, 如果更新才会去算下一个位置, 否则提前退出</p><p>这里还有一点是就是 运算时,当给定l的时候, dp[i]仅依赖于dp[i-1]和a[i], 所以说如果dp[i]没有更新,则i以后的也不会更新, 所以更新的一定是连续的区间</p><p>所以sum 遍历 = sum 更新次数 = sum变化次数 = O(n)</p><h3 id="Koosha-Mv"><a href="#Koosha-Mv" class="headerlink" title="Koosha_Mv"></a>Koosha_Mv</h3><p>一个由升序和降序列合成的序列,当且仅当它不含 3412 也不含 2143</p><p>显然包含则不满足</p><p>怎么证明不满足一定包含这样的呢</p><p>回到dp的过程, 如果刚好在i不满足, </p><p>那么, 如果 a[i-1] &lt; a[i], (a[i-1] &gt; a[i] 对称同理</p><p>显然a[i-1] 在增序列不合法, (如果a[i-1] 在增序列有合法方案,那么把a[i]放到增序列即可</p><p>a[i-1]在减序列, 且 增序列最小值 &gt; a[i]</p><p>所以 存在a[j] &gt; a[i] &gt; a[i-1], j &lt; i-1</p><p>所以原序列是由</p><p>增序列 <code>..... a[j]</code> 和 减序列<code>.... a[i-1]</code>合成的</p><p>因为a[j] 是满足的最小的a[j]</p><p>也就是, a[j] 不能放进减序列里(如果可以则能得到更小的增序列值</p><p>那么 不妨设下标 w(可能不存在) &lt; j &lt; k ,且 a[k] 在减序列中, a[w] 在减数列中</p><p>那么<code>a[j] &lt; a[k] (j k i-1 i =&gt; 3 4 1 2)</code> 或 <code>a[j] &gt; a[w]</code>(a[j] 左侧至少一个</p><p>考虑把a[j]左侧分成三部分讨论, 大于a[j]的, a[i]到a[j]之间的, 小于a[i]的</p><p>如果a[i]到a[j]之间存在(3 4 1 2)`, 否则完全不存在, 且 小于a[i] 至少一个</p><p>如果大于a[j]的存在,则一定全属于减序列</p><p>如果小于a[i]的有不只1个, 那么一旦有其中两个递减 <code>=&gt; (? ? j i) =&gt; (2 1 4 3)</code> 即它的对称状态</p><p>小于a[i]的一定是升序列</p><p>总上可以重组 升序列<code>a[j] 左侧,小于a[i], 包含a[w] .... a[j]</code>, 降序列<code>a[j]左侧大于a[j]...a[j]右侧原减序列</code></p><p>注意到这样重组以后, <code>a[j]</code> 可以被放入减序列, 而增序列最小值将不再是a[j]</p><p>性质充要得证</p><hr><p>如何实现</p><p>注意到3412和2143是对称的,所以a[i] = n+1-a[i] ,再跑一次3412就行</p><p>那么如何计算3412</p><p>考虑计算的结果是对于当前位置i作为3,<code>min_r[i]</code>表示最近的<code>2</code>让<code>3412</code>出现</p><p>给定3以后,4要是最近的,如果有2,那么1是离2最近的</p><p>所以先预处理每个位置后面和它最近的比它大的,以及每个位置前面最近的比它小的的位置</p><p>但是记录并不是<code>[3]-&gt;4</code>, <code>[2] -&gt; 1</code></p><p>考虑反着来<code>4-&gt; array{3}</code>, <code>1-&gt;array{2}</code></p><p>为什么要这么样做呢,因为除了大小关系还有顺序,<code>1</code> 需要在<code>4</code>的右侧</p><p>那么我们倒着遍历4的位置</p><p>我们可以用fenwick记录i右侧, (1,2) 存在的<code>[值]-&gt;2的坐标</code></p><p>这样我们对于每个3, 去fenwick上查, 值 &lt; 3的值中存在的最大坐标, 就算出答案了</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><a href="https://codeforces.com/contest/1693/submission/160996027" target="_blank" rel="noopener">https://codeforces.com/contest/1693/submission/160996027</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readconst int N = 2e5 + 10;int n;int a[N]; // 数组int inc0[N]; // a[i] 在增数组时, 减数组的最大值int dec0[N]; // a[i] 在减数组时, 增数组的最小值int f[N]; // f[i] = 该轮次的计算中,当前点i到 以l为起点的终点 的距离ll ans;void udec0(int i){  if (n &gt;= i){    // 就硬算    int inc1 = max( (dec0[i - 1] &lt; a[i]?a[i - 1]:0), (a[i - 1] &lt; a[i] ? inc0[i - 1]: 0));    int dec1 = min( (a[i] &lt; inc0[i - 1]?a[i - 1]:n+1), (a[i] &lt; a[i - 1] ? dec0[i - 1]: n+1));    if (!(inc1 == inc0[i] &amp;&amp; dec1 == dec0[i])){ // 更新的一定是连续的区间, sum(遍历) = sum(更新) = sum(变化)      inc0[i] = inc1;      dec0[i] = dec1;      f[i] = 0; // 结束点 距离为0      if (dec1 &lt;= n || inc1) udec0(i+1);    }  }  f[i - 1] = f[i] + 1; // 到结束点距离+1}int main(){  n = read();  rep(i,1,n+1) a[i] = read();  per(i,1,n+1) { // 倒序l    inc0[i] = n + 1;    dec0[i] = 0;    udec0(i + 1);    ans += f[i];  }  printf(&quot;%lld\n&quot;, ans);  return 0;}</code></pre><p>3412,2143的</p><p><a href="https://codeforces.com/contest/1693/submission/161132167" target="_blank" rel="noopener">https://codeforces.com/contest/1693/submission/161132167</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readconst int N = 2e5 + 10;int INF = 0x3f3f3f3f;// 前缀最小值fenwickstruct Fenwick {  const int n;  vector&lt;int&gt; a;  Fenwick(int n) : n(n), a(n, INF) {}  // 支持 [0..n) 更新最大值  void setMin(int x, int v) {    for (int i = x + 1; i &lt;= n; i += i &amp; -i) a[i - 1] = min(a[i - 1], v);  }  // 获得 [0,x) 最大值  int get(int x) {    int ans = INF;    for (int i = x; i &gt; 0; i -= i &amp; -i) ans = min(ans, a[i - 1]);    return ans;  }};int n;int a[N]; // 数组int min_r[N];ll ans;stack &lt;int&gt; sk;vector &lt;int&gt; vec[2][N];// 如果指定3和2的位置,所以你需要的是3后面最近的4, 和2前面最近的1void find_3412(){  Fenwick f(n+10); // 下标是值, 前缀表示小于某个值的出现的最小坐标  rep(i,0,2) fill(vec[i]+1,vec[i]+n+1,vector&lt;int&gt;());  // vec[0][i] = vector&lt;int&gt; {j,...}, 表示 j 前面最近的比j小的是i, sk中保留单增的值对应的下标  sk = {};  rep(i,1,n+1) {    while (!sk.empty() &amp;&amp; a[i] &lt; a[sk.top()]) sk.pop();    if (!sk.empty()) vec[0][sk.top()].push_back(i);    sk.push(i);  }  // 倒着做一边, sk中保持值单调递减, vec[1][i] = {j...} , j后面最近的比a[j]大的是a[i]  sk = {};  per(i,1,n+1) {    while (!sk.empty() &amp;&amp; a[sk.top()] &lt; a[i]) sk.pop();    if (!sk.empty()) vec[1][sk.top()].push_back(i);    sk.push(i);  }  // 倒着做  per(i,1,n+1){    // f在遍历过程中,存的是(1,2) 的下标都&gt;=i, 然后[2的值] = 位置    // i=&gt;1, ind=&gt;2    for (auto ind : vec[0][i]) f.setMin(a[ind], ind); // (i,ind) 构成增序列    // 这次就是 i=&gt;4, ind =&gt; 3, 因为如果确定了3,那么4就最近最好, 所以查询的是(1,2)位置在(以后,且值小于3的,结束位置的最小值),    // 这里遍历过程之所以i=&gt;4 而不是3,主要因为 保证(1,2)在当前位置右侧    for (auto ind : vec[1][i]) min_r[ind] = min(min_r[ind], f.get(a[ind]));    // 得到的是min_r[3的位置] = 最近的2的位置能构成3 4 1 2    // 在反转过程中 min_r 直接取min,而f是清空  }}int main(){  n = read();  INF = n+1;  rep(i,1,n+1) a[i] = read();  fill(min_r, min_r + n + 2, INF);  find_3412();  rep(i,1,n+1) a[i] = n + 1 - a[i]; // 做对称, 因为对称不影响答案, 而3412和2143是对称的  find_3412();  per(i,1,n+1) {    min_r[i] = min(min_r[i], min_r[i + 1]);    ans += min_r[i] - i;  }  printf(&quot;%lld\n&quot;, ans);  return 0;}</code></pre><h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://codeforces.com/contest/1693/problem/E" target="_blank" rel="noopener">https://codeforces.com/contest/1693/problem/E</a></p><p>n+2 长度数组a</p><p>首尾元素值为0</p><p>最小操作次数让 所有值 = 0</p><p>每次操作可以任选以下一种</p><ol><li>最左的最大值=它的左侧的最大值</li><li>最右的最大值=它的右侧的最大值</li></ol><h3 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h3><p>n 2e5</p><p>2s</p><p>256mb</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h3><p>值挺友好,给你的是[0,n]的范围,(就算很大也可以手动离散</p><p>没思路了</p><h3 id="ecnerwala"><a href="#ecnerwala" class="headerlink" title="ecnerwala"></a>ecnerwala</h3><p>官方的代码实在太长了</p><p>ecnerwala 有个超短的代码</p><p><a href="https://codeforces.com/contest/1693/submission/160890042" target="_blank" rel="noopener">https://codeforces.com/contest/1693/submission/160890042</a></p><p>有点延后判断, 贪心选最小值的意味</p><pre><code>0 1 4 2 4 0 2 0. . . . . . . . // 初始. . ? . ? . . . // 最大的标记为?, 贡献 +2, 意义是第一轮处理2个. . . x x x x . // 准备处理2的也就是x覆盖区间的, 把区间左侧问号标成 &lt;(表示这个?位置的值比当前小,和左侧的最值相等, 右侧标成 &gt; (同理. . &lt; . ? . . . // 标记. . &lt; ? ? . ? . // 对2处理, 贡献 +3. . ? &gt; &gt; . &gt; . // 同理对于1, 但注意到 1右侧的 &lt; 会变成? 因为. ? ? &gt; &gt; . &gt; . // 贡献+2// 0 不需要处理</code></pre><p>总贡献是2+3+2 = 7</p><hr><p>样例2</p><pre><code>0 1 3 5 4 2 0. . . . . . .. . . ? . . . // +1. . . &lt; . . . // . . . &lt; ? . . // +1. . . ? &gt; . . //. . ? ? &gt; . . // +2. . &lt; &lt; ? . . //. . &lt; &lt; ? ? . // +2. . ? ? &gt; &gt; . //. ? ? ? . . . // +3</code></pre><p>1+1+2+2+3 = 9</p><p>再补充一个例子 <code>1 2 3</code></p><pre><code>0 1 2 3 0. . . . .. . . ? . // +1. . . &gt; . // . . ? &gt; . // +1. . &gt; &gt; . // . ? &gt; &gt; . // +1</code></pre><p>1+1+1 = 3</p><hr><p>总的来说, 每轮最大值,确定覆盖区间</p><p>区间左侧:</p><pre><code>? 变 &lt;&gt; 变?</code></pre><p>区间内部</p><pre><code>&lt; 变 ?&gt; 变 ?</code></pre><p>区间右侧</p><pre><code>? 变 &gt;&lt; 变 ?</code></pre><p>最后最大值的所有点都是? , 统计?个数即可</p><hr><p>实现</p><p>并不需要真的像上面思路那样维护4种 . , ? , &gt; , &lt;的状态</p><p>发现其实只需要统计?的个数</p><p>那么?个数有多少呢</p><p>区间内,所有大于它的都变成了问号, 所以区间内就是大于它的个数</p><p>区间左侧, 可能有 &gt;,?,&lt;</p><p>但 注意到一旦出现 &gt; ,说明上一轮 &gt; 的左侧有?, 如果出现 &lt; 说明上一轮右侧有 ?</p><p>引理, 每轮结束后 除开.的情况,剩下的一定是 &lt; ? &gt; 形状的</p><p>归纳法可证明</p><p>因此, 你需要统计的是</p><ol><li>相交关系</li></ol><pre><code>    ?   ?      // 上一轮结果&lt;  [l...r] &gt;   // 上一轮结果     [l...r]   // 本轮      ?   ?    // 本轮   &lt; [l...r]&gt;  // 结果</code></pre><ol start="2"><li>非相交关系</li></ol><pre><code>    ?   ?                 // 上一轮结果&lt;  [l...r] &gt;              // 上一轮结果                [l...r]   // 本轮                 ?   ?    // 本轮        &lt; [l      ...r]&gt;  // 结果</code></pre><p>有</p><pre><code>newl = min(l, lastr)newr = max(r, lastl)</code></pre><p>区间统计点 = 前缀差 = 树状数组维护</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>ecnerwaia <a href="https://codeforces.com/contest/1693/submission/160890042" target="_blank" rel="noopener">https://codeforces.com/contest/1693/submission/160890042</a></p><p>基于修改+注释+自己格式+bit改为fenwick: <a href="https://codeforces.com/contest/1693/submission/161139663" target="_blank" rel="noopener">https://codeforces.com/contest/1693/submission/161139663</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readint main() {  int n = read();  vector&lt;vector&lt;int&gt; &gt; idxs(n+1); // [值] = 下标数组  rep(i,1,n+1) idxs[read()].push_back(i);  vector&lt;int&gt; fenwick(n); // 树状数组, 大于等于当前的点记为1  ll ans = 0;  int lo = 1, hi = n + 1; // 左闭右开, [lo,hi)  per(v, 1, n+1) { // 从大到小    if (idxs[v].empty()) continue; // 忽略不存在的值    // 本轮全为问号的范围    std::tie(lo, hi) = make_pair(        min(idxs[v].front(), hi),        max(idxs[v].back()+1, lo)    );    // 本轮点 树状数组上标记为1,    for (int a : idxs[v]) {      for (; a &lt;= n; a += (a&amp;-a)) fenwick[a-1]++;    }    // 区间 [lo, hi) = pre[hi-1] - pre[lo-1]    for (int a = hi-1; a; a -= (a&amp;-a)) ans += fenwick[a-1];    for (int a = lo-1; a; a -= (a&amp;-a)) ans -= fenwick[a-1];  }  printf(&quot;%lld\n&quot;, ans);  return 0;}</code></pre><h1 id="F"><a href="#F" class="headerlink" title="F"></a>F</h1><p><a href="https://codeforces.com/contest/1693/problem/F" target="_blank" rel="noopener">https://codeforces.com/contest/1693/problem/F</a></p><p>0/1 字符串 S</p><p>每次选择一段 sort, 代价 |cnt(1) - cnt(0)| + 1</p><p>求最小总代价,让整个S有序</p><h2 id="范围-2"><a href="#范围-2" class="headerlink" title="范围"></a>范围</h2><p>n 2e5</p><h2 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h2><h3 id="我的想法"><a href="#我的想法" class="headerlink" title="我的想法"></a>我的想法</h3><p>假设最后一次操作了 [l..r]</p><p>那么说明 操作之前, [0..l-1] 和目标一样[r+1..n-1] 和目标一样</p><p>并且[l..r]中的1和0的个数尽可能的靠近</p><h3 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h3><p>结论: 只对0和1个数相等的进行排序</p><p>证明:</p><p>若最优方案中, 对[l,r]排序,且区间中,0比1多d个(d &gt; 0), 代价d+1</p><p>如果l上是0, 只需要对[l+1,r]排序,代价为d, 且效果相同, 所以l上一定是1</p><p>确定区间左端点,右端点增加时,0和1的差的变化为+1/-1</p><p>因此必然存在k &lt; r, 区间 [l,k] 的0和1的个数相等</p><p>排序[l,k],代价1, 再排序 [l+1,r] 代价 = d, 总代价 = d+1</p><p>所以任何一个0比1多排序, 可以拆成 (0和1相等的排序,代价1) + (0和1的差更小,更短,比原来代价更小的排序)</p><p>对于1比0多的情况, 对称关系同理可证</p><p>得证</p><p>问题变成如何选尽量少的0和1相等区间排序</p><hr><p>把0换为-1</p><p>又变成经典的,前缀和2维图形化了, 每次选择的是等高的点, 让等高点之间变成 V字形</p><p>假设1比-1多,那么也就是结束点比起点高, 如果最后一段是从一个和起点相等的值 一直+1达到 结束点的,那么 把起点和这个值的区间处理即可</p><p>所以就是让最后一个连续+1 到的结束点 的那一串尽量长</p><p>我们记录达到每个值的首先出现的点, 只考虑(&gt;=0的部分) 显然随着值越大,下标大,( 因为是从0涨过来的</p><p>而我们对末端的操作不会改变这个首次出现的位置</p><p>贪就完了</p><p>-1 比 1多 对称处理即可, 这里只要方案数不要操作细节,(所以还可以把 1变-1,0变1,并旋转字符串)</p><hr><p>样例输入1的最后一个数据</p><p><img src="/Blog/img/CF_1693F.jpeg" alt></p><p>这个和上面假设相反, 那就是 把头部可达的值的最小值的最后出现位置之间做区间处理</p><p>当然也可以双指针, (总代价移动是线性的</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><p><a href="https://codeforces.com/contest/1693/submission/162002156" target="_blank" rel="noopener">https://codeforces.com/contest/1693/submission/162002156</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;(int)n;i++)#define per(i,a,n) for (int i=n;i--&gt;(int)a;)int read(){int r;scanf(&quot;%d&quot;,&amp;r);return r;} // readchar s[200010];int pre[200010]; // 前缀和int pos[200010]; // 首次出现的位置int w(){  int n = read();  fill(pos,pos+n+1,-1);  scanf(&quot;%s&quot;,s);  int cnt[] = {0,0};  rep(i,0,n) cnt[s[i] == &#39;1&#39;] ++;  if(cnt[0] &gt; cnt[1]) { // 保证 个数1 &gt; 个数0    swap(cnt[0],cnt[1]);    rep(i,0,n) s[i] = (1 - (s[i] - &#39;0&#39;)) + &#39;0&#39;;    rep(i,0,n/2) swap(s[i],s[n-1-i]);  }  int d = cnt[1] - cnt[0];  rep(i,0,n) pre[i+1] = pre[i] + (s[i] == &#39;0&#39;? -1 : 1);  rep(i,0,n+1){    if(pre[i] &lt; 0) continue;    if(pos[pre[i]] != -1) continue;    pos[pre[i]] = i;  }  int minv = d; // 倒着最小能连续到达的值  per(i,-cnt[0],d+1){    if(pre[n - (d-i)] != i) break;    minv = i;  }  int ans = 0;  while(minv + cnt[0] &gt; 0){ // 已经完成排序    if(minv &lt; 0) return ans + 1; // 和l=0配    ans ++ ;    minv -= ((n-(d-minv))/*r*/-pos[minv]/*l*/)/2; // [l..r]  }  return ans;}int main(){  int t = read();  while(t--) printf(&quot;%d\n&quot;,w());  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>C</p><p>Dijkstra 性质还是不够熟啊</p><p>D</p><p>直接的dp能想到,也在想转移,倒是转移也可以倒着做, 而且需要推导这个变化的条件,从而得到必定是区间变化,有遍历次数=变化次数=可能次数</p><p>另一个方案, 我有大的方向, 说看能不能找不成立的,但是没有得到3412/2143, 一个是这个充要真不知道比赛能不能快速证明,</p><p>再就是3412, 就算我知道了, 也不知道怎么去算, 这个按中间位置做遍历, 预处理 两头算是又学了一手</p><p>E</p><p>总觉得好像见过类似的标记处理, 这里是标记+延后+贪心</p><p>哦 像python里的 a,b= b,a+b 可以写成 std::tie(a,b) = make_pair(b,a+b)</p><p>原来树状数组还有bit和fenwick写法区别</p><p>bit版本的是 a|=a+1</p><p>fenwick的是 a+=(a&amp;-a)</p><p>逻辑上 bit版本,统计的是末尾连续1的所有子集或上高位1的信息</p><p>而fenwick是当前结束向前(a&amp;-a)长度的信息</p><p>F</p><p>敢于去猜让解答变容易的特殊情况,并证明它</p><p>经典的0/1区间个数相等处理, 变成-1,1 和二维图</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://codeforces.com/blog/entry/103952" target="_blank" rel="noopener">官方</a></p><p><a href="https://codeforces.com/blog/entry/103952?#comment-923531" target="_blank" rel="noopener">ecnerwala E</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;C(反向dijkstra)D(DP,数学,贡献)E(标记,延后,贪心,树状数组)F(0/1串,数学)&lt;/p&gt;
&lt;h1 id=&quot;D&quot;&gt;&lt;a href=&quot;#D&quot; class=&quot;headerlink&quot; title=&quot;D&quot;&gt;&lt;/a&gt;D&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https:/
      
    
    </summary>
    
      <category term="Codeforces" scheme="http://yexiaorain.github.io/Blog/categories/Codeforces/"/>
    
    
      <category term="DP" scheme="http://yexiaorain.github.io/Blog/tags/DP/"/>
    
      <category term="贪心" scheme="http://yexiaorain.github.io/Blog/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="贡献" scheme="http://yexiaorain.github.io/Blog/tags/%E8%B4%A1%E7%8C%AE/"/>
    
      <category term="数学" scheme="http://yexiaorain.github.io/Blog/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="树状数组" scheme="http://yexiaorain.github.io/Blog/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
      <category term="标记" scheme="http://yexiaorain.github.io/Blog/tags/%E6%A0%87%E8%AE%B0/"/>
    
      <category term="延后" scheme="http://yexiaorain.github.io/Blog/tags/%E5%BB%B6%E5%90%8E/"/>
    
      <category term="0/1串" scheme="http://yexiaorain.github.io/Blog/tags/0-1%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 1697F(2-sat)</title>
    <link href="http://yexiaorain.github.io/Blog/2022-06-14-CF1697F/"/>
    <id>http://yexiaorain.github.io/Blog/2022-06-14-CF1697F/</id>
    <published>2022-06-14T14:24:00.000Z</published>
    <updated>2022-06-28T02:50:31.934Z</updated>
    
    <content type="html"><![CDATA[<p>我的第二次 2-SAT 练习</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://codeforces.com/contest/1697/problem/F" target="_blank" rel="noopener">https://codeforces.com/contest/1697/problem/F</a></p><p>给你m个限制, 分别可能是</p><ol><li>$a_i \neq x$</li><li>$a_i+a_j \ge x$</li><li>$a_i+a_j \le x$</li></ol><p>请构造一个满足限制的长n的数组a, 且每个元素在$[1,k]$之间</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>n 2e4</p><p>m 2e4</p><p>k 10</p><p>2s</p><p>512MB</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>一眼2-sat,写过但不熟, 来看看题解如何建立图的</p><p>tourist ,jiangly也是拖的板子, XD, 看来我要好好准备板子了?</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>一个值拆成2k个点</p><p>分别是$\le 1,\le 2,\cdots,\le k,&gt;1,&gt;2,\cdots,&gt;k$</p><p>其中$\le i, &gt; i$ 是一个互补对</p><p>$(i,v,0) = a_i \le v$</p><p>$(i,v,1) = a_i &gt; v$</p><p>因为2-sat 就是每个点选或不选 0/1, 而上面的两个必定一个满足一个不满足</p><p>$(i,v,0) \to (i,v+1,0)$ 不等式关系</p><p>$(i,v,1) \to (i,v-1,1)$ 不等式关系 (可以由上面自动建立对称关系</p><p>$(i,v,1) \to (i+1,v,1)$ 非严格单增</p><p>$(i,x,0) \to (i,x-1,0)$, $a_i \ne x$</p><p>$(i,x-1,1) \to (i,x,1)$, $a_i \ne x$ (可以由上面自动建立对称关系</p><p>$(i,v,1) \to (j,x-a_i-1,0)$, $a_i + a_j \le x$, 轮换$i,j$</p><p>$(i,v,0) \to (j,x-a_i-1,1)$, $a_i + a_j \ge x$, 轮换$i,j$ </p><hr><p>对于限制必定不合法的$(i,v,x)$ , 建立 $(i,v,x) \to (i,v,x\oplus 1)$</p><h2 id="2-sat-的选择"><a href="#2-sat-的选择" class="headerlink" title="2-sat 的选择"></a>2-sat 的选择</h2><p>之前有个问题, 我一直没想太通, 现在有点思路了</p><p>假设我们完成建边和tarjan的部分</p><p>如下, 这样那怎么顺序选都没问题</p><pre><code>a0 &lt;-&gt; b0a1 &lt;-&gt; b1</code></pre><p>而对于这种, 你是不能去选b1/c1 的,而这也是Tarjan 不会处理的,因为tarjan只是合并联通块, 这种还算有答案</p><pre><code>a0 &lt;-&gt; b0b1 &lt;-&gt; c1c1 -&gt; a0</code></pre><p>这种是没有答案, 而且tarjan 的时候是判断不了的</p><pre><code>a0&lt;-&gt;b0b1&lt;-&gt;c1c0&lt;-&gt;a1</code></pre><hr><p>那么两个办法我想的</p><p><strong>方法一</strong></p><p>如果我们要加 $a[x] \to b[y]$</p><p>考虑 如果 $b[y\oplus 1]$ ,那么a不能选x, 所以同时会产生$b[y\oplus 1] \to a[x\oplus1]$</p><p>这个好处是,本身可以利用tarjan</p><p><strong>方法二</strong></p><p>在tarjan处理完scc后, 对scc的每个点的<code>反点</code>做并查集, 缺点是还要跑并查集</p><hr><p>等价性 一个奇怪的视角可以证明就是 这些操作是对称性的, 比如方法一里面每次都是对称加的边, 而方法二,不妨设scc 中的反点个数比它大,那么scc必定会合其它scc连接,最终所有并查集完成后, scc和scc反点的scc个数相等</p><hr><p>这两个任选一种以后, 最后对scc/并查集 做原图的反向边 做倒序拓扑选择,必定有解?</p><p>再看上面的 3个例子</p><p>第一个不变</p><pre><code>a0 &lt;-&gt; b0a1 &lt;-&gt; b1</code></pre><p>第二个变成如下,你需要反向拓扑选择</p><pre><code>a0 &lt;-&gt; b0 &lt;-&gt; c0a1 &lt;-&gt; b1 &lt;-&gt; c1c1 -&gt; a0</code></pre><p>第三个则全部连到一个并查集里了, 直接确定不合法了</p><hr><p>第三个是限制的不可选状态</p><p>比如 $(i,x)$ 不可选, 之前的办法是做一个 失败的节点,让它和这个节点双向连通</p><p>而现在发现其实$(i,x) \to (i,x\oplus 1)$, 因为这样如果选$(i,x)$自动造成矛盾</p><hr><p>注意区别是<code>不可选</code>还是<code>选了一定满足</code></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>我先自己写了个twosat的板子,下次也可以用</p><p><a href="https://codeforces.com/contest/1697/submission/160657743" target="_blank" rel="noopener">https://codeforces.com/contest/1697/submission/160657743</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readclass TwoSat{  vector&lt;int&gt; low; // 能达到的最小的点  vector&lt;int&gt; dfn; // tarjan 用的深搜访问次序标识  stack&lt;int&gt; stk; // tarjan 用的stk  vector&lt;int&gt; res; // tarjan 结果  vector&lt;vector&lt;int&gt; &gt; p; // 所有点  int n;  void scc(int v) {    static int id = 0;    low[v] = dfn[v] = id++;    stk.push(v);    for(auto w:p[v]){      if(dfn[w] == -1){ // 未访问过        scc(w);        low[v] = min(low[v],low[w]);      } else if(res[w] == -1){ // 访问过但没有结果(在栈中)        low[v] = min(low[v],dfn[w]);      }    }    int u;    if(low[v] == dfn[v])  {      do{        res[u = stk.top()] = v;        stk.pop();      }while(u != v);    }  }public:  TwoSat(int SZ):n(SZ){ // 点范围[0..SZ-1]    low = vector&lt;int&gt;(2*n,-1);    dfn = vector&lt;int&gt;(2*n,-1);    stk = {};    res = vector&lt;int&gt; (2*n,-1);    p = vector&lt;vector&lt;int&gt; &gt;(2*n);  }  bool calc(vector&lt;bool&gt; &amp; ans){    rep(i,0,2*n) if(res[i] == -1) scc(i);    // rep(i,0,2*n) printf(&quot;scc[%lld] = %d\n&quot;,i,res[i]);    rep(i,0,n) if(res[i*2] == res[i*2+1]) return false; // 同一个块的真假都在一个scc里    vector&lt;int&gt; revscc(2*n); // 互斥scc    rep(i,0,n) {      revscc[res[i*2]] = res[i*2+1];      revscc[res[i*2+1]] = res[i*2];    }    vector&lt;set&lt;int&gt; &gt; scc2scc(2*n);    unordered_map&lt;int,int&gt; degree; // scc入度    unordered_map&lt;int,bool&gt; scctf; // scc 真假    rep(i,0,2*n) { // 跨scc的反向边, 做拓扑选择      degree[res[i]] = 0;      for(auto j:p[i]){ // i -&gt; j        if(res[i] == res[j]) continue;        scc2scc[res[j]].insert(res[i]);      }    }    for(auto s:scc2scc){      for(auto t:s) degree[t]++;    }    vector&lt;int&gt; d0; // 入度为0    for(auto [v,d]: degree) if(!d) d0.pb(v);    rep(i,0,d0.size()) {      if(!scctf.count(d0[i])){ // 没有选择过        // printf(&quot;pick %d, unpick %d\n&quot;,d0[i],revscc[d0[i]]);        scctf[d0[i]] = true;        scctf[revscc[d0[i]]] = false;      }      for(auto item:scc2scc[d0[i]]) { // 更新入度排序        if(!(--degree[item])) d0.pb(item);      }    }    ans = vector&lt;bool&gt;(n);    rep(i,0,n) ans[i] = scctf[res[i*2+1]];    return true;  }  void p2(pair&lt;int,bool&gt; pi, pair&lt;int,bool&gt; pj){ // {i,true/false} -&gt; {j,true/false}    auto [i,bi] = pi;    auto [j,bj] = pj;    // printf(&quot;(%d,%d) -&gt; (%d,%d)\n&quot;,i,(int)bi,j,(int)bj);    // printf(&quot;(%d,%d) -&gt; (%d,%d) (auto\n&quot;,j,(int)bj^1,i,(int)bi^1);    assert(i &gt;= 0 &amp;&amp; i &lt; n);    assert(j &gt;= 0 &amp;&amp; j &lt; n);    p[2*i+bi].pb(2*j+bj);    p[2*j+(!bj)].pb(2*i+(!bi)); // 自动建立逻辑边  }};int n;int m;int k;int c(int i,int j){  return i*k+j;}void w(){  n = read();  m = read();  k = read();  TwoSat ts(n*k);  // a[i][j=0..k-1] =&gt; i*k+j  // false : &lt;= j+1  // true  : &gt;  j+1  // 不等式关系  rep(i,0,n){    rep(j,0,k-1){      ts.p2({c(i,j),0},{c(i,j+1),0}); // 自动建立反向边 ts.p2({c(i,j+1),1},{c(i,j),1});    }    ts.p2({c(i,k-1),1},{c(i,k-1),0}); // 不能选 &gt; k  }  // 非严格单增  rep(i,0,n-1){    rep(j,0,k){      ts.p2({c(i,j),1},{c(i+1,j),1});    }  }  while(m--){    int op = read();    int i = read()-1;    if(op == 1){      int x = read()-1;      if(x){        ts.p2({c(i,x),0},{c(i,x-1),0});        // ts.p2({c(i,x-1),1},{c(i,x),1}); // 对称自动      }else{        ts.p2({c(i,x),0},{c(i,x),1}); // 输入的原始 x = 1 的时候, 不能选 &lt;= 1      }    }else if(op == 2){      int j = read() - 1;      int x = read(); // a[i] + a[j] &lt;= x , a[i] &gt; v : a[j] &lt;= x-a[i] &lt; x-v, a[j] &lt; x-v-1      rep(v,1,k+1){        int v2 = x - v - 1;        if(v2 &gt;= 1 &amp;&amp; v2 &lt;= k){          ts.p2({c(i,v-1),1},{c(j,v2-1),0});          // ts.p2({c(j,v-1),1},{c(i,v2-1),0}); // 对称自动建立        }else if(v2&lt;1){ // 不可选的v , ( v2 &gt; k 说明一定满足          ts.p2({c(i,v-1),1},{c(i,v-1),0});          ts.p2({c(j,v-1),1},{c(j,v-1),0});        }      }    }else if(op == 3){      int j = read() - 1;      int x = read(); // a[i] + a[j] &gt;= x, a[i] &lt;= v : a[j] &gt;= x - a[i] &gt;= x - v &gt; x - v - 1      rep(v,1,k+1){        int v2 = x - v - 1;        if(v2 &gt;= 1 &amp;&amp; v2 &lt;= k){          ts.p2({c(i,v-1),0},{c(j,v2-1),1});          // ts.p2({c(j,v-1),0},{c(i,v2-1),1}); // 对称自动建立        }else if(v2 &gt; k){ // 不可选的v, (v2 &lt; 1 是一定满足          ts.p2({c(i,v-1),0},{c(i,v-1),1});          ts.p2({c(j,v-1),0},{c(j,v-1),1});        }      }    }  }  vector&lt;bool&gt; ans;  vector&lt;int&gt; a(n);  if(!ts.calc(ans)){    printf(&quot;-1\n&quot;);  }else{    rep(i,0,n){      rep(j,0,k){        if(!ans[i*k+j]){          a[i] = j+1;          break;        }      }    }    rep(i,0,n) printf(&quot;%d%c&quot;,a[i],&quot; \n&quot;[i==n-1]);  }}int main(){  int t = read();  while(t--) w();  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这里的问题就是说 选则一个范围的值,怎么变成2-sat需要的 真/假</p><p>这里的办法是拆成大于小于</p><p>当然从逻辑上 用 $= v$ 和$\ne v$ 也可以, 但是这样的问题是, 在做上面的和的不等式的关系时, 边的量就很大了, 不是k条边了</p><p>之前2-sat 还有点问题,缺少了一些反向的连接,和缩点后的反向拓扑序选择</p><p>准备准备2sat的板子了</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://codeforces.com/blog/entry/103835" target="_blank" rel="noopener">官方</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我的第二次 2-SAT 练习&lt;/p&gt;
&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1697/pro
      
    
    </summary>
    
      <category term="Codeforces" scheme="http://yexiaorain.github.io/Blog/categories/Codeforces/"/>
    
    
      <category term="2-sat" scheme="http://yexiaorain.github.io/Blog/tags/2-sat/"/>
    
  </entry>
  
  <entry>
    <title>Atcoder abc254 G(倍增)</title>
    <link href="http://yexiaorain.github.io/Blog/2022-06-13-ac_abc254/"/>
    <id>http://yexiaorain.github.io/Blog/2022-06-13-ac_abc254/</id>
    <published>2022-06-12T20:25:14.000Z</published>
    <updated>2022-06-28T02:50:31.934Z</updated>
    
    <content type="html"><![CDATA[<p>G(倍增)</p><h1 id="G"><a href="#G" class="headerlink" title="G"></a>G</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://atcoder.jp/contests/abc254/tasks_print" target="_blank" rel="noopener">https://atcoder.jp/contests/abc254/tasks_print</a></p><p>n个楼, 每个楼高都是1..1e9</p><p>有m个电梯, 每个电梯在一个楼里,负责[li,ri] 之间</p><p>可以允许这个楼里, [li,ri] 范围中的移动</p><p>跨楼同楼层移动代价1</p><p>同楼电梯内移动,代价 高度差</p><p>q个询问, ai楼bi层 到 ci楼di层最小代价, 或它们不可达</p><h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h3><p>n 2e5</p><p>m 2e5</p><p>q 2e5</p><p>6s</p><p>1024mb</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h3><p>显然 同楼层答案是1或0</p><p>不同楼层,只会单调移动,不会先上再下这种, 答案 = 距离+跨楼数, 需要最小化跨楼数</p><p>而每次移动贪心距离, 这样模拟可做, 但是复杂度无法接受</p><p>显然同楼的重叠电梯可以合并</p><h3 id="官方"><a href="#官方" class="headerlink" title="官方"></a>官方</h3><p>显然上下还满足对称性, 那么只考虑从下向上</p><p>合并同楼重叠电梯(这样做了以后剩下的线段就不用考虑属于哪个楼了? 因为是一旦重叠肯定不重楼</p><p>如果 ai楼内bi移动到最高位置, ci 楼内 di 移动到最低位置, 合法提前输出</p><p><code>dp[i][j]</code> 当前建筑第i层,用j个电梯后最高能到达的楼层</p><p>考虑 离散+倍增</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>我写的按右断点跳右端点的map不知道为什么WA了除了测试点, 调了七八个小时,atcoder还没数据, 放弃了</p><p>下面是一个别人的代码,我改了部分格式,靠清理了一些线段,保持左右端点都严格单调递增, 然后用线段跳线段来做的, 我觉得完全一样啊, 吐了, 搞不动了,心态炸了</p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;(int)n;i++)#define per(i,a,n) for (int i=n;i--&gt;(int)a;)#define pb push_backint read(){int r;scanf(&quot;%d&quot;,&amp;r);return r;} // readvector&lt;array&lt;int,2&gt; &gt; ilr[200010];vector&lt;array&lt;int, 2&gt;&gt; segs;vector&lt;vector&lt;int&gt;&gt; jump;int N;int lg = 20;int n, m, q;int query(){  int i0, f0, i1, f1;  i0 = read() - 1;  f0 = read();  i1 = read() - 1;  f1 = read();  if(f0 == f1) return i0 != i1;  if (f0 &gt; f1) {    swap(i0, i1);    swap(f0, f1);  }  int ans = f1 - f0;  auto it =    lower_bound(ilr[i0].begin(), ilr[i0].end(), array&lt;int, 2&gt;{f0 + 1, -1});  if (it != ilr[i0].begin()) f0 = max(f0,(*--it)[1]);  it = lower_bound(ilr[i1].begin(), ilr[i1].end(), array&lt;int, 2&gt;{f1 + 1, -1});  if (it != ilr[i1].begin()) {    it--;    if (f1 &lt;= (*it)[1]) {      f1 = (*it)[0];    }  }  if (f0 &gt;= f1) return ans + (i0 != i1);  // 跳到一个右端点 保证f0 是右端点  ans++;  int idx = lower_bound(segs.begin(), segs.end(), array&lt;int, 2&gt;{f0 + 1, -1}) - segs.begin();  // 未被覆盖到  if (!idx) return -1;  idx--;  if (f0 &gt; segs[idx][1]) return -1;  if (segs[idx][1] &gt;= f1) return ans + 1;  if (segs[jump[idx][lg]][1] &lt; f1) return -1;  per(k,0,lg+1){    if (segs[jump[idx][k]][1] &gt;= f1) continue;    idx = jump[idx][k];    ans += 1 &lt;&lt; k;  }  idx = jump[idx][0];  return ans + 2;}int main() {  n = read();  m = read();  q = read();  rep(i,0,m){    int a, b, c;    a = read() - 1;    b = read();    c = read();    ilr[a].push_back({b, c});  }  // 每组内部 排序 与 合并  rep(i,0,n){    sort(ilr[i].begin(), ilr[i].end());    vector&lt;array&lt;int, 2&gt;&gt; temp;    for (auto [l, r] : ilr[i]) {      if (!temp.empty() &amp;&amp; l &lt;= temp.back()[1]) {        temp.back()[1] = max(temp.back()[1], r);      } else {        temp.push_back({l, r});      }    }    ilr[i] = temp;    for (auto s : temp) segs.push_back(s);  }  sort(segs.begin(), segs.end());  vector&lt;array&lt;int, 2&gt;&gt; temp;  for (auto [l, r] : segs) {    if (!temp.empty() &amp;&amp; r &lt;= temp.back()[1]) { //      continue;    }    if (!temp.empty() &amp;&amp; l == temp.back()[0]) {      temp.pop_back();    }    temp.push_back({l, r});  }  segs = temp;  N = segs.size();  jump = vector&lt;vector&lt;int&gt;&gt;(N, vector&lt;int&gt;(lg + 1));  // jump[段id][pwr] = 段id  for (int i = 0, j = 0; i &lt; N; i++) {    while (j + 1 &lt; N &amp;&amp; segs[j + 1][0] &lt;= segs[i][1]) {      j++;    }    jump[i][0] = j;  }  rep(j,0,lg){    rep(i,0,N){      jump[i][j + 1] = jump[jump[i][j]][j];    }  }  while(q--) printf(&quot;%d\n&quot;, query());  return 0;}</code></pre><p>我的代码 不知道WA在哪里了</p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readint n,m,q;vector&lt;pair&lt;int,int&gt; &gt; ilr[200010]; // 每个楼vector&lt;pair&lt;int,int&gt; &gt; segs; // 所有楼vector&lt;int&gt; maxr = {0}; // 前缀 最大rmap&lt;int,vector&lt;int&gt;&gt; jump = {}; // jump[结束位置][2**i次跳跃] = 最高位置const int lg = 20;int query(){  int i0 = read();  int f0 = read();  int i1 = read();  int f1 = read();  // 同楼层  if(f0 == f1) return i0 != i1;  // 从低到高 f0 &lt; f1  if(f0 &gt; f1){    swap(i0,i1);    swap(f0,f1);  }  int ans = f1-f0;  // 注意不在区间的情况不会跳  int itr0 = lower_bound(ilr[i0].begin(),ilr[i0].end(),make_pair(f0+1,-1)) - ilr[i0].begin();  if(itr0 &gt; 0) f0 = max(f0, ilr[i0][itr0-1].second);  int itr1 = lower_bound(ilr[i1].begin(),ilr[i1].end(),make_pair(f1+1,-1)) - ilr[i1].begin();  if(itr1 &gt; 0 &amp;&amp; ilr[i1][itr1-1].second &gt;= f1) f1 = ilr[i1][itr1-1].first;  if(f1 &lt;= f0) return ans + (i0 != i1);  // next0 可能不是某个右端点, 不可能一次跳到, 否则 perv1 &lt;= next0, 所以直接贪心去最大可达右端点  // 跳一次 保证f0 是右端点  int idx = lower_bound(segs.begin(),segs.end(),make_pair(f0+1,-1)) - segs.begin();  if(idx == 0 || maxr[idx] &lt; f0) return -1; // 未被覆盖到  f0 = maxr[idx]; // 当不可达时可能是比它小的右端点, 但是不影响结果逻辑  ans ++;  if(f1 &lt;= f0) return ans + 1;  // ? 需要吗 TODO  // if(!h.count(f0)) return -1;  if(jump[f0][lg] &lt; f1) return -1;  per(pwr,0,lg+1){    if(jump[f0][pwr] &gt;= f1) continue;    f0 = jump[f0][pwr];    ans += (1&lt;&lt;(pwr));  }  assert(f0 &lt; f1 &amp;&amp; jump[f0][0] &gt;= f1);  // printf(&quot;%d\n&quot;,ans+1 +1); // 分别是跳到比f1 大的和跳到恰好f1  return ans + 2; // 分别是跳到比f1 大的和跳到恰好f1}int main(){  n = read();  m = read();  q = read();  rep(i,0,m) {    // 注意g++ 函数处理顺序问题    // ilr[read()].pb(make_pair(read(),read()));    int pos = read();    int l = read();    int r = read();    ilr[pos].pb({l,r});  }  // 合并同楼 重叠  rep(i,1,n+1){    sort(ilr[i].begin(),ilr[i].end());    vector&lt;pair&lt;int,int&gt; &gt; tmp = {}; // 合并辅助    for(auto [l,r]: ilr[i]){      if(tmp.size() == 0 || l &gt; tmp.back().second){ // 不连续 [l0,r0] .. [l1..r1]        tmp.pb({l,r});      }else{        tmp.back().second = r;      }    }    ilr[i] = tmp;    for(auto o:tmp) segs.pb(o);  }  sort(segs.begin(),segs.end()); // 所有楼的  for(auto item:segs) maxr.pb(max(maxr.back(), item.second));  // 倍增  for(auto item:segs){    auto r = item.second;    if(jump.count(r)) continue;    jump[r] = vector&lt;int&gt;(lg+1,r);    // [...r] [r+1...    int idx = lower_bound(segs.begin(),segs.end(),make_pair(r+1,-1)) - segs.begin();    jump[r][0] = maxr[idx]; // 初始化跳2^0 = 1次  }  rep(pwr,1,lg+1){    for(auto item:segs){ // 会重复计算,不影响      auto r = item.second;      jump[r][pwr] = jump[jump[r][pwr-1]][pwr-1];    }  }  while(q--) printf(&quot;%d\n&quot;, query());  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>G</p><p>倍增, 编码速度也是问题, 写几个小时还在wa,哎</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>官方题解 <a href="https://atcoder.jp/contests/abc254/editorial" target="_blank" rel="noopener">https://atcoder.jp/contests/abc254/editorial</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;G(倍增)&lt;/p&gt;
&lt;h1 id=&quot;G&quot;&gt;&lt;a href=&quot;#G&quot; class=&quot;headerlink&quot; title=&quot;G&quot;&gt;&lt;/a&gt;G&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/
      
    
    </summary>
    
      <category term="Atcoder" scheme="http://yexiaorain.github.io/Blog/categories/Atcoder/"/>
    
    
      <category term="倍增" scheme="http://yexiaorain.github.io/Blog/tags/%E5%80%8D%E5%A2%9E/"/>
    
  </entry>
  
  <entry>
    <title>CodeChef June Div1 Prefix Suffix Distinct(数学)</title>
    <link href="http://yexiaorain.github.io/Blog/2022-06-12-COOK142A-4/"/>
    <id>http://yexiaorain.github.io/Blog/2022-06-12-COOK142A-4/</id>
    <published>2022-06-12T14:24:00.000Z</published>
    <updated>2022-06-28T02:50:31.934Z</updated>
    
    <content type="html"><![CDATA[<p>主要问题不在算法,在自己写bug</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://www.codechef.com/submit-v2/PRFSUFDSTNCT" target="_blank" rel="noopener">https://www.codechef.com/submit-v2/PRFSUFDSTNCT</a></p><p>一个数组, 的前缀i个数,不重复的数值个数为pi</p><p>后缀i到结束,不重复的数值个数为si</p><p>给你p和s,问是否存在数组满足, 返回是否即可</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>n 1e5</p><p>1s</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>首先最直接的,</p><p>p[0] = s[n-1] = 1</p><p>p[n-1] = s[0]</p><p>然后 p的增量为0/1,s的增量为0/-1</p><p>再因为每个值至少贡献1次</p><p>所以如果p[i] + s[i+1] == p[n-1], 那么说明 i 和i+1 可以切开,并且这位置p增量为1,s增量为-1</p><p>对于切开后的每一段 找到变化的位置(增量为1/-1)的位置</p><p>分别跑后缀的前缀 应该小于等于前缀(与前缀首个的差)</p><p>和 前缀的后缀 应该小于等于后缀(与后缀最后一个的差)</p><h2 id="官方"><a href="#官方" class="headerlink" title="官方"></a>官方</h2><p>反而没有切割的操作,上面几个倒是有</p><p>官方 判断了个<code>a[i]+b[i] &lt;= a[n-1]</code> 跟我切割操作有点像,但是 不是错位的判断</p><p>原理和我那个也是类似,所有数贡献一次,左右统计的第i个两侧都有贡献,所以至少是a[n-1]+1</p><p>–</p><p>分析的是同一位的(p[i]-p[i-1],s[i]-s[i+1]) 的四种情况</p><p>1,1 原数组中唯一的值, 不需要额外判断, 甚至可以考虑原数组删除它</p><p>0,1 和 1,0 是对称的, 如果全部都是这两个</p><p>那么1,0 的出现意味着 右侧会有一个0,1 也就是从后缀上这个数首次出现的</p><p>可以看成1,0左括号,0,1右括号做括号匹配, 但不完全是相邻位置的, 如 (()), 可以1和3,2和4配</p><p>0,0 说明没有变化,应该被包含在某个值中, 如果记作.</p><p>那么<code>(.)(.)</code>是好的, 而<code>().()</code>,0,0无值可选</p><p>如此检查</p><hr><p><code>(.)(.)</code> 如</p><pre><code>p 111222s 222111</code></pre><p>正好一个答案是<code>111222</code></p><p><code>().()</code>如</p><pre><code>1112222111</code></pre><p>再换句 (, 上面+1, 右括号下面后一个-1, 所以考虑上下的总和变化, 出现问题就是 a[i]+b[i] &lt;= a[n-1]</p><hr><p>看了一下应该是有真的代码被我判否了, 因为我把答案逻辑塞到我代码后面return false也不对</p><p>最后发现是因为我代码 if 的l和r复制漏改了</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>按照我的逻辑AC的代码</p><p><a href="https://www.codechef.com/viewsolution/66653363" target="_blank" rel="noopener">https://www.codechef.com/viewsolution/66653363</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 1000000007#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readll p[100010]; // a 前缀 [..i] 不同的个数ll s[100010]; // a 后缀 [i..] 不同的个数bool p0[100010];bool p1[100010];// 只用 yes or noint n;// 保证范围 单增 单减 , 跨度 0/1bool check(int l,int r){  // [st..en]  if(l &gt; 0 &amp;&amp; p[l] != p[l-1]+1) return false;  if(r &lt; n - 1 &amp;&amp; p[r] != p[r+1]-1) return false;  if(l &gt; 0 &amp;&amp; s[l] != s[l-1]-1) return false;  if(r &lt; n - 1 &amp;&amp; s[r] != s[r+1]+1) return false; // 这里写成l了  if(p[r] - p[l] != s[l] - s[r])return false;  // 计算变化的点  rep(i,l,r+1){    if(i == r || p[i] != p[i+1]){      p0[i] = true;    }  }  rep(i,l,r+1){    if(i == l || s[i] != s[i-1]){      p1[i] = true;    }  }  // 跑前缀 &lt;= 前缀  {    int cur = 0;    rep(i,l,r+1){      cur += p1[i];      if( cur &gt; p[i] - p[l]+1) return false;    }  }  {    int cur = 0;    per(i,l,r+1){      cur += p0[i];      if( cur &gt; s[i] - s[r]+1) return false;    }  }  return true;}bool w(){  // 清空  n = read();  fill(p0,p0+n,0);  fill(p1,p1+n,0);  rep(i,0,n) p[i] = read();  rep(i,0,n) s[i] = read();  // p [n-1] 不同的总数  if(p[n-1] != s[0]) return false;  if(p[0] != s[n-1]) return false;  if(p[0] != 1) return false;  // 跨度 0/1  rep(i,1,n)if(p[i] &lt; p[i-1] || p[i] &gt; p[i-1] + 1)return false;  rep(i,1,n)if(s[i] &gt; s[i-1] || s[i] &lt; s[i-1] - 1)return false;  int itr = 0;  rep(i,0,n-1){    if(p[i] + s[i+1] == p[n-1]){      if(!check(itr,i)) return false;      itr = i+1;    }else if(p[i] + s[i+1] &lt; p[n-1]){      // ???      return false;    }  }  return check(itr,n-1);}int main(){  int t = read();  while(t--) printf(&quot;%s\n&quot;,w()?&quot;YES&quot;:&quot;NO&quot;);  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>BUG 是我AC失败一个重大阻碍</p><p>题解的转化我也是没想到的学习了</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://discuss.codechef.com/t/prfsufdstnct-editorial/101414" target="_blank" rel="noopener">官方</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;主要问题不在算法,在自己写bug&lt;/p&gt;
&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.codechef.com/submit-v2/PR
      
    
    </summary>
    
      <category term="CodeChef" scheme="http://yexiaorain.github.io/Blog/categories/CodeChef/"/>
    
    
      <category term="数学" scheme="http://yexiaorain.github.io/Blog/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 1687E(数学,构造,min-max容斥,kmin/kmax容斥)</title>
    <link href="http://yexiaorain.github.io/Blog/2022-06-07-CF1687E/"/>
    <id>http://yexiaorain.github.io/Blog/2022-06-07-CF1687E/</id>
    <published>2022-06-07T14:24:00.000Z</published>
    <updated>2022-06-28T02:50:31.934Z</updated>
    
    <content type="html"><![CDATA[<p>评分3500,题是国内洛谷大佬出的, t神都炸了</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://codeforces.com/contest/1687/problem/E" target="_blank" rel="noopener">https://codeforces.com/contest/1687/problem/E</a></p><p>长n的数列a</p><p>初始 v = 1</p><p>不超过1e5操作,让gcd(all(ai * aj)) = v,i != j, 就是所有不相同的两个数的乘积的gcd</p><p>一次操作, 选取a的一个子序列b,(子序列=保持顺序不要求连续)</p><p>并执行<code>v = v * lcm(b)</code>或 <code>v = v / lcm(b)</code>, 注意的是过程中,v 可以不是整数, 这里是数学除,不是整除</p><p>同时保证,所有选取的b的长度和 小于1e6</p><p>输出任何一个满足要求的方案</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>n 1e5</p><p>ai 1e6</p><p>3s</p><p>512MB</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>考虑所有与 a1 乘的</p><p><code>a1 * gcd(a2,...,an)</code></p><p>所有与a2乘的</p><p><code>a2 * gcd(a1,a3,...,an)</code></p><p>但怎么组合并不知道</p><p>反过来,既然是gcd/lcm,乘法,那么就考虑质数的出现计数</p><p>所有ai的两两相乘的gcd,其实就是 每个质数出现次数, 最小的两个和</p><p>所以目标的v 是O(n log ai) 可以得到的</p><hr><p>那么问题是如何通过lcm去搞, 题目里说 It can be shown that the answer exists</p><p>如果是两个数的gcd</p><p>gcd(a,b) * lcm(a,b) = ab</p><p>gcd(a,b) = lcm(a,a) * lcm(b,b) / lcm(a,b)</p><hr><p>考虑一下小的情况</p><blockquote><p>两个数</p></blockquote><p>v = a0 a1 = lcm(a0,a0) * lcm(a1,a1)</p><blockquote><p>三个数</p></blockquote><p>a0 = k0 q x y</p><p>a1 = k1 q y z</p><p>a2 = k2 q z x</p><p>其中 q = gcd(a0,a1,a2)</p><p>gcd(a0,a1) = qy</p><p>gcd(a1,a2) = qz</p><p>gcd(a2,a0) = qx</p><p>那么有 lcm(a0,a1,a2) = k0 k1 k2 q x y z</p><p>lcm(a0,a1) = k0 k1 q x y z</p><p>lcm(a1,a2) = k1 k2 q x y z</p><p>lcm(a2,a0) = k2 k0 q x y z</p><p>那么 目标 v = q q x y z</p><p>而观察上面的lcm, 注意到如果用一个的, 会出现如果要x y z 相等 那么会造成 q比它们多, 需要使用一个元素</p><p>那么 q x y z = lcm0 lcm1 lcm2 / lcm 012</p><blockquote><p>四个数</p></blockquote><p>考虑从三个数变形</p><p>a0 = k0 q x y</p><p>a1 = k1 q y z</p><p>a2 = k2 q z x</p><p>a3</p><p>目标是 v = gcd(a3 q,q q x y z)</p><p>这相当于 v(a0,a1,a2,a3) = gcd(a3 gcd(a0,a1,a2),v(a0,a1,a2))</p><p>如果按照这个写法,去看3个数</p><p>v(a0,a1,a2) = gcd(a2 gcd(a0,a1), v(a0,a1))</p><p>= lcm(a2 gcd(a0,a1) lcm(v(a0,a1)) / lcm(a2 gcd(a0,a1), v(a0,a1))</p><p>= v(a0,a1) a2 gcd(a0,a1) / lcm(a2 gcd(a0,a1), v(a0,a1))</p><p>= v(a0,a1) lcm(a2) lcm(a0) lcm(a1) / (lcm(a2 gcd(a0,a1), v(a0,a1)) lcm(a0,a1))</p><p>= ???</p><p>= 0 1 2 / 012</p><p>只能说 v(a0,a1) / (lcm(a2 gcd(a0,a1), v(a0,a1) lcm(a0,a1) == lcm(0,1,2) ?</p><p>没有什么思路</p><hr><p>再会看题目 n是1e5, 但希望操作不要超过1e5</p><p>但注意到上面3个数的时候用了4次,</p><p>具体例子</p><p>a0 = 11 2 3 5</p><p>a1 = 13 2 5 7</p><p>a2 = 17 2 7 3</p><p>lcm(0,1) = 11 13 2 3 5 7</p><p>lcm(1,2) = 13 17 2 3 5 7</p><p>lcm(2,0) = 17 11 2 3 5 7</p><p>lcm(0,1,2) = 11 13 17 2 3 5 7</p><p>v(0,1,2) = 2 2 3 5 7 = lcm0 lcm1 lcm2 / lcm012</p><p>说明3个的做法对于大的n并不通用, 通用的应该要能达到n个是n次的样子</p><p>对于大的n, 不会使用单个, 因为单个会有独立的系数, 任何其它gcd无法消掉</p><hr><p>那不如强行拆一下四个数</p><p>其中k是独立的部分</p><pre><code>a0 = k0  b c d        w x y    qa1 = k1  b     e f    w x   z  qa2 = k2    c   e   g  w   y z  qa3 = k3      d   f g    x y z  q</code></pre><p>发现其中出现次数都是C(4,i)对应的表现</p><p><code>v = w x y z q q</code></p><p>一个为组的轮换 (1次) (2次) (3次) (4次)</p><p>两个为组的轮换 (3次) (5次) (6次) (6次)</p><p>三个为组的轮换 (3次) (4次) (4次) (4次)</p><p>四个为组的轮换 (1次) (1次) (1次) (1次)</p><p>以线性方程组的知识, 显然 <code>(0 0 1 2) = (1 2 3 4) + 2(1 1 1 1) - (3 4 4 4)</code>, 次数是 <code>4 + 2 * 1 + 4</code> 要10次</p><hr><p>剩下的观察就是, n 1e5, 而 ai 1e6</p><p>也就是说可能有不少的因子被干掉了</p><p>并不知道如何量化分析了</p><p>只知道 k0,k1,k2,k3,b,c,d,e,f,w,x,y,z 应该是两两互质的, 否则把它们的gcd提取出来转到下一级别</p><p>而如果全部互质, 那么<code>2*3*5*7*8*11*13 = 240240</code> 在超界的边缘</p><p>似乎不可能构成的样子</p><h2 id="官方"><a href="#官方" class="headerlink" title="官方"></a>官方</h2><p>考虑容斥原理</p><p>一样的, 对于一个质数的幂次 在结果中 = 这个质数最小出现的两个幂次的和</p><p>广义 容斥</p><p>$\gcd_{i\ne j}{A_i\times A_j}=\prod_{T\subseteq U}\text{lcm}(T)^{(-1)^{|T|}(|T|-2)}$</p><p>证明一下这个表达式</p><p>因为对于不同质数,可以独立的看其幂次</p><p>不妨设对于一个具体质数, 它在这些数组元素中的幂次从小到大为 <code>p0 p1 &gt;=p1 &gt;=p1 ...</code>, 也就是a0按照p的幂次排序</p><p>需要的是$p_1+p_2$</p><p>$(lcm(a_1)) \cdot (lcm(a_2) \cdot lcm(a_1,a_2)^0 ) \cdot ( a_3^{ 1 + 0 + (-1) } \cdot (a4^{ 1 + 0 + (-1 \cdot 3) + 2 \cdot 1}) \cdot (a_5^{1 + 0 + (-1 \cdot 6) + (2 \cdot 4) + (-3 \cdot 1)}) \cdots$</p><p>$ = a_1 \cdot a_2 = p^{p_1+p_2}$</p><p>这么神奇的吗</p><p>你会发现$lcm_k, k \ge 3$ 的幂次为</p><p>$ \sum_{i=1}^k (-1)^i \cdot (i-2) \cdot C(k-1,i-1) $</p><p>$ = - \sum_{i=0}^{k-1} (-1)^i \cdot (i-1) \cdot C(k-1,i)$</p><p>$ = - \sum_{i=0}^{w} (-1)^i \cdot (i-1) \cdot C(w,i) , w = k-1 \ge 2$</p><p>$ = - \sum_{i=0}^{w} (-1)^i \cdot i \cdot C(w,i)$ ( 因为$w \ge 2 &gt; 0 时, 0 = (1-1)^w = \sum_{i=0}^{w} (-1)^i \cdot C(w,i)$</p><p>$ = - \sum_{i=0}^w (-1)^i \cdot i \cdot \frac{w!}{i!(w-i)!} $</p><p>$ = - \sum_{i=1}^w (-1)^i \cdot i \cdot \frac{w!}{i!(w-i)!} $</p><p>$ = - \sum_{i=1}^w (-1)^i \cdot \frac{w!}{(i-1)!(w-i)!} $</p><p>$ = - w \sum_{i=1}^w (-1)^i \cdot \frac{(w-1)!}{(i-1)!(w-i)!} $</p><p>$ = - w \sum_{i=1}^w (-1)^i \cdot C(w-1,i-1) $ ( 同上 因为$w-1 \ge 2-1 &gt; 0 时, 0 = (1-1)^w = \sum_{i=0}^{w} (-1)^i \cdot C(w,i)$</p><p>$ = - w \cdot 0$</p><p>$ = 0 $</p><p>其中 $ k - 1 = w \ge 2$</p><p>算强行证明了</p><hr><p>题解的过程是 有得到第k小的数的反演公式 $k\text{-th}\min{S}=\sum\limits_{\varnothing\ne T\subseteq S}(-1)^{|T|-k}\tbinom{|T|-1}{k-1}\max{T}$</p><p>那么 其实就是最小的(k=1) + 次小的(k=2) 得到</p><hr><p>一个可重整数集$S$, 其中整数范围$[1,10^6]$, 那么 总能选出大小不超过7的子集$T\subseteq S$, 让$\gcd(S)=\gcd(T)$</p><p>易证,因为$gcd(S) \le 10^6$ 所以它的质因子个数不超过7个, T只需要每个质因子的最小幂次选出来就行了</p><p>但和本题还是有区别</p><p>本题是 $gcd_2(S)$的情况, 两两下标不同乘积的gcd</p><p>这样考虑 先让集合$T$为空, 然后我们针对质数p 的幂次来讲, 假设前面已经选了几轮了, 那么最坏情况, 没有选p的最低和次低幂次, 所以为了让p的幂次满足, 任选两个最低和次低幂次, 也就是填2个, 而这种情况说明$gcd_2(S)$ 至少包含p的一次方</p><p>所以 最多有7个不同的有效p,最多选14个就能达成</p><hr><p>这样也没要求最小数量</p><p>直接用上面的lcm和gcd的min/max 表达式就可以了</p><hr><p>因为可能其它数字 虽然贡献是两个0次,但是因为, 只做了幂次最小限制,会让它们的gcd不止是对应的幂次</p><p>wa5或者看下面的例子</p><pre><code>2   3 5 72     52 2 32 2     7</code></pre><p>注意到3,5,7的最小两个幂次和都是0,而2的最小两个幂次和为1+1=2</p><p>但是如果你只选前两个去做集合运算,那么gcd = 2 5</p><p>所以你可以通过数量控制</p><h3 id="关于Min-Max-容斥"><a href="#关于Min-Max-容斥" class="headerlink" title="关于Min-Max 容斥"></a>关于Min-Max 容斥</h3><p>$max_k(S) = $ 集合$S$的第$k$大元素</p><p>TODO 再整理一篇文章: 反演 =&gt; 二项式反演 =&gt; min-max 反演 =&gt; kmax/kmin 反演</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>感觉代码还真不难写, 纯代码不到100行,毕竟给了3s</p><p><a href="https://codeforces.com/contest/1687/submission/159885371" target="_blank" rel="noopener">https://codeforces.com/contest/1687/submission/159885371</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_back#define all(O) O.begin(),O.end()ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readint n;int a[100010];int v2p[1000010]; // 每个数的质数拆解const int INF = 0x3f3f3f3f;int getpwr(int v,int p){  int r = 0;  while(v % p == 0){    r++;    v/=p;  }  return r;}int main(){  int n = read();  rep(i,1,n+1) a[i] = read();  // 质数 到最低两个幂次 和对应的数的下标  unordered_map&lt;int, vector&lt; pair&lt;int,int&gt; &gt; &gt; p2low2;  // 质数  rep(i,2, 1000000){    if(v2p[i])continue; // 合数    p2low2[i] = vector(2,make_pair(INF,-1));    for(ll j = i*i;j &lt;= 1000000;j+=i){      v2p[j] = i;    }  }  // 筛出至多14个数  rep(i,1,n+1) {    vector&lt;int&gt; rm;    for(auto &amp;item: p2low2){      auto &amp;[p,low2] = item;      low2.push_back({getpwr(a[i],p),i});      sort(all(low2));      low2.pop_back();      if(low2.back().first == 0 &amp;&amp; p2low2.size() &gt;= 7 + 1 + rm.size()){ // wa5, 0 幂次贡献也有作用        rm.push_back(p);      }    }    for(auto p:rm) p2low2.erase(p);  }  vector&lt;int&gt; pos;  for(auto &amp;[p,low2]:p2low2){    pos.push_back(low2[0].second);    pos.push_back(low2[1].second);  }  assert(pos.size() &lt;= 14);  // 排序去重  sort(all(pos));  pos.erase(unique(all(pos)),pos.end());  int cnt = 0;  // 公式输出  rep(bits,1,(1&lt;&lt;pos.size())){    // lcm{set} ^ ( (-1)^|set| (|set| - 2))    int t = __builtin_popcount(bits);    int pwr = (t%2?-1:1) * (t-2);    cnt += abs(pwr);  }  printf(&quot;%d\n&quot;,cnt);  rep(bits,1,(1&lt;&lt;pos.size())){    // lcm{set} ^ ( (-1)^|set| (|set| - 2))    int t = __builtin_popcount(bits);    int pwr = (t%2?-1:1) * (t-2);    if(!pwr) continue;    int op = pwr &lt; 0 ? 1 : 0;    pwr = abs(pwr);    while(pwr--){      printf(&quot;%d %d&quot;,op,t);      rep(i,0,pos.size()){        if(bits &amp; (1&lt;&lt;i)){          printf(&quot; %d&quot;, pos[i]);        }      }      printf(&quot;\n&quot;);    }  }  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>光是这个容斥公式, 我都得不出, 全靠手工算了个特例</p><p>知识点1, kmin/kmax 反演 有地一个公式</p><p>知识点2, 从gcd 集合, 推理到gcd2集合的元素个数上限和一种构造方案</p><p>gcd2(S) =&gt; gcd2(T) =&gt; kmin容斥</p><hr><p>思考角度从小量枚举和得到的线性公式是可以的,而主要缺乏相关反演知识,应该去补充</p><p>然后有感觉到可能被值的范围限制了运算, 但是没想到考虑从gcd 演变到gcd2</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://codeforces.com/blog/entry/103493" target="_blank" rel="noopener">官方</a></p><p><a href="https://www.luogu.com.cn/problem/solution/CF1687E" target="_blank" rel="noopener">luogu</a></p><p><a href="https://www.luogu.com.cn/blog/command-block/xuan-ku-fan-yan-mo-shu" target="_blank" rel="noopener">反演</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;评分3500,题是国内洛谷大佬出的, t神都炸了&lt;/p&gt;
&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contes
      
    
    </summary>
    
      <category term="Codeforces" scheme="http://yexiaorain.github.io/Blog/categories/Codeforces/"/>
    
    
      <category term="构造" scheme="http://yexiaorain.github.io/Blog/tags/%E6%9E%84%E9%80%A0/"/>
    
      <category term="数学" scheme="http://yexiaorain.github.io/Blog/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="min-max容斥" scheme="http://yexiaorain.github.io/Blog/tags/min-max%E5%AE%B9%E6%96%A5/"/>
    
      <category term="kmin/kmax容斥" scheme="http://yexiaorain.github.io/Blog/tags/kmin-kmax%E5%AE%B9%E6%96%A5/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 1687D(数学,跳点)</title>
    <link href="http://yexiaorain.github.io/Blog/2022-06-05-CF1687D/"/>
    <id>http://yexiaorain.github.io/Blog/2022-06-05-CF1687D/</id>
    <published>2022-06-05T14:24:00.000Z</published>
    <updated>2022-06-28T02:50:31.934Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://codeforces.com/contest/1687/problem/D" target="_blank" rel="noopener">https://codeforces.com/contest/1687/problem/D</a></p><p>f(x) =比x小最大平方数</p><p>g(x) =比x大最小平方数</p><p>如果 x - g(x) &lt; f(x) - x 那么x是好的</p><p>给长度n的单调数组a, 求最小非负k,使得 ai+k 全为好的</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>n 1e6</p><p>ai 2d6</p><p>2s</p><p>256MB</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>先做点数学变形</p><p>易知, 如果 $x \in [w^2,w^2+w]$ 那么x是好的</p><p>然后 真不会了</p><h2 id="官方"><a href="#官方" class="headerlink" title="官方"></a>官方</h2><p>显然 $k \le a_n^2$, 因为 $[a_n^2,a_n^2+a_n]$ 的长度都是 $a_n$ 一定能放下所有数</p><p>有$w \le a_n$</p><p>令$f(x) = w$</p><p>枚举$f(a_1 + k) le a_n$ 得到$le a_n$个区间</p><p>然后枚举 $f(a_i + k)$ 的所有区间</p><p>伪代码</p><pre><code>for w = sqrt(a_1)...: //枚举根号后的结果  krange = [...]  for i = 2..n:    krange = krange 交 calc(krange, a_i) // 注意到 合法与不合法的间隔单调递增, 所以 交完后还是连续区间  if len(krange) == 0:      break  if len(krange) &gt; 0:    return krange.start</code></pre><p>这样 n个 和$a_n$ 个区间, 复杂度$O(n a_n)$</p><p>实际上 你需要考虑的是$f(a_i+k) \neq f(a_{i-1} + k)$, </p><p>也就是 这里的 对于给定的 $f(a_1+k) = w$</p><p>那么 相邻的f不等的情况只有w 种, 所以你考虑 不等的时候, 不等的前一个 和 后一个 都会对区间更新有影响</p><p>但是中间的, 因为是连续的范围,所以不会有额外影响</p><p>所以 $O(\sum{\frac{a_n}{w}})$ 期望 是 $a_n log (a_n)$,</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://codeforces.com/contest/1687/submission/159707568" target="_blank" rel="noopener">https://codeforces.com/contest/1687/submission/159707568</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readint n;ll a[1000010]; // 有序 ai &lt; 2e6ll mysqrt(ll v){  ll l = 1;  ll r = v;  while(l != r){    ll mid = (l+r)/2;    // 先控范围防止 overflow    if( v/mid &lt; mid ){      r = mid - 1;    }else if( mid * mid &lt;= v &amp;&amp; (mid+1)*(mid+1) &gt; v){      return mid;    }else if( (mid+1) * (mid+1) &lt;= v){      l = mid + 1;    }else {      r = mid - 1;    }  }  return l;}//  [l...r]bool calc(ll w,ll &amp;l,ll &amp;r){  // printf(&quot;calc %lld [%lld %lld] [%lld %lld]\n&quot;,w,w*w,w*(w+1),l,r);  while(true){    // [w^2,w^2+w, 因为长度单增,不可能和 [(w+1)**2 有交集    // 找同为w的最大的 w^2 &lt;= a[idx-1] + kmin &lt;= w^2 + w, a[idx-1] &lt;= w(w+1) - kmin    int idx = lower_bound(a,a+n,w*(w+1)-l+1) - a;    // 首个 ?    ll v = a[idx-1];    r = min(r,w*(w+1) - v);    // printf(&quot;lower_bound a[%d]:%lld =&gt; [%lld %lld]\n&quot;,idx-1,a[idx-1],l,r);    if(l &gt; r) return false;    if(idx == n)return true; // 最后一个    w = mysqrt(a[idx]+r); // 下一个位置的    ll nl = w*w - a[idx];    ll nr = w*(w+1) - a[idx];    l = max(l,nl);    r = min(r,nr);    // printf(&quot;next %lld =&gt; [%lld %lld]\n&quot;,a[idx],l,r);    if(l &gt; r) return false;  }  assert(false);  return true;}int main(){  n = read();  rep(i,0,n) a[i] = read();  rep(w,mysqrt(a[0]),a[n-1]+1){    ll l = max(w*w - a[0],(ll)0);    ll r = w*(w+1) -a[0];    // printf(&quot;\t rep %lld [%lld %lld] [%lld %lld]\n&quot;,w,w*w,w*(w+1),l,r);    if(r &lt; l) continue;    if(calc(w,l,r)){      printf(&quot;%lld\n&quot;,l);      return 0;    }  }  assert(false);  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过枚举w来, 让a的是多个连续的一段,且只有区间端点有影响, 这样, 通过枚举的初始值 让总枚举量为接近自然数分之一的级数 表达,而在有限范围时 , 区域log级别</p><p>完全没想到是通过 w来划分的, 也就是还是有点按结果划分,又不是二分的划分形式</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://codeforces.com/blog/entry/103493" target="_blank" rel="noopener">官方</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1687/problem/D&quot; target=&quot;_blank
      
    
    </summary>
    
      <category term="Codeforces" scheme="http://yexiaorain.github.io/Blog/categories/Codeforces/"/>
    
    
      <category term="数学" scheme="http://yexiaorain.github.io/Blog/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="跳点" scheme="http://yexiaorain.github.io/Blog/tags/%E8%B7%B3%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 1691F(贡献统计,组合数,树)</title>
    <link href="http://yexiaorain.github.io/Blog/2022-06-04-CF1691F/"/>
    <id>http://yexiaorain.github.io/Blog/2022-06-04-CF1691F/</id>
    <published>2022-06-04T14:24:00.000Z</published>
    <updated>2022-06-28T02:50:31.934Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://codeforces.com/contest/1691/problem/F" target="_blank" rel="noopener">https://codeforces.com/contest/1691/problem/F</a></p><p>树,n个点,点上1~n</p><p>给定k</p><p>对于点r, 树的一个k个点的子点集S, 令f(r,S) = 根为r, 且包含所有S中点的原树的子树最少的点的个数</p><p>你需要计算 所有 r和S的组合 求 所有f(r,S)的和</p><p>答案mod 1e9+7</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>n 2e5</p><p>3s</p><p>512MB</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>看数据范围n方都不行, 既然又是求和</p><p>那么估计又是算贡献一类</p><p>从树的结构讲, 与其算贡献不如算不被贡献</p><p>一个点u,连接了很多点v0,v1,v2,v3</p><p>如果要u不被贡献, 那么r和S的所有点一定在某个vi的联通块内,不会是不同vi的联通块内</p><p>而选择来讲, 对于S, 就是C(联通块大小,k), 对于r就是联通块大小</p><p>注意联通块 &lt; k时 方案为0</p><hr><p>感觉就过了???不想写代码</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>鸽</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>感觉给时间, 就这样随便搞一搞就完了?</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>无</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1691/problem/F&quot; target=&quot;_blank
      
    
    </summary>
    
      <category term="Codeforces" scheme="http://yexiaorain.github.io/Blog/categories/Codeforces/"/>
    
    
      <category term="树" scheme="http://yexiaorain.github.io/Blog/tags/%E6%A0%91/"/>
    
      <category term="组合数" scheme="http://yexiaorain.github.io/Blog/tags/%E7%BB%84%E5%90%88%E6%95%B0/"/>
    
      <category term="贡献统计" scheme="http://yexiaorain.github.io/Blog/tags/%E8%B4%A1%E7%8C%AE%E7%BB%9F%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Pollard-Rho 质数拆分</title>
    <link href="http://yexiaorain.github.io/Blog/2022-06-03-pollard-rho/"/>
    <id>http://yexiaorain.github.io/Blog/2022-06-03-pollard-rho/</id>
    <published>2022-06-03T02:37:14.000Z</published>
    <updated>2022-06-28T02:50:31.934Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h1><p>在之前做Project Euler 216 的时候</p><p>学了一下 如何利用别人的答案,在log n时间内判断n是否是一个 64位以内的质数的 Miller-Rabin 判别法</p><p>但如果这个数不是质数, 如何能拆解还没有解决</p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h2><p>回到最初的起点, for一遍 那也是$\sqrt(n)$</p><p>而众所周知, $\sqrt {2^{64}} = 2^{32} = $ 4.2e9</p><p>单独算一次的时间复杂度都接受不了</p><h2 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h2><p>相信随机的力量, 先特判是否质数</p><p>在不停的随一个判断是否<code>gcd != 1</code> 来找因数</p><hr><p>问题是, 生日悖论(一个房间里有23个人，则他们中有两人生日相同的概率超过一半)</p><p>换句话说, 反复生成随机数,有很高几率生成了不少一样的</p><h2 id="Pollard-的伪随机数"><a href="#Pollard-的伪随机数" class="headerlink" title="Pollard 的伪随机数"></a>Pollard 的伪随机数</h2><p>问题变成 我们希望它概率上看起来随机,值上有不重复得不那么随机</p><p>$x_{n+1} = f(x_n) = (x_n^2 + c) mod N$</p><p>但也不一定如期望, 例如 x = 0, c= 24,N = 9400, 很有规律, 因为这个递推式说白了就是下一项由上一项决定,肯定有循环,只是循环的早晚</p><p>低空间,低时间判断环? 那不是经典面试题双指针吗?(floyd判环算法)</p><p>初始$x_1 = y_1$</p><p>$x_{n+1} = f(x_n)$</p><p>$y_{n+1} = f(f(y_n))$</p><p>每次判断$gcd(|x_n - y_n|,N) &gt; 1$, 和是否到达环, 成环则换一个c来跑</p><hr><p>性质 |i-j| 是p的倍数,则 |f(i)-f(j)| 也是p的倍数</p><p>如果看作环上指针, 也就意味这两个指针距离相等时,其它距离和这个距离相等的两个指针之差,都是p的倍数,</p><p>而快慢指针每次会让距离+1, 而对于环上的视角, 其实追上慢指针相当于逐渐减少</p><h2 id="实现和细节"><a href="#实现和细节" class="headerlink" title="实现和细节"></a>实现和细节</h2><p>据说$O(n^{\frac{1}{4}}\log n)$</p><p>$N = 4,N = 1$ 需要特判</p><p>素数平方提前判断</p><p>让x=0</p><pre><code class="cpp">ll Pollard_Rho(ll N) {  assert(N!=1);  if (N == 4) return 2;  if (is_prime(N)) return N;  if (is_prime_square(N)) return prime_square(N);  while(true) {    ll c = randint(1, N - 1); // 生成随机的c    auto f = [=](ll x) { return ((lll)x * x + c) % N; }; // lll表示__int128，防溢出    ll t = 0, r = 0;    do{      t = f(t);      r = f(f(r));      ll d = gcd(abs(t - r), N);      if (d &gt; 1) return d;    }while (t != r)  }}</code></pre><h2 id="固定128距离"><a href="#固定128距离" class="headerlink" title="固定128距离"></a>固定128距离</h2><p>减少求gcd的次数, 128次 或者 即将乘起来是N的倍数</p><p>大概是$O(n^{\frac{1}{4}})$</p><pre><code class="cpp">ll Pollard_Rho(ll N) {  assert(N!=1);  if (N == 4) return 2;  if (is_prime(N)) return N;  if (is_prime_square(N)) return prime_square(N);  while(true){    ll c = randint(1, N - 1);    auto f = [=](ll x) { return ((lll)x * x + c) % N; };    ll t = 0, r = 0, p = 1, q;    do {      for (int i = 0; i &lt; 128; ++i) { // 令固定距离C=128        t = f(t), r = f(f(r));        if (t == r || (q = (lll)p * abs(t - r) % N) == 0) break; // 如果发现环，或者积即将为0，退出        p = q;      }      ll d = gcd(p, N);      if (d &gt; 1) return d;    } while (t != r);  }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前情提要&quot;&gt;&lt;a href=&quot;#前情提要&quot; class=&quot;headerlink&quot; title=&quot;前情提要&quot;&gt;&lt;/a&gt;前情提要&lt;/h1&gt;&lt;p&gt;在之前做Project Euler 216 的时候&lt;/p&gt;
&lt;p&gt;学了一下 如何利用别人的答案,在log n时间内判断n是否
      
    
    </summary>
    
      <category term="Math" scheme="http://yexiaorain.github.io/Blog/categories/Math/"/>
    
    
      <category term="math" scheme="http://yexiaorain.github.io/Blog/tags/math/"/>
    
      <category term="prime" scheme="http://yexiaorain.github.io/Blog/tags/prime/"/>
    
  </entry>
  
  <entry>
    <title>Atcoder arc141 C D E</title>
    <link href="http://yexiaorain.github.io/Blog/2022-06-02-ac_arc141/"/>
    <id>http://yexiaorain.github.io/Blog/2022-06-02-ac_arc141/</id>
    <published>2022-06-01T20:25:14.000Z</published>
    <updated>2022-06-28T02:50:31.934Z</updated>
    
    <content type="html"><![CDATA[<p>C(math, 括号对)D(math,集合,数论,动归)E(并查集)</p><h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://atcoder.jp/contests/arc141/tasks/arc141_c" target="_blank" rel="noopener">https://atcoder.jp/contests/arc141/tasks/arc141_c</a></p><p>他给两个排列p和q, 长度2n</p><p>构造 长2n的括号字符串,含有n个左括号,n个右括号</p><p>使得p是所有 让 s[p[i]] 为合法括号序列中的字典序最小的</p><p>同时q是所有 让 s[q[i]] 为合法括号序列中的字典序最大的</p><h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h3><p>n&lt;=2e5</p><p>2s</p><p>1024mb</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h3><p>显然开始和最后的位置分别是 左右括号</p><p>对于p, 当左右括号都可以选时,一定会选没有被选坐标最小的</p><p>当前缀完成匹配时, 只能选左括号, 这时选左括号坐标最小的</p><p>于是, 如果当前坐标以前的没有选完,那么说明当前位置是左括号,且没有被选的是右括号</p><p>对于q,类似的, 先选最大的, 左括号也是先选最大的</p><p>这样分别确定的右括号不少于 左括号个数</p><hr><p>但是对于剩余没有填的位置怎么做,我没有思路了,因为它不只需要保证一个排列合法,它需要保证p和q都合法</p><h3 id="官方"><a href="#官方" class="headerlink" title="官方"></a>官方</h3><p>前面还是一样的, 但这里强调了是 奇数处出现, 因为 要前面匹配完,说明前面用了偶数个</p><p>而且不像我那样 需要 前缀未填完, 而只是 奇小于下一个偶, P[2i-1] &lt; P[2i]</p><p>但说是 如果还是有多个候选的,那么就是没有方案</p><p>如果只有一个候选S,就看是否同时满足p和q</p><p>简单的来讲如果S或它的逆序是一个合法的括号序列, (一般情况也可以类似证明, 因为一般的S 可以表示成合法和 和 逆序合法的连接</p><p>令 L1 &lt; L2 &lt; L3 … &lt; LN 分别是左括号的下标</p><p>R1 &lt; R2 &lt; R3 … &lt; RN 分别是右括号的下标</p><p>既然S是合法的,那么有 Li &lt; Ri</p><p>因此字典序最大的排列是$L_N,R_N,L_{N-1},R_{N-1},…,L_1,R_1$</p><p>因此 S是唯一的</p><p>并且确定的过程和上述描述的也是一致的</p><hr><p>如果S的逆序是合法的</p><p>那么有</p><p>令 L1 &lt; L2 &lt; L3 … &lt; LN 分别是左括号的下标</p><p>R1 &lt; R2 &lt; R3 … &lt; RN 分别是右括号的下标</p><p>既然S的逆序列是合法的,那么有 Li &gt; Ri</p><p>所以字典序最小的是$L_1,R_1,L_2,R_2,…,L_N,R_N$</p><p>并且确定的过程和上述描述的也是一致的</p><hr><p>再对于一般序列来讲</p><p>又回到 括号序列的常用技巧,左括号+1,右括号-1</p><p>那么其实就是 一些在正平面的一些曲线和负平面的一些曲线,</p><p>显然由和0点隔开的 顺序上也相互独立(见官方youtube上画的图</p><p>这样 对于每一段来说,是正平面则由最大序列唯一确定, 是负平面则由最小序列</p><p>所以 整体都是唯一的</p><p>这样就是官方提接说的一般序列的 拼接类似</p><p>综上得证</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/arc141/submissions/32155305" target="_blank" rel="noopener">https://atcoder.jp/contests/arc141/submissions/32155305</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;(int)n;i++)int read(){int r;scanf(&quot;%d&quot;,&amp;r);return r;} // readint p[400010];int q[400010];char s[400010];char sets(int i,char ch){  return (s[i] &amp;&amp; s[i] != ch) ? 0 : (s[i] = ch);}bool work(){  int n = read() * 2; // 2e5 * 2  rep(i,0,n) p[i] = read() - 1;  rep(i,0,n) q[i] = read() - 1;  for(auto [arr, cmp]:vector&lt;pair&lt;int *,int&gt; &gt; {{p, 1},{q,-1}}){    rep(i,0,n-1) {      if((arr[i] - arr[i+1]) * cmp &lt;= 0) continue; // 出现反序列      if(!sets(arr[i],&#39;(&#39;) || !sets(arr[i+1],&#39;)&#39;)) return false;    }  }  rep(i,0,n) if(!s[i]) return false; // 不唯一  // check 可能一个合法 另一个不合法  for(auto [arr,st,d]:vector&lt;tuple&lt;int*,int,int&gt; &gt;{{p,0,1},{q,n-1,-1}}){    // 双指针    int i0 = st; // 找所有值    int i1 = st; // 只找左括号    int cnt = 0;    vector&lt;bool&gt; vis(n,false);    rep(i,0,n){      int pos ; // 选取的位置      if(cnt == 0){        while(vis[i1] || s[i1] != &#39;(&#39;) i1+=d;        pos = i1;      }else{ // cnt &gt; 0        while(vis[i0])i0+=d;        pos = i0;      }      if(arr[i] != pos) return false; // 和提供的不一致      vis[pos] = true;      cnt += s[pos] == &#39;(&#39;?1:-1;    }    if(cnt) return false;  }  printf(&quot;%s\n&quot;,s);  return true;}int main(){  if(!work()) printf(&quot;-1\n&quot;);  return 0;}</code></pre><h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p><a href="https://atcoder.jp/contests/arc141/tasks/arc141_d" target="_blank" rel="noopener">https://atcoder.jp/contests/arc141/tasks/arc141_d</a></p><p>对于一个集合S, 任意两个元素不成倍数关系,那么认为是一个好集合</p><p>给一个n个元素,元素值范围在[1,2m]之间的集合, 元素值不重复, 给值时从小到大</p><p>对于每个元素,判断是否存在一个S的子集,包含该元素且是好集合</p><h3 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h3><p>M&lt;=N&lt;2M</p><p>M 3e5</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><h3 id="我的想法"><a href="#我的想法" class="headerlink" title="我的想法"></a>我的想法</h3><p>既然给值就是从小到大, 那么省去了排序</p><p>既然一定要a[i], 那么它的倍数和约数一定不可行,而约数是log级别的个数,</p><p>这里虽然问是否能恰好m个, 但如果&gt;=m 合法,删掉多于m的依然合法</p><p>所以变成能否有不少于m个</p><p>对于即不是ai倍数,也不是ai约数的, 考虑最多能取多少个</p><p>于是集合被化分成(ai,ai约数,ai倍数) (其它), 那么包含ai的最大的个数是 1+max(其它)</p><hr><p>首先 值的倍数从均摊上讲 也是 log级别的, 因为 1/2+1/3+1/4… 在小的时候是 常数倍</p><p>但 剩下的如何尽可能多的取, 以及如果只是暴力去尝试的话, 显然 会达到至少 n平方</p><hr><p>另一个就是互斥关系,  如果建立互斥关系的2-sat图, 跑tarjan ,能一次计算</p><p>注意到互斥关系不会变, 所以2-sat不会变, 但是怎么选一个而不选其它</p><h3 id="官方-1"><a href="#官方-1" class="headerlink" title="官方"></a>官方</h3><p><strong>其实是个卡着边界的问题</strong></p><p>考虑所有奇数的2的幂次倍</p><p><code>(1,2,4,8,16...),(3,6,12,24...),(5,10,20...)</code></p><p>注意到的是 ,一共有m组,且每组内部两两是倍数关系, 因此我们选的答案,不会同时出现在一组中, 所以 至多选m个</p><hr><p>这个对答案也有帮助, 如果题目给的S, 在上述的2的幂次倍中 有的组不存在,那么显然达不到m</p><p>现在问题是跨组会不会有 倍数关系</p><p>假设 $x_1 &lt; x_2$ 都是奇数, 选了 $x_1 2^{p_1},x_22^{p_2}$</p><p>那么如果成倍数一定是 $p_2 \ge p_1$ 且 $x_2$是$x_1$的倍数</p><p>换句话说, 要想合法, 那么一个数的约数对应的2的幂次要比它本身大</p><hr><p>考虑 每个奇数的2的幂次的上下界, [Li,Ri]</p><p>直接动归转移方程</p><p>对于<code>R[value] = min(R[value 的因子]) - 1 且存在于S</code></p><p>对于<code>L[value] = max(L[value的倍数]) + 1 且存在于S</code></p><p><code>R1,R2,R3,...R,被选的值,L,...,L</code> 将是合法解, <code>[Li &lt;= 被选的幂次 &lt;= Ri]</code></p><p>因为前面的尽可能大,后面尽可能小且 被选值在范围中</p><hr><p>综上 因为因子数和均摊倍数个数都是log级别,所以总的均摊代价就是log级别</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/arc141/submissions/32169715" target="_blank" rel="noopener">https://atcoder.jp/contests/arc141/submissions/32169715</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readbool exist[600010];vector&lt;int&gt; ys[600010]; // 所有真奇数约数int L[600010];int R[600010];int a[600010];int n,m;bool w(){  n = read();  m = read()*2;  rep(i,0,n) {    exist[a[i] = read()] = 1;  }  rep(i,1,m/2+1){    if(i%2 == 0)continue;    rep(t,3,m/2+1){      if(t%2 == 0)continue;      if(i*t &gt; m)break;      ys[i*t].push_back(i);    }  }  // 先检查是否所有组都有  rep(i,1,m+1){    if(i%2==0)continue;    bool found = false;    int itr = i;    while(itr &lt;= m){      if(exist[itr]){        found = true;        break;      }      itr*=2;    }    if(!found)return false;  }  // 计算R  rep(i,1,m){    if(i%2 == 0) continue;    int pwr = 20;    // 计算它因数对它的限制    for(auto item:ys[i]){      pwr = min(pwr,R[item]-1);    }    // 找一个范围内且存在的    bool found = false;    while(pwr &gt;= 0){      if(i * (1&lt;&lt;pwr) &lt;= m){ // 小心 out bound        if(exist[i * (1&lt;&lt;pwr)]){          R[i] = pwr;          found = true;          break;        }      }      pwr--;    }    // printf(&quot;L %lld =&gt; %d\n&quot;,i,pwr);    if(!found) return false; // 不存在合法范围的值  }  // 计算L  per(i,1,m){    if(i%2 == 0) continue;    int pwr = 0;    // 计算它倍数对它的限制    rep(k,3,m+1){      if(k%2==0)continue;      if(i*k &gt; m)break;      pwr = max(pwr,L[i*k]+1);    }    // 找一个范围内且存在的    bool found = false;    while( i*(1&lt;&lt;pwr) &lt;= m){      if(exist[i * (1&lt;&lt;pwr)]){        L[i] = pwr;        found = true;        break;      }      pwr++;    }    if(!found) return false; // 不存在合法范围的值    if(L[i] &gt; R[i]) return false;  }  // 计算答案  rep(i,0,n){    int v = a[i];    int pwr = 0;    while(v%2 == 0){      pwr++;      v/=2;    }    printf(&quot;%s\n&quot;, L[v] &lt;= pwr &amp;&amp; pwr &lt;= R[v]?&quot;Yes&quot;:&quot;No&quot;);  }  return true;}int main(){  if(!w()) rep(i,0,n) printf(&quot;No\n&quot;);  return 0;}</code></pre><h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p><a href="https://atcoder.jp/contests/arc141/tasks/arc141_e" target="_blank" rel="noopener">https://atcoder.jp/contests/arc141/tasks/arc141_e</a></p><p>n方个点, <code>(1..n,1..n)</code></p><p>q 个询问</p><p>每个询问 a,b,c,d</p><p>会把 点((a+k)%n,(b+k)%n) 和 点((c+k)%n,(d+k)%n) 相连, 其中k取 0 到 n-1</p><p>询问之间是影响的, 是在上一次结果上继续连</p><p>每次回答一个询问操作后,剩下的联通块数</p><h3 id="范围-2"><a href="#范围-2" class="headerlink" title="范围"></a>范围</h3><p>n 2e5</p><p>q 2e5</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h3><p>首先, 其实让a,b,c,d 变成 a1=(a+n-a)%n,b1=(b+n-a)%n,c1=(c+n-a)%n,d1=(d+n-a)%n, 因为k取[0..n-1], 所以等价</p><p>变成 k,(b1+k)%n,(c1+k)%n,(d1+k)%n</p><p>画图, 会发现 (k,(b1+k)%n) 在一条45度角的一条斜线上,((c1+k)%n,(d1+k)%n) 也在一条45度角的一条斜线上</p><ol><li>如果共线, 那么 如果原来不是一个联通块,则 减少了 n-1个联通块, 如果原来是多个联通, 那么对结果影响 = -(个数-1)</li></ol><p>有了这个思路, 我们问题通过图像可以变一变</p><p>沿着+1,+1的45度, 形成n组点,每组点有个属性内部是否相连</p><p>考虑两组之间的关系, </p><p>1次连接, 那么这两组形成的是n个连通块, 且内部联通关系,一旦有一个联通则连通</p><p>而这个值其实 = gcd(偏移量间隔)</p><p>所以未连接和 连接一次的偏移量间隔为 n</p><p>而对两个组的影响是相同的</p><p>所以变成</p><p>哪些组属于一个并查集合, 它们自身内部的偏移量等价(一个值) 它们与根的偏移量等价</p><hr><p>似乎就可以做了</p><p>但感觉在合并并查集时更新需要注意</p><hr><p>然后 真的 我就AC了???? atcoder真的是数学场吗</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/arc141/submissions/32185372" target="_blank" rel="noopener">https://atcoder.jp/contests/arc141/submissions/32185372</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 1000000007#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readint gcd(int a,int b){  while(b!=0){    a=a%b;    swap(a,b);  }  return a;}int fa[200010];int a[4];int inner[200010]; // 组内部最小间隔, 一定是n的因子int tofa[200010]; // 跨组偏移距离ll n;int getfa(int i){  if(i == fa[i]) return i;  int newfa = getfa(fa[i]);  tofa[i] = ((tofa[i] + tofa[fa[i]])%n)%inner[newfa];  return fa[i] = newfa;}// new root u// u and v is old rootvoid link(int u,int v,int off){  fa[v] = u;  inner[u] = gcd(inner[u],inner[v]);  tofa[v] = off % inner[u];}int main(){  n = read();  ll q = read();  ll ans = n*n;  iota(fa,fa+n,0);  fill(inner,inner+n,n);  rep(i,0,q){    rep(j,0,4) a[j] = read();    per(j,0,4) (a[j] += n-a[0])%=n;    int g1 = a[1] - a[0];    int g2 = (a[3]-a[2]+n)%n;    int off = a[2] - a[0];    int f1 = getfa(g1);    int f2 = getfa(g2);    // 同组更新内部间隔    if(f1 == f2){      // ans -= inner[f1] - inner[f1];      // printf(&quot;SAME %d[%d] =&gt; &quot;,f1,inner[f1]);      ans -= inner[f1];      inner[f1] = gcd(inner[f1], 2*n + tofa[g1] - tofa[g2] + off); // 不是off      ans -= -inner[f1];      // printf(&quot;%d \n&quot;,inner[f1]);    }else{ // 不同组 合并组      // printf(&quot;DIFF %d[%d] + %d[%d] =&gt; &quot;,f1,inner[f1],f2,inner[f2]);      // g1-&gt;f1, g2-&gt;f2      // f2-&gt;f1?      // f1 - f2 = (f1 - g1) - (f2 - g2) + (g2 - g1)      // ans -= inner[f1] + inner[f2] - inner[f1];      ans -= inner[f1] + inner[f2];      link(f1,f2, (2*n + tofa[g1] - tofa[g2] + off)%n);      ans -=  - inner[f1];      // printf(&quot;%d \n&quot;,inner[f1]);    }    printf(&quot;%lld\n&quot;,ans);  }  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>C</p><p>这个基本的能想到, 但是没有尝试更多数据, 去考虑它的唯一性, 还在想怎么填中间的</p><p>这方面要培养,有点像反过来想题目, 如果题目本身设计上有唯一性只是需要证明, 这个思路方向, 因为毕竟是确定有答案的题目而不是开放性问题</p><p>另外就是括号序列还是不熟悉, 如果熟悉常见+1,-1套路,画图去思考也会简单不少</p><p>虽然从逻辑上 我的 当前前面未填完,则当前(,未填都是),  数学上好像 更多信息, 但这里反而成了干扰</p><p>据说能用DP做?</p><p>D</p><p>这数学性好强啊, 知识点是属于集合论的和数论的,甚至有点抽屉原理,</p><p>能想到奇数与它的2的幂次倍数的分组是这个题的核心一点</p><p>这一想出后面就自然很多了</p><p>E</p><p>我这赛后没有看题解,竟然AC了 ??????</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>官方题解 <a href="https://atcoder.jp/contests/arc141/editorial/" target="_blank" rel="noopener">https://atcoder.jp/contests/arc141/editorial/</a></p><p><a href="https://www.youtube.com/watch?v=_oUQyyjp4Wk" target="_blank" rel="noopener">官方youtube</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;C(math, 括号对)D(math,集合,数论,动归)E(并查集)&lt;/p&gt;
&lt;h1 id=&quot;C&quot;&gt;&lt;a href=&quot;#C&quot; class=&quot;headerlink&quot; title=&quot;C&quot;&gt;&lt;/a&gt;C&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;he
      
    
    </summary>
    
      <category term="Atcoder" scheme="http://yexiaorain.github.io/Blog/categories/Atcoder/"/>
    
    
      <category term="math" scheme="http://yexiaorain.github.io/Blog/tags/math/"/>
    
      <category term="并查集" scheme="http://yexiaorain.github.io/Blog/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="动归" scheme="http://yexiaorain.github.io/Blog/tags/%E5%8A%A8%E5%BD%92/"/>
    
      <category term="括号对" scheme="http://yexiaorain.github.io/Blog/tags/%E6%8B%AC%E5%8F%B7%E5%AF%B9/"/>
    
      <category term="集合" scheme="http://yexiaorain.github.io/Blog/tags/%E9%9B%86%E5%90%88/"/>
    
      <category term="数论" scheme="http://yexiaorain.github.io/Blog/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 1685 C D1</title>
    <link href="http://yexiaorain.github.io/Blog/2022-06-01-CF1685_C_D1/"/>
    <id>http://yexiaorain.github.io/Blog/2022-06-01-CF1685_C_D1/</id>
    <published>2022-05-31T19:24:00.000Z</published>
    <updated>2022-06-28T02:50:31.934Z</updated>
    
    <content type="html"><![CDATA[<p>C(括号对,前缀和,数学)D1(构造,排列,并查集)</p><h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://codeforces.com/contest/1685/problem/C" target="_blank" rel="noopener">https://codeforces.com/contest/1685/problem/C</a></p><p>给你一个 n个左括号 n个右括号 的序列</p><p>最小次数, 翻转子区间,让整个括号合法</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>n 1e5</p><p>1s</p><p>256MB</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h3><p>括号嘛, 认知还在任意前缀1的个数大于等于0的个数</p><p>想的是先转换成0/1,两个指针包裹 两头贪心</p><p>没了, 没思路了, 感觉贪心都不对的</p><p>写了果然wa了</p><h3 id="官方"><a href="#官方" class="headerlink" title="官方"></a>官方</h3><p>别统计1和0, 直接 左括号1贡献,右括号-1贡献 XD</p><p>同样的也就是前缀和 大于等于0</p><p>一个数学结论, 至多两次就能让结果合法</p><p>如果 前缀i是 所有前缀中最大的,那么翻转 <code>[1..i]</code>和<code>[i+1,2n]</code> </p><p>因为 对于 j&lt;=i,新的前缀 newpre[j] = pre[i] - pre[j] &gt;= 0</p><p>因为 对于 j&gt; i,新的前缀 newpre[j] = pre[2n] - pre[j] + pre[i] = pre[i] - pre[j] &gt;= 0</p><hr><p>那么问题变成有没有办法一次翻转, 因为0次是直接合法,很容易判断,2次有上述方案</p><p>对于一次反转, 如果是<code>[L,R]</code>, 那么必然有 <code>L &lt;= 首个负前缀l, R&gt;= 最后一个负前缀r</code></p><p>再数学一点 对于 $i \in [L,R] $, <code>newpre = pre[R] - pre[i-1] + pre[L] &gt;= 0</code></p><p><code>pre[i-1] &lt;= pre[L] + pre[R]</code> 也就是 区间里所有的都不大于两头的和</p><p>而<code>pre[i]</code> 的可选值是 <code>[L..l-1][l..r][r+1..R]</code></p><p>注意到<code>[l..r]</code> 始终被选, 而两头的随着<code>L</code>和<code>R</code>变化</p><p>如果<code>L</code>选<code>[0..l-1]</code>中最大</p><p>如果<code>R</code>选<code>[r+1..2n]</code>中最大</p><p>那么对于两头的来说, 一定成立,而对<code>[l..r]</code> 来说 它们是能选到的最大的,如果这个还不满足,则没有办法了</p><p>如果这个满足则是答案</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://codeforces.com/contest/1685/submission/159099077" target="_blank" rel="noopener">https://codeforces.com/contest/1685/submission/159099077</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 1000000007#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // read// n对括号// reverse substringchar s[200010];int n;int pre[200010];void calc(int st){  int last = -1;  per(i,0,n){    if(pre[i+1] &lt; 0){      last = i;      break;    }  }  // printf(&quot;[%d %d]\n&quot;,st,last);  int ml = 0;  int mr = 0;  rep(i,0,st){    ml = max(ml,pre[i+1]);  }  rep(i,last,n){    mr = max(mr,pre[i+1]);  }  rep(i,st,last+1){    if(pre[i+1] &gt; ml+mr){      // rev2      printf(&quot;2\n&quot;);      int maxi = 0;      rep(i,0,n){        if(pre[i+1] &gt; pre[maxi]){          maxi = i+1;        }      }      printf(&quot;1 %d\n&quot;,maxi);      printf(&quot;%d %d\n&quot;,maxi+1,n);      return ;    }  }  printf(&quot;1\n&quot;);  int maxl = 0;  rep(i,0,st){    if(pre[i+1] &gt; pre[maxl]) maxl = i+1;  }  int maxr = n-1;  rep(i,last,n){    if(pre[i+1] &gt; pre[maxr]) maxr = i+1;  }  printf(&quot;%d %d\n&quot;,maxl+1,maxr);}void w(){  n = read();  n*=2;  scanf(&quot;%s&quot;,s);  rep(i,0,n) pre[i+1] = pre[i] + (s[i] ==&#39;(&#39;?1:-1);  rep(i,0,n){    if(pre[i+1] &lt; 0){      calc(i);      return ;    }  }  printf(&quot;0\n&quot;);}int main(){  int t = read();  while(t--)w();  return 0;}</code></pre><h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p><a href="https://codeforces.com/contest/1685/problem/D1" target="_blank" rel="noopener">https://codeforces.com/contest/1685/problem/D1</a></p><p><a href="https://codeforces.com/contest/1685/problem/D2" target="_blank" rel="noopener">https://codeforces.com/contest/1685/problem/D2</a></p><p>给一个1到n的排列p</p><p>定义一个排列p的代价为</p><p>$\sum {q_i - p_{q_{i+1}}}$</p><p>找最小代价的排列q</p><p>D2: Hard version: 最小代价排列中字典序最小的</p><h2 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h2><p>t 100 组测试</p><p>n 200, $\sum{n} \le 400$</p><p>1s</p><p>256mb</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h3><p>注意到上面的求和表达式,也就是每一项和它的后一项的差的绝对值,</p><p>那么如果一个排列q合法,那么 对它循环的旋转也合法</p><p>再来看期望最小值, 如果能够成 |1-1|+..+|v-v| ,全部是相同相减, 那么最小就是0, 而这种需要所有的跳转关系构成一个大环, 而这样解法也就唯一(对于循环的最小来说)</p><p>以样例中的2 1, =&gt; |1 - (P2=1)| + |2 - (P1=2)| = 0</p><p>对于不够成大环的, 必定跳转关系是多个小环</p><p>以样例中的2 3 1 4, 这样 是 1-&gt;3-&gt;2 构成环 ,4 单独一个环, 那么如果让环内代价为0, 那剩下的就是两头的链接代价, </p><p>|1 - (P3=1)| + |3 - (P2=3)| + |2 - (P4=4)| + |4 - (P1=2)| = 2+2</p><p>|3 - (P2=3)| + |2 - (P1=2)| + |1 - (P4=4)| + |4 - (P3=1)| = 3+3</p><p>|2 - (P1=2)| + |1 - (P3=1)| + |3 - (P4=4)| + |4 - (P2=3)| = 1+1</p><p>其实是环中选出一个值 和 其它环作拼接, (这里保证环内最小 不知道细节怎么证,但感觉看起来这样贪没啥问题</p><p>再比如样例 5 4 3 2 1, 环分别是 1-&gt;5, 2-&gt;4, 3</p><p>分别拿出来1,2,3</p><p>(5-&gt;1) (3) (4-&gt;2)</p><p>代价就是 |1-3| + |3-2| + |2-1|</p><p>这里也很清晰的是, 这样如果确定了拿出来的值,那么最小代价 = 2|max - min|</p><hr><p>综上所述</p><ol><li><p>找环</p></li><li><p>每个环拿出一个值来连接, 让所有拿出来的值 最大减最小尽量小, 这样D1 做完了</p></li><li><p>需要在这样的方法中, 1. 正负顺序, 2, 循环平移到1开始 的字典序列最小</p></li></ol><hr><p>问题来了</p><p>找环很简单, 但是如何让每个环拿出来一个值,差尽量小?</p><p>这里我想到的是染色+滑动窗口, 记录最小的滑动窗口和位置</p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 1000000007#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readint p[210];int p2i[210];int c[210]; // 染色void w(){  int n = read();  fill(c+1,c+n+1,-1);  rep(i,1,n+1) {    p[i] = read();    p2i[p[i]] = i;  }  int color = 0;  rep(i,1,n+1) {    if(~c[i])continue;    int itr = i;    do{      c[itr] = color;      itr = p2i[itr];    }while(itr != i);    color++;  }  // 单个环唯一  if(color == 1){    int itr = 1;    do{      printf(&quot;%d &quot;,itr);      itr = p2i[itr];    }while(itr != 1);    printf(&quot;\n&quot;);    return ;  }  vector&lt;int&gt;cnt(color,0); // 当前滑窗各种颜色个数  // 答案 起始位置  int ansst = 0;  int anssz = n+1;  // 滑窗  int l = 1;  int r = 0;  int cur = 0; // 滑窗内颜色种数  while(cur &lt; color &amp;&amp; r+1 &lt; n+1) if(++cnt[c[++r]] == 1) cur ++;  // [l..r] 包含所有颜色  while(l &lt;= r){    if( r-l+1 &lt;= anssz){      anssz = r-l+1;      ansst = l;      // printf(&quot;[%d %d]\n&quot;,l,r);    }    if( -- cnt[c[l++]] == 0 ) cur--;    while(cur &lt; color &amp;&amp; r+1 &lt; n+1){      ++r;      cnt[c[r]] ++;      if(cnt[c[r]] == 1) cur ++;    }    if(cur &lt; color)break;  }  // [ansst..ansst+anssz-1]  fill(c+1,c+n+1,-1);  rep(i,ansst,ansst+anssz - 1 + 1){    if(~c[i])continue;    int itr = i;    do{      printf(&quot;%d &quot;,p2i[itr]);      c[itr] = 1;      itr = p2i[itr];    }while(itr != i);  }  printf(&quot;\n&quot;);}int main(){  int t = read();  while(t--)w();  return 0;}</code></pre><p>然而实现以后wa2的第11个样例了</p><pre><code>41 3 2 4</code></pre><p>如果按照我上面所说的, (2,3) (1) (4) 这样的三个环, 那么 最大最小差是|4-1| = 3, 所以答案是6</p><p>然而, 给了一个拆掉环还更小的方法</p><p>q = <code>1 3 4 2</code></p><p><code>|1 - P3| + |3 - P4| + |4 - P2| + |2 - P1| = |1 - 2| + |3 - 4| + |4 - 3| + |2 - 1| = 4</code></p><p>emmmmmmm</p><p>所以我的思路的细节并卜行</p><h3 id="官方-D1"><a href="#官方-D1" class="headerlink" title="官方 D1"></a>官方 D1</h3><p>也是先考虑什么时候可以得到零</p><p>也是按照 跳转构成的环 来看, 假设有k个环</p><p>跨环 的链接 至少是1, 所以下界是 2(k-1)</p><hr><p>给出一种构造方法</p><p>初始化 p1 = p</p><p>for x = 1..n-1 如果 对当前p1 来说 x和 x+1在不同的环中, 则交换他们</p><p>显然根据学过的 排列的环的性质来讲, 每次交换两个环里的值 相当于把两个环合并</p><p>那么 也就是k-1次操作就可以全部合并成一个环</p><hr><p>最后 $q_i = p1_{q_{i+1}}$ 了, 显然这就是一个环, 这个答案对于p1来说,就是0</p><p>但我们求的是对于p</p><p>$|q_i - p1_{q_{i+1}}| = |p1_{q_{i+1}} - p_{q_{i+1}}|$ 了, 反过来看操作毕竟交换是对称的, 考虑从p1变到p, 每一次交换至多会让结果+2, 因为交换的是两个相邻的值, 所以 答案不大于2(k-1)</p><p>综上 从下界看 不小于2(k-1),  从操作上看不大于2(k-1), 所以这个方案就是2(k-1)</p><hr><p>至此 并查集随便搞一搞 D1 就做了</p><p>D2 现场只有4个人AC了 XD</p><p>pi向i连一条有向边</p><p>问题变成, 添加一些 i-&gt;i-1 和  i-1 -&gt; i 变成 存在欧拉回路</p><p>其实和上面 等价的, 这里的环和上面的边对应, 而成欧拉回路, 就是和变成新的环</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><h3 id="D1"><a href="#D1" class="headerlink" title="D1"></a>D1</h3><p><a href="https://codeforces.com/contest/1685/submission/159201728" target="_blank" rel="noopener">https://codeforces.com/contest/1685/submission/159201728</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 1000000007#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readint p[210];int p2i[210];int vis[210]; // 染色int fa[210];int getfa(int i){ return i==fa[i]?i:(fa[i] = getfa(fa[i]));}void link(int u,int v){  int fu = getfa(u);  int fv = getfa(v);  if(fu == fv)return;  fa[fu] = fv;}void w(){  int n = read();  fill(vis+1,vis+n+1,false);  iota(fa,fa+n+1,0);  rep(i,1,n+1) {    p[i] = read();    p2i[p[i]] = i;  }  rep(i,1,n+1){    if(vis[i])continue;    int itr = i;    do{      vis[itr] = true;      link(itr,i);      itr = p2i[itr];    }while(itr != i);  }  rep(v,1,n){    if(getfa(v) == getfa(v+1))continue;    swap(p[p2i[v]],p[p2i[v+1]]);    swap(p2i[v],p2i[v+1]);    link(v,v+1);  }  int itr = 1;  do{    printf(&quot;%d &quot;,itr);    itr = p2i[itr];  }while(itr != 1);  printf(&quot;\n&quot;);}int main(){  int t = read();  while(t--)w();  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>C</p><p>括号匹配还是不熟, 1,-1贡献 比1和0统计好很多</p><p>这最大值翻转只需要两次也是妙啊</p><p>后面的切割和最值</p><p>完全就是math,math,math</p><p>D1</p><p>想到环 和 环之间是好的</p><p>但是我构造能力实在是太菜了</p><p>而且下界估计想法也有问题,错误的下界估计也会影响思路</p><p>感觉这个题还是属于排列的环相关的知识点</p><p>然后有上下界相等, 和操作与逆向操作对结果的影响</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://codeforces.com/blog/entry/103198" target="_blank" rel="noopener">官方</a></p><p><a href="https://www.cnblogs.com/QQQ0000/p/16321569.html" target="_blank" rel="noopener">https://www.cnblogs.com/QQQ0000/p/16321569.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;C(括号对,前缀和,数学)D1(构造,排列,并查集)&lt;/p&gt;
&lt;h1 id=&quot;C&quot;&gt;&lt;a href=&quot;#C&quot; class=&quot;headerlink&quot; title=&quot;C&quot;&gt;&lt;/a&gt;C&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="Codeforces" scheme="http://yexiaorain.github.io/Blog/categories/Codeforces/"/>
    
    
      <category term="并查集" scheme="http://yexiaorain.github.io/Blog/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="前缀和" scheme="http://yexiaorain.github.io/Blog/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
      <category term="构造" scheme="http://yexiaorain.github.io/Blog/tags/%E6%9E%84%E9%80%A0/"/>
    
      <category term="数学" scheme="http://yexiaorain.github.io/Blog/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="排列" scheme="http://yexiaorain.github.io/Blog/tags/%E6%8E%92%E5%88%97/"/>
    
      <category term="括号对" scheme="http://yexiaorain.github.io/Blog/tags/%E6%8B%AC%E5%8F%B7%E5%AF%B9/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 1682EF</title>
    <link href="http://yexiaorain.github.io/Blog/2022-05-29-CF1682EF/"/>
    <id>http://yexiaorain.github.io/Blog/2022-05-29-CF1682EF/</id>
    <published>2022-05-28T19:24:00.000Z</published>
    <updated>2022-06-28T02:50:31.934Z</updated>
    
    <content type="html"><![CDATA[<p>E(排序,排列,拓扑排序,数学,无代码)F(网络流,二分图,排序,树状数组,扫描线, 前缀和,离线,差分)</p><h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://codeforces.com/contest/1682/problem/E" target="_blank" rel="noopener">https://codeforces.com/contest/1682/problem/E</a></p><p>给一个不含重复数字的<code>1~n</code>的排列数组a</p><p>然后有人通过m次交换,让数组有序, 每次交换记录了被交换数字的坐标(i,j)</p><p>其中交换次数是最小次数</p><p>现在把交换的坐标对的顺序打乱了给你, 问怎么把交换数组重排序让它恢复, 保证合法</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>n 2e5</p><p>m &lt;= n-1</p><p>ai &lt;= n</p><p>2s</p><p>256MB</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h3><p>先考虑自己会怎么交换,能够最小的次数</p><p>如果给你的数组, 有多个坐标和值构成环 , 那么最小次数 = (这些环长-1)的和</p><p>而每次交换一定让一个位置跑到合法的位置上,并且跑到合法以后不会再动这个位置</p><p>因此两个位置只会出现一次不会重复</p><p>或者从环的角度看,一次操作,就是 让环的一条边没了连接环的两端</p><p>所以考虑类似做拓扑排序, 每次选择一个 交换后有合法产生且能让 目标不再被操作的进行处理</p><p>问题在比赛时重复添加的bug没考虑清楚, 但即使修复了重复添加 依然wa5</p><h3 id="官方"><a href="#官方" class="headerlink" title="官方"></a>官方</h3><p>还好wa5数据小(当然比赛时看不了数据</p><pre><code>4 32 3 4 11 22 43 4</code></pre><p>果然我想的交换 虽然次数上表述是对的,但是操作上不一定是删了环上的边,</p><p>而是可以交换环上任意两点, 这样的话, 如果是环边,就是环-1</p><p>如果不是环边实际上是把环切割成两个小环,而总代价不会减少</p><p>而如果是这样,上面的实现当然也不对了,不再是交换后不会再交换了</p><hr><p>举一个例子来说</p><p> <code>a-&gt;b-&gt;c-&gt;d-&gt;e-&gt;f-&gt;a</code>: 意思是位置a的值应该要去位置b, 位置b的值应该要去位置c …</p><p> 那么如果交换了<code>位置a</code>和<code>位置e</code></p><p> 那么新的来说 <code>位置e</code>的值需要去位置<code>b</code></p><p> 也就是说当发生(位置i,位置j) 交换以后</p><p> i和j就不再属于同一个环了, 并且它们分别属于它们的来源的环</p><p> 再去掉无关的抽象一次 <code>x0-&gt;x1-&gt;....-&gt;y0-&gt;y1-&gt;...</code>, 如果(x1,y1)交换, 则得到这样两个环 <code>x0-&gt;x1) (....-&gt;y0-&gt;y1) (...</code></p><hr><p>这样于是就有了 假设x和多个y换,如(x,y0),(x,y1)</p><p><code>x-&gt;....-&gt;y0-&gt;...-&gt;y1-&gt;...</code>,</p><p>那么对于x来说,它和这些y的顺序一定是按箭头方向从近到远的</p><p>因为 如果先换了y1,就会变成<code>x) (...-&gt;y0-&gt;...-&gt;y1) (...</code>, 这样x都和y0不在同一个环上,再交换会合并环而不是拆环了</p><p>那么对于有x的所有交换就有了拓扑关系, 因为交换的对称性, 所有的交换序列都有了拓扑关系, 然后建立个拓扑图, 随便拓扑排序一下就好了</p><hr><p>实现要素</p><p>找环, vis数组 + dfs 随便搞</p><p>把交换和环一起处理, <code>vector&lt;int&gt; [idx] =</code> 发生了的交换</p><p>环上可以做的是值 -&gt; 下标</p><p>建立拓扑, 再从环中提取这些交换 并建立拓扑, 判断前后就是 <code>(下标差 + 环长)% 环长</code> 就知道前后了</p><p>拓扑排序, 维护入度计数 和 入度为0的点的数组</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>无(鸽子)</p><h1 id="F"><a href="#F" class="headerlink" title="F"></a>F</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p><a href="https://codeforces.com/contest/1682/problem/F" target="_blank" rel="noopener">https://codeforces.com/contest/1682/problem/F</a></p><p>长n 数组a, 非严格递增排序</p><p>长n 数组b, bi != 0</p><p>一共q组询问,每次询问l,r, 保证sum(b[l..r]) == 0</p><p>b[l..r] 中 小于0的点作为左侧点, 大于0的点作为右侧点, 建立二分图</p><p>左侧点i 向 右侧点j 有一条 无限容量,每单位flow代价 为 abs(ai - aj) 的边</p><p>源点S, 汇点T</p><p><code>S-&gt;左侧i</code>, cost = 0, 容量|bi|</p><p><code>右侧j-&gt;T</code>, cost = 0, 容量|bj|</p><p>问你, 图的最大流的最小cost为多少, 答案 mod 1e9+7</p><h2 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h2><p>n 2e5</p><p>q 2e5</p><p>ai [0,1e9]</p><p>bi [-1e9,1e9], bi != 0</p><p>3s</p><p>256mb</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h3><p>而如果和为零,其实也就是说 负数和 = 正数和</p><p>那么建立的图,左右侧点连接的边都是无限容量, 而和源点汇点的边容量为 |bi|</p><p>所以其实最大流显然是 abs|负数和/或正数和|</p><p>换句话说 不需要S和T</p><p>就是每个左侧点发出|bi|的流量,每个右侧点接受|bi|的流量, 然后 左侧i到右侧j, 的无线容量的边,每单位流量 = |ai-aj|的代价</p><p>问最小代价</p><hr><p>如果单次, 贪心</p><p>是不是左侧按照ai大小排序,右侧也按照ai大小排序</p><p>然后每次最小未输的左侧和右侧点进行1单位flow</p><p>证明, 如果有交差(左小到右大,右小到左大)那么必然交换1单位结果更小,而唯一不存在交叉的就是都按照ai排序</p><p>代价 = ai排序后 对应输送</p><p>或者看成所有的 |bi|个ai 进行排序分别得到l数组和r数组</p><p>然后答案 <code>= sum{abs(r[i] - l[i])}</code></p><p>这样如果是单次查询就没啥东西</p><hr><p>题目条件中说了ai非严格单调递增</p><p>因此不需要自己去排序了</p><p>但我并不知道怎么维护,能进行多次查询</p><h3 id="官方-1"><a href="#官方-1" class="headerlink" title="官方"></a>官方</h3><p>上面我的思路的结论是没问题的,但是在计算代价时实际上可以变成 不是去排序</p><p>初始化, 大于零和小于零bi绝对值和都为0, 分别记作 S+, S-,</p><p>然后遍历i从l到r, 每次遍历后更新S+,S-</p><p>如果 当前bi &gt; 0 且 S+ &gt;= S-, 那么说明 这一部分的ai在计算绝对值时全部取负号,因为它要和比它大的ai配</p><p>所以贡献为 -ai * |bi|</p><p>如果 当前bi &gt; 0 且 S+ &lt; S-, 那么说明 这一部分的ai在计算绝对值时, 有min((S-) - (S+), |bi|)个取负号, 剩下的取负号,因为它一部分和前面配对,一部分和后面配对</p><p>所以贡献为 ai <em> min((S-) - (S+),|bi|) - ai </em> (|bi| - min((S-)-(S+),|bi|)) = ai * (2min((S-)-(S+),|bi|) - |bi|)</p><p>如果 当前bi &lt; 0 且 S+ &lt;= S-, 那么说明 这一部分的ai在计算绝对值时全部取负号,因为它要和比它大的ai配</p><p>所以贡献为 -ai * |bi|,和上面同理</p><p>bi&lt;0, S+ &gt; S- 也是一样的</p><p>综上 都需要ai乘, 那么变化的是ai的贡献的次数, 而这个次数相关的就是 [b[l]..b[i-1]] 的正负绝对值和的差, 再和bi的大小关系</p><p>显然 这样的思考方式比我排序依次减和绝对值求和的效率高,因为对于每个i是O(1)的,总代价就是O(r-l), 而我的那样需要O(sum(|b[l..r]|))</p><p>而上面的 (S+)-(S-) 其实 等于 sum{b[l..i-1]}</p><hr><p>后缀 变形(也可以前缀变形,同理, 计算[0..i]</p><p>如果按上述的方法,计算了 [i..n] 的结果, 记录为 res[i]</p><p>那么对于查询[l..r], 且 sum{b[l..r]} == 0, 那么答案就是 res[l] - res[r+1], 因为 [l..r]为0了, 所以从r+1开始向后运算时, 一定是正负绝对值差是0</p><p>当然这个直接暴力计算res的代价是$O(n^2)$</p><p>反过来从贡献角度考虑</p><p>a[i] 要 贡献给 res[j], j&lt;=i</p><p>与 ai,bi, sum{b[j..i-1]} = pre[i-1] - pre[j-1] 有关</p><p>而对于具体的i, ai,bi,pre[i-1]是常量, pre[j-1]随着j变化</p><p>pre[i-1]-pre[j-1] 根据上面的推论, 有两头段会让a[i] 常数贡献, 中间一段与pre[j-1]线性关系</p><p>考虑 {pre[j-1],j } 二元组排序, 注意 j&lt;=i 的范围限制</p><p>然后就变成 区间贡献统计, 区间线性贡献统计, 上树状数组或者线段树?</p><hr><p>具体一点</p><p>前缀和$p_i = \sum_{k=1}^{i} b_k$</p><p>$j \le i$</p><hr><p>$b_i &gt; 0$ 时</p><p>若 $p_{i-1} - p_{j-1} \ge 0$, 有 $res_j += a_i * -b_i $</p><p>若 $p_{i-1} - p_{j-1} \le -b_i$, 有 $res_j += a_i * b_i $</p><p>若 $-b_i &lt; p_{i-1} - p_{j-1} &lt; 0$, 有 $res_j += a_i * ( 2p_{j-1} - 2p_{i-1} - b_i ) $</p><hr><p>$b_i &lt; 0$ 时</p><p>若 $p_{i-1} - p_{j-1} \le 0$, 有 $res_j += a_i * -b_i $</p><p>若 $p_{i-1} - p_{j-1} \ge - b_i$, 有 $res_j += a_i * b_i $</p><p>若 $ 0 &lt; p_{i-1} - p_{j-1} &lt; - b_i $, 有 $res_j += a_i * ( 2p_{j-1} - 2p_{i-1} - b_i ) $</p><hr><p>问题是, 不只是需要 满足 大小关系, 还需要范围, 而且p的排序后下标就不再连续</p><p>先不考虑$j \le i$</p><p>建立个 下标数组, 按照$p_i$ 大小排序</p><p>那么 对于i 来说, 它对三个连续范围内每个贡献 常数($a_i \cdot -b_i$ 或 $ a_i \cdot b_i $ 或 $ a_i \cdot (-2p_{i-1} - b_i) $) / 线性函数的系数 $2a_i$</p><p>这样 当你要求具体 查一个位置的时候, 就树状数组 求点值</p><p>而这个操作 可以通过 差分数组+树状数组完成, 范围增加 = 范围起始点差值+, 范围结束点差值-, 单点值 = 前缀和</p><hr><p>剩下的问题是如何控制$j \le i$</p><p>考虑扫描指针,先让所有点都贡献,然后 随着扫描指针从1到n,增加它的反贡献 相当于去掉它的贡献</p><p>这样的话我们就能算出每个<code>res[i] =</code> 单点常数 + 单点线性系数$\cdot p_{i-1}$</p><p>最后所有询问 直接 <code>res[l] - res[r+1]</code></p><h3 id="jiangly"><a href="#jiangly" class="headerlink" title="jiangly"></a>jiangly</h3><p>似乎jiangly的比官方题解更简单, 他做了a数组的差分, 直接用差分和前缀b算的, 没有再用原始的b和a了</p><p>在白板上画了一下jiangly老哥的代码</p><p>发现jiangly老哥的想法其实 有点牛顿积分-&gt;勒贝格积分的味道</p><p><img src="/Blog/img/CF1682F.png" alt></p><p>$i \in [l,r]$</p><p>我们以<code>a[i]-a[i-1]</code> 这段间隔贡献的长度来看</p><p>发现, 假设以<code>j</code>开头,那么这段的贡献的长度为$|p_{i-1} - p_{j-1}|$</p><p><strong>鹅妹子嘤!!!!!</strong></p><p>这直接和单个bi没关系,也不用大于零小于零分类和范围分类讨论了, 只和b前缀和 与 a差分相关了</p><p>而且简洁到 对<code>ans[l..r]</code>贡献就是$(a[i] - a[i-1]) * |p_{i-1} - p_{l-1}|$</p><p>注意这里和题解也不一样, 不需要先后缀数组res, 再去求差, 直接算每个位置对答案的贡献</p><hr><p>剩下的就一样了</p><p>为了解决绝对值的问题, 对$p_i$排序</p><p>因为对于一个具体的查询来说 j是给定值,所以 你需要的是$(a[i] - a[i-1]) * p_{i-1}$的和 与 $a[i] - a[i-1]$ 的和</p><p>对于 $p_{i-1} &gt; p_{j-1}$ 的 正贡献,而 $p_{i-1} &lt; p_{j-1}$ 的负贡献</p><p>所以计算答案时, 从$p_i$ 从小到达算, 并且根据$p_i$的指针更新 每个位置i 贡献的正负</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p><a href="https://codeforces.com/contest/1682/submission/158828392" target="_blank" rel="noopener">https://codeforces.com/contest/1682/submission/158828392</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;// jiangly// https://codeforces.com/contest/1682/submission/158055817// power 和 norm 和std有冲突using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // read// 基于 mod P 的整数, structZconstexpr int P = 1000000007;// assume -P &lt;= x &lt; 2Pint mynorm(int x) {  if (x &lt; 0) {    x += P;  }  if (x &gt;= P) {    x -= P;  }  return x;}template&lt;class T&gt;T mypow(T a, ll b) {  T res = 1;  for (; b; b /= 2, a *= a) {    if (b % 2) {      res *= a;    }  }  return res;}struct Z {  int x;  Z(int x = 0) : x(mynorm(x)) {}  Z(ll x) : x(mynorm(x % P)) {}  int val() const {    return x;  }  Z operator-() const {    return Z(mynorm(P - x));  }  Z inv() const {    assert(x != 0);    return mypow(*this, P - 2);  }  Z &amp;operator*=(const Z &amp;rhs) {    x = ll(x) * rhs.x % P;    return *this;  }  Z &amp;operator+=(const Z &amp;rhs) {    x = mynorm(x + rhs.x);    return *this;  }  Z &amp;operator-=(const Z &amp;rhs) {    x = mynorm(x - rhs.x);    return *this;  }  Z &amp;operator/=(const Z &amp;rhs) {    return *this *= rhs.inv();  }  friend Z operator*(const Z &amp;lhs, const Z &amp;rhs) {    Z res = lhs;    res *= rhs;    return res;  }  friend Z operator+(const Z &amp;lhs, const Z &amp;rhs) {    Z res = lhs;    res += rhs;    return res;  }  friend Z operator-(const Z &amp;lhs, const Z &amp;rhs) {    Z res = lhs;    res -= rhs;    return res;  }  friend Z operator/(const Z &amp;lhs, const Z &amp;rhs) {    Z res = lhs;    res /= rhs;    return res;  }  friend istream &amp;operator&gt;&gt;(istream &amp;is, Z &amp;a) {    ll v;    is &gt;&gt; v;    a = Z(v);    return is;  }  friend ostream &amp;operator&lt;&lt;(ostream &amp;os, const Z &amp;a) {    return os &lt;&lt; a.val();  }};// 树状数组 0-indextemplate &lt;typename T&gt;struct Fenwick {  const int n;  vector&lt;T&gt; a;  Fenwick(int n) : n(n){    a.resize(n);  }  // [x] += v  void add(int x, T v) {    for (int i = x + 1; i &lt;= n; i += i &amp; -i) {      a[i - 1] += v;    }  }  // [0..x)  T sum(int x) {    T ans = 0;    for (int i = x; i &gt; 0; i -= i &amp; -i) {      ans += a[i - 1];    }    return ans;  }  // [l,r)  T rangeSum(int l, int r) {    return sum(r) - sum(l);  }};int main() {  int n = read(), q = read();  vector&lt;int&gt; a(n);  vector&lt;ll&gt; b(n + 1);  rep(i,0,n) a[i] = read();  // 倒序做差分  per(i,1,n) a[i] -= a[i - 1];  rep(i,1,n+1) {    b[i] = read();    // 前缀和    b[i] += b[i - 1];  }  // 离线  vector&lt;array&lt;ll, 4&gt;&gt; qry(q); // 查询 按照 {b[l-1],l-1,r,qidx} 排序  rep(i,0,q) {    int l = read()-1, r = read();    qry[i] = {b[l], l, r, i};  }  sort(qry.begin(), qry.end());  // https://en.cppreference.com/w/cpp/algorithm/ranges/iota  // https://www.cplusplus.com/reference/numeric/iota/  // 按照bi 前缀和 大小排序下标  vector&lt;int&gt; p(n);  iota(p.begin(), p.end(), 0);  sort(p.begin(), p.end(), [&amp;](int i, int j) { return b[i] &lt; b[j]; });  Fenwick&lt;Z&gt; s(n), c(n);  rep(i,0,n) {    // 先全部正贡献    s.add(i, Z(b[i]) * a[i]);    c.add(i, a[i]);  }  vector&lt;Z&gt; ans(q);  int j = 0;  for (auto [v, l, r, i] : qry) {    while (j &lt; n &amp;&amp; b[p[j]] &lt;= v) { // 根据 bi 前缀大小 决定贡献正负      int k = p[j++];      // 树状数组不支持修改, 只支持增量 ,实际是改成负贡献      s.add(k, -2*Z(b[k]) * a[k]);      c.add(k, -2*a[k]);    }    ans[i] = s.rangeSum(l, r) - c.rangeSum(l, r) * v;  }  for (auto x : ans) {    printf(&quot;%d\n&quot;,x.val());  }  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>E 的关键在于</p><p>不只有相邻的可以换, 不相邻的同环上也可以换(Wa5, 这点还是<strong>应该枚举稍微大一点的</strong>, 其实wa5 的点数才4</p><p>交换同环 = 拆环, 交换异环 = 合环</p><p>而交换两点,<strong> 这两点分别属于它们前个点的环</strong> 从而推得 同点和其它点多次交换时的先后顺序</p><p>有了先后顺序的逻辑,后面拓扑就无脑做了</p><p>F</p><p>简化的部分做了</p><p>但是 在排序对应 相减 取 绝对值 求和的部分, 没有想到怎么转换成 正负号标记, 还是说明绝对值相关知识点不够熟练</p><p>而即使看题解时 知道了这样转化, 也没有变成后缀来求的思路, 还在想分治</p><p>而且后缀的思路也是提供一个叫 无效答案同规则的差是可以得到有效答案的, 就像函数补充中间点一样</p><hr><p>看jiangly的代码, 一个是 基于mod的 struct,可以让逻辑代码里完全不需要写mod 也不用担心写掉, 减少心智负担</p><p>第二个是 没有 using namespace std 减少碰撞</p><p>iota 可以填数组, sort+lambda 简化排序</p><p>另外就是 using namespace std; 是个坏习惯, 比如这里norm和power就有冲突</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://codeforces.com/blog/entry/103097" target="_blank" rel="noopener">官方</a></p><p><a href="https://codeforces.com/contest/1682/submission/158055817" target="_blank" rel="noopener">jiangly</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;E(排序,排列,拓扑排序,数学,无代码)F(网络流,二分图,排序,树状数组,扫描线, 前缀和,离线,差分)&lt;/p&gt;
&lt;h1 id=&quot;E&quot;&gt;&lt;a href=&quot;#E&quot; class=&quot;headerlink&quot; title=&quot;E&quot;&gt;&lt;/a&gt;E&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a h
      
    
    </summary>
    
      <category term="Codeforces" scheme="http://yexiaorain.github.io/Blog/categories/Codeforces/"/>
    
    
      <category term="网络流" scheme="http://yexiaorain.github.io/Blog/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
      <category term="扫描线" scheme="http://yexiaorain.github.io/Blog/tags/%E6%89%AB%E6%8F%8F%E7%BA%BF/"/>
    
      <category term="排序" scheme="http://yexiaorain.github.io/Blog/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="前缀和" scheme="http://yexiaorain.github.io/Blog/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
      <category term="离线" scheme="http://yexiaorain.github.io/Blog/tags/%E7%A6%BB%E7%BA%BF/"/>
    
      <category term="二分图" scheme="http://yexiaorain.github.io/Blog/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    
      <category term="数学" scheme="http://yexiaorain.github.io/Blog/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="排列" scheme="http://yexiaorain.github.io/Blog/tags/%E6%8E%92%E5%88%97/"/>
    
      <category term="拓扑排序" scheme="http://yexiaorain.github.io/Blog/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    
      <category term="树状数组" scheme="http://yexiaorain.github.io/Blog/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
      <category term="差分" scheme="http://yexiaorain.github.io/Blog/tags/%E5%B7%AE%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 1684FGH</title>
    <link href="http://yexiaorain.github.io/Blog/2022-05-28-CF1684FGH/"/>
    <id>http://yexiaorain.github.io/Blog/2022-05-28-CF1684FGH/</id>
    <published>2022-05-28T02:24:00.000Z</published>
    <updated>2022-06-28T02:50:31.930Z</updated>
    
    <content type="html"><![CDATA[<p>F(双指针,滑窗,同值跳点,前缀最值)G(二分图匹配,数学)H(构造,分治,小值枚举,无代码)</p><h1 id="F"><a href="#F" class="headerlink" title="F"></a>F</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://codeforces.com/contest/1684/problem/F" target="_blank" rel="noopener">https://codeforces.com/contest/1684/problem/F</a></p><p>长n数组a</p><p>m个区间[l,r]</p><p>自己任选一个范围(与上面的区间无关),修改区间中所有值成任意值, 让上面区间每个区间都没有重复的数</p><p>问 你任选的区间最短长度</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>n 2e5</p><p>m 2e5</p><p>ai 1e9</p><p>2s</p><p>256MB</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h3><p>ai和n不成比例,与具体值无关, 无脑离散化一下,把ai范围降低到n</p><p>对于一个区间[l,r], 如果覆盖了一侧,如[l0,r],那么其实很好求l0的最大值(因为要区间尽量小</p><p>只需要通过<code>v2idx[v] = last index</code>, 跳一跳就行了</p><p>那么其实可以得到 这些l0 中最小的l0, 记为 L, 同样可以得到最大的R</p><p>那么 答案一定是包含了<code>[L,R]</code>的</p><p>那么问题变成了, 如果就是给你一个区间,但是是部分覆盖如何做到最短, [l,r] 你要找 <code>[l...[L..R]...r]</code></p><p>其中 <code>[l..L-1][R+1..r]</code> 不存在重复的数,还要<code>[L,R]</code>最短</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>如果答案是<code>[L,R]</code> 也就是 任何给的线段[l,r]中,不存在相同值都不属于<code>[L,R]</code>,</p><p>先让<code>L = 1</code>, 那么找<code>r</code> 跟上面说的一样, 找到max(min(ri))</p><p>然后,如果L左移1,R会如何变化</p><p>如果<code>[L+1,R]</code> 满足则就是<code>R</code>否则<code>R</code>只能增大, 甚至 <code>L+1</code>就无法合法了</p><p>注意到 如果有同样的<code>l</code> ,那么只用考虑<code>r</code>更大的即可</p><hr><p><code>[L..R] =&gt; [L+1..?]</code></p><p>首先 如果 <code>[lastpos[v[L]]...L]</code> 被包含在某个区间中, 那么必定不可行, 之后更大的L也不可行了break掉</p><p>如果 大于R的 value = v[L]的 位置在p</p><p>且<code>[L...p]</code>在某个区间中, 那么必定<code>[L+1..R]</code>不合法</p><p><code>[L+1...p]</code> 则是新的合法的</p><hr><p>上面两个都需要的是查询 左端点在<code>[0...pos]</code> 中的给定线段, 右侧端点最大值</p><p>这个注意到是一次赋值,多次查询没有更改的,直接前缀最大值</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://codeforces.com/contest/1684/submission/158651275" target="_blank" rel="noopener">https://codeforces.com/contest/1684/submission/158651275</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb emplace_back#define all(x) (x).begin(), (x).end()#define pii pair&lt;int, int&gt;ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readconst int N = 200000;int f[N+10]; // 前缀最大值[前缀左端点] = 最大右侧端点ll a[N+10];vector&lt;int&gt; gist[N+10]; // gist[值] = vector&lt;int&gt; 下标pii seg[N+10]; // 题目给的线段ll mnl[N+10]; // mnl[ir] = 最小合法il =&gt; [il..ir]没有重复的数bool s[N+10]; // 存在过的数int n,m;void solve() {  // clear  fill(f,f+n,-1);  fill(gist,gist+n,vector&lt;int&gt;());  n = read();  m = read();  rep(i,0,n) a[i] = read();  // 离散一下  vector&lt;pii&gt; sa ;  rep(i,0,n) sa.push_back({a[i],i});  sort(all(sa));  rep(i,0,n) {    auto [v,j] = sa[i];    if(i == 0) a[j] = 0;    else if(v == sa[i-1].first) a[j] = a[sa[i-1].second];    else a[j] = a[sa[i-1].second] + 1;  }  rep(i,0,n) gist[a[i]].pb(i);  rep(i,0,m){    int l = read();    int r = read();    seg[i] = {--l,--r};    f[l] = max(f[l], r);  }  rep(i,1,n) f[i] = max(f[i-1],f[i]);  // 双指针 [il...ir] 没有重复的数  // mnl[ir] = 合法的最小il  int il = n;  per(ir,0,n){    while (il &amp;&amp; !s[a[il - 1]]) s[a[--il]] = true;    mnl[ir] = il;    s[a[ir]] = false;  }  // mnr 为L = 1 时 R的最小值 , [R+1..n] 要么就是 本身合法线段要么就是 [R+1..r] 合法  ll mnr = -1;  rep(i,0,m){    auto [l,r] = seg[i];    if (mnl[r] &lt;= l) continue; // 本身就合法 直接忽略    mnr = max(mnr, mnl[r] - 1);  }  if (mnr == -1) {    printf(&quot;0\n&quot;);    return;  }  ll ans = mnr + 1;  // L 每次 +1  // [l..mnr] =&gt; [l+1..?]  rep(l,0,n-1){    // l 不是 a[l] 首次出现的位置    if (gist[a[l]][0] != l) {      // 上一个同样值的位置      int pr = *(--lower_bound(all(gist[a[l]]), l));      // 左端点小于等于 pr, 的最大右端点, 如果删除了 就会有区间包含[pr...l] 有两个a[l]      // 再移动 就不可能了, 所以直接break      if (f[pr] &gt;= l) break;    }    // 下一个 为a[l] 的 且在某个区间中    if (gist[a[l]].back() &gt; mnr ) {      int nxt = *upper_bound(all(gist[a[l]]), mnr);      if (f[l] &gt;= nxt) mnr = nxt;    }    assert(mnr &gt; l);    ans = min(ans, mnr - l);  }  printf(&quot;%lld\n&quot;,ans);}int main() {  int t = read();  while (t--) solve();  return 0;}</code></pre><h1 id="G"><a href="#G" class="headerlink" title="G"></a>G</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p><a href="https://codeforces.com/contest/1684/problem/G" target="_blank" rel="noopener">https://codeforces.com/contest/1684/problem/G</a></p><p>t 是一个数组</p><p>考虑Euclid求gcd</p><pre><code>function Euclid(a, b):    if a &lt; b:        swap(a, b)    if b == 0:        return a    r = reminder from dividing a by b    if r &gt; 0:        append r to the back of t    return Euclid(b, r)</code></pre><p>p 是一个包含不超过m的正数对的数组</p><p>t 初始为空</p><p>然后 对p的所有 数对 运行上述算法</p><p>t然后被打乱了给你</p><p>你需要找一个 数组, len &lt;= 2e4, 能产生 t, 或者判断它不可能存在</p><h2 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h2><p>len(t) 1e3</p><p>m 1e9</p><p>1 &lt;= ti &lt;= m</p><p>1s</p><p>256mb</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h3><p>其实就是 辗转相除<code>(a,b), a&gt;b</code> 中间的所有非零余数</p><p><code>b &gt; v, a &gt;= b + v &gt; 2v</code></p><p>所以如果有值不满足<code>m &gt; 2v</code> 则直接不可能输出-1</p><p>否则直接无脑<code>2v+1,v+1</code>?, 但注意到<code>2v+1,v+1,v,1</code> 还会产生1, 也就是不行的</p><p>另外<code>3v,2v,v</code> 不会有额外产生,如果有多余的<code>3v &lt;= m</code> 可以这样处理掉</p><p>所以只用考虑<code>3v &gt; m &gt; 2v</code> 的v值<code>m/2 &gt; v &gt; m/3</code> (非整除)</p><p><code>a = 2v+i,b = v+i,v,i,...</code> (i &lt;= m-2v &lt; v)</p><p>但怎么选i, 以及处理之后的余数,并没有任何想法</p><p>v的选择可以从大到小, 这样也可能消耗掉 一部分 <code>m/2 &gt; v &gt; m/3</code></p><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>一样 先把v的范围限定在了<code>3v &gt; m &gt; 2v</code>, 范围以外的和我想的一样的处理</p><p><code>m &gt;= a=2v+i,b=v+i,v,i,...</code></p><p>也就是考虑到 <code>2v + gcd(v,i) &lt;= 2v+i &lt;= m</code></p><p>也就是对于每个 <code>v &gt; m/3</code>, 一定存在一个是它因数的<code>x</code>,且<code>2v + x &lt;= 2m</code></p><p>于是建立二分图</p><p>左边 &gt; m/3, 右边 &lt;= m/3</p><p>做二分图匹配即可</p><hr><p>我的问题,在i 和 m/3大小判断错了, 其实<code>2v+i = a &lt;= m</code>和<code>v &gt; m/3</code> 就可以得到<code>i &lt; m/3</code>的</p><p>这样的话,v必然是靠小于等于m/3的消耗掉的,不如直接贪约数</p><p>有一说一,写起来其实会比F简单?</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p><a href="https://codeforces.com/contest/1684/submission/158654516" target="_blank" rel="noopener">https://codeforces.com/contest/1684/submission/158654516</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readconst int N = 1000;vector&lt;int&gt; g[N+10]; // g[二分图左端点] = vector&lt;&gt;右端点int with[N+10]; // with[右端点] = 链接的来源左端点int vis[N+10]; // 二分图每轮选左侧起始点时,是否访问到ll a[N+10];bool dfs(int v) {  if (vis[v]) return false;  vis[v] = 1;  // 直接就有可选终点  for (auto to : g[v]) {    if (with[to] == -1) {      with[to] = v;      return true;    }  }  // 递归走 v -&gt; to0 -&gt; with[to0] -&gt; t1 -&gt; with[t1] - ... -&gt; took  for (auto to : g[v]) {    if (dfs(with[to])) {      with[to] = v; // 更新指向      return true;    }  }  return false;}int main() {  int n = read();  int A = read();  // 二分图  vector&lt;ll&gt; l;  vector&lt;ll&gt; r;  rep(i,0,n) {    a[i] = read();    (3 * a[i] &gt; A ? l : r).pb(a[i]);  }  // 建立边  rep(i,0,l.size()) {    rep(j,0,r.size()) {      if (l[i] % r[j])continue;      if(2 * l[i] + r[j] &gt; A) continue;      g[i].pb(j);    }  }  // 二分图匹配  fill(with,with+r.size(),-1);  rep(i,0,l.size()) {    fill(vis,vis+l.size(),0);    if(!dfs(i)){      // 未消耗掉所有 &gt; m/3      printf(&quot;-1\n&quot;);      return 0;    }  }  vector&lt;pair&lt;ll,ll&gt;&gt; ans;  rep(j,0,r.size()) {    if (with[j] == -1) {      ans.pb({3 * r[j], 2 * r[j]}); // &lt;= m/3 的 直接 `3v,2v =&gt; v`    } else { // 2v+i,v+i =&gt; v,i      ans.pb({2 * l[with[j]] + r[j], l[with[j]] + r[j]});    }  }  printf(&quot;%d\n&quot;,(int)ans.size());  for (auto [a,b]: ans) printf(&quot;%lld %lld\n&quot;,a,b);  return 0;}</code></pre><h1 id="H"><a href="#H" class="headerlink" title="H"></a>H</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p><a href="https://codeforces.com/contest/1684/problem/H" target="_blank" rel="noopener">https://codeforces.com/contest/1684/problem/H</a></p><p>给0/1串s, 切分成任意多个不相交子串, 然后让这些子串表示的二进制值的和是2的幂次</p><h2 id="范围-2"><a href="#范围-2" class="headerlink" title="范围"></a>范围</h2><p>|s| 1e6</p><p>2s</p><p>256mb</p><h2 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路-2"><a href="#我的思路-2" class="headerlink" title="我的思路"></a>我的思路</h3><p>如果1的个数是2的幂次, 那么直接全部拆碎就完了</p><p>不妨设一共有$w$个1,且 $2^k &lt; w &lt; 2^{k+1}$</p><p>除了最后一位1, 任何一个1 都可变成2的贡献,不论是通过 11还是10, 它对w的贡献就是+1</p><p>但是如果连续的两个1,至多有一个可以贡献2,</p><p>同样除了最后两位1, 任何一个1 都可变成4的贡献,通过1XX, 对w贡献是+3</p><p>但是如果连续的三个中出现的1,至多有一个可以贡献4,</p><p>所以 (w-2)/3 个1 可以变成贡献4, 于是可以多贡献 (w-2)</p><p>但值得注意的是, 之所以 (w-2)/3 一个是因为尾部, 一个是因为 连续的3个中出现1, 才会不能让所有的1贡献4, 下限是(w-2)/3</p><p>这样的话,也就是说 有部分的贡献的是2, 总可以补全到$&gt;= 2^{k+1}$</p><pre><code>100 = 4 (+3)10,0 = 2 (+1)1,0,0 = 1101 = 5 (+3)10,1 = 3 (+1)1,0,1 = 2110 = 6 (+4)1,10 = 3 (+1)11,0 = 3 (+1)1,1,0 = 2111 = 7 (+4)11,1 = 4 (+1)1,1,1 = 3</code></pre><p>所以对于所有1开头的3位, 有的贡献可以+1,+3, 有的贡献可以+1,+4</p><p>2^{k+1}-1 &gt;= w &gt;= 2^k+1</p><p>所以 通过+3,+4 让w和 2^{k+1}的距离 在某个3元组能达到<code>[1,3]</code>之间, 剩下的<code>[1,3]</code>就靠<code>+1</code>补满</p><p>且, 注意到如果是靠不少+3达到的,那么剩余的长3的组一定还不少, 不会耗尽所有</p><p>所以w足够大时,必定可行</p><p>需要考虑w小的时候, 但多么小呢?</p><p>w = 1,2,4,8直接可行</p><p>w = 3 时, dst = 4. +1 必定可行</p><p>w = 5 时, dst = 8, 需要+3, <code>(111)(110)</code> 就是个不能用上面切割达到的</p><p>w = 6,7 时, dst = 8, 需要+2/+1, 必定两/一次+1可以达到</p><p>w = 9 时, dst = 16, 需要+7, <code>(111)(111)(111)</code> ,也是不能用上面切割达到</p><p>w = …</p><p>这块细节就不知道怎么搞, 也不知道大于多少以后w一定可以</p><h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><p>1,2,4,等2的幂次, 直接切碎</p><p>k = 3 可以用上面我说的方法</p><p>k = 5</p><p>如果1连续, 1111+1 = 10000</p><p>否则1之间存在0, 存在一个0,则101存在,多个0,则100存在. 101+1+1+1=1000, 100+1+1+1+1 = 1000</p><p>k &gt; 5</p><p>solve(l,r,k,n) 函数表示把有k个1的[l..r]段切来和为n</p><p>这里目标n也是放在 2的log(2,k)向上取整幂次, </p><p>足够大的n, 考虑是按照k 来切开, 让它分别为 k/2向下取整和 k/2向上取整, 并且 让它们的和都是 n/2</p><p>solve(l,r,k,n) = solve(l,pos,k/2,n/2) and solve(pos+1,r,k-k/2,n/2)</p><p>然后界限来就是说 k = 6..11 时 如何搞</p><hr><p>这里其实可以自己随便乱搞了,毕竟范围有限,目标明确</p><p>官方英文题解里有具体方法</p><hr><p>这里方法上有一个要注意的是, 当 1的个数是 <code>(2的幂次)+1</code> 时, 它期望切割出来的<code>2的(幂次-1)</code>那一部分还是需要到</p><p>比如 <code>17 = 16+1</code>个1, 期望的结果是 <code>2**5 = 32</code></p><p><code>17 = 8+9</code>, <code>9</code>的期望结果是<code>16</code>没问题, 但是<code>8</code> 也需要<code>16</code> 而不是得到<code>8</code></p><p>但注意到这个问题集中在2的幂次上</p><p>所以再向下考虑4个1要得到8</p><p>考虑最左1开头的数:</p><p><code>111</code>: 111+1=1000</p><p><code>110</code>: 110+1+1 = 1000</p><p><code>101</code>: 后面一个1贡献2,1个1贡献1, 101+10+1 = 1000</p><p><code>100</code>: 后面一个1贡献2,两个1贡献1, 100+10+1+1 = 1000</p><p>都可以得到8</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><p>鸽, 构造+枚举小值 是我太菜了</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>F:</p><p>一个是 包含两个相同值,转化成包含两个相邻相同值,因为同样的值出现多次, 只用考虑相邻 v…v…v, 只用考虑[v…v]…v 或v…[v…v]</p><p>看起来没离散2e5个&lt;1e9的map效率还行啊, 仅仅是查询的话</p><p>双指针 + 滑窗还是写不熟啊</p><p>G:</p><p>这里主要在i的范围判断错了,如果 i &gt; m/3 那么 <code>2v+i &gt;= 2m/3 + m/3 = m</code>, 我数学太菜了</p><p>H:</p><p>从小特例开始考虑算是有一定思路是对的, 但是要敢于分情况讨论</p><p>但是这个分治的确没想到,就算想到一半, 可能没想到让k/2向下和向上取整,都去等于 n/2</p><p>或者整体来说, 没想到 和可以拆成 和的一半 对应 1个数的一半</p><p>特别是这里敢于 2的幂次+1这种数也这样拆</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://codeforces.com/blog/entry/102995" target="_blank" rel="noopener">官方</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;F(双指针,滑窗,同值跳点,前缀最值)G(二分图匹配,数学)H(构造,分治,小值枚举,无代码)&lt;/p&gt;
&lt;h1 id=&quot;F&quot;&gt;&lt;a href=&quot;#F&quot; class=&quot;headerlink&quot; title=&quot;F&quot;&gt;&lt;/a&gt;F&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
      <category term="Codeforces" scheme="http://yexiaorain.github.io/Blog/categories/Codeforces/"/>
    
    
      <category term="分治" scheme="http://yexiaorain.github.io/Blog/tags/%E5%88%86%E6%B2%BB/"/>
    
      <category term="构造" scheme="http://yexiaorain.github.io/Blog/tags/%E6%9E%84%E9%80%A0/"/>
    
      <category term="双指针" scheme="http://yexiaorain.github.io/Blog/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="滑窗" scheme="http://yexiaorain.github.io/Blog/tags/%E6%BB%91%E7%AA%97/"/>
    
      <category term="前缀最值" scheme="http://yexiaorain.github.io/Blog/tags/%E5%89%8D%E7%BC%80%E6%9C%80%E5%80%BC/"/>
    
      <category term="同值跳点" scheme="http://yexiaorain.github.io/Blog/tags/%E5%90%8C%E5%80%BC%E8%B7%B3%E7%82%B9/"/>
    
      <category term="二分图" scheme="http://yexiaorain.github.io/Blog/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    
      <category term="数学" scheme="http://yexiaorain.github.io/Blog/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>nowcoder 牛客练习赛99 E(图特殊情况)</title>
    <link href="http://yexiaorain.github.io/Blog/2022-05-27-nowcoder-34330E/"/>
    <id>http://yexiaorain.github.io/Blog/2022-05-27-nowcoder-34330E/</id>
    <published>2022-05-27T02:37:14.000Z</published>
    <updated>2022-06-28T02:50:31.930Z</updated>
    
    <content type="html"><![CDATA[<h1 id="比赛总结"><a href="#比赛总结" class="headerlink" title="比赛总结"></a>比赛总结</h1><p><a href="https://ac.nowcoder.com/acm/contest/34330/E" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/contest/34330/E</a></p><p>考虑存在一个点 其它点仅和它断边</p><p>注意sum n很大, 清理按m清理</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;n;i++)// n(完全图), n-1, &lt;= n-2?int p2[1000010];ll n ;ll m ;vector&lt;int&gt;uv;void w(){  scanf(&quot;%lld %lld&quot;,&amp;n,&amp;m);  rep(i,0,m){    int u,v;    scanf(&quot;%d %d&quot;,&amp;u,&amp;v);    p2[u] ++ ;    p2[v] ++ ;    uv.push_back(u);    uv.push_back(v);  }  // 完全图  if(m == n*(n-1)/2){    printf(&quot;0\n&quot;);    return ;  }  if(m == n*(n-1)/2 - 1){     printf(&quot;-1\n&quot;);    return ;  }  // 连了4个点 -2  // 连了3个点 -1  // sum n 很大  if(n*(n-1)/2 - m &gt; n){    printf(&quot;-2\n&quot;);    return ;  }    rep(i,1,n+1){      if(p2[i] == n-1 - (n*(n-1)/2 - m)){        printf(&quot;-1\n&quot;);        return ;      }    }  printf(&quot;-2\n&quot;);}int main(){  int t;  scanf(&quot;%d&quot;,&amp;t);  while(t--){      w();      for(auto u:uv)p2[u] = 0;      uv = {};  }  return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;比赛总结&quot;&gt;&lt;a href=&quot;#比赛总结&quot; class=&quot;headerlink&quot; title=&quot;比赛总结&quot;&gt;&lt;/a&gt;比赛总结&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/34330/E&quot; target=&quot;
      
    
    </summary>
    
      <category term="NowCoder" scheme="http://yexiaorain.github.io/Blog/categories/NowCoder/"/>
    
    
      <category term="图" scheme="http://yexiaorain.github.io/Blog/tags/%E5%9B%BE/"/>
    
  </entry>
  
</feed>
