<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog</title>
  
  
  <link href="/Blog/atom.xml" rel="self"/>
  
  <link href="http://yexiaorain.github.io/Blog/"/>
  <updated>2022-08-12T03:23:03.827Z</updated>
  <id>http://yexiaorain.github.io/Blog/</id>
  
  <author>
    <name>Xiao Ye</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Atcoder abc226</title>
    <link href="http://yexiaorain.github.io/Blog/2022-08-13-ac_abc226/"/>
    <id>http://yexiaorain.github.io/Blog/2022-08-13-ac_abc226/</id>
    <published>2022-08-12T20:25:14.000Z</published>
    <updated>2022-08-12T03:23:03.827Z</updated>
    
    <content type="html"><![CDATA[<p>F(DP,组合数,gcd)G(贪心)H()</p><h1 id="F-Score-of-Permutations"><a href="#F-Score-of-Permutations" class="headerlink" title="F - Score of Permutations"></a>F - Score of Permutations</h1><p>排列P, </p><p>初始,i号人有球i</p><p>每次 所有 i != pi 的人, 把球给pi号人</p><p>在 &gt; 0 次后,如果所有人又是i号人有球i, 那么就停止</p><p>分数 = 最小的次数</p><hr><p>求所有排列方案 的分数的k次方的和</p><p>mod 998244353</p><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>N 50</p><p>k 1e4</p><p>2 s</p><p>1024 mb</p><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>很明显, 交换的圈构成环, 次数 = lcm(每个环长)</p><p>N 很小, 是不是可以枚举因数</p><p><code>dp[i][j] =</code> 使用i个,最大是j,的<code>{lcm,方案数}</code></p><p><code>dp[i][j]</code> 贡献来自 <code>dp[i- tm][m],m &gt; j, t &gt; 0</code>, 即<code>n-i+tm</code>个中选<code>tm</code>个, 然后分成<code>t</code>组每组m个</p><p>因为组合tm中分成t组,每组m个</p><p>这样想,tm中最小的作为开头,依次剩下的选m-1个, 然后剩余就是(t-1)m 同样的</p><p>这样每次考虑最小的所在环, 就不重不漏</p><p>$\binom{n-i+tm}{tm} A(tm-1,m-1) \cdot A((t-1)m-1,m-1) \cdots$</p><p>$ = \binom{n-i+tm}{tm} \frac{(tm)!}{m\cdot 2m \cdots tm}$</p><p>$ = \binom{n-i+tm}{tm} \frac{(tm)!}{m^t * t!}$</p><p>似乎就对了</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc226/submissions/33934208" target="_blank" rel="noopener">https://atcoder.jp/contests/abc226/submissions/33934208</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;#include &lt;atcoder/modint&gt;using mint = atcoder::modint998244353;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readll gcd(int a,int b){ return b == 0? a: gcd(b,a%b);}map&lt;int,mint&gt; dp[60][60]; // dp[选最小i个][最大的环为j] = {lcm, count}mint fac[100] = {1};mint ifac[100];mint binom(int n,int m) { return fac[n] * ifac[m] * ifac[n-m];}int main(){  rep(i,1,51) fac[i] = fac[i-1] * i;  ifac[50] = fac[50].inv();  per(i,0,50) ifac[i] = ifac[i+1] * (i+1);  int n = read();  int k = read();  dp[0][0][1] = 1;  rep(i,1,n+1) rep(j,1,i+1){    mint invj = mint(j).inv();    rep(t,1,n+1){      int oldi = i - j*t; // [i - j*t][&lt;j]      if(oldi &lt; 0) break;      rep(k,0,j) for(auto [lcm,cnt]: dp[oldi][k]){        dp[i][j][lcm * j / gcd(lcm,j)] += cnt * binom(n-oldi,j*t) * fac[j*t] * ifac[t] * invj.pow(t);      }    }  }  mint ans = 0;  rep(j,1,n+1) for(auto [lcm,cnt]:dp[n][j]) ans += cnt * mint(lcm).pow(k);  printf(&quot;%d\n&quot;,ans.val());  return 0;}</code></pre><h1 id="G-The-baggage"><a href="#G-The-baggage" class="headerlink" title="G - The baggage"></a>G - The baggage</h1><p>重量1~5的物品每个Ai个</p><p>搬运能力1~5的人每个Bi个</p><p>问是否有方法, 让所有物品被至少一个人搬运,且每个人搬运的物品重量和不大于他的能力</p><p>一共T个询问</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>T 5e4</p><p>Ai,Bi [0,10^16]</p><p>2s</p><p>1024mb</p><h2 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h2><p>一样看上去, 枚举或者数学题</p><p>考虑 物品重量不超过5的组合</p><p>再 组合x能力, 应该大概有 5x2^5以内的选项 </p><p>每个选项有限制, 一些之间的和小于等于Bi, 一些之间的和 = Ai, 看是否有方案</p><p>似乎变成2sat? 然后是 偏序的样子, 但Ai,Bi范围大, 似乎没法那么多点</p><hr><p>另一个从能力从小到大</p><p>能力1的只能消耗重量1,那么贪心</p><p>能力2的可以消耗 1个2,2个1,1个1, 而如果同时有1个2和2个1, 显然后面的更灵活,所以贪心消耗1个2,再消耗1</p><p>能力3的也是先1个3,然后2+1,然后剩余1</p><p>能力4的,先1个4, 问题来了, 是3+1先还是2+2先呢? 如果都考虑3+1还是2+2了, 说明4消耗完了,对5来说 5,3,2,1的处理肯定先整个5,然后先3找2,再去2+2+1</p><p>所以对于4来说,先2+2,后3+1</p><p>就这样? 似乎贪心就没了?</p><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readint n;ll a[10];ll b[10];vector&lt;vector&lt;pair&lt;int,int&gt; &gt; &gt; child[10];void w(){  rep(i,1,5+1) a[i] = read();  rep(i,1,5+1) b[i] = read();  rep(i,1,5+1) per(j,1,i+1) for(auto arr: child[j]){    ll c = b[i];    for(auto [v,t]:arr) c = min(c, a[v] / t);    b[i] -= c;    for(auto [v,t]:arr) a[v] -= c*t;  }  ll s = 0;  rep(i,1,5+1) s += a[i];  printf(&quot;%s\n&quot;,s == 0 ? &quot;Yes&quot; : &quot;No&quot;);}int main(){  child[1] = {    {{1,1}} // 1  };  child[2] = {    {{2,1}}, // 2    {{1,2}} // 1+1  };  child[3] = {    {{3,1}}, // 3    {{2,1},{1,1}}, // 2+1    {{1,3}} // 1+1+1  };  child[4] = {    {{4,1}}, // 4    {{2,2}}, // 2+2    {{3,1},{1,1}},// 3+1    {{2,1},{1,2}}, // 2+1+1    {{1,4}} // 1+1+1+1  };  child[5] = {    {{5,1}}, // 5    {{4,1},{1,1}}, // 4+1    {{3,1},{2,1}}, // 3+2    {{3,1},{1,2}}, // 3+1+1    {{2,2},{1,1}}, // 2+2+1    {{2,1},{1,3}}, // 2+1+1+1    {{1,5}} // 1+1+1+1+1  };  int t = read();  while(t--) w();  return 0;}</code></pre><p>但ac x15, wa x33</p><p>看起来贪假了</p><hr><p>原因大概是<code>{1,5}</code> 优先级比<code>{3,1},{1,1}</code> 高了?</p><p>调了半天优先顺序都没对</p><p>好神奇啊这题</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>还是贪心,</p><p>但是说</p><p>5拿5</p><p>4拿4</p><p>5拿4</p><p>3拿3</p><p>5拿3</p><p>4拿3</p><p>5拿2</p><p>4拿2</p><p>3拿2</p><p>2拿2</p><p>5拿1</p><p>4拿1</p><p>3拿1</p><p>2拿1</p><p>1拿1</p><p>????????????? 学不会</p><p>tourist 都wa了一次</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc226/submissions/33953558" target="_blank" rel="noopener">https://atcoder.jp/contests/abc226/submissions/33953558</a></p><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readint n;ll a[10];ll b[10];void pack(ll x, ll y) {  ll c = min(a[x], b[y]);  a[x] -= c;  b[y] -= c;  if(y-x) b[y - x] += c; // c个工人的负重还剩下y-x  return;}void w(){  rep(i,1,5+1) a[i] = read();  rep(i,1,5+1) b[i] = read();  per(i,1,5+1){    pack(i,i);    per(j,i+1,5+1) pack(i,j);    pack(i,i);  }  bool ans = true;  rep(i,1,5+1)if (a[i] &gt; 0)ans = false;  printf(&quot;%s\n&quot;, ans? &quot;Yes&quot;: &quot;No&quot;);}int main(){  int t = read();  while(t--) w();  return 0;}</code></pre><h1 id="H-Random-Kth-Max"><a href="#H-Random-Kth-Max" class="headerlink" title="H - Random Kth Max"></a>H - Random Kth Max</h1><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>F</p><p>dp 组合数, 主要是看到和很小,所以lcm估计也很少,没啥难的</p><p>G</p><p>贪心完全不会</p><p>H</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://atcoder.jp/contests/abc226/editorial" target="_blank" rel="noopener">官方题解</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;F(DP,组合数,gcd)G(贪心)H()&lt;/p&gt;
&lt;h1 id=&quot;F-Score-of-Permutations&quot;&gt;&lt;a href=&quot;#F-Score-of-Permutations&quot; class=&quot;headerlink&quot; title=&quot;F - Score of Perm
      
    
    </summary>
    
      <category term="Atcoder" scheme="http://yexiaorain.github.io/Blog/categories/Atcoder/"/>
    
    
      <category term="贪心" scheme="http://yexiaorain.github.io/Blog/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>maspy 生成方程与问题解决</title>
    <link href="http://yexiaorain.github.io/Blog/2022-08-12-generate_function/"/>
    <id>http://yexiaorain.github.io/Blog/2022-08-12-generate_function/</id>
    <published>2022-08-12T14:24:00.000Z</published>
    <updated>2022-08-12T03:23:03.827Z</updated>
    
    <content type="html"><![CDATA[<h1 id="生成方程"><a href="#生成方程" class="headerlink" title="生成方程"></a>生成方程</h1><p>感谢google翻译和maspy大佬的几篇博客, 见下方链接</p><p>用很多例子来实例如何使用 多项式乘积</p><p>状態ごとに何らかの値が計算されているときに、その計算結果を多項式の形で持ちます。この際、 「多項式の次数」が「考えている状態」、「係数」が状態ごとの「計算した値」（多くの場合、数え上げ）を表すように多項式を持つのが原則です。</p><p>括号内是或关系, 括号间幂次是加和关系,系数是代价倍数一般是1</p><p>翻译了一下, 统一了一下格式,增加了一些步骤</p><p>以下未强调的都是非负整数</p><p>注意的是有不少都可以写成无限次方的上限,因为超过n不会影响n,看具体情况哪个更好用用哪个</p><h2 id="maspy-1-如何把问题转化"><a href="#maspy-1-如何把问题转化" class="headerlink" title="maspy 1 如何把问题转化"></a>maspy 1 如何把问题转化</h2><blockquote><p>问题1, $A=\{2,3\},B=\{2,4\},C=\{3,5,7\} , a+b+c=n$ 有多少种方法可以</p></blockquote><p>$\lbrack x^n \rbrack (x^2+x^3)(x^2+x^4)(x^3+x^5+x^7)$, 就是乘开后$n$次项的系数</p><blockquote><p>问题2. $a \le 2,b\le 3,c\le 4, a+b+c = n$ 有多少种</p></blockquote><p>$\lbrack x^n \rbrack (1+x+x^2)(1+x+x^2+x^3)(1+x+x^2+x^3+x^4)$</p><blockquote><p>问题3. 无限制的$a,b,c \ge 0, a+b+c=n$ 有多少种</p></blockquote><p>$\lbrack x^n \rbrack (1+x+x^2+\cdots)^3$</p><p>$\lbrack x^n \rbrack (1+x+x^2+\cdots+x^n)^3$, (因为高次不影响n</p><blockquote><p>问题4(ABC149E), $A=\{a_1,a_2,\cdots,a_k\}, n = a_i + a_j$ 有多少种</p></blockquote><p>$\lbrack x^n \rbrack (x^{a_1}+x^{a_2}+\cdots+x^{a_k})^2$</p><blockquote><p>问题5, 从1开始,每次+2或+3, 恰好n次移动到N的方案数</p></blockquote><p>$\lbrack x^{N-1} \rbrack (x^2+x^3)^n$, 从增量的角度</p><p>$\lbrack x^{N} \rbrack x(x^2+x^3)^n$, 从状态的角度</p><blockquote><p>问题6, 从1开始,每次+2或+3, 移动到N的方案数</p></blockquote><p>$\lbrack x^{N-1} \rbrack \sum_{n=0}^{\infty}(x^2+x^3)^n$</p><p>$\lbrack x^{N-1} \rbrack \sum_{n=0}^{\frac{N}{2}}(x^2+x^3)^n$</p><blockquote><p>问题7, 1元,5元,10元有无限多, 组合成n元方案数</p></blockquote><p>$\lbrack x^{n} \rbrack (1+x^1+x^2+x^3+\cdots)(1+x^5+x^{10}+x^{15}+\cdots)(1+x^{10}+x^{20}+x^{30}+\cdots)$</p><blockquote><p>问题8, 重量分别$w_i$, 总重量不超过$W$ 有多少方案</p></blockquote><p>$\sum_{n=0}^W \lbrack x^n \rbrack (1+x^{w_1})(1+x^{w_2})\cdots (1+x^{w_k})$</p><p>$\sum_{n=0}^{W}[x^n]\prod_{i=1}^k$</p><blockquote><p>问题9, $0\le a_i \le N$, $a_1+\cdots+a_8=6N$ $a_i$的方案数</p></blockquote><p>$\lbrack x^{6N} \rbrack (1+x^1+x^2+\cdots+x^N)^8$</p><blockquote><p>问题10, $0\le a,b,c \le N$且为素数,$a+b+c$ 也是素数方案数</p></blockquote><p>$\sum_{p=2}^{3N} \lbrack x^{p} \rbrack (x^2+x^3+x^5+x^7+\cdots+x^{prime,\le N})^3$, 且$p$为素数</p><blockquote><p>问题11, $N$ 拆成正整数求和表达式(关心顺序)</p></blockquote><p>$\sum_{n=1}^{\infty} \lbrack x^{N} \rbrack (x^1+x^2+x^3+\cdots+x^N)^n$</p><p>$\sum_{n=1}^{N} \lbrack x^{N} \rbrack (x^1+x^2+x^3+\cdots+x^N)^n$</p><p>$\lbrack x^{N} \rbrack \sum_{n=1}^{N} (x^1+x^2+x^3+\cdots+x^N)^n$</p><blockquote><p>问题12, $N$ 拆成正整数求和表达式, 但是数字从小到大(不关心顺序)</p></blockquote><p>$\lbrack x^{N} \rbrack \prod_{k=1}^{\infty} (\sum_{i=0}^{\infty} x^{ki})$, 相当于数字相同的视作一致,只有每个的数字的个数</p><p>$\lbrack x^{N} \rbrack \prod_{k=1}^{n} (\sum_{i=0}^{n} x^{ki})$</p><blockquote><p>问题13, $N$ 拆成多个不同整数的和, 但是数字从小到大(不关心顺序)</p></blockquote><p>$\lbrack x^{N} \rbrack \prod_{k=1}^{\infty} (1+x^k)$, 选或不选</p><p>$\lbrack x^{N} \rbrack \prod_{k=1}^{N} (1+x^k)$</p><blockquote><p>问题14, $N,M &gt; 0, 0 &lt; A_1 \le A_2 \le \cdots \le A_N = M$, 相邻$A_i$的差在$[3,5]$, 求方案数</p></blockquote><p>$\lbrack x^M \rbrack (x^1+x^2+\cdots+x^M)(x^3+x^4+x^5)^{N-1}$, 相当于一个是$A_1$ 的选择,后面是增加到$A_N$的选择</p><blockquote><p>问题15, $N,M &gt; 0, 0 &lt; A_1 \le A_2 \le \cdots \le A_N &lt; M$, 相邻$A_i$的差在$[3,5]$, 求方案数, 和上面不同的是最后</p></blockquote><p>$\sum_{m=0}^{M-1} \lbrack x^m \rbrack (x^1+x^2+\cdots+x^m)(x^3+x^4+x^5)^{N-1}$, 相当于枚举$A_N$的值</p><p>$\lbrack x^M \rbrack (x^1+x^2+\cdots+x^M)(x^3+x^4+x^5)^{N-1}(x^1+x^2+\cdots+x^M)$, 相当于想象多一个$A_{N+1} = M$</p><blockquote><p>问题16, $[1,6]$的骰子,扔100次, 总和为$n$的概率</p></blockquote><p>$\lbrack x^{n} \rbrack (\frac{x^1+x^2+x^3+x^4+x^5+x^6}{6})^{100}$ 这里系数终于不是1了,而是概率倍数的贡献</p><blockquote><p>问题17, $p+q = 1,p,q\ge 0$是 实数概率, $p$概率$+1$,$q$概率$-1$, 总和$=100$的概率</p></blockquote><p>$\lbrack x^{n} \rbrack (px+qx^{-1})^{100}$ , 这里一个是再次展示了系数,一个是出现了负数幂次, 称作 Laurent polynomial, 几乎没有区别 </p><p>$\lbrack x^{n+100} \rbrack x^{100}(px+qx^{-1})^{100}$</p><p>$\lbrack x^{n+100} \rbrack (px^2+q)^{100}$</p><blockquote><p>问题18(AGC013E), 对N划分成有序的正整数的和, 划分后 获得价值 = 所有正整数的平方的乘积, 求所有方案的 价值和</p></blockquote><p>$\lbrack x^N \rbrack \sum_{n=0}^{N} (x+4x^2+9x^3+16x^4+\cdots+N^2x^N)^n$, 代价拆散到每个选择上</p><h3 id="高维"><a href="#高维" class="headerlink" title="高维"></a>高维</h3><blockquote><p>问题19, A:3元,4克; B:5元,6克, 每个最多选2个, 构成n元,m克的方案数</p></blockquote><p>$\lbrack x^ny^m \rbrack (1+x^3y^4+x^6y^8)(1+x^5y^6+x^{10}y^{12})$</p><blockquote><p>问题20, 1元,5元,10元,无限个, 用n个,组成m元方案数</p></blockquote><p>$\lbrack x^my^n \rbrack (1+x^1y^1+x^2y^2+x^3y^3+\cdots)(1+x^5y^1+x^{10}y^2+x^{15}y^3+\cdots)(1+x^{10}y^1+x^{20}y^2+x^{30}y^3+\cdots)$</p><blockquote><p>问题21(ARC012D), 每次随机$x\pm 1$或$y\pm 1$, 问$(0,0)$在恰好$T$次走到$(a,b)$的概率</p></blockquote><p>$\lbrack x^ay^b \rbrack (\frac{x+x^{-1}+y+y^{-1}}{4})^T$</p><blockquote><p>问题22, $x,y,z$ 每次随机一个$\pm 1$或 全部一起$\pm 1$, 问$(0,0,0)$在恰好$T$次走到$(a,b,c)$的方案数</p></blockquote><p>$\lbrack x^ay^bz^c \rbrack (x+x^{-1}+y+y^{-1}+z+z^{-1}+xyz+(xyz)^{-1})^T$, 很能表达或关系</p><p><a href="https://maspypy.com/atcoder-k-one-or-all%ef%bc%88kupc-2019%ef%bc%89" target="_blank" rel="noopener">21,22, maspy 具体计算方案</a></p><blockquote><p>问题23, $(x,y,z)$ 每次任意非0正增量,任意维度变化$\ge 0$, 至少一个维度变化$ &gt; 0$, 求原点到$(a,b,c)$的方案数</p></blockquote><p>$\lbrack x^ay^bz^c \rbrack \sum_{n=0}^{\infty} ((1+x+x^2+x^3+\cdots)(1+y+y^2+y^3+\cdots)(1+z+z^2+z^3+\cdots) - 1)^n$</p><blockquote><p>问题24, $(x,y,z)$ 每次随机一个方向随机$\pm 1$, T次,$3a+4b+5c=n$的概率</p></blockquote><p>$\sum_{3a+4b+5c=n} \lbrack x^ay^bz^c \rbrack (\frac{x+x^{-1}+y+y^{-1}+z+z^{-1}}{6})^T$</p><p>$\lbrack t^n \rbrack (\frac{t^3+t^{-3}+t^4+t^{-4}+t^5+t^{-5}}{6})^T$, 其实对各个坐标没限制 只对总和限制,$3,4,5$看成贡献倍数</p><h2 id="maspy-2-如何计算"><a href="#maspy-2-如何计算" class="headerlink" title="maspy 2 如何计算"></a>maspy 2 如何计算</h2><h3 id="二项式定理"><a href="#二项式定理" class="headerlink" title="二项式定理"></a>二项式定理</h3><p>$(x+y)^n = \sum_{i=0}^{n} \binom{n}{i} x^iy^{n-i}$</p><p>其中$\binom{n}{i} = \frac{n!}{i!(n-i)!}$是排列数, 为了方便当$ i &lt; 0 $或$ i &gt; n$ 时令它为$0$</p><p>$(x+y)^n = \sum_{i=0}^{\infty} \binom{n}{i} x^iy^{n-i}$</p><h3 id="等比数列求和"><a href="#等比数列求和" class="headerlink" title="等比数列求和"></a>等比数列求和</h3><p>$r\neq 1$时</p><p>$\sum_{i=0}^{n} r^i = \frac{1-r^{n+1}}{1-r}$</p><h3 id="形式幂级数-运算法则"><a href="#形式幂级数-运算法则" class="headerlink" title="形式幂级数 运算法则"></a>形式幂级数 运算法则</h3><p>形式幂级数 $F = \sum_{n=0}^{\infty} f_nx^n$</p><p>若$G = \sum_{n=0}^{\infty} g_nx^n$</p><p>加减: $\lbrack x^n \rbrack (F\pm G) = f_n \pm g_n$</p><p>乘法: $\lbrack x^n \rbrack (FG) =  \sum_{i+j=n}f_ig_j.$</p><p>在运算中可以 只考虑 小于等于 $x^n$的部分</p><p>满足,交换律,结合律,分配律, 被称作 环</p><h3 id="形式的べき級数環の位相"><a href="#形式的べき級数環の位相" class="headerlink" title="形式的べき級数環の位相"></a>形式的べき級数環の位相</h3><p>形式的べき級数$F$は、最低次の項が高いほど、 $0$に近いと考えて扱います。このことを利用して、形式的べき級数の列の極限を定義することができます：</p><p>【定義】</p><p>形式的べき級数列$F1,F2,F3\cdots F$ に収束するとは、任意の$k$ に対してある$N$が存在して、$n\ge N$ ならば $F_n$ と $F$ の $k$ 次未満部分が一致することを指す。</p><p>我没看懂翻译以后的XD</p><h3 id="形式幂级数的倒数"><a href="#形式幂级数的倒数" class="headerlink" title="形式幂级数的倒数"></a>形式幂级数的倒数</h3><p>$FG = 1$, 则$F = \frac{1}{G}$</p><p>也可以和正常分数类似的计算规则$\frac{F_1}{G_1}\pm\frac{F_2}{G_2}=\frac{F_1G_2\pm F_2G_1}{G_1G_2}$</p><p>最常用的一个</p><p>$\frac{1}{1-x} = 1 + x + x^2 + x^3 + x^4 + \cdots = \sum_{n=0}^{\infty}x^n$</p><p>因为$(1-x)(1+x+x^2+x^3+\cdots) $, 而对于一个具体$x^n$ 前面乘了以后会变成$1-x^{\infty}$, 又高于$x^n$不会对$x^n$的系数有影响, 所以即使 从级数收敛角度看起来 $x \ge 1$ 时它不收敛, 但从求系数意义上它是合理 </p><p>对于<strong>没有常数项的</strong>多项式 $F$, 也有, 原理也是相同的, 也需要注意没有常数项</p><p>$\frac{1}{1-F} = 1 + F + F^2 + F^3 + F^4 + \cdots  = \sum_{n=0}^{\infty}F^n.$</p><h3 id="幂级数-示例"><a href="#幂级数-示例" class="headerlink" title="幂级数 示例"></a>幂级数 示例</h3><blockquote><p>问题 N拆成正整数和的表达式</p></blockquote><p>前面已经有转换了</p><p>$\lbrack x^N \rbrack \sum_{n=0}^{\infty} (x+x^2+x^3+\cdots)^n$</p><p>然后利用这里幂级数</p><p>$ = \lbrack x^N \rbrack \sum_{n=0}^{\infty} (\frac{x}{1-x})^n$</p><p>$ = \lbrack x^N \rbrack \frac{1}{1- \frac{x}{1-x}}$</p><p>$ = \lbrack x^N \rbrack \frac{1-x}{1-2x}$</p><p>$ = \lbrack x^N \rbrack (1-x)(1+2x+4x^2+8x^3+\cdots)$</p><p>$ = 2^N - 2^{N-1}$</p><p>$ = 2^{N-1} $</p><p>同样在分数过程也可以简化掉 分子</p><p>$ = \lbrack x^N \rbrack \frac{1-x}{1-2x}$</p><p>$ = \lbrack x^N \rbrack \frac{1}{2} + \frac{1}{2} \cdot \frac{1}{1-2x}$</p><p>$ = \lbrack x^N \rbrack \frac{1}{2} + \frac{1}{2}(1+2x+4x^2+8x^3+\cdots)$</p><h3 id="因式分解-示例"><a href="#因式分解-示例" class="headerlink" title="因式分解 示例"></a>因式分解 示例</h3><blockquote><p>问题 $\lbrack x^ay^b\rbrack(x+x^{-1}+y+y^{-1})^T$</p></blockquote><p>$ = \lbrack x^ay^b \rbrack ((xy)^{-1}(xy+1)(x+y))^T$</p><p>$ = \lbrack x^ay^b \rbrack \sum_{i,j} \binom {T}{i}\binom{T}{j}x^{i+j-T}y^{i-j}.$</p><p>只会有唯一的$(i,j)$</p><h3 id="积累和-推到-dp转换"><a href="#积累和-推到-dp转换" class="headerlink" title="积累和 推到 dp转换"></a>积累和 推到 dp转换</h3><blockquote><p>问题 $xi \in [0,a_i]$, 选择$x_1+\cdots+x_N = M$, 找出方案数, $a_i \le M \le 10^5, N \le 100$</p></blockquote><p>$\lbrack x^M \rbrack \prod_{i=1}^N (\sum_{j=0}^{a_i} x^j)$</p><p>$\lbrack x^M \rbrack \prod_{i=1}^N \frac{1-x^{a_i+1}}{1-x}$</p><hr><p>分解成一个稀疏多项式(项少,就可以DP)的方法, $(1-x)Q = P$, 那么$p_n = q_n-q_{n-1}$, 有可以$q_n = q_{n-1}+p_n$递推</p><p>$1-x^{a_i+1}$ 也是类似, 相当于$dp[j] = dp[j] - dp[j-(a_i+1)]$</p><p>这样是$O(NM)$, 这里$NM \le 10^7$ 可做</p><p>据说$N = 1e5$ 也有方法可搞?</p><h3 id="DP的推导返回"><a href="#DP的推导返回" class="headerlink" title="DP的推导返回"></a>DP的推导返回</h3><blockquote><p>问题 $xi \in [0,a_i]$, 选择$x_1+\cdots+x_N = M$, 找出方案数<br>但是Q个独立询问, 让$x_{p_j} = c_j$<br>$a_i \le M \le 2000, N \le 2000, Q \le 500000$</p></blockquote><p>对i以外的前后缀来计算 $\prod$, 再用FFT 可以得到</p><p>另一个思路是,能否接受除法</p><p>先算出所有的$\prod$ 再除以被更改部分的</p><h3 id="交换律-和-迭代平方法"><a href="#交换律-和-迭代平方法" class="headerlink" title="交换律 和 迭代平方法"></a>交换律 和 迭代平方法</h3><p>没看懂翻译</p><hr><p>鸽</p><h3 id="负二项式定理"><a href="#负二项式定理" class="headerlink" title="负二项式定理"></a>负二项式定理</h3><p>$(1-rx)^{-d} = \sum_{n=0}^{\infty}\binom{n+d-1}{d-1}(rx)^n$</p><p>证明:</p><p>归纳+导数, 可证 <code>-d</code>成立,那么<code>-d-1</code>也成立</p><p>这个在百度百科上也有</p><p>$(1+x)^{-d} = \sum_{n=0}^{\infty} (-1)^n \binom{d+n-1}{n}x^n$</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://maspypy.com/category/%e5%bd%a2%e5%bc%8f%e7%9a%84%e3%81%b9%e3%81%8d%e7%b4%9a%e6%95%b0%e8%a7%a3%e8%aa%ac" target="_blank" rel="noopener">maspy</a></p><p><a href="https://baike.baidu.com/item/%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%AE%9A%E7%90%86" target="_blank" rel="noopener">百度百科 二项式定理推广</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;生成方程&quot;&gt;&lt;a href=&quot;#生成方程&quot; class=&quot;headerlink&quot; title=&quot;生成方程&quot;&gt;&lt;/a&gt;生成方程&lt;/h1&gt;&lt;p&gt;感谢google翻译和maspy大佬的几篇博客, 见下方链接&lt;/p&gt;
&lt;p&gt;用很多例子来实例如何使用 多项式乘积&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="algorithm" scheme="http://yexiaorain.github.io/Blog/categories/algorithm/"/>
    
    
      <category term="生成方程" scheme="http://yexiaorain.github.io/Blog/tags/%E7%94%9F%E6%88%90%E6%96%B9%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Atcoder abc225</title>
    <link href="http://yexiaorain.github.io/Blog/2022-08-11-ac_abc225/"/>
    <id>http://yexiaorain.github.io/Blog/2022-08-11-ac_abc225/</id>
    <published>2022-08-10T20:25:14.000Z</published>
    <updated>2022-08-12T03:23:03.827Z</updated>
    
    <content type="html"><![CDATA[<p>F(字符串,偏序,DP,倒着DP,局部性)G(题意转化,最小割,最大流)H(NTT,FFT,生成方程,分治,归并)</p><h1 id="F-String-Cards"><a href="#F-String-Cards" class="headerlink" title="F - String Cards"></a>F - String Cards</h1><p>给N个字符串, 恰好选其中K个, 拼接出的最小字典序的字符串是什么</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>N 50</p><p>|Si| [1,50], 每个长度</p><p>只含小写英文字母</p><p>2s</p><p>1024 mb</p><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>例如</p><p>b和ba</p><p>b &lt;= ba</p><p>但是</p><p>bab &lt;= bba</p><p>非前缀的 s1 &lt; s2, 一定s1</p><p>s1 是 s2的前缀的  s1 &lt; s2</p><p>如果只剩下一个,则s1</p><p>否则,形如</p><pre><code>[A][A][B][A][B][C][A][B][C][D][A][A] ?[A][B] [A] ?[A][B][C] [A] ?[A][B][C][D] [A] ?</code></pre><p>如果本身A和B有直接大小, 那么就能知道第一个还是后面3个,A和C再比,A和D再比</p><p>但如果A和B依然是前后缀关系, 这会考虑长度,也会考虑要选的个数</p><hr><p>少考虑一点, 对于两个</p><pre><code>AAB</code></pre><p>两种排列</p><pre><code>AABABA</code></pre><p>长度一致, 考虑是否交换</p><p>但感觉两个到三个之间局部性不知道是否成立:</p><p>(A,AB)组合A 放在前,  (AB,ABC) 组合 AB 放在前, 能否推出 (A,ABC) 中 A要放在前</p><pre><code>AABABC</code></pre><hr><p>其实我在想,是不是n^4 可以暴力dp?, 好像会是n^6?</p><p><code>dp[i][j][length]</code>, <code>前i选j,长度=length的最小前缀</code></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>有意思, 还给了一些错误解法的反例</p><blockquote><p>反例1, sort取前k个连起来</p></blockquote><p>就是我已经想到的 b, ba</p><blockquote><p>反例2, 还是sort, 保证相邻拼接 &lt; 相邻逆序拼接, 的前k 个</p></blockquote><p>这也是想到了的, 当个数为1时ba,b 还是会选b</p><blockquote><p>反例3, sort, 保证相邻拼接 &lt; 相邻逆序拼接</p></blockquote><p>定义<code>dp[i][j]=</code> 前i个选j个能得到的最小字典序</p><p><code>dp[i][j] = min(dp[i-1][j],dp[i-1][j-1] + Si)</code> 的转移方程, 输出<code>dp[N][K]</code></p><p>对于 baa,ba,b, 选出两个, 期望是baab, 而输出是baaba</p><p>应该就是没有最小的性质</p><p>前两个选1个最小是ba, 拼接b得到bab</p><p>而前两个选2个最小是baaba, 这两个都不是最小答案</p><p>最小的构成是 baab = 前两个中大的一个 和最后一个拼接</p><blockquote><p>反例4</p></blockquote><p>同样的排序, 同样的<code>dp</code>定义</p><p>但是改变转移方程</p><p><code>dp[i][j] = min(dp[i-1][j],dp[k &lt; i][j-1] + Si)</code> 的转移方程, 输出<code>dp[N][K]</code></p><p>然后</p><p>bbaba</p><p>bba</p><p>b</p><p>b</p><p>选3个也是反例</p><hr><p>其实这列我们可以看到, dp的定义 只能说是希望它是这样,一旦你的转移方程之类出现问题, 它的结果将不满足定义</p><hr><p>正确方案</p><p>尝试排序 让排序后 任意(i &lt; j) 满足,  Si+Sj &lt; Sj + Si</p><p>这里有点和我想的有没有偏序关系的问题了一样了, 怎么证明存在啊?</p><p>证明</p><p>把字符串变成数字 a,b</p><p>AB &lt; BA</p><p>等价<code>a * 26^len(B) + b &lt; b * 26^len(A) + a</code></p><p>a/(26^len(A)-1) &lt; b/(26^len(B)-1)</p><p>好有道理, 事后看起也不难, 我咋自己想不到简单转换一下就证明了</p><p>那这样整个问题就简单了</p><p>也就是 如果选定了字符串, 那么 它们的顺序就是一定的, 有偏序关系,就可以按照上面的排序来排</p><hr><p>那么这样再<code>dp[i][j]</code>= S[i..N] 中选j个能构成的最小字典需</p><p>和前面不一样的是, 变成后缀中选j个</p><p>转移方程<code>dp[i][j] = min(dp[i+1][j], S[i]+ dp[i+1][j-1])</code></p><p>显然如果<code>S[i]</code> 本来就非前缀的小于<code>S[i+1]</code>, 那么min 一定取右侧, 且子问题已经被计算了</p><p>而如果要<code>S[i]</code> 则<code>S[i]</code> 一定是开头的</p><p>答案是<code>dp[1][K]</code></p><hr><p>这里其实dp的问题在于 为啥正着做不对,而倒着的是对的?</p><p>其实问题就在于 选第i个时</p><p>正着选第 i个时, 它也在末尾, 但是并不一定意味着 前缀是<code>dp[i-1][j-1]</code>, 因为<code>dp[i-1][j-1]</code> 可能是通过长度胜出的最小,而不是字符胜出的最小,</p><p>可能有 D0 &lt; D1, 但是D0是D1前缀,</p><p>从而 D1+Si &lt; D0+Si的情况, 没有了局部性</p><p>而倒过来, Si放在最前</p><p>如果同样有 有 D0 &lt; D1, 但是D0是D1前缀</p><p>但 Si+D0 &lt; Si + D1始终成立的, 保证了局部性</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc225/submissions/33909604" target="_blank" rel="noopener">https://atcoder.jp/contests/abc225/submissions/33909604</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readchar s[60][60];int sz[60];int idx[60];char dp[60][60][2500];int main(){  int n = read();  int k = read();  rep(i,0,n) {    scanf(&quot;%s&quot;,s[i]);    sz[i] = strlen(s[i]);  }  iota(idx,idx+n,0);  sort(idx,idx+n,[=](int i,int j){      rep(p,0,sz[i]+sz[j]){        char ch0 = p &lt; sz[i] ? s[i][p] : s[j][p-sz[i]];        char ch1 = p &lt; sz[j] ? s[j][p] : s[i][p-sz[j]];        if(ch0 != ch1) return ch0 &lt; ch1;      }      return false;  });  rep(i0,0,n){    char *t = s[idx[n-1-i0]];    rep(j,0,i0+1){ // 选 j+1 个      // dp[n-1-i][j] = min(dp[n-1-i+1][j], s[n-1-i] + dp[n-1-i+1][j-1]);      strcpy(dp[i0][j], t);      if(i0 &gt; 0) {        if(j &gt; 0) strcpy(dp[i0][j] + strlen(t), dp[i0-1][j-1]);        if(i0 &gt; j &amp;&amp; strcmp(dp[i0][j], dp[i0-1][j]) &gt; 0) strcpy(dp[i0][j], dp[i0-1][j]);      }    }  }  printf(&quot;%s\n&quot;,dp[n-1][k-1]);  return 0;}</code></pre><h1 id="G-X"><a href="#G-X" class="headerlink" title="G - X"></a>G - X</h1><p><a href="https://atcoder.jp/contests/abc225/tasks/abc225_g" target="_blank" rel="noopener">https://atcoder.jp/contests/abc225/tasks/abc225_g</a></p><p>矩阵H x W, 每个上面Aij</p><p>选任意个格子,每个被选的格子画X, 连通左上右下,左下右上角</p><p>然后 分数 = 画了X的格子的数字和 - C 乘 画X的最小需要的线段数, 没有选的格子不能画,任何东西</p><p>例如这样选的话, 左下角到右上只需要一个长线段,一共是3个线段</p><pre><code> XX</code></pre><p>求 最大分数 = sum(选的格子) - C 倍最小画线段数</p><h2 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h2><p>H,W 100</p><p>C 1e9</p><p>Aij [1,1e9]</p><p>2s</p><p>1024 mb</p><h2 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h2><p>先试试形状</p><pre><code>X</code></pre><p>1个格子, -2C</p><pre><code>XXXX</code></pre><p>4个格子, -6C</p><pre><code>XXXXXXXXX</code></pre><p>9个格子, -10C</p><pre><code>XXXXXXXXXXXXXXXX</code></pre><p>16个格子,-14C</p><pre><code> XX X X</code></pre><p>4个格子,-4C</p><pre><code>  X X XX X X X X  X</code></pre><p>9个格子, -6C</p><p>收获不大至少说明一点,即使格子本身小于C,但是可以通过相邻的线段可以贯通,而让均摊下来每个减去的不到C</p><hr><p>第二个思路就是</p><p>如果一排一排的铺</p><p><code>dp[state i] =&gt; dp[state i+1]</code>, 根据上面左上角和右上角的两个是否被选决定当前选择的贡献是什么</p><p>这样 做个类似插头dp的样子, 每次转移O(1) 但是,因为要存边界状态</p><p>所以状态 高达 <code>N^2 * 2^N</code>, 分别是切割线的位置, 和 切割线的状态</p><p>这里最主要的就是 会受到它顶部两个的选择状态的影响它的贡献</p><hr><p>然后考虑说在位置上相邻,在实际填写中互不影响, 其实可以把 横纵坐标和为奇数/ 和偶数分开考虑</p><pre><code>ABABABABABABABABABAB</code></pre><hr><p>然后可以转个45度, 补成个长方形, 原来空白的地方放0,问题变成选一些数的 和 - C 乘 (纵向连续块数+横向连续块数), 这样最大答案不会变</p><pre><code>0A00AAA0AAAA0AA0</code></pre><p>但这依然有和左侧和上面的关联决定一个块的贡献</p><p>整体的考虑</p><pre><code>Y? Y</code></pre><p>如果出现这样的选择, 那么? 必然选择,因为选择它不会增加带来的收益$\ge 0$</p><p>因此在新的里面选的一定是长方形</p><p>但可能不止一个长方形</p><pre><code>000000000YY111100YY11YY001111YY0</code></pre><p>例如这样 = S - 8C</p><pre><code>000000000YYYYYY00YYYYYY00YYYYYY0</code></pre><p>而这样是 = S+10-9C</p><p>如果是C很大,则上面的更优</p><hr><p>每个长方形代价 = sum(长方形) - C 乘 (长+高)</p><p>并且显然长方形的 轮廓的 横向和 &gt;= C, 纵向和 &gt;= C,( 内部不一定</p><pre><code>YYYY1111YYYY</code></pre><p>这样是 = S - 10C</p><pre><code>YYYYYYYYYYYY</code></pre><p>这样是 = S+4 - 7C</p><p>C很大,后面会更好,但中间行和可能 &lt; C</p><hr><p>找不到什么合并不合并规则</p><hr><p>如何在100x100量级中 选多个长方形, 每个贡献 = Sum - C(长 + 宽)</p><p>让贡献最大</p><p>虽然对于单个来说, 可以矩阵前缀,很快算出单个的贡献</p><p>不太会了</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>每个选, +Aij</p><p>每个选 左上角不选, -C</p><p>每个选 右上角不选, -C</p><p>又有加又有减, 不好</p><hr><p>变化</p><p>如果你不选, Aij代价, 选无代价</p><p>每个选 左上角不选, C代价</p><p>每个选 右上角不选, C代价</p><p>这样就全是 增加了</p><p>现在答案 = sum A - 代价</p><p>要总代价最小</p><hr><p>代价最小 =&gt; 最小割问题</p><p>S源(与S同块的视作选择),T汇(与T同块的视作不选)</p><p>S -&gt; (i,j), 容量Aij, (割这条边相当于不选它 的代价)</p><p>对于左上角没有块的(i,j): (i,j) -&gt; T , 容量C (割这条边相当于选它的代价)</p><p>对于右上角没有块的(i,j): (i,j) -&gt; T , 容量C (同理,割这条边相当于选它的代价), 相当于可能重边</p><p>对于左上角有块的, (i,j) -&gt; (i-1,j-1) 容量C, (割这条边,相当于它和S同块(选择),左上角和T同块(不选择),所产生的代价)</p><p>对于右上角有块的, (i,j) -&gt; (i-1,j+1) 容量C, (同理, 割这条边,相当于它和S同块(选择),右上角和T同块(不选择))</p><hr><p>这个复杂度, 不理解???</p><p>看数据, 似乎没有调小, 还是和题目说的量级</p><p>但实际跑起来, 我本地i7-7700HQ, 跑数据最长的0.2~0.3s</p><p>但是提交的远端是几十ms</p><pre><code>TestCase G.in.014 =&gt; G.out.014 Time spend: 0.002467sTestCase G.in.006 =&gt; G.out.006 Time spend: 0.002532sTestCase G.in.033 =&gt; G.out.033 Time spend: 0.264098sTestCase G.in.031 =&gt; G.out.031 Time spend: 0.235067sTestCase G.in.021 =&gt; G.out.021 Time spend: 0.012753sTestCase G.in.012 =&gt; G.out.012 Time spend: 0.00644sTestCase G.in.015 =&gt; G.out.015 Time spend: 0.003208sTestCase G.in.039 =&gt; G.out.039 Time spend: 0.04113sTestCase G.in.002 =&gt; G.out.002 Time spend: 0.002386sTestCase G.in.034 =&gt; G.out.034 Time spend: 0.193138sTestCase G.in.028 =&gt; G.out.028 Time spend: 0.227858sTestCase G.in.005 =&gt; G.out.005 Time spend: 0.002228sTestCase G.in.000 =&gt; G.out.000 Time spend: 0.014386sTestCase G.in.045 =&gt; G.out.045 Time spend: 0.163sTestCase G.in.001 =&gt; G.out.001 Time spend: 0.002495sTestCase G.in.049 =&gt; G.out.049 Time spend: 0.166109sTestCase G.in.040 =&gt; G.out.040 Time spend: 0.143258sTestCase G.in.016 =&gt; G.out.016 Time spend: 0.003306sTestCase G.in.018 =&gt; G.out.018 Time spend: 0.003002sTestCase G.in.023 =&gt; G.out.023 Time spend: 0.012607sTestCase G.in.025 =&gt; G.out.025 Time spend: 0.255023sTestCase G.in.042 =&gt; G.out.042 Time spend: 0.150962sTestCase G.in.003 =&gt; G.out.003 Time spend: 0.001938sTestCase G.in.017 =&gt; G.out.017 Time spend: 0.011363sTestCase G.in.0 =&gt; G.out.0 Time spend: 0.001994sTestCase G.in.004 =&gt; G.out.004 Time spend: 0.018588sTestCase G.in.051 =&gt; G.out.051 Time spend: 0.152942sTestCase G.in.037 =&gt; G.out.037 Time spend: 0.017386sTestCase G.in.047 =&gt; G.out.047 Time spend: 0.195896sTestCase G.in.029 =&gt; G.out.029 Time spend: 0.244589sTestCase G.in.009 =&gt; G.out.009 Time spend: 0.017067sTestCase G.in.041 =&gt; G.out.041 Time spend: 0.185784sTestCase G.in.053 =&gt; G.out.053 Time spend: 0.134323sTestCase G.in.046 =&gt; G.out.046 Time spend: 0.199048sTestCase G.in.019 =&gt; G.out.019 Time spend: 0.004681sTestCase G.in.030 =&gt; G.out.030 Time spend: 0.24435sTestCase G.in.1 =&gt; G.out.1 Time spend: 0.002198sTestCase G.in.035 =&gt; G.out.035 Time spend: 0.277394sTestCase G.in.024 =&gt; G.out.024 Time spend: 0.269645sTestCase G.in.032 =&gt; G.out.032 Time spend: 0.276123sTestCase G.in.026 =&gt; G.out.026 Time spend: 0.235927sTestCase G.in.010 =&gt; G.out.010 Time spend: 0.015773sTestCase G.in.027 =&gt; G.out.027 Time spend: 0.239164sTestCase G.in.013 =&gt; G.out.013 Time spend: 0.00688sTestCase G.in.022 =&gt; G.out.022 Time spend: 0.119993sTestCase G.in.038 =&gt; G.out.038 Time spend: 0.038151sTestCase G.in.007 =&gt; G.out.007 Time spend: 0.002414sTestCase G.in.020 =&gt; G.out.020 Time spend: 0.015595sTestCase G.in.052 =&gt; G.out.052 Time spend: 0.134451sTestCase G.in.044 =&gt; G.out.044 Time spend: 0.151272sTestCase G.in.011 =&gt; G.out.011 Time spend: 0.015062sTestCase G.in.043 =&gt; G.out.043 Time spend: 0.163996sTestCase G.in.036 =&gt; G.out.036 Time spend: 0.019596sTestCase G.in.050 =&gt; G.out.050 Time spend: 0.187503sTestCase G.in.054 =&gt; G.out.054 Time spend: 0.123545sTestCase G.in.048 =&gt; G.out.048 Time spend: 0.162755sTestCase G.in.055 =&gt; G.out.055 Time spend: 0.124003sTestCase G.in.008 =&gt; G.out.008 Time spend: 0.016901sTestCase G.in.2 =&gt; G.out.2 Time spend: 0.00257s</code></pre><hr><p>这样看来, 如果变成我的那样转化, 其实也可以类似的, 左侧依赖,上侧依赖,不选负贡献 来做最小割</p><p>甚至可以变成新的题?</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc225/submissions/33910465" target="_blank" rel="noopener">https://atcoder.jp/contests/abc225/submissions/33910465</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;#include&lt;atcoder/maxflow&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readint A[110][110];int main(){  int H = read();  int W = read();  int C = read();  auto enc = [=](int i,int j){return i*W+j;};  atcoder::mf_graph&lt;ll&gt; graph(H*W+2);  rep(i,0,H) rep(j,0,W) A[i][j] = read();  int S = H*W; // 源,同块表示选  int T = S+1; // 汇,同块表示不选  // S-&gt;(i,j), 容量A[i][j], 不选  rep(i,0,H) rep(j,0,W) graph.add_edge(S,enc(i,j),A[i][j]);  // (i,j) -&gt; (i-1,j-1), 当前选, 左上不选; (i,j) -&gt; T 当前选,左上不存在  rep(i,0,H) rep(j,0,W) graph.add_edge(enc(i,j),(i &amp;&amp; j    )?enc(i-1,j-1):T,C);  // (i,j) -&gt; (i-1,j+1), 当前选, 右上不选; (i,j) -&gt; T 当前选,右上不存在  rep(i,0,H) rep(j,0,W) graph.add_edge(enc(i,j),(i &amp;&amp; j+1&lt;W)?enc(i-1,j+1):T,C);  ll ans = -graph.flow(S,T);  rep(i,0,H) rep(j,0,W) ans += A[i][j];  printf(&quot;%lld\n&quot;,ans);}</code></pre><h1 id="H-Social-Distance-2"><a href="#H-Social-Distance-2" class="headerlink" title="H - Social Distance 2"></a>H - Social Distance 2</h1><p><a href="https://atcoder.jp/contests/abc225/tasks/abc225_h" target="_blank" rel="noopener">https://atcoder.jp/contests/abc225/tasks/abc225_h</a></p><p>N个椅子排成一排, 每个最多坐一个人</p><p>M个人坐(每个人两两不同)</p><p>分数 = 相邻坐标差的乘积,</p><p>给定编号1~K的人的坐的位置</p><p>问剩下的M-K 的所有坐的方案的分数的和</p><p>mod 998244353</p><h2 id="范围-2"><a href="#范围-2" class="headerlink" title="范围"></a>范围</h2><p>2e5</p><p>2s</p><p>1024 mb</p><h2 id="我的思路-2"><a href="#我的思路-2" class="headerlink" title="我的思路"></a>我的思路</h2><p>类型应该至少是组合数+ 贡献统计吧</p><p>要么就是想法容斥</p><p>那么考虑是如何归类</p><p>一个不满足范围的DP </p><p><code>dp[i][j] =</code>小于等于给定的第i大的位置内, 坐了j个人的乘积的和,</p><p>`dp[i][j] = sum_t ( dp[i-1][t] * (A[i]-A[i-1] 空隙中(最后位置要放一个), 放入 j-t 个 的乘积和) )</p><p>状态就是 N^2的</p><p>如果后面的乘积和能直接算的话, 也需要N^3的时间复杂度, 即使走fft一类, 也是 N^2 log^2 N</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>先学一下maspy的三篇博文, 见底部链接</p><hr><p>对于未确定的$M-K$, 我们不要关心它们的区别, 直接所有方案乘上 $(M-K)!$ 即可</p><p>定义<code>f1[n][k] =</code>, 跨度<code>n</code>的椅子,两端都坐了人, 一共<code>k+2</code>个人,的内部的乘积权和</p><p>定义<code>f2[n][k] =</code>, 跨度<code>n</code>的椅子,左端坐了人, 一共<code>k+1</code>个的 内部的乘积权和</p><p>定义<code>f3[n][k] =</code>, 跨度<code>n</code>的椅子, 一共<code>k</code>个的 内部的乘积权和</p><p>其实区别只在端上</p><hr><p>那么有</p><p>$\displaystyle f_1(n,k) = \lbrack x^{n-1} \rbrack (x + 2x^2 + 3x^3 + \cdots)^{k+1} $</p><p>相当于 从$1$走到$n$,走$k+1$次,每步任意正长度(每步对最终的贡献倍数也是长度的贡献)</p><p>$ = \lbrack x^{n-k-2} \rbrack (1 + 2x + 3x^2 + \cdots)^{k+1} $</p><p>$ = \lbrack x^{n-k-2} \rbrack \frac{1}{((1-x)^2)^{k+1}}$</p><p>$ = \lbrack x^{n-k-2} \rbrack \frac{1}{(1-x)^{2k+2}}$</p><p>$ = \lbrack x^{n-k-2} \rbrack \frac{1}{(1-x)^{2k+2}}$</p><p>$ = \binom{(n-k-2) + (2k+2-1)}{2k+2-1}$</p><p>$ = \binom{n+k-1}{2k+1}$</p><hr><p>类似的有</p><p>$f_2(n,k) = \binom{n+k-1}{2k}$</p><p>$f_3(n,k) = \binom{n+k-1}{2k-1}$</p><hr><p>那么对于原问题, 如果$K=0$, 就是所有人都未确定, 使用$f_3$</p><p>对于$K\neq 0$</p><p>那么其实就是 两端用$f_2$, 中间是$K-1$个$f_1$</p><p>然后不要挨个乘,用归并的思想,尽量小乘小,大乘大, 不要太多 大乘小, 就可以了</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><p>看起来atcoder的执行是没有<code>-fsanitize</code>参数的, 很快</p><p><a href="https://atcoder.jp/contests/abc225/submissions/33929839" target="_blank" rel="noopener">https://atcoder.jp/contests/abc225/submissions/33929839</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;#include &lt;atcoder/modint&gt;#include &lt;atcoder/convolution&gt;using mint=atcoder::modint998244353;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readconst int N = 200000;ll a[N+10];mint fac[2*N+10] = {1}; // fac[i] = i!mint ifac[2*N+10]; // ifac[i] = 1/i!vector&lt;mint&gt; polys[N+10]; // 总长 &lt;= O(n + k)mint C(int n,int m){return fac[n]*ifac[m]*ifac[n-m];}ll n; // 2e5ll m; // 2e5ll k; // 2e5// 本质就是 尽量小乘小, 大乘大, 不要大量 大*小vector&lt;mint&gt; solve(ll l,ll r) {  if(l == r) return polys[l];  auto res = atcoder::convolution(solve(l,(l+r)/2),solve((l+r)/2+1,r));  if((int)res.size() &gt; m-k+1) res.resize(m-k+1); // 删除不影响结果的  return res;}int main() {  rep(i,1,2*N+1) fac[i] = fac[i-1]*i;  ifac[2*N] = fac[2*N].inv();  per(i,0,2*N) ifac[i] = ifac[i+1]*(i+1);  n = read(); // 2e5  m = read(); // 2e5  k = read(); // 2e5  rep(i,0,k) a[i] = read();  if(k==0) { // f_3(n,m) * m!    printf(&quot;%d\n&quot;,(C(n+m-1,2*m-1) * fac[m]).val()); // 无序变有序 * m!    return 0;  }  rep(i,0,k-1) { // f_1 中间间隔    ll len = a[i+1]-a[i]+1; // 区间长度, 两端已经放了    rep(seg,0,len-1) polys[i].pb(C(len+seg-1,2*seg+1)); // seg = 中间自由的元素个数  }  rep(i,0,2) { // f_2 首尾    auto len = (i==0) ? a[0] : (n-a[k-1]+1); // 区间长度, 一侧已经放了    rep(seg,0,len) polys[k-1+i].pb(C(len+seg-1,2*seg)); // seg = 中间自由的元素个数  }  printf(&quot;%d\n&quot;,(solve(0,k)[m-k] * fac[m-k]).val()); // 无序变有序 * (m-k)!  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>F</p><p>这个字符串的偏序证明 事后看起来还挺简单的,虽然我有这个方向想法, 但没去简单尝试一下</p><p>然后就是倒着dp的局部性保证了, 感觉对于这种通过长度悬空,的非真实的小于 似乎都可以类似思考一下</p><p>G</p><p>题意转化 成 只有增的世界, 题意转化还是不会</p><p>最小 转化成 最小割</p><p>不过感觉看了第二次这种 最小变成 最小割的建图, 悟出了一点东西</p><p>大概,想表达的意思就是,每个点和S同块还是T同块, 而和S同块/T同块 分别表示选和不选的一个对立状态, 而建立的容量边, 便是这些选择状态会长生的代价贡献</p><p>H</p><p>学了maspy的生成方程,感觉又多会了一点</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://atcoder.jp/contests/abc225/editorial" target="_blank" rel="noopener">官方题解</a></p><p><a href="https://maspypy.com/category/%e5%bd%a2%e5%bc%8f%e7%9a%84%e3%81%b9%e3%81%8d%e7%b4%9a%e6%95%b0%e8%a7%a3%e8%aa%ac" target="_blank" rel="noopener">maspy</a></p><p><a href="http://yexiaorain.github.io/Blog/2022-08-12-generate_function/">我基于maspy做的翻译和笔记</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;F(字符串,偏序,DP,倒着DP,局部性)G(题意转化,最小割,最大流)H(NTT,FFT,生成方程,分治,归并)&lt;/p&gt;
&lt;h1 id=&quot;F-String-Cards&quot;&gt;&lt;a href=&quot;#F-String-Cards&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="Atcoder" scheme="http://yexiaorain.github.io/Blog/categories/Atcoder/"/>
    
    
      <category term="DP" scheme="http://yexiaorain.github.io/Blog/tags/DP/"/>
    
      <category term="网络流" scheme="http://yexiaorain.github.io/Blog/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
      <category term="分治" scheme="http://yexiaorain.github.io/Blog/tags/%E5%88%86%E6%B2%BB/"/>
    
      <category term="NTT" scheme="http://yexiaorain.github.io/Blog/tags/NTT/"/>
    
      <category term="字符串" scheme="http://yexiaorain.github.io/Blog/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="FFT" scheme="http://yexiaorain.github.io/Blog/tags/FFT/"/>
    
      <category term="生成方程" scheme="http://yexiaorain.github.io/Blog/tags/%E7%94%9F%E6%88%90%E6%96%B9%E7%A8%8B/"/>
    
      <category term="归并" scheme="http://yexiaorain.github.io/Blog/tags/%E5%BD%92%E5%B9%B6/"/>
    
  </entry>
  
  <entry>
    <title>Atcoder abc224</title>
    <link href="http://yexiaorain.github.io/Blog/2022-08-10-ac_abc224/"/>
    <id>http://yexiaorain.github.io/Blog/2022-08-10-ac_abc224/</id>
    <published>2022-08-09T20:25:14.000Z</published>
    <updated>2022-08-12T03:23:03.827Z</updated>
    
    <content type="html"><![CDATA[<p>G(概率论,二分)H(线性规划,对偶问题,费用流,MCMF)</p><h1 id="G-Roll-or-Increment"><a href="#G-Roll-or-Increment" class="headerlink" title="G - Roll or Increment"></a>G - Roll or Increment</h1><p><a href="https://atcoder.jp/contests/abc224/tasks/abc224_g" target="_blank" rel="noopener">https://atcoder.jp/contests/abc224/tasks/abc224_g</a></p><p>1~N 骰子</p><p>初始S, 得分f(X) = X</p><p>A元, 让得分+1</p><p>B元, 重新转</p><p>求最小期望代价, 让得分为T</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>N 1e9</p><p>A,B [1,1e9]</p><p>2s</p><p>1024 mb</p><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>日常不会概率论</p><p>猜一个</p><p>S &lt; T</p><p>直接通过A, (T-S)A</p><p>转一次的期望 E</p><p>(N-T)/N * (B+E), 大于T 部分的贡献</p><p>1/N ( min(0,B+E) + min(A,B+E) + min(2A,B+E) + … + min((T-1)A,B+E)),  $\le T$ 部分的贡献</p><p>$E = \frac{N-T}{N} \cdot (B+E) + \frac{1}{N} ( min(0,B+E) + min(A,B+E) + min(2A,B+E) + \cdots + min((T-1)A,B+E))$</p><p>若能求出E, 就做出来了</p><p>转化一下</p><p>$NB + \sum_{i=0}^{T-1} \text{min}(iA-(B+E),0) = 0$</p><p>只有E是变化的, 随着E 增大, 表示式变小, 单调, 可二分</p><hr><p>好像还真就过了</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc224/submissions/33889681" target="_blank" rel="noopener">https://atcoder.jp/contests/abc224/submissions/33889681</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef long double LD;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readint main(){  ll N = read();  ll S = read();  ll T = read();  ll A = read();  ll B = read();  auto calc = [=](LD E){    ll l = 0;    ll r = T-1;    if(r*A-B-E&lt;=0){      l = r;    }else{      while(l+1&lt;r){        ll m = (l+r)/2;        if(m*A-B-E&lt;=0) l = m;        else r = m;      }    }    // nb + sum min(iA-B - E,0), i = 0~T-1;    return N * B+ A * l * (l+1) / 2 - (B+E) * (l+1) ;  };  LD LE = 0;  LD RE = A * T;  while(calc(RE) &gt; 0) RE *= 2;  rep(t,0,10000){ // E增, 和减    LD E = (LE+RE)/2;    (calc(E) &gt; 0 ? LE : RE) = E;  }  LD ans = B + LE;  if(S &lt;= T) ans = min(ans,(LD)((T-S) * A));  printf(&quot;%.15Lf&quot;,ans);  return 0;}</code></pre><h1 id="H-Security-Camera-2"><a href="#H-Security-Camera-2" class="headerlink" title="H - Security Camera 2"></a>H - Security Camera 2</h1><p><a href="https://atcoder.jp/contests/abc224/tasks/abc224_h" target="_blank" rel="noopener">https://atcoder.jp/contests/abc224/tasks/abc224_h</a></p><p>二分图, 左侧L个点,右侧R个点</p><p>在点i上每次安装摄像头, 有 Ai(左侧),Bj(右侧) 的代价, 一个点可安多次</p><p>目标 让 i上安装的个数 + j上安装的个数 &gt;= Cij</p><p>一左一右侧</p><p>问最小安装代价</p><h2 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h2><p>L,R 100</p><p>Ai,Bi [1,10]</p><p>Cij, [0,100]</p><p>2s</p><p>1024mb</p><h2 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h2><p>这个数还不少, 而代价的范围还挺小的?</p><p>然后有点费用流又有点2sat的感觉</p><p>emmmm</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这个题主要在练习线性规划的技术和,对偶问题的创造能力</p><hr><p>首先是构造线性规划</p><p>li 表示左侧每个安装的个数</p><p>ri 表示左侧每个安装的个数</p><p>要求 $min(\sum_{i} A_il_i + \sum_{i}B_ir_i)$</p><p>限制</p><p>$li+rj \ge C_{i,j}$</p><p>$li \ge 0, ri \ge 0$ 且都是整数(需要存在整数的方案最优)</p><hr><p>然后 构造对偶问题</p><p>对于限制</p><p>$l_i+r_j \ge C_{i,j}$</p><p>同时乘上$k_{i,j} \ge 0$</p><p>$k_{i,j}(l_i+r_j) \ge k_{i,j} C_{i,j},$</p><p>对于$k_{i,j},p_i,q_i \ge 0$</p><p>$\sum_{i,j} k_{i,j} (l_i+r_j) + \sum_i p_i l_i + \sum_i q_i r_i \ge \sum_{i,j} k_{i,j} C_{i,j}$</p><p>这样不等式左边如果和目标一致,那么右边的值就是它的下界</p><p>也就是 对于任意k的选取</p><p>找p和q, 让 $\sum_{i,j} k_{i,j} (l_i+r_j) + \sum_i p_i l_i + \sum_i q_i r_i = \sum_i (\sum_j k_{i,j} + p_i) l_i + \sum_j (\sum_i k_{i,j} + q_j) r_j = \sum_i A_il_i + \sum_j B_jr_j.$</p><p>那么 原目标 大于右侧的$\sum$</p><p>也就是任何满足$0\le \sum_j k_{i,j} \le A_i, 0 \le \sum_i k_{i,j} \le B_j $的 $\forall k$, 会产生不大于原目标的$\sum_{i,j} k_{i,j} C_{i,j}$</p><p>那么 原目标 $\ge max(\sum_{i,j} k_{i,j} C_{i,j})$</p><p>emmmm 有个问题是 只是证明了, min(原) &gt;= max(sum kc) </p><p>这个<strong>等号</strong>好像没证明????</p><hr><p>怎么算对偶问题呢</p><p>就是最小费用流了</p><p>左点A, 右点B</p><p>源到Ai, 容量Ai, 单位代价0</p><p>Bi到汇, 容量Bi, 单位代价0</p><p>Ai到Bj, 容量无限, 单位代价$-C_{i,j}$</p><p>求最大流的最小代价</p><hr><p>注意到atcoder自带的mcmf(min cost max flow)是无法处理负边权的, 让所有每单位流量增加max(c) 即可</p><p>手写的话, 也可以就是做最大流时找新的流的过程用spfa来更新最近距离</p><p>之前做abc 214 也写到过mcmf,见下方</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc224/submissions/33906446" target="_blank" rel="noopener">https://atcoder.jp/contests/abc224/submissions/33906446</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;#include &lt;atcoder/mincostflow&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readint c[110][110];int main(){  int L = read();  int R = read();  atcoder::mcf_graph&lt;int, int&gt; network(L+R+2); // 点个数  int S = L+R; // 源  int T = S+1; // 汇  rep(i,0,L) network.add_edge(S,i,read(),0); // ai  rep(j,0,R) network.add_edge(L+j,T,read(),0); // bi  int maxc = 0;  rep(i,0,L) rep(j,0,R) maxc = max(maxc, c[i][j] = read());  rep(i,0,L) rep(j,0,R) network.add_edge(i,L+j,10,maxc-c[i][j]); // 保证全部非负  auto [maxflow, mincost] = network.flow(S,T);  printf(&quot;%d\n&quot;, maxflow * maxc - mincost); // - (mincost - maxflow * maxc)  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>G</p><p>概率论, 竟然对了</p><p>H</p><p>线性规划,对偶问题</p><p>对偶问题学了几次感觉也没有悟到</p><p>但是从技术上讲,应该能看出这个类型的, 这里没看出是线性规划问题也是有问题</p><hr><p>有一说一,这atcoder 题解真的细, 我之前做cf,和一些其它的线性规划对偶, 都是直接甩公式, 然后找了各种博客,都在那里比喻来比喻去的, 这里竟然数学公式教会了我证明的一部分, 而且其实过程也没几步</p><p>Atcoder yyds</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://atcoder.jp/contests/abc224/editorial" target="_blank" rel="noopener">官方题解</a></p><p><a href="http://yexiaorain.github.io/Blog/2022-07-30-ac_abc214/">abc 214 mcmf</a></p><p><a href="http://yexiaorain.github.io/Blog/2022-06-26-CF1696/">cf 1969 线性规划对偶</a></p><p><a href="https://www.slideshare.net/wata_orz/ss-91375739" target="_blank" rel="noopener">wata 对偶讲义</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;G(概率论,二分)H(线性规划,对偶问题,费用流,MCMF)&lt;/p&gt;
&lt;h1 id=&quot;G-Roll-or-Increment&quot;&gt;&lt;a href=&quot;#G-Roll-or-Increment&quot; class=&quot;headerlink&quot; title=&quot;G - Roll or Incr
      
    
    </summary>
    
      <category term="Atcoder" scheme="http://yexiaorain.github.io/Blog/categories/Atcoder/"/>
    
    
      <category term="二分" scheme="http://yexiaorain.github.io/Blog/tags/%E4%BA%8C%E5%88%86/"/>
    
      <category term="线性规划" scheme="http://yexiaorain.github.io/Blog/tags/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/"/>
    
      <category term="费用流" scheme="http://yexiaorain.github.io/Blog/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/"/>
    
      <category term="概率论" scheme="http://yexiaorain.github.io/Blog/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"/>
    
      <category term="对偶问题" scheme="http://yexiaorain.github.io/Blog/tags/%E5%AF%B9%E5%81%B6%E9%97%AE%E9%A2%98/"/>
    
      <category term="MCMF" scheme="http://yexiaorain.github.io/Blog/tags/MCMF/"/>
    
  </entry>
  
  <entry>
    <title>Atcoder abc223</title>
    <link href="http://yexiaorain.github.io/Blog/2022-08-09-ac_abc223/"/>
    <id>http://yexiaorain.github.io/Blog/2022-08-09-ac_abc223/</id>
    <published>2022-08-08T20:25:14.000Z</published>
    <updated>2022-08-12T03:23:03.827Z</updated>
    
    <content type="html"><![CDATA[<p>G(树,dp,换根dp)H(线性基)</p><h1 id="G-Vertex-Deletion"><a href="#G-Vertex-Deletion" class="headerlink" title="G - Vertex Deletion"></a>G - Vertex Deletion</h1><p><a href="https://atcoder.jp/contests/abc223/tasks/abc223_g" target="_blank" rel="noopener">https://atcoder.jp/contests/abc223/tasks/abc223_g</a></p><p>N 点, 标号1到N, 的树</p><p>找有几个点满足, 删了它和它直接相连的边以后, 最大匹配个数 = 原图最大匹配个数</p><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>N 2e5</p><p>2 s</p><p>1024 mb</p><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>显然如果删了u以后最大匹配个数不变, 那么在原图中u所直接连的点,在删除以后的图中都被选了</p><p>否则的话, 其中一个和u可以让匹配数+1</p><p>并且这些和u直接相连的点在最大匹配中是<code>必选</code>, 也就是不存在方案让它不被选</p><p>又因为结构是树</p><p>假设断开u-v的连接</p><p>以v为根的连通块为根做树</p><p>v必选(和子节点匹配)的条件是,任何一个子树的根未被选</p><p>v不被选(不和子节点匹配,可能和父节点匹配)的条件是,所有子树的根被选</p><hr><p>感觉像是换根dp</p><p>也就是求u作为根 f(u) 为不和子节点匹配的 u的个数</p><p>f(u) = !(f(v1) &amp; f(v2) &amp; f(v3))</p><p>为了减少枚举,可以变成 子点0的个数统计</p><p>f(u) = count(f(v) == 0) &gt; 0</p><hr><p>u 交换 v</p><p>u 的子节点里没有了v, 更新u</p><p>v 的子节点里没有了u, 更新v</p><p>顺序就dfs顺序就完了</p><p>好像就AC了</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc223/submissions/33887853" target="_blank" rel="noopener">https://atcoder.jp/contests/abc223/submissions/33887853</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readvector&lt;int&gt;p2[200010];int c[200010]; // count 0int x(int u){ return c[u] &gt; 0;} // 根据子节点0的个数 推断是否和子节点匹配void dfs(int u,int f){  for(auto v:p2[u]) if(v != f) {    dfs(v,u);    c[u] += !x(v);  }}void swaproot(int u,int v){  c[u] -= !x(v);  c[v] += !x(u);}int dfs2(int u,int f){  int r = !x(u);  for(auto v:p2[u]) if(v != f) {    swaproot(u,v);    r += dfs2(v,u);    swaproot(v,u);  }  return r;}int main(){  int n = read();  rep(i,1,n){    int u = read();    int v = read();    p2[u].pb(v);    p2[v].pb(u);  }  dfs(1,0);  printf(&quot;%d\n&quot;, dfs2(1,0));  return 0;}</code></pre><h1 id="H-Xor-Query"><a href="#H-Xor-Query" class="headerlink" title="H - Xor Query"></a>H - Xor Query</h1><p><a href="https://atcoder.jp/contests/abc223/tasks/abc223_h" target="_blank" rel="noopener">https://atcoder.jp/contests/abc223/tasks/abc223_h</a></p><p>N个整数数组A[1…N]</p><p>做Q次询问, 每次询问[L..R]区间,是能选出一些数 使得它们的xor = Xi</p><p>不用给方案,只用输出Yes/No</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>N 4e5</p><p>Q 2e5</p><p>Ai [1,2^60]</p><p>Xi [1,2^60]</p><p>3s</p><p>1024 mb</p><h2 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h2><p>无</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>线性代数的一点基础知识</p><p>每个数字可以表示成60个维度的向量</p><p>xor = 每个维度和 %2</p><p>选一些数 xor = x</p><p>等同于 选一些数,做向量各维度和 % 2</p><p>对x的集合$X$, span(X)表示 集合中能构成所有xor的结果的集合</p><hr><p>本身是在一个 2^{60} 的空间里</p><p>如果区间[L..R] 中能选出一些让xor的值 = X</p><p>那么 span({a[k..R]}) 能产生向量X, 其中k &gt;= L</p><p>对于给定R</p><p>如果 span{a[k..R]} 不等于 span{a[k+1..R]}</p><p>那么说明 a[k] 是 a[k..R]的一个线性基</p><p>那么对L 来说, a{L..R} 的能生成的 只和中间这些满足 的k有关</p><hr><p>那么枚举右端点, 维护的每次如果不增加基,更新掉最前面一个和它冲突的</p><p>这样每个右端点都记录了最近的一些到它的线性基的下标了</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc223/submissions/33888843" target="_blank" rel="noopener">https://atcoder.jp/contests/abc223/submissions/33888843</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // read#define N 400000int n, m;pair&lt;ll,int&gt; a[N+10][100]; // [区间右端点 i][pwr] = pwr对应修改bit的 距离最近的 {线性基,下标}bool query(){  int l = read();  int r = read();  ll x = read();  rep(i,0,61) if ((x&gt;&gt;i)&amp;1) { // x 的 i 位bit 是1    auto [base,idx] = a[r][i];    if (!base || idx &lt; l) return false; // 找不到, 或者最近的修改 超出范围    x ^= base;  }  return true;}int main() {  int n = read();  int q = read();  rep(pos,1,n+1) {    int i = pos;    ll x = read();    rep(pwr,0,61) a[pos][pwr] = a[pos-1][pwr];// 拷贝一份    rep(pwr,0,61) if ( (x&gt;&gt;pwr) &amp; 1) { // x 位是1 , 这里和query的 位顺序一致即可, 可以从小到大,也可以从大到小      auto [base,idx] = a[pos][pwr];      if (!base) { // 新增基        a[pos][pwr] = {x,i}; // 基,下标        break;      } else if (i &gt; idx) { // 换离pos更近的基        swap(a[pos][pwr].first, x);        swap(a[pos][pwr].second, i);      }      x ^= a[pos][pwr].first; // 把pwr位的1删掉, 变换基    }  }  while (q--) printf(&quot;%s\n&quot;,query()?&quot;Yes&quot;:&quot;No&quot;);  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>G</p><p>没啥难的</p><p>H</p><p>线性基的知识点</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://atcoder.jp/contests/abc223/editorial" target="_blank" rel="noopener">官方题解</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;G(树,dp,换根dp)H(线性基)&lt;/p&gt;
&lt;h1 id=&quot;G-Vertex-Deletion&quot;&gt;&lt;a href=&quot;#G-Vertex-Deletion&quot; class=&quot;headerlink&quot; title=&quot;G - Vertex Deletion&quot;&gt;&lt;/a&gt;G - Ver
      
    
    </summary>
    
      <category term="Atcoder" scheme="http://yexiaorain.github.io/Blog/categories/Atcoder/"/>
    
    
      <category term="线性基" scheme="http://yexiaorain.github.io/Blog/tags/%E7%BA%BF%E6%80%A7%E5%9F%BA/"/>
    
  </entry>
  
  <entry>
    <title>Atcoder abc222</title>
    <link href="http://yexiaorain.github.io/Blog/2022-08-08-ac_abc222/"/>
    <id>http://yexiaorain.github.io/Blog/2022-08-08-ac_abc222/</id>
    <published>2022-08-07T20:25:14.000Z</published>
    <updated>2022-08-12T03:23:03.827Z</updated>
    
    <content type="html"><![CDATA[<p>G(数学, 欧拉定理,phi,miller-robin,pollard-rho)H(题意转化,DP,FFT,生成函数,拉格朗日反演,P-recursive )</p><h1 id="G-222"><a href="#G-222" class="headerlink" title="G - 222"></a>G - 222</h1><p><a href="https://atcoder.jp/contests/abc222/tasks/abc222_g" target="_blank" rel="noopener">https://atcoder.jp/contests/abc222/tasks/abc222_g</a></p><p>在数列2,22,222,2222,22222,….中</p><p>N个X, 首个是 Xi的倍数的下标是?, 或者不存在</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>N 200</p><p>Xi [1,1e8]</p><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>一眼看上去很数学, 很像Project Euler的题</p><p>$2222222 = 2 * 1111111 = 2 * \frac{(10^7 - 1)}{9}$</p><p>其实就是问对于x</p><p>是否 2 * (10^7 - 1) = 9 k x</p><p>首先x的2的幂次为0/1</p><hr><p>好像有点绕</p><p>$kx = 1111111 = 10^0+10^1+10^2+\cdots$</p><p>右边虽然项数为合数时可以拆分, 例如$6 = 3 * 2$,  $111111 = 111 \cdot 1001 = 11 \cdot 10101$</p><p>但不知道是否能拆出所有</p><hr><p>另一个就是对于比较小的<code>11111</code>的部分,可以<code>pollard-rho</code>分解</p><hr><p>考虑长除法?</p><p>每次 除法取mod 乘10 加1</p><p>但1e8 不知道效率怎么样</p><hr><p><a href="http://yexiaorain.github.io/Blog/2020-12-03-pe129/">PE 129</a> 做过类似的, 但是问题是首个 让是它倍数的最小$111\cdots 111$长度超过百万的是哪个因子</p><p>而有一些可用的结论</p><p>除了上面$2,5$因子外$kx = 111\cdots 111$始终有解, 且$111\cdots 111$ 的长度不超过$n$ (因为模数随着长度变化成环)</p><p>因此 如果暴力的话, 期望值是在 $O(NAi)$ 的</p><hr><p>想了下打表 超过1e6的记录下来, 未超过的现场算, 但很多 超过1e6的</p><pre><code class="cpp">int two(int v){  int c = 0;  ll m = 0;  do{    m*=10;    m+=2;    c++;    m%=v;  }while(m!=0);  return c;}void calc(){  rep(i,1000000, 100000000+1){    if(i % 1000000 == 0) printf(&quot;progress %lld\n&quot;,i/1000000);    if(i % 4 == 0 || i % 5 == 0)continue;    int res = two(i);    if(res &gt; 1000000) printf(&quot;ans[%lld] = %d\n&quot;,i,res);  }}</code></pre><hr><p>另一个就是根据PE129的证明过程, 反正有$\phi(n)$ 或者$\phi(9n)$ 是一个解</p><p>那么可以找$\phi(n) , \phi(9n)$的因子尝试, 但这样是否能保证是最小的呢????? 根据倍数, 显然最小的是这个解的因子</p><p>$\phi(n) = n \cdot (1-1/p1) \cdot (1-1/p2) \cdots$</p><p>似乎可做?</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>题解说不需要这么多, 就欧拉定理+暴力找phi就够了</p><p>看来我用高级算法乱搞了太多</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc222/submissions/33867609" target="_blank" rel="noopener">https://atcoder.jp/contests/abc222/submissions/33867609</a></p><p>16ms 还不是最快的, 有人10ms</p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef __int128 lll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readll quick_p(ll b, ll p,ll mod){  ll r = 1;  while(p){    if(p%2)(r*=b)%=mod;    (b*=b)%=mod;    assert(r&gt;0);    assert(b&gt;0);    p/=2;  }  return r%mod;}bool is_prime_32(ll v){  if(v == 2)return true;  if(v &lt; 2)return false;  if(v%2 == 0)return false;  ll test_g[] = {2, 325, 9375, 28178, 450775, 9780504, 1795265022};  ll startp = v-1;  while(startp%2 == 0)startp&gt;&gt;=1;  rep(i,0,7){    ll p = startp;    ll base = test_g[i];    // don&#39;t break may cause 4033 bug    if(base % v == 0)continue;    bool find = false;    ll r = quick_p(base,p,v);    while(p != v-1){      if(r == v-1){        find = true;        break;      }      // -1 开始的序列, 或全1序列      if(r == 1){        if(p == startp){          find = true;          break;        }        return false;      }      p*=2;      (r*=r)%=v;    }    if(!find){      return false;    }  }  return true;}ll my_sqrt(ll v){  assert(v &gt; 1);  ll l = 1;  ll r = v; // care overflow  ll ret = 1;  while(l &lt; r){    ll m = (l+r)/2;    ll m2 = m*m;    if(m2 == v) return m;    if(m2 &lt; v) {      ret = m;      l = m + 1;    } else {      r = m - 1;    }  }  return ret;}ll randint(ll low,ll hi){  return low + (rand() % static_cast&lt;int&gt;(hi - low + 1));}ll Pollard_Rho(ll N) { // 返回一个&gt; 1的因数  assert(N &gt; 1);  if (N == 4) return 2;  ll ret = my_sqrt(N); // 质数平方 效率低 提前判断  if(ret * ret == N) return ret;  while(true) {    ll c = randint(1, N - 1); // 生成随机的c    auto f = [=](ll x) { return ((lll)x * x + c) % N; }; // ll 表示__int128，防溢出    ll t = 0, r = 0; // 初始两个相同    do{      t = f(t); // 1倍速度      r = f(f(r)); // 2倍速度      ll d = gcd(abs(t - r), N);      if (d &gt; 1 &amp;&amp; d &lt; N) return d;    }while (t != r);  }}// 分解x为质因数, sorted, {prime,power}vector&lt;pair&lt;ll,int&gt; &gt; fenjie(ll x) {  vector&lt;int&gt; res = {};  deque &lt;ll&gt; arr = {x};  while(arr.size()){    ll v = arr.front();    arr.pop_front();    if(v == 1) continue;    if(is_prime_32(v)) {      res.pb(v);      continue;    }    ll divisor = Pollard_Rho(v);    arr.push_back(divisor);    arr.push_back(v/divisor);  }  sort(res.begin(),res.end());  vector&lt;pair&lt;ll,int&gt; &gt; ret;  rep(i,0,res.size()){    if(i == 0|| res[i] != res[i-1]) ret.push_back({res[i], 1});    else ret.back().second++;  }  return ret;}ll phi(ll n){  auto primes = fenjie(n);  // printf(&quot;%lld =&quot;,n);  // for(auto [v,pwr]:primes) printf(&quot;[%lld %d]&quot;,v,pwr);  // printf(&quot;\n&quot;);  ll ret = n;  for(auto [v,pwr]:primes) ret = (ret/v)*(v-1);  return ret;}// -------------------------- lib -------------------------- int n ;void dfs(int idx, vector&lt;pair&lt;ll,int&gt;&gt; primes, ll mul, ll &amp; ans){  if(idx == (int)primes.size()){    // test pwr 10^p = k 9v + 1,  10^p % 9v == 1    if(quick_p(10,mul,9*n) == 1) ans = min(ans,mul);    return ;  }  rep(pwr,0,primes[idx].second+1){    if(mul &gt; ans) return;    dfs(idx+1,primes,mul,ans);    mul *= primes[idx].first;  }}void w(){  n = read();  if(n % 4 == 0 || n % 5 == 0){    printf(&quot;-1\n&quot;);    return ;  }  if(n % 2 == 0) n /= 2;  ll phin = n % 3 == 0 ? phi(9*n) : phi(n);  if(phin == 1){    printf(&quot;1\n&quot;);    return ;  }  auto primes = fenjie(phin);  ll ans = phin;  dfs(0, primes, 1, ans);  printf(&quot;%lld\n&quot;,ans);}int main(){  int t = read();  while(t--) w();  return 0;}</code></pre><h1 id="H-Beautiful-Binary-Tree"><a href="#H-Beautiful-Binary-Tree" class="headerlink" title="H - Beautiful Binary Tree"></a>H - Beautiful Binary Tree</h1><p><a href="https://atcoder.jp/contests/abc222/tasks/abc222_h" target="_blank" rel="noopener">https://atcoder.jp/contests/abc222/tasks/abc222_h</a></p><p>给定N, 问多少个满足条件的有根二叉树, 每个点上有数字 0 或 1, 叶子点上都是1</p><p>至多n-1次操作, 让根上值为N, 其它所有点的值为0</p><p>每次操作, 把一个点的值全部加到它的父节点或,父节点的父节点上</p><p>答案mod 998244353</p><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>N 1e7</p><p>3s</p><p>1024 mb</p><h2 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h2><p>首先 叶子上全是1, 且n-1次内全部移动完, 限制了最大的树的高度</p><p>而这里 二叉树 还可能有多个点只有一个子节点的</p><p>至于如何操作呢</p><p>那感觉上也是贪心从下向上,</p><p>而如果叶子向上看是 x-1-?的形式, 那么中间的一定会操作, 所以叠加上去, 0-(1+x)-?</p><p>而如果是 <code>x-0-?</code>, 那就直接跳过</p><p>这里要注意的是 可能有 长成这样的</p><pre><code> 0 01 0   1</code></pre><p>因此顺序应该是 从深度从大到小,而不是所有叶子做bfs</p><hr><p>再看如果给定图 做dfs的话,</p><p>dfs(i) 表示把低层的都收集到i的次数</p><p>那么 对于一个节点 u-v-k</p><p>v 原来是1, 那么次数 = dfs(v) + 1</p><p>如果v 原来是0, 那么 次数 = sum (dfs(k) + 1), k 是v的所有子节点</p><hr><p>换句话说, dfs过程中 一部分是在合并和, 还有一部分是在+1</p><p>所以本质上,能让所有的和 = N, 就要看所有+1的来源, 当然根上可以直接放1</p><p>又注意到上面写的 dfs转移方程式, 其实每次+1, 对应一个次移动</p><p>那么一共n-1次+1, 也就意味 根上一定是1</p><hr><p>然后感觉上, 可以考虑左右树拆分</p><p>左树贡献 i的话, 右侧贡献为 n-1 - i</p><p>两边独立, 似乎就可以fft/ntt 来搞了</p><hr><p>然后如何变成和主问题等价的子问题呢?</p><p>考虑其中一个子节点 让它对根贡献i, 记作$h(i)$</p><p>子节点为空, 则贡献i = 0,方案1</p><p>子节点为1, 则贡献为 i = 子树贡献(和原问题等价) + 1</p><p>子节点为0, 则考虑它的子节点, 因为它不能是叶子,它至少有一个子节点</p><p>那么1个的情况 i = 子树贡献() + 1, 方案数 x 2</p><p>那么2个的情况 i = 左子树贡献x + 1 + 右子树贡献y + 1, 方案数加和, </p><hr><p>有点问题是 这样下面贡献可能根是非1的, 因此<code>f(x)</code> 的意义改成产生的+1贡献, 根也是0的情况</p><hr><p>$f(x) = \sum_{i=0}^{x} h(i)\cdot h(x-i)$,</p><p>$h(0) = 1$ // 对应无节点</p><p>$h(x) = f(x-1) + 2 * f(x-1) + \sum_{i=0}^{x-2} f(i)\cdot f(x-2-i), x &gt; 0$</p><p>答案就是$f(n-1)$</p><p>这种自身相互依赖的用cdq二分 好像能做?吗?</p><hr><p><strong> 好像我的过程漏掉了总和, 只考虑操作步数……… 推了半天推了个锤子,白推了 </strong></p><h2 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a>官方题解</h2><p>满足条件的树的充要</p><ol><li>根和叶子都是1</li><li>所有1的和 = N</li><li>0不连续</li></ol><p>证明</p><p>首先所有1 要汇总到根, 所有不在根上的1, 至少操作1次, 而最多n-1次,因此 根有1,且所有其它1恰好被操作1次,而非1的地方不被操作</p><p>因此也不能有连续的0</p><p>问题变成统计上面的树的个数了</p><hr><p>定义,对于$i &gt; 0$</p><p>$a_i = i$个点是1,根也是1的满足要求的树的方案数</p><p>$b_i = i$个点是1,根是0的,满足剩余要求的树的方案</p><p>因为没有连续零,那么bi 要么有单个子树 $2 a_i$, 要么两个子树都不为空</p><p>所以 $b_i = 2a_i + \sum_{j=1}^{i-1} a_ja_{i-j}$</p><p>类似的,对于$a_i$</p><p>$a_1 = 1$</p><p>一个子节点时 $2(a_{i-1}+b_{i-1})$</p><p>所以 $a_i = 2(a_{i-1}+b_{i-1}) + \sum_{j=1}^{i-2} (a_j+b_j)(a_{i-1-j} + b_{i-1-j}), i &gt; 1$</p><hr><p><del>一点简化?(并不是) 是不是令$a_0 = 1,b_0 = 0$ 可以让上面变成完全的求和式子</del></p><hr><p>这里也说 分治类fft 可以做到 $N log^2 N$, 虽然没试过两个怎么做分治, 但会超时</p><h3 id="生成方程"><a href="#生成方程" class="headerlink" title="生成方程"></a>生成方程</h3><p>$a_0 = b_0 = 0$</p><p>分别把$a_i$和$b_i$作为系数做它们的生成方程$A(x),B(x)$</p><p>那么第一个表达式和$B=2A+A^2$等价</p><p>第二个和$A = x + 2x(A+B) + x(A+B)^2$</p><p>然后两个生成式带入一下</p><p>$A = x(1+A+B)^2 = x(1+3A+A^2)^2$</p><p>用 Newton’s algorithm 据说可以 $O(N log N)$, 也会超时</p><h3 id="Lagrange-inversion-theorem-拉格朗日反演"><a href="#Lagrange-inversion-theorem-拉格朗日反演" class="headerlink" title="Lagrange inversion theorem 拉格朗日反演?"></a>Lagrange inversion theorem 拉格朗日反演?</h3><p>解决的问题, 给定F(x)</p><p>找G(x) 使得 G(F(x)) = x</p><p><strong>这里有一点要用到,但是没有证明的是 $G(F(x)) = x$ 则 $F(G(x)) = x$</strong>, 只能说在$F(x)$的值域内$F(G(F(x)) = F(x)$即$F(G(x)) = x$可以证明, 但在值域外不知道如何证明…</p><p>如果 F,G满足, 且它们0次项系数均为0, 1次项系数均非0</p><p>那么有$\lbrack x^n \rbrack G(x) = \frac{1}{n} \lbrack x^{n-1} \rbrack \left(\frac{x}{F(x)}\right)^n.$</p><p>即是G的n次项 = $(\frac{x}{F(x)})^n$ 的$n-1$次项的$\frac{1}{n}$</p><p>证明</p><hr><p>辅助lemma: 对于任何0次系数为0,存在非0次系数不为0的$F(x)$, 有对于整数$k$</p><p>$\lbrack x^{-1} \rbrack F’(x) F(x)^k = \lbrack k = -1\rbrack$, 即是$k=-1$时$-1$次系数为$1$,否则$-1$次系数为$0$</p><p>证明lemma:</p><p>对于$k\neq -1$, 显然求导法则$F’(x) F(x)^k = \frac{\left ( F(x)^{k+1} \right)’}{k+1}$</p><p>对于$k = -1$, $F(x) = \sum_{i&gt;0} a_i x^i$</p><p>$\frac{F’(x)}{F(x)} = \frac{a_1+2a_2x+3a_3x^2+\cdots}{x(a_1+a_2x+a_3x^2+\cdots}= x^{-1} \frac{1 + 2\frac{a_2}{a_1}x + \cdots}{1 + \frac{a_2}{a_1}x + \cdots}$</p><p>也就是右侧这个分式除完以后是$1+k_1x+k_2x^2+\cdots$的样子, 因此 -1 次方的系数是 1, lemma 证毕.</p><hr><p>因此$G(F(x)) = x$, 的$G$ 满足条件</p><p>$G’(F)\cdot F’ = 1$ ( 同时求导</p><p>展开$\sum_i i(\lbrack x^i\rbrack G(x) ) F^{i-1} F’ = 1$, (基本的求导法则 $(ax^i)’ = iax^{i-1}$, 注意到前两项都是系数而非生成函数</p><p>$\sum_{i} i (\lbrack x^i \rbrack G (x)) F^{i-1-n} F’ = F^{-n}.$ ( 同乘上$F^{-n}$</p><p>$\lbrack x^{-1}\rbrack \left(\sum_{i} i (\lbrack x^i \rbrack G (x)) F^{i-1-n} F’\right) = \lbrack x^{-1}\rbrack \left(F^{-n}\right).$ (提取$-1$次项目的系数</p><p>因为左侧$i (\lbrack x^i \rbrack G (x)) $ 整个都是系数,以及上面的lemma, 左侧只有$i=n$时 生成系数的内容才为$1$,其它则是$0$</p><p>$n[x^n]G = [x^{-1}]F^{-n}$</p><p>变形一下,就有了最初要证明的$\lbrack x^n \rbrack G(x) = \frac{1}{n} \lbrack x^{n-1} \rbrack \left(\frac{x}{F(x)}\right)^n.$</p><hr><p>这玩意 百科上说建立了函数方程和幂级数之间的联系</p><h3 id="使用示例-卡特兰数Catalan-number"><a href="#使用示例-卡特兰数Catalan-number" class="headerlink" title="使用示例: 卡特兰数Catalan number"></a>使用示例: 卡特兰数Catalan number</h3><p>$c_0 = 1$</p><p>$c_{n+1} = \sum_{i=0}^n c_{i} \cdot c_{n-i}$</p><p>令$C$为以卡特兰数 1,1,2,5,14为系数的生成方程</p><p>令$F(x) = C(x) - 1$, 保证0次项系数为0, 1次系数非0</p><p>那么$F(x) = x(F(x)+1)^2$ , 根据卡特兰数本身推导的定义的到的</p><p>令$G(x) = \frac{x}{(x+1)^2}$</p><p>那么有$G(F(x)) = \frac{F(x)}{(F(x)+1)^2} = x$</p><p>那么$c_n$ 就有了</p><p>因此</p><p>$<br>\begin{aligned}<br>[x^n]F(x) &amp;= \frac{1}{n} \lbrack x^{n-1} \rbrack \left(\frac{x}{G(x)}\right)^n \\<br>&amp;= \frac{1}{n} \lbrack x^{n-1} \rbrack (x + 1)^{2n} \\<br>&amp;= \frac{1}{n} \binom{2n}{n-1} = \frac{1}{n+1} \binom{2n}{n},<br>\end{aligned}$</p><h3 id="回到原问题"><a href="#回到原问题" class="headerlink" title="回到原问题"></a>回到原问题</h3><p>$A(x) = x(1+3A(x)+A(x)^2)^2$</p><p>令$G(x) = \frac{x}{(1+3x+x^2)^2}$</p><p>感觉到一点点套路了, 就是如果本身A(x) 的等式里是 $A(x) = x W(A)$的形式,直接$G(x) = \frac{x}{W(x)}$ 就行了,因为这样就有 $G(A) = \frac{A}{W(A)} = \frac{xA}{xW(A)} = \frac{xA}{A} = x$</p><p>同时$A(G(x)) = x$, 可以验证$x = A(G) = G(1+3A(G)+A(G)^2)^2 = \frac{x}{(1+3x+x^2)^2}(1+3x+x^2)^2$</p><p>$\lbrack x^n \rbrack A(x) = \frac{1}{n}\lbrack x^{n-1}\rbrack \left(\frac{x}{G(x)}\right)^{2n}= \frac{1}{n}\lbrack x^{n-1}\rbrack (1+3x+x^2)^{2n}$</p><hr><p>现在只要找到$(1+3x+x^2)^{2N} $的$N-1$次的系数,再除以$N$就是要的答案了</p><p>$\left((1+3x+x^2)^{2N}\right)’ = 2N(1+3x+x^2)^{2N-1}(1+3x+x^2)’$</p><p>$(1+3x+x^2)\left((1+3x+x^2)^{2N}\right)’ = 2N(1+3x+x^2)^{2N}(1+3x+x^2)’$</p><p>把这个用生成方程表示$\sum u_k x^k = (1+3x+x^2)^{2N}$</p><p>$(1+3x+x^2)\left(\sum u_k x^k\right)’ = 2N(1+3x+x^2)’ (\sum u_k x^k)$</p><p>$(1+3x+x^2)(\sum ku_k x^{k-1}) = 2N(3+2x)(\sum u_k x^k)$</p><p>考虑两边$x^{k-1}$次项系数</p><p>$ku_k + 3(k-1)u_{k-1} + (k-2)u_{k-2} = 2N(3u_{k-1}+2u_{k-2})$</p><p>$u_k = \frac{(6N-3k+3)u_{k-1} + (4N - k + 2)u_{k-2}}{k}$</p><p>这样可以O(N) 递推, ??? 这样会触发很多乘法逆元的出现吗? 还是用分数做中间过程?</p><hr><p>不做递推的直接求</p><p>$\begin{aligned}<br>u_k &amp;= \lbrack x^k \rbrack (1+3x+x^2)^{2N} \\<br>&amp;= \lbrack x^k \rbrack ( (1+3x)+x^2)^{2N} \\<br>&amp;=\lbrack x^k \rbrack \sum_{0 \leq j \leq 2N} \binom{2N}{j}x^{2j} (1+3x)^{2N-j} \\<br>&amp;=\sum_{0 \leq j \leq 2N} \binom{2N}{j}\lbrack x^{k-2j} \rbrack (1+3x)^{2N-j} \\<br>&amp;=\sum_{0 \leq j \leq 2N} \binom{2N}{j} \binom{2N-j}{k-2j} 3^{k-2j},<br>\end{aligned}$</p><p>至此可以$O(N)$, 算出</p><hr><p>再次注意,要算的是$N-1$次项系数再除以$N$</p><h3 id="继续优化-P-recursive"><a href="#继续优化-P-recursive" class="headerlink" title="继续优化 P-recursive"></a>继续优化 P-recursive</h3><p>TODO, orz</p><p>据说能做到$O(\sqrt{N} log N)$</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>基于 最后那个非递推求的</p><p>maspy 的只有46ms</p><p><a href="https://atcoder.jp/contests/abc222/submissions/33870319" target="_blank" rel="noopener">https://atcoder.jp/contests/abc222/submissions/33870319</a></p><p>300+ms</p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 998244353#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readint n;int qpow(ll v,int pwr){  ll r = 1;  while(pwr){    if(pwr%2) (r*=v)%=MOD;    (v*=v)%=MOD;    pwr/=2;  }  return r;}int fac[20000010] = {1};int ifac[20000010];ll binom(ll n,ll m){  if(n &lt; 0 || m &lt; 0 || m &gt; n) return 0;  return fac[n]*(ll)ifac[m]%MOD*(ll)ifac[n-m]%MOD;}int main(){  int n = read();  rep(i,1,2*n+1) fac[i] = fac[i-1]*(ll)i % MOD;  ifac[2*n] = qpow(fac[2*n],MOD-2);  per(i,0,2*n) ifac[i] = ifac[i+1] * (ll)(i+1) % MOD;  ll ans = 0;  ll p3 = qpow(3,n-1);  ll inv3_sq = qpow(3*3, MOD-2);  // sum_{i=[0..2n]}binom(2n,i)binom(2n-i,n-1-2i) 3^{n-1-2i}  rep(i,0,2*n+1) {    if(n-1-2*i &lt; 0) break;    (ans += binom(2*n,i)*binom(2*n-i,n-1-2*i)%MOD*p3) %= MOD;    (p3 *= inv3_sq)%=MOD;  }  printf(&quot;%lld\n&quot;,ans*qpow(n,MOD-2) % MOD); // 1/n  return 0;}</code></pre><h3 id="使用了atcoder-modint"><a href="#使用了atcoder-modint" class="headerlink" title="使用了atcoder modint"></a>使用了atcoder modint</h3><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;#include &lt;atcoder/modint&gt;using mint = atcoder::modint998244353;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readint n;mint fac[20000010] = {1};mint ifac[20000010];mint binom(ll n,ll m){  if(n &lt; 0 || m &lt; 0 || m &gt; n) return 0;  return fac[n] * ifac[m] * ifac[n-m];}int main(){  int n = read();  rep(i,1,2*n+1) fac[i] = fac[i-1] * i ;  ifac[2*n] = fac[2*n].inv();  per(i,0,2*n) ifac[i] = ifac[i+1] * (i+1);  mint ans = 0;  mint p3 = mint(3).pow(n-1);  mint inv3_sq = mint(3*3).inv();  // sum_{i=[0..2n]}binom(2n,i)binom(2n-i,n-1-2i) 3^{n-1-2i}  rep(i,0,2*n+1) {    if(n-1-2*i &lt; 0) break;    ans += binom(2*n,i)*binom(2*n-i,n-1-2*i)*p3;    p3 *= inv3_sq;  }  printf(&quot;%d\n&quot;,(ans/n).val()); // 1/n  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>G</p><p>欧拉公式, $gcd(a,n) = 1$时$a^{\phi(n)} \equiv 1 \pmod n$</p><p>后面乱搞也行, 枚举算$\phi$也行</p><p>H</p><p>题意转化</p><p>DP</p><p>FFT</p><p>生成方程</p><p>拉格朗日反演</p><p>可以又学了一堆新知识点</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://atcoder.jp/contests/abc222/editorial" target="_blank" rel="noopener">官方题解</a></p><p><a href="https://en.wikipedia.org/wiki/Repunit" target="_blank" rel="noopener">wikipedia repunits</a></p><p><a href="http://yexiaorain.github.io/Blog/2020-12-03-pe129/">Project Euler 129 repunits</a></p><p><a href="http://yexiaorain.github.io/Blog/2021-06-12-project-euler216/">Project Euler 216 miller robin 质数判别</a></p><p><a href="http://yexiaorain.github.io/Blog/2022-06-03-pollard-rho/">pollard-rho质数拆分</a></p><p><a href="https://baike.baidu.com/item/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E5%8F%8D%E6%BC%94/20844121" target="_blank" rel="noopener">拉格朗日反演</a></p><p><a href="https://chaoli.club/index.php/6072" target="_blank" rel="noopener">超理论坛 拉格朗日反演</a></p><p><a href="https://www.luogu.com.cn/blog/tiw-air-oao/post-ke-pu-xiang-la-ge-lang-ri-fan-yan-di-ji-zhong-xing-shi" target="_blank" rel="noopener">洛谷 拉格朗日反演</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;G(数学, 欧拉定理,phi,miller-robin,pollard-rho)H(题意转化,DP,FFT,生成函数,拉格朗日反演,P-recursive )&lt;/p&gt;
&lt;h1 id=&quot;G-222&quot;&gt;&lt;a href=&quot;#G-222&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="Atcoder" scheme="http://yexiaorain.github.io/Blog/categories/Atcoder/"/>
    
    
      <category term="DP" scheme="http://yexiaorain.github.io/Blog/tags/DP/"/>
    
      <category term="数学" scheme="http://yexiaorain.github.io/Blog/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="欧拉定理" scheme="http://yexiaorain.github.io/Blog/tags/%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86/"/>
    
      <category term="phi" scheme="http://yexiaorain.github.io/Blog/tags/phi/"/>
    
      <category term="miller-robin" scheme="http://yexiaorain.github.io/Blog/tags/miller-robin/"/>
    
      <category term="pollard-rho" scheme="http://yexiaorain.github.io/Blog/tags/pollard-rho/"/>
    
      <category term="题意转化" scheme="http://yexiaorain.github.io/Blog/tags/%E9%A2%98%E6%84%8F%E8%BD%AC%E5%8C%96/"/>
    
      <category term="FFT" scheme="http://yexiaorain.github.io/Blog/tags/FFT/"/>
    
      <category term="生成函数" scheme="http://yexiaorain.github.io/Blog/tags/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"/>
    
      <category term="拉格朗日反演" scheme="http://yexiaorain.github.io/Blog/tags/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E5%8F%8D%E6%BC%94/"/>
    
      <category term="P-recursive" scheme="http://yexiaorain.github.io/Blog/tags/P-recursive/"/>
    
  </entry>
  
  <entry>
    <title>Atcoder abc221</title>
    <link href="http://yexiaorain.github.io/Blog/2022-08-07-ac_abc221/"/>
    <id>http://yexiaorain.github.io/Blog/2022-08-07-ac_abc221/</id>
    <published>2022-08-06T20:25:14.000Z</published>
    <updated>2022-08-12T03:23:03.827Z</updated>
    
    <content type="html"><![CDATA[<p>F(树的直径)G(坐标转化,笛卡尔系)H(差分转化,前缀和,滑窗和,动态规划)</p><h1 id="F-Diameter-set"><a href="#F-Diameter-set" class="headerlink" title="F - Diameter set"></a>F - Diameter set</h1><p><a href="https://atcoder.jp/contests/abc221/tasks/abc221_f" target="_blank" rel="noopener">https://atcoder.jp/contests/abc221/tasks/abc221_f</a></p><p>N 点树, 找染色法, 染&gt;=2个点为红色,让红色点两两之间距离为直径</p><p>方案数 mod 998244353</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>N 2e5</p><p>2s</p><p>1024mb</p><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>首先直径 是经典算法, 随机点u,找最远点v, 再以v找最远点 便是直径</p><p>如果选v</p><p>那么可以把v看作根, 相当于做树上dp</p><p>因为有深度和直径都知道, 那么对于到叶子距离2倍小于直径的分叉至多选一个,</p><p>而2倍大于直径的分叉(不可能都有直径,否则这样能得到更大的长度)</p><p>如果直径是偶数, 那么从v到1/2直径点u再到最远点, 这样的点u只有一个,并且这个u可以看成重心</p><p>因此可以从重心去找 直径/2 的距离做树上统计 即可</p><p>问题来到了奇数长度的直径, 如果直径是奇数, 选了v到最远点的方案 就是最远点的个数</p><hr><p>任意两个直径 必有交点, 否则 两个直径上 p1..p2 有一个简单路径 取 p1 — 最远, p2 — 最远, p1-p2, 大于等于 直径/2向上取整 + 1</p><p>这样的话</p><p>任取一条来看,</p><p>v …. x - y…..t</p><p>假设,x和y是中间距离的两个点</p><p>那么不可能有不经过y的v..x…t1, 否则 t..x..t1 更长</p><p>换句话说</p><p>一定所有直径有x-y</p><p>类似的证明</p><p>已经证明了有公共点,</p><p>那么假设是y右侧的最近的某个p</p><p>同样v ….p…更长的一半, 将会比直径长</p><p>x对称同理</p><hr><p>所以奇数情况,就是, x 去找距离的方案 乘上 y 去找距离的方案</p><hr><p>似乎就推出来了?</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc221/submissions/33847992" target="_blank" rel="noopener">https://atcoder.jp/contests/abc221/submissions/33847992</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 998244353#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readvector&lt;int&gt; p2[200010];// {distance, node}pair&lt;int,int&gt; dfs(int u,int fa,int d = 0){  pair&lt;int,int&gt; r = {d ,u};  for(auto v:p2[u]) if(v != fa) r = max(r, dfs(v,u,d +1));  return r;}int D = 0;bool dfsxy(int u,int fa,int findv,int &amp;x,int &amp;y,int d = 0){  bool ok = u == findv;  for(auto v:p2[u]) if(v!=fa) ok = ok || dfsxy(v,u,findv,x,y,d+1);  if(ok &amp;&amp; d == D/2) x = u;  if(ok &amp;&amp; d == D/2 + 1) y = u;  return ok;}int dfscnt(int u,int fa,int d){  int r = d==0;  for(auto v:p2[u])if(v!=fa) r += dfscnt(v,u,d-1);  return r;}int main(){  int n = read();  rep(i,1,n){    int u = read();    int v = read();    p2[u].pb(v);    p2[v].pb(u);  }  auto [_,u] = dfs(1,0);  auto [d,v] = dfs(u,0);  D = d;  int x,y; // x: d/2, y: d/2+1  dfsxy(u,0,v,x,y);  if(d % 2){ // 奇数长度    ll cx = dfscnt(x,y,D/2);    ll cy = dfscnt(y,x,D/2);    printf(&quot;%lld\n&quot;,cx*cy % MOD);  }else{ // 偶数长度    ll s = 1;    ll r = 1;    for(auto p:p2[x]){      ll c = dfscnt(p,x,D/2-1);      (r*=(c+1))%=MOD;      s += c;    }    printf(&quot;%lld\n&quot;,(r+MOD-s)%MOD);  }  return 0;}</code></pre><h1 id="G-Jumping-sequence"><a href="#G-Jumping-sequence" class="headerlink" title="G - Jumping sequence"></a>G - Jumping sequence</h1><p><a href="https://atcoder.jp/contests/abc221/tasks/abc221_g" target="_blank" rel="noopener">https://atcoder.jp/contests/abc221/tasks/abc221_g</a></p><p>能否从(0,0) 恰好N次,跳到(A,B)</p><p>第i次可以向, x正/x负/y正/y负(4选1),跳恰好Di</p><p>如果可以,给一个方案</p><h2 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h2><p>N 2000</p><p>A,B [-3.6e6,3.6e6]</p><p>Di 1800</p><p>5s</p><p>1024</p><h2 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h2><p>顺序其实没有关系,因为是向量加和</p><p>那一个角度转化就是</p><p>分成4组,</p><p>其中两组的差 = X</p><p>另外两组的差 = Y</p><hr><p>另一个就是</p><p>先分两组 组A-组B = X+Y</p><p>然后找到组A中部分 = Y的 移出来</p><p>但这个只是 充分条件不是必要条件</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>逆时针转45度坐标轴 长度再乘上 根号2</p><p>终点 原坐标系(a,b) -&gt; 新坐标系 (a-b,a+b)</p><p>操作 全变成了(+-di,+-di)的形式</p><p>什么好处呢, 两个轴单独考虑了</p><hr><p>对于一个轴, 要找</p><p>S = sum (1/-1) * di</p><p>的方案</p><p>可以同时加 所有di的和</p><p>S + sum di = sum (2/0) <em> di = 2 </em> (选一些di)</p><p>就是简单的01 背包,需要bitset搞一下 空间</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc221/submissions/33849395" target="_blank" rel="noopener">https://atcoder.jp/contests/abc221/submissions/33849395</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readbitset&lt;3600001&gt; dp[2001]; // bitset 压空间, dp[前i个][值] = 是否可达int d[2000];// 旋转矩阵: 逆时针 45度 * 根号2// (x y) ( 1  1) =&gt; (x-y, x+y)//       (-1  1)//                                     x y   y   x// L: (-1 0) =&gt; (-1 -1)  =&gt;  +1)/2 =&gt; (0,0)  0 + 0 =  0// D: (0 -1) =&gt; ( 1 -1)  =&gt;  +1)/2 =&gt; (1,0)  0 + 1 =  1// U: (0  1) =&gt; (-1  1)  =&gt;  +1)/2 =&gt; (0,1) 10 + 0 = 10// R: (1  0) =&gt; ( 1  1)  =&gt;  +1)/2 =&gt; (1,1) 10 + 1 = 11const char c[] = { &#39;L&#39;,&#39;D&#39;,&#39;U&#39;,&#39;R&#39;};char ans[2010];bool w(){  int n = read();  int x = read();  int y = read();  int m[2] = {x-y,x+y};  int s = 0;  rep(i,0, n) {    d[i] = read(); // [1,1800]    s += d[i];  }  rep(i,0,2) if(abs(m[i]) &gt; s) return false; // 过远  rep(i,0,2) if((m[i] + s) % 2 != 0) return false; // (m[i] + s )/2 = 选部分di  rep(i,0,2) m[i] = (m[i] + s) / 2;  dp[0][0] = true;  rep(i,0, 2000) dp[i + 1] = dp[i] | (dp[i] &lt;&lt; d[i]); // 哇  rep(j,0,2) if(!dp[n][m[j]]) return false; // 有值无法构成  per(i,0,n){ // 倒着找哪些用了哪些没用    int bit = 0;    rep(j,0,2) if (!dp[i][m[j]]) { // 表示可达, 直接贪心选取, 两个中必有一个可行,一个不可行另一个一定可行      m[j] -= d[i];      bit += (1 &lt;&lt; j);    }    ans[i] = c[bit];  }  return true;}int main() {  if(!w()) printf(&quot;No\n&quot;);  else {    printf(&quot;Yes\n&quot;);    printf(&quot;%s\n&quot;,ans);  }  return 0;}</code></pre><h1 id="H-Count-Multiset"><a href="#H-Count-Multiset" class="headerlink" title="H - Count Multiset"></a>H - Count Multiset</h1><p><a href="https://atcoder.jp/contests/abc221/tasks/abc221_h" target="_blank" rel="noopener">https://atcoder.jp/contests/abc221/tasks/abc221_h</a></p><p>输入正整数 N, M</p><p>找可重集合,k=1…N个正整数, 和=N, 同一个重复数量不超过M, 这样可重集合的个数</p><p>mod 998244353</p><p>对于k=1..N 分别输出答案</p><h2 id="范围-2"><a href="#范围-2" class="headerlink" title="范围"></a>范围</h2><p>M &lt;= N &lt;= 5000</p><p>2 s</p><p>1024 mb</p><h2 id="我的思路-2"><a href="#我的思路-2" class="headerlink" title="我的思路"></a>我的思路</h2><p>5000 很想平方</p><p>但是直接之想到3维dp</p><p><code>dp[v][x][c] =</code> 和 = v, 最大值不超过v, 一共用了c个数 的方案数</p><p>转移</p><p><code>dp[v][x][c] = sum dp[v-kx][x-1][c-k], k=0..m</code></p><p>这样$N^3$的状态, 转移还要枚举k(可以跳点双指针变成O1均摊), 虽然滚动可以吃掉一维解决空间,还是无法解决时间</p><p>但是从加和的角度可以看成二维卷积 一个稀疏的<code>[k][1] * 0..m</code></p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>显然 等于 非严格递增序列的方案数(其实上面dp就是按照这个来的</p><p>令B为其差分数组,其中B1=A1, Bi = Ai-A[i-1]</p><p>sum Ai = N</p><p>sum Bi * (k-1+i) = N</p><p>考虑翻转顺序</p><p>sum i Bi = N</p><p>然后限制是最多M个Ai, 也就是连续0的个数 &lt;= M-1 &lt; M</p><p>这里的好处就是把M限制变成了连续0的限制,不影响总和,而非0的内容是任意的数量,没有限制</p><p><code>f[i][j] =</code> B中前i个数和为j 且最后一个数不为0的方案数</p><p>$f_{i,j}=\sum\limits_{k=\max(0,i-m)}^{i-1}\sum\limits_{l = ik &lt; j} f_{k,j-l}$</p><p>初始状态<code>f[0][0] = 1, f[0][&gt;0] = 0</code></p><hr><p>滑窗和/前缀和优化一下就n^2了</p><p>注意到颠倒了i以后正好我们要的就是首个不为0,变成末尾不为零</p><p>因此<code>f[i][n]</code> 就是要求的k=i的答案</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc221/submissions/33848661" target="_blank" rel="noopener">https://atcoder.jp/contests/abc221/submissions/33848661</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 998244353#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readconst int N = 5000;ll f[N+10][N+10]; // f[i][j] = 前i个(第i个不为0), sum(i*Bi) = j 方案数ll sum[N+10][N+10]; // sum[i][j] = sum f[i-m+1..i][j], 对i维度的滑窗和(也可以前缀和)int main() {  int n = read();  int m = read();  f[0][0] = sum[0][0] = 1;  rep(i,1,n+1) rep(j,0,n+1) {    // f[i][j] = sum f[i-m ~ i-1][j - i * bi] ,  k = bi * i, O(log)    for(int k = i; k &lt;= j; k+=i) (f[i][j] += sum[i-1][j-k]) %= MOD;    sum[i][j] = (sum[i-1][j] + f[i][j] - (i-m&gt;=0?f[i-m][j]:0)) % MOD; // 长度m的滑窗  }  rep(i,1,n+1) printf(&quot;%lld\n&quot;, (f[i][n] + MOD) % MOD);  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>F</p><p>没啥难的</p><p>先知道基本的直径算法, 也是可以自己推的</p><p>G</p><p>分离相关性</p><p>坐标轴转化</p><p>据说有黑科技 能55ms Linear Time Algorithms for Knapsack Problems with Bounded Weights</p><p><a href="https://www.sciencedirect.com/science/article/abs/pii/S0196677499910349" target="_blank" rel="noopener">https://www.sciencedirect.com/science/article/abs/pii/S0196677499910349</a></p><p>H</p><p>差分转化!!!</p><p>这里的好处就是把M限制变成了连续0的限制,不影响总和,而非0的内容是任意的数量,没有个数限制</p><p>只有对于首个非零和连续0的个数的限制了</p><p>然后是bitset的熟练应用了, 甚至位运算做01背包转移</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://atcoder.jp/contests/abc221/editorial" target="_blank" rel="noopener">官方题解</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;F(树的直径)G(坐标转化,笛卡尔系)H(差分转化,前缀和,滑窗和,动态规划)&lt;/p&gt;
&lt;h1 id=&quot;F-Diameter-set&quot;&gt;&lt;a href=&quot;#F-Diameter-set&quot; class=&quot;headerlink&quot; title=&quot;F - Diameter set&quot;
      
    
    </summary>
    
      <category term="Atcoder" scheme="http://yexiaorain.github.io/Blog/categories/Atcoder/"/>
    
    
      <category term="动态规划" scheme="http://yexiaorain.github.io/Blog/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="树" scheme="http://yexiaorain.github.io/Blog/tags/%E6%A0%91/"/>
    
      <category term="前缀和" scheme="http://yexiaorain.github.io/Blog/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
      <category term="直径" scheme="http://yexiaorain.github.io/Blog/tags/%E7%9B%B4%E5%BE%84/"/>
    
      <category term="树的直径" scheme="http://yexiaorain.github.io/Blog/tags/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/"/>
    
      <category term="坐标转化" scheme="http://yexiaorain.github.io/Blog/tags/%E5%9D%90%E6%A0%87%E8%BD%AC%E5%8C%96/"/>
    
      <category term="笛卡尔系" scheme="http://yexiaorain.github.io/Blog/tags/%E7%AC%9B%E5%8D%A1%E5%B0%94%E7%B3%BB/"/>
    
      <category term="差分转化" scheme="http://yexiaorain.github.io/Blog/tags/%E5%B7%AE%E5%88%86%E8%BD%AC%E5%8C%96/"/>
    
      <category term="滑窗和" scheme="http://yexiaorain.github.io/Blog/tags/%E6%BB%91%E7%AA%97%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>Atcoder abc220</title>
    <link href="http://yexiaorain.github.io/Blog/2022-08-06-ac_abc220/"/>
    <id>http://yexiaorain.github.io/Blog/2022-08-06-ac_abc220/</id>
    <published>2022-08-05T20:25:14.000Z</published>
    <updated>2022-08-12T03:23:03.827Z</updated>
    
    <content type="html"><![CDATA[<p>G(计算几何,排序,自定义排序)H(FWHT,FWT,meet-in-middle,bitmask)</p><h1 id="G-Isosceles-Trapezium"><a href="#G-Isosceles-Trapezium" class="headerlink" title="G - Isosceles Trapezium"></a>G - Isosceles Trapezium</h1><p>二维平面, N个点,坐标Xi,Yi, 权重Ci</p><p>选4个点, 形成 等腰梯形, 问选的4个点最大权重和</p><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>N 1000</p><p>Xi,Yi [-1e9,1e9]</p><p>Ci [1,1e9]</p><p>无重点</p><p>3s</p><p>1024</p><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>有点计算几何</p><p>N的样子,像是N^2的做法</p><p>如果是暴力找三个点, 确定平行边,那么剩下一个点就自然确定了, 这样的话是 <code>N^3 log(N)</code></p><hr><p>换个想法, 按对称轴来找</p><p>如果是垂于对称轴的一点,则找对称轴最远的两个点</p><p>这样 N^2 的对称轴, 其中相等的里面 按照垂点相同的最大的,找不同的两组就行了??</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc220/submissions/33799130" target="_blank" rel="noopener">https://atcoder.jp/contests/abc220/submissions/33799130</a></p><pre><code class="cpp">    #include &lt;bits/stdc++.h&gt;    using namespace std;    typedef long long ll;    #define MOD 1000000007    #define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)    #define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)    #define pb push_back    ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // read    ll gcd(ll a,ll b){      a = abs(a);      b = abs(b);      while(b!= 0) tie(a,b) = make_pair(b,a%b);      return a;    }    const ll INF = 0x3f3f3f3f3f3f3f3f;    array&lt;ll,3&gt; xyv[1010];    map&lt;tuple&lt;ll,ll,ll&gt;, vector&lt;pair&lt;int,int&gt; &gt; &gt; cx;    void addp(int i,int j){      auto [x0,y0,v0] = xyv[i];      auto [x1,y1,v1] = xyv[j];      // 对称轴, 标准化      ll ky = 2*(y1-y0);      ll kx = -2*(x1-x0);      ll k  = (x1-x0)*(x1+x0) + (y1-y0)*(y1+y0);      ll g = gcd(k,gcd(ky,kx));      ky /= g;      kx /= g;      k  /= g;      if(ky &lt; 0){        ky = -ky;        kx = -kx;        k  = -k;      }else if(ky == 0 &amp;&amp; kx &lt; 0){        kx = -kx;        k  = -k;      }      cx[{ky,kx,k}].push_back({i,j});    }    int main(){      int n = read();      rep(i,0,n){        int x = read();        int y = read();        int v = read();        xyv[i] = {x,y,v};      }      rep(i,0,n) rep(j,i+1,n) addp(i,j);      ll ans = -1;      for(auto [_,vec]:cx){        auto center = [=](const pair&lt;int,int&gt;&amp;ij){            auto [i0,j0] = ij;            auto [x0,y0,v0] = xyv[i0];            auto [x1,y1,v1] = xyv[j0];            return make_pair(x0+x1,y0+y1);        };        sort(vec.begin(),vec.end(), [=](const auto &amp;ij0,const auto &amp;ij1){            return center(ij0) &lt; center(ij1);        });        ll lastmax = -INF;        ll cur = -INF;        rep(i,0,vec.size()){          if(i == 0 || center(vec[i]) != center(vec[i-1])){            lastmax = max(lastmax,cur);            cur = 0;          }          auto [i0,j0] = vec[i];          cur = max(cur, xyv[i0][2] + xyv[j0][2]);          if(lastmax != -INF){            ans = max(ans, lastmax + cur);          }        }      }      printf(&quot;%lld\n&quot;,ans);      return 0;    }    // y = -(x1-x0)/(y1-y0) (x - (x0+x1)/2) + (y0+y1)/2    // 2(y1-y0) y = -2(x1-x0) x + (x1-x0)(x1+x0) + (y0+y1)(y1-y0)</code></pre><h1 id="H-Security-Camera"><a href="#H-Security-Camera" class="headerlink" title="H - Security Camera"></a>H - Security Camera</h1><p>N 点, M 边</p><p>选定一些点, 让边(至少一个点上有被选定的)的数量是偶数个</p><p>求合法方案数</p><h2 id="限制-1"><a href="#限制-1" class="headerlink" title="限制"></a>限制</h2><p>N 40</p><p>无重边,自环</p><p>2s</p><p>1024mb</p><h2 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h2><p>感觉题面就是个朴素的图论</p><p>40 呢, 对应边就是780</p><p>估计是个边平方~ 3次方 左右的算法, 或者点的5次方?</p><hr><p>思路正向就是考虑局部可行方案加上插头状态</p><p>逆向就是 所有减去存在未选择的 做容斥</p><p>点数量40, 2^40 = 1099511627776</p><hr><p>如果, 是一个一个安装的, 那么考虑对于个数的影响</p><p>增量是 相邻未安装的和</p><p>而对于这个连接出的点,相邻未安装的奇偶性发生颠倒</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>2^20 = 1048576</p><p>折半</p><p>把拆成两个点集合S,T</p><p><code>L1[S,s] =</code> 点集S的子集s 被选了, 覆盖的边数的奇偶性</p><p><code>L2[S,T,s] =</code> 点集T中, 连向S\s的数量是奇数的点集? (因为偶数的话,首先不被s选,其次不论在T中是否被选不影响奇偶性</p><p><code>R[T,t] =</code> 点集T的子集t被选了,覆盖的两端属于T的边的奇偶性</p><p>因为对于每个选中状态, 可以枚举剩下所有点, 所以 可以$O(|S|2^{|S|})$ 暴力算完</p><p>那么对于答案有贡献的</p><p>$L_1[s] \oplus  ((\text{popcount} (L_2[s]  \&amp;  t) ) \&amp;1) \oplus R[t] = 0$</p><p>意义 s得到的奇数偶,t内部奇偶,和t向S\s的奇偶 = 最终奇偶</p><hr><p>中间这玩意怪怪的,虽然很长意义也就是<code>L2[s] &amp; t</code> 的1的个数的奇偶性</p><p>像个办法把右侧合并一下</p><p>$F[S,T,s] = \sum_{t \subset T} ((\text{popcount} (L_2[s]  \&amp;  t) ) \&amp; 1) \oplus R[t] $</p><p>注意到 求和部分,奇数贡献1, 偶数贡献0, 所以这里是对于给定s,在T的子集中, 让上述表达式贡献1的个数</p><p>那么贡献0的个数就是 $2^{|T|} - F[S,T,s]$</p><p>如果能求出来, 那么对于每个$s$, 有$L1[s]$ 的奇偶性, 直接加上对应贡献即可</p><hr><p>问题变成是如何求出<code>F[S,T,s]</code></p><p>这里记$t’ = L2[s]$, 这样一个s唯一对应一个<code>t&#39;</code>, 但<code>t&#39;</code>可能有多个<code>s</code> 映射过来</p><p>记作$G[T,t’] = \sum_{t \subset T} ((\text{popcount} (t’ \&amp;  t) ) \&amp;1) \oplus R[t] $</p><p>这样有个好处是,不再关心<code>S</code>和<code>s</code>, 只用管<code>T</code>中的即可</p><hr><p>注意到 $FWHT$的变换公式是</p><p>$fwht[a]_ i = \sum_{(\text{popcount}(i \&amp; j) \bmod 2 = 0}a_j - \sum_{(\text{popcount}(i\&amp; j) \bmod 2  = 1}a_j$</p><p>对于给定 i</p><p>一个具体的j</p><p>左侧为0时, 原式子贡献是 R[j], 而fwht贡献是 a[j]</p><p>左侧为1时, 原式子贡献是 R[j]^1, 而fwht贡献是 -a[j]</p><p>如果让a[j] = R[j], 那么</p><p>左侧为0时, 原式子贡献是 0 , 而fwht贡献是 0</p><p>左侧为0时, 原式子贡献是 1 , 而fwht贡献是 1</p><p>左侧为1时, 原式子贡献是 0^1, 而fwht贡献是 -0</p><p>左侧为1时, 原式子贡献是 1^1, 而fwht贡献是 -1</p><p>左侧为0和为1各占一半, 总贡献会少掉$2^{|T|-1}$</p><p>加上即可?</p><h2 id="另一个做法"><a href="#另一个做法" class="headerlink" title="另一个做法"></a>另一个做法</h2><p>所有边变成”有向”, 小点连出到大点</p><p><code>f[i][j][k] =</code> 前i个点, 未覆盖的边的两端都在前i的边数为j(奇1/偶0), 一些未来不选的会影响未覆盖边的奇偶性的点的方案数</p><p><code>i+1</code>选 <code>f[i][j][k]</code> 贡献 <code>f[i+1][j][k高(i+2)位]</code></p><p><code>i+1</code>不选 <code>f[i][j][k]</code> 贡献 <code>f[i+1][j^(i+1是否在k中)][(k高(i+2)位) ^ (i+1 连出的边) ]</code></p><hr><p>很神奇的是, 这样每个点对于每个上个状态最多分支出两个状态</p><p>那么前一半最多<code>2^20</code>个状态</p><p>而状态低<code>i</code>位都是<code>0</code>, 所以后面的一半也是最多<code>2^20</code>个状态</p><p>所以复杂度也是</p><p><code>n 2^{n/2}</code></p><p>从一定程度上也有meet-in-middle 的感觉,而没有了fwt的需要</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc220/submissions/33847519" target="_blank" rel="noopener">https://atcoder.jp/contests/abc220/submissions/33847519</a></p><p>1.7s 快超时了, 为什么有人6ms 啊</p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readll g[50]; // g[小点] = 大点的bit mask// f[前i个点][两端均在前i个中的未覆盖的边的奇偶][mask中的点每不选一个奇偶性变化1]=方案数unordered_map&lt;ll,ll&gt;f[50][2];int main() {  int n = read(); // 点  int m = read(); // 边  rep(i,0,m){    int x = read() - 1;    int y = read() - 1;    if(x &gt; y) swap(x,y);    g[x] |= 1ll&lt;&lt;y; // 全是小 -&gt; 大  }  f[0][0][0]=1; // 选 点0，所有点因为不选 未覆盖 的边都为0，为偶数。  f[0][0][g[0]]++; // 不选 点0，0指向的点因为不选 未覆盖 的边+1.  rep(i,0,n-1) rep(j,0,2) { // 枚举当前的未覆盖的边数的奇偶。    for(auto [mask,cnt]:f[i][j]) { // 枚举上一层的所有状态，进行推磨式转移。      ll bit = (mask &gt;&gt; (i+1)) &amp; 1;// 确定 不选点i+1 未覆盖的边的 奇偶变化。      //选 点i+1，所有点(i+1之后的点) 因为不选而未覆盖的边数的就不变。且j的状态不变。      f[i+1][j][mask^(bit&lt;&lt;(i+1))]+=cnt;      //不选 点i+1，j的状态 根据当前j 和 因为i不选要未覆盖的边数的就确定      //并且改变之后的点因为不选而未覆盖的边的奇偶      f[i+1][j^bit][mask^(bit&lt;&lt;(i+1))^g[i+1]] += cnt;    }  }  ll ans=0;  for(auto [_,cnt]:f[n-1][m&amp;1]) ans += cnt; // m&amp;1 未覆盖的奇偶和总边一样,则覆盖了的为偶数  printf(&quot;%lld&quot;,ans);  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>G</p><p>没啥难的</p><p>简单的计算几何,排序,自定义排序</p><p>H</p><p>一个是40的一半是20, 2^20 是可以范围内的</p><p>另一个是拆的时候,可以按点拆分,一半是有点就包含,另一半是需要两端都属于集合</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://atcoder.jp/contests/abc220/editorial" target="_blank" rel="noopener">官方题解</a></p><p><a href="https://www.cnblogs.com/gcfer/p/15344079.html" target="_blank" rel="noopener">csdn 逆天峰 H</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;G(计算几何,排序,自定义排序)H(FWHT,FWT,meet-in-middle,bitmask)&lt;/p&gt;
&lt;h1 id=&quot;G-Isosceles-Trapezium&quot;&gt;&lt;a href=&quot;#G-Isosceles-Trapezium&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
      <category term="Atcoder" scheme="http://yexiaorain.github.io/Blog/categories/Atcoder/"/>
    
    
      <category term="计算几何" scheme="http://yexiaorain.github.io/Blog/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
    
      <category term="排序" scheme="http://yexiaorain.github.io/Blog/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="bitmask" scheme="http://yexiaorain.github.io/Blog/tags/bitmask/"/>
    
      <category term="FWT" scheme="http://yexiaorain.github.io/Blog/tags/FWT/"/>
    
      <category term="FWHT" scheme="http://yexiaorain.github.io/Blog/tags/FWHT/"/>
    
      <category term="自定义排序" scheme="http://yexiaorain.github.io/Blog/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F/"/>
    
      <category term="meet-in-middle" scheme="http://yexiaorain.github.io/Blog/tags/meet-in-middle/"/>
    
  </entry>
  
  <entry>
    <title>Atcoder abc219</title>
    <link href="http://yexiaorain.github.io/Blog/2022-08-05-ac_abc219/"/>
    <id>http://yexiaorain.github.io/Blog/2022-08-05-ac_abc219/</id>
    <published>2022-08-04T20:25:14.000Z</published>
    <updated>2022-08-12T03:23:03.827Z</updated>
    
    <content type="html"><![CDATA[<p>F(排序,分组)G(根号分类,分类)H(区间dp,问题转化)</p><h1 id="F-Cleaning-Robot"><a href="#F-Cleaning-Robot" class="headerlink" title="F - Cleaning Robot"></a>F - Cleaning Robot</h1><p><a href="https://atcoder.jp/contests/abc219/tasks/abc219_f" target="_blank" rel="noopener">https://atcoder.jp/contests/abc219/tasks/abc219_f</a></p><p>给序列 从点(0,0) 出发,上下左右走n个点,</p><p>重复序列k次, 问经过次数&gt;=1的点有几个</p><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>n 2e5</p><p>k 1e12</p><p>2s</p><p>1024mb</p><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>可以看成 一个图形, 每次平移固定向量, k次,问覆盖的图形面积</p><p>似乎脑补可得: 每次计算增量, 如果增量不变, 则往后都是这个增量</p><hr><p>但不知道如何判断 达到了最小增量</p><p>如果是这个形状, s -&gt; e</p><pre><code>xxxxxesxx</code></pre><p>那么下一次增量是5, 下下次增量也是5, 但是 这不是最小增量, 最小是3</p><hr><p>所以可能要变成去计算每个点首次不产生贡献的时刻, 而不产生贡献,也就是沿着 e -&gt; s 的向量方向如果存在点</p><p>所以考虑对点归类, 能够通过向量 e -&gt; s 到达的 归类</p><p>然后比较时刻和所有点的首次不产生贡献的时间即可</p><p>不产生时刻 = 同类别最近的方向向量 / 向量</p><p>好像就过了</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc219/submissions/33772772" target="_blank" rel="noopener">https://atcoder.jp/contests/abc219/submissions/33772772</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readchar s[200010];int ch[256];int di[] = {-1,1,0,0};int dj[] = {0,0,-1,1};vector&lt;pair&lt;pair&lt;ll,ll&gt;,ll&gt; &gt; pos;int main(){  ch[(int)&#39;L&#39;] = 0;  ch[(int)&#39;R&#39;] = 1;  ch[(int)&#39;U&#39;] = 2;  ch[(int)&#39;D&#39;] = 3;  scanf(&quot;%s&quot;,s);  int n = strlen(s);  ll k = read();  ll dx = 0;  ll dy = 0;  vector&lt;pair&lt;ll,ll&gt; &gt; vis = {{dx,dy}};  rep(i,0,n){    dx += di[ch[(int)s[i]]];    dy += dj[ch[(int)s[i]]];    vis.push_back({dx, dy});  }  if(dx &lt; 0){ // 保证在 (-pi/2,pi/2]    dx = -dx;    dy = -dy;  }else if(dx == 0 &amp;&amp; dy &lt; 0){ // &lt;- bug dx == 0    dy = -dy;  }  sort(vis.begin(),vis.end());  rep(i,0,vis.size()) if(i == 0 || vis[i] != vis[i-1]){    auto [x,y] = vis[i];    ll t = 0;    if(dx != 0){ // dx &gt;= 0      t = x/dx;      x -= t * dx;      y -= t * dy;      if(x &lt; 0){        t --;        x += dx;        y += dy;      }    }else if(dy != 0){ // dx == 0, dy &gt;= 0      t = y/dy;      y -= t * dy;      if(y &lt; 0){        t --;        y += dy;      }    }    pos.push_back({ { x , y } , t}); // 没空格 hexo 炸了  }  sort(pos.begin(),pos.end());  ll ans = 0;  if(dx == 0 &amp;&amp; dy == 0){    ans = pos.size();  }else{    rep(i,0,pos.size()){      if(i == 0 || pos[i].first != pos[i-1].first){        ans += k;      }else{        ans += min(k, pos[i].second - pos[i-1].second);      }    }  }  printf(&quot;%lld\n&quot;,ans);  return 0;}</code></pre><h1 id="G-Propagation"><a href="#G-Propagation" class="headerlink" title="G - Propagation"></a>G - Propagation</h1><p><a href="https://atcoder.jp/contests/abc219/tasks/abc219_g" target="_blank" rel="noopener">https://atcoder.jp/contests/abc219/tasks/abc219_g</a></p><p>n个点,m跳边的图, 点i上写的i</p><p>q次操作</p><p>每次让点xi 上的值扩散给它的所有相邻节点</p><p>输出最终每个点上的值</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>n 2e5</p><p>m 2e5</p><p>q 2e5</p><p>无重边 自环</p><p>2s</p><p>1024mb</p><h2 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h2><p>直接模拟? 如果出现2层菊花形状 每次一个外层染进来,中心扩散, 那么可能就是QN的量级</p><p>那么思路方向一个如何批量 或者 lazy的表示</p><p>另一个就是有没有可能倒着做</p><hr><p>如果把做为修改中心的, 作为点, 按时间顺序和依赖关系 可以建立树(森林), 但不太知道怎么去建</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>分度处理</p><p>对于度小于 $\sqrt{m}$, 直接修改周围的点, 而对于 $\ge \sqrt{m}$的度的点, 在点上标识</p><p>对于查询, 可以查询所有, 相当于边访问2次</p><p>而每次 处理前, 需要遍历一次周围度大于等于$\sqrt{m}$ 的</p><p>复杂度分析</p><p>修改就不用说了显然</p><p>而就每次获取最新状态时, 因为要遍历相邻的所有度$\sqrt{m}$</p><p>那么假设有$w$个, 那么即使边来自它们之间 $\frac{w \sqrt{m}}{2} leq m$, 即$w \leq {2\sqrt{m}}$, 说明也是$O(\sqrt{m})$ 级别的访问</p><p>中间复杂度$O(q\sqrt{m})$, 最后查询复杂度$O(n\sqrt{m})$</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc219/submissions/33773300" target="_blank" rel="noopener">https://atcoder.jp/contests/abc219/submissions/33773300</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readvector&lt;int&gt;p2[200010];vector&lt;int&gt;pl[200010]; // linked largebool large[200010]; // is largepair&lt;int,int&gt; distr[200010]; // [u] = {value, time}int a[200010]; // valueint t[200010]; // timeint getV(int u){  int val = a[u];  int ti = t[u];  for(auto v:pl[u]) if(distr[v].second &gt; ti) tie(val,ti) = distr[v];  return val;}int main(){  int n = read();  ll m = read();  int q = read();  rep(i,0,m){    int u = read();    int v = read();    p2[u].pb(v);    p2[v].pb(u);  }  iota(a+1,a+n+1,1);  rep(i,1,n+1) large[i] = (ll)p2[i].size() * (ll)p2[i].size() &gt; m;  rep(u,1,n+1){    for(auto v:p2[u]){      if(large[v]) pl[u].push_back(v);    }  }  rep(ti,1,q+1){    int u = read();    int val = getV(u);    a[u] = val;    t[u] = ti;    if(large[u]){      distr[u] = {val, ti};    }else{      for(auto v:p2[u]){        a[v] = val;        t[v] = ti;      }    }  }  rep(i,1,n+1) printf(&quot;%d &quot;,getV(i));  return 0;}</code></pre><h1 id="H-Candles"><a href="#H-Candles" class="headerlink" title="H - Candles"></a>H - Candles</h1><p><a href="https://atcoder.jp/contests/abc219/tasks/abc219_h" target="_blank" rel="noopener">https://atcoder.jp/contests/abc219/tasks/abc219_h</a></p><p>N 个蜡烛, 第i个在Xi, 长度Ai</p><p>每分钟, 点燃的蜡烛长度-1, 直到 = 0, 而没点燃的不变化</p><p>初始在0,每分钟可以移动+1/-1, 如果当前位置有任何蜡烛,可以扑灭(不耗时)</p><p>求所有蜡烛长度剩余和的最大值</p><h2 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h2><p>N 300</p><p>xi [-1e9,1e9]</p><p>Ai [1,1e9]</p><h2 id="我的思路-2"><a href="#我的思路-2" class="headerlink" title="我的思路"></a>我的思路</h2><p>第一感觉是, 向左走 然后一直向右, 或者向右然后一直向左, 找这个折反点</p><p>问题是,会不会出现 左右左的情况?</p><p>例如-1上有10个, 2上有10个, -4 上1个, 都足够的长</p><p>那么 0 -&gt; -1 -&gt; 2 -&gt; -4 的损失是21 <em> 1 + 11 </em> 3 + 1 * 6, 是最小的</p><hr><p>这样证否了贪心折返</p><p>注意到N很小</p><p>甚至能接受 n^3, 考虑dp</p><p><code>dp[i..j][0]</code> = <code>[i,j]</code> 区间内全部熄灭(烧完), 停在i 的 {最大长度, 时间} </p><p>问题是, 这种状态设计下, 最大长度和时间是有一致性吗?</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>也是说, 仅从访问来看</p><p>如果已经访问过的区间是<code>[X_i,X_j]</code> 那么下一次 一定是<code>[X_{i-1},X_j]</code> 或<code>[X_i,X_{j+1}]</code></p><hr><p>修改一下问题</p><ol><li>蜡烛可以负数长度</li><li>你可以在起始时移除一些蜡烛</li></ol><p>显然新答案不会比原答案更大,而如果有一个答案的方案你照着走,然后把是会是负数的在一开始就移除,那么也可以达到这个原答案的最大值</p><hr><p>那么</p><ol><li>初始 分 = 0</li><li>计数 C 去 [0,N] 之间的一个值, 相当于剩余的蜡烛个数,但是不知道具体是哪C个蜡烛</li><li>Hi等于对应蜡烛的高度</li><li>每次移动坐标变化1, 分数 -= C</li><li>对于走到一个未访问过的点, 且C &gt; 0, 可以选择 C-=1, 分 += Hi</li></ol><p>求最大分</p><p>显然最优解和答案是一样的</p><p>// 咦 我怎么看到上凸函数的影子</p><hr><p>然后就可以dp了</p><p><code>dp[i][j][flag][k] =</code> 已获的最大分数, $[X_i,X_j]$ 已经访问,$flag = 0$ 在$X_i$,$flag = 1$ 在$X_j$, $k$ 是剩余的要去熄灭的蜡烛个数</p><p>那么转移方程, 走到$X_i$</p><p><code>dp[i][j][0][k] = max(dp[i+1][j][0/1][k] - 距离 * k, dp[i+1][j][0/1][k+1] - 距离 * (k+1) + H[i])</code></p><p>转移方程, 走到$X_j$</p><p><code>dp[i][j][1][k] = max(dp[i][j-1][0/1][k] - 距离 * k, dp[i][j-1][0/1][k+1] - 距离 * (k+1) + H[i])</code></p><p>最后答案就是<code>dp[0][n-1][0/1][0]</code></p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc219/submissions/33780170" target="_blank" rel="noopener">https://atcoder.jp/contests/abc219/submissions/33780170</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readconst int N = 300;ll dp[N+10][N+10][2][N+10];pair&lt;int,int&gt; ph[N+10]; // pos height 起点 {0,0}const ll INF = 0x3f3f3f3f3f3f3f3f;void setMax(ll &amp;v0,ll v1){ if(v1 &gt; v0) v0 = v1; }int main(){  int n = read();  rep(i,1,n+1){    auto p = read();    auto h = read();    ph[i] = {p,h};  }  sort(ph,ph+n+1);  int ci = -1; // center i 起始点  rep(i,0,n+1){    if(ph[i] == make_pair(0,0)){      ci = i;      break;    }  }  rep(i,0,n+1) rep(j,0,n+1) rep(f,0,2) rep(c,0,n+1) dp[i][j][f][c] = -INF;  rep(f,0,2) rep(c,0,n+1) dp[ci][ci][f][c] = 0;  per(i,0,ci+1) rep(j,ci,n+1) {    //dp[i][j][0][k]=max(dp[i+1][j][0/1][k]-距离*k,dp[i+1][j][0/1][k+1]-距离*(k+1)+H[i])`    //dp[i][j][1][k]=max(dp[i][j-1][0/1][k]-距离*k,dp[i][j-1][0/1][k+1]-距离*(k+1)+H[i])`    if(i == j) continue;    rep(c,0,n+1) rep(f,0,2) {      if(i &lt; ci) {        auto [x,h] = ph[i];        const ll pos[] = {i+1, j};        ll &amp;res = dp[i][j][0][c];        setMax(res, dp[pos[0]][pos[1]][f][c] - (ph[pos[f]].first - x) * c);        if(c &lt; n) setMax(res, dp[pos[0]][pos[1]][f][c+1] - (ph[pos[f]].first - x) * (c+1) + h);      }      if(j &gt; ci){        auto [x,h] = ph[j];        const ll pos[] = {i, j-1};        ll &amp;res = dp[i][j][1][c];        setMax(res, dp[pos[0]][pos[1]][f][c] - (x - ph[pos[f]].first) * c);        if(c &lt; n) setMax(res, dp[pos[0]][pos[1]][f][c+1] - (x - ph[pos[f]].first) * (c+1) + h);      }    }  }  printf(&quot;%lld\n&quot;, max(dp[0][n][0][0], dp[0][n][1][0]));  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>F</p><p>一眼题</p><p>G</p><p>分类处理, 根号分治</p><p>做了不少分类的,又忘了分类</p><p>H</p><p>一个是题目转化去掉限制的技巧不会啊, 如果直接是转化后的题面, 那我还是会区间DP的, 但这个转化感觉遇到多了学一学转化</p><p>其实就是这里每分钟下降 燃烧着的个数, 会因为=0而难以维护, 通过支持负数 和可预先移除来让每分钟下降易于维护, 同时保持新的最大答案 = 原答案</p><p>n^3和dp的感知还是没有问题, 虽然在没有前面转化的情况下用处不大</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://atcoder.jp/contests/abc219/editorial" target="_blank" rel="noopener">官方题解</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;F(排序,分组)G(根号分类,分类)H(区间dp,问题转化)&lt;/p&gt;
&lt;h1 id=&quot;F-Cleaning-Robot&quot;&gt;&lt;a href=&quot;#F-Cleaning-Robot&quot; class=&quot;headerlink&quot; title=&quot;F - Cleaning Robot&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="Atcoder" scheme="http://yexiaorain.github.io/Blog/categories/Atcoder/"/>
    
    
      <category term="排序" scheme="http://yexiaorain.github.io/Blog/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="区间dp" scheme="http://yexiaorain.github.io/Blog/tags/%E5%8C%BA%E9%97%B4dp/"/>
    
      <category term="分组" scheme="http://yexiaorain.github.io/Blog/tags/%E5%88%86%E7%BB%84/"/>
    
      <category term="根号分类" scheme="http://yexiaorain.github.io/Blog/tags/%E6%A0%B9%E5%8F%B7%E5%88%86%E7%B1%BB/"/>
    
      <category term="分类" scheme="http://yexiaorain.github.io/Blog/tags/%E5%88%86%E7%B1%BB/"/>
    
      <category term="问题转化" scheme="http://yexiaorain.github.io/Blog/tags/%E9%97%AE%E9%A2%98%E8%BD%AC%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Atcoder abc218</title>
    <link href="http://yexiaorain.github.io/Blog/2022-08-04-ac_abc218/"/>
    <id>http://yexiaorain.github.io/Blog/2022-08-04-ac_abc218/</id>
    <published>2022-08-03T20:25:14.000Z</published>
    <updated>2022-08-12T03:23:03.827Z</updated>
    
    <content type="html"><![CDATA[<p>G(dp,树,multiset)H(王钦石二分,Alien Trick)</p><h1 id="G-Game-on-Tree-2"><a href="#G-Game-on-Tree-2" class="headerlink" title="G - Game on Tree 2"></a>G - Game on Tree 2</h1><p><a href="https://atcoder.jp/contests/abc218/tasks/abc218_g" target="_blank" rel="noopener">https://atcoder.jp/contests/abc218/tasks/abc218_g</a></p><p>n点, 树, 点i上有数字Ai</p><p>初始 棋子在点1, 交替玩, 每次移动到未访问过的相邻点, 直到无法移动为止</p><p>先手 希望最大化访问过的中位数, 后手希望最小化中位数</p><p>如果他们都最优方案, 求这个中位数</p><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>N 1e5</p><p>Ai [2,1e9]</p><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>既然是树, 相当于1作为根, 走到叶节点结束, 路径上的中位数就是结果</p><p>换句话说, 每个叶节点 可以存储结果</p><p>如果能够算出每个从根到叶的结果, 那么简单的根据深度树上dp就完了(根 同的2倍深度 选最大, 根%2不同深度选最小)</p><p>想到的是相当于从中间剖开,那么dfs维护一个大根堆,一个小根堆,让它们元素个数差最多是1即可</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc218/submissions/33755229" target="_blank" rel="noopener">https://atcoder.jp/contests/abc218/submissions/33755229</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readint A[100010];vector&lt;int&gt; e[100010];template&lt;typename T&gt; using maxSet = multiset&lt;T, greater&lt;T&gt;&gt;;template&lt;typename T&gt; using minSet = multiset&lt;T&gt;;int mid[100010];template&lt;typename T&gt;void balance(maxSet&lt;T&gt; &amp;small,minSet&lt;T&gt; &amp;large){  while(large.size() &gt; small.size()){    small.insert(*large.begin());    large.erase(large.begin());  }  while(small.size() &gt;= large.size() + 2){    large.insert(*small.begin());    small.erase(small.begin());  }}template&lt;typename T&gt;int dfs(int u,int f,maxSet&lt;T&gt; &amp;small,minSet&lt;T&gt; &amp;large, int dep){  // 插入  if(small.size() == 0 || *small.begin() &gt;= A[u]){    small.insert(A[u]);  }else{    large.insert(A[u]);  }  balance(small,large);  int res = 0;  if(u != 1 &amp;&amp; e[u].size() == 1){ // leaf    res = (small.size() == large.size()) ? (*small.begin() + *large.begin())/2 : *small.begin();  }else{    vector&lt;int&gt; vals;    for(auto v:e[u]) if(v != f) vals.push_back(dfs(v,u,small,large,dep^1));    res = (dep==0)? *max_element(vals.begin(),vals.end()) : *min_element(vals.begin(),vals.end());  }  // 删除  auto sptr = small.find(A[u]);  if(sptr != small.end()){    small.erase(sptr);  }else{    auto lptr = large.find(A[u]);    assert(lptr != large.end());    large.erase(lptr);  }  balance(small,large);  return res;}int main(){  int n = read();  rep(i,1,n+1) A[i] = read();  rep(i,1,n){    int u = read();    int v = read();    e[u].pb(v);    e[v].pb(u);  }  maxSet&lt;int&gt; small ; // 前一半  minSet&lt;int&gt; large ;  printf(&quot;%d\n&quot;,dfs(1,1,small,large,0));  return 0;}</code></pre><h1 id="H-Red-and-Blue-Lamps"><a href="#H-Red-and-Blue-Lamps" class="headerlink" title="H - Red and Blue Lamps"></a>H - Red and Blue Lamps</h1><p><a href="https://atcoder.jp/contests/abc218/tasks/abc218_h" target="_blank" rel="noopener">https://atcoder.jp/contests/abc218/tasks/abc218_h</a></p><p>N个灯, 你需要让R个红色,N-R个蓝色</p><p>如果 i 和 i+1 不同色 则有Ai的贡献</p><p>求最大的贡献</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>N 2e5</p><p>R [1,N-1]</p><p>Ai [1,1e9]</p><p>2s</p><p>1024mb</p><h2 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h2><p>显然有个n^2的dp</p><p><code>dp[i][j][c] =</code> 前i个有j个红色,第i个颜色为c,的最大贡献</p><p><code>dp[i][j][red] = max(dp[i-1][j-1][red] , dp[i-1][j-1][blue] + A[i])</code></p><p><code>dp[i][j][blue] = max(dp[i-1][j][red] +A[i], dp[i-1][j][blue])</code></p><p>但肯定超时</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>如果红色比蓝色多, 则交换颜色数量</p><p>那么尽量多的两两不同,显然红色不相邻</p><p>那么把 A[i]+A[i+1] 看作整体</p><p>构造B[i] = A[i]+A[i+1] 数组</p><p>变成在B中选r个不相邻的元素使得总价值最大, 类似的<code>dp[i][j][0/1] =</code>前i个,选了j个,第i个是否选的最大值</p><p><code>dp[i][j][1] = dp[i-1][j-1][0] + B[i]</code></p><p><code>dp[i][j][0] = max(dp[i-1][j][1],dp[i-1][j][0])</code></p><p>复杂度依然不能接受</p><hr><p>但是有简单的性质: 可以王钦石二分</p><h2 id="王钦石二分"><a href="#王钦石二分" class="headerlink" title="王钦石二分"></a>王钦石二分</h2><ol><li>当可选的越多(虽然题目要你求具体的), 那么总收益越大(单增)</li><li>当选的越多, 增量非严格递减凹函数(上凸)</li><li>不限制个数,容器得到最优方案</li></ol><p>反过来, 如果我们指定一个最大收益, 那么可以快速算出需要可选的最少数量</p><p>如果变成二维图,是凹(上凸)函数,</p><p>方法是二分斜率, 对斜率找和凹函数的切点(切线)</p><p>而显然切线在y轴截距最大, <code>f(x) = g(x) - k x</code>, 原函数<code>g(x)</code>, 截距函数<code>f(x)</code></p><p>问题变成 给k, 找最大f(x), 而 g(x) - k x 从另一个角度看, 就是每个值-k 以后选x, 对于x没有限制时, 容易求的话,那就容易得到f(x) 和 x</p><p>求的话因为干掉了一个记录当前有多少个的限制, 从而可以简单dp</p><hr><p>然后…. 我被卡double /long double 了</p><p>现实是,本身斜率就是 每次增量, 答案不会有小数,而切点对切线斜率也是单调影响, 所以,全整数就行了</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc218/submissions/33768310" target="_blank" rel="noopener">https://atcoder.jp/contests/abc218/submissions/33768310</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readint n;ll a[200010];pair&lt;ll,int&gt; f(ll v){ // f(斜率) =&gt; {最大截距, 横坐标(选的个数)}  auto dp = vector(n,vector(2,pair&lt;ll,int&gt;{0,0})); // dp[i][选/不选] = {最大截距,个数}  rep(i,1,n){    auto [y0, c0] = dp[i-1][0];    dp[i][1] = {y0 + (a[i-1] - v), c0 + 1}; // 当前选, 则上一个不选    dp[i][0] = max(dp[i-1][0],dp[i-1][1]); // 当前不选, 则上一个可选可不选  }  return max(dp[n-1][0],dp[n-1][1]);}int main(){  n = read();  int x = read();  x = min(x, n-x);  rep(i,0,n-1) a[i] = read(); // [0..n-2]  rep(i,0,n-1) a[i] += a[i+1]; // [0..n-2], 看成多了末尾多了一个0, 对最大值无影响  ll L = 0, R = 3&#39;000&#39;000&#39;000; // 斜率  while(L + 1 &lt; R) { // 二分, 这里可能 有多个点 让同一个斜率最大, 保证 f(R).pos &lt; x &lt;= f(L).pos 即可    ll mid = (L + R) / 2;    auto [_, pos] = f(mid);    if(pos &lt; x) R = mid;    else L = mid;  }  auto [y,_] = f(L);  ll ans = (ll)(y + x * L);  printf(&quot;%lld\n&quot;, ans);}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>G</p><p>没啥难的</p><p>H</p><p>感觉有的时候还是有点 PE的味道,偏数学一点</p><p>这里涉及 王钦石二分, 也是凸(凹)函数和二分相关的知识</p><p>然后这里double还不行,得long double</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://atcoder.jp/contests/abc218/editorial" target="_blank" rel="noopener">官方题解</a></p><p><a href="https://zhuanlan.zhihu.com/p/340514421" target="_blank" rel="noopener">王钦石二分</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;G(dp,树,multiset)H(王钦石二分,Alien Trick)&lt;/p&gt;
&lt;h1 id=&quot;G-Game-on-Tree-2&quot;&gt;&lt;a href=&quot;#G-Game-on-Tree-2&quot; class=&quot;headerlink&quot; title=&quot;G - Game on Tree
      
    
    </summary>
    
      <category term="Atcoder" scheme="http://yexiaorain.github.io/Blog/categories/Atcoder/"/>
    
    
      <category term="dp" scheme="http://yexiaorain.github.io/Blog/tags/dp/"/>
    
      <category term="二分" scheme="http://yexiaorain.github.io/Blog/tags/%E4%BA%8C%E5%88%86/"/>
    
      <category term="树" scheme="http://yexiaorain.github.io/Blog/tags/%E6%A0%91/"/>
    
      <category term="multiset" scheme="http://yexiaorain.github.io/Blog/tags/multiset/"/>
    
      <category term="王钦石二分" scheme="http://yexiaorain.github.io/Blog/tags/%E7%8E%8B%E9%92%A6%E7%9F%B3%E4%BA%8C%E5%88%86/"/>
    
      <category term="Alien Trick" scheme="http://yexiaorain.github.io/Blog/tags/Alien-Trick/"/>
    
      <category term="凹函数" scheme="http://yexiaorain.github.io/Blog/tags/%E5%87%B9%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>Atcoder abc217</title>
    <link href="http://yexiaorain.github.io/Blog/2022-08-03-ac_abc217/"/>
    <id>http://yexiaorain.github.io/Blog/2022-08-03-ac_abc217/</id>
    <published>2022-08-02T20:25:14.000Z</published>
    <updated>2022-08-12T03:23:03.827Z</updated>
    
    <content type="html"><![CDATA[<p>G(dp)H(凸函数)</p><h1 id="G-Groups"><a href="#G-Groups" class="headerlink" title="G - Groups"></a>G - Groups</h1><p><a href="https://atcoder.jp/contests/abc217/tasks/abc217_g" target="_blank" rel="noopener">https://atcoder.jp/contests/abc217/tasks/abc217_g</a></p><p>有数字1..N</p><p>把它们分成k组(每组至少一个数)</p><p>要求, 每组中没有两个数 mod M 是相等的</p><p>问对于k=1…n 分别有多少方案</p><p>答案 模 998244353</p><p>方案: 如果两方案不同,至少有一个(x,y) 在一个中同组,另一个是不同组</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>n 5000</p><p>2 &lt;= m &lt;= n</p><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>显然 (n - 1) / m + 1 个 mod m = 1 的</p><p>我们也容易计算mod m = r 的有多少个</p><p>然后 计算这个方案数无非是两个方向, 正向算和逆向算</p><p>正向算, 则需要对每个方案唯一标识, 那么考虑用每组中( (value - 1 )mod m, value) 最小的作为组标识</p><p>似乎相互依赖很多, 不知道怎么算</p><p>反向算, 则就是同 mod的放在同一个位置了</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>我感觉自己已经傻掉了, 看到n 5000 竟然没有想一下n方的算法</p><p><code>dp[i][j]</code> 表示前i个数,分成了j组方案</p><p>如果没有同余限制</p><p><code>dp[i][j] = dp[i-1][j-1](单独放在j) + j * dp[i-1][j] (前面i-1已经放了j)</code> 个</p><p>注意到同余的限制</p><p>那么j的放法就是 和它不同余的位置</p><p>已经有 ((i-1) / m)个和它同余了</p><p><code>dp[i][j] = dp[i-1][j-1](单独放在j) + (j-(i-1)/m)保证非负 * dp[i-1][j] (前面i-1已经放了j)</code> 个</p><hr><p>就没了</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc217/submissions/33750183" target="_blank" rel="noopener">https://atcoder.jp/contests/abc217/submissions/33750183</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;#include &lt;atcoder/modint&gt;using mint = atcoder::modint998244353;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;(int)n;i++)int read(){int r;scanf(&quot;%d&quot;,&amp;r);return r;} // readint main() {  int n = read();  int m = read();  vector&lt;vector&lt;mint&gt;&gt; dp(n + 1, vector&lt;mint&gt; (n + 1));  dp[0][0] = 1;  rep(i,1,n+1){    rep(j,1,i+1) { // j-(i-1)/m &gt;= 0      dp[i][j] = dp[i-1][j-1];      if(j-(i-1)/m &gt;= 0) dp[i][j] += dp[i-1][j] * (j-(i-1)/m);    }  }  rep(i,1,n+1) printf(&quot;%d\n&quot;,dp[n][i].val());  return 0;}</code></pre><h1 id="H-Snuketoon"><a href="#H-Snuketoon" class="headerlink" title="H - Snuketoon"></a>H - Snuketoon</h1><p><a href="https://atcoder.jp/contests/abc217/tasks/abc217_h" target="_blank" rel="noopener">https://atcoder.jp/contests/abc217/tasks/abc217_h</a></p><p>初始在点0, 每秒可以-1,0,+1</p><p>N次事件: 在ti时刻, 若在Xi左侧且Di = 0,受到和Xi距离的伤害, 若在Xi右侧, 且Di = 1,受到和Xi距离的伤害</p><p>想要受到伤害最小化, 求最小值</p><h2 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h2><p>N 2e5</p><p>ti [1,1e9]</p><p>di 0/1</p><p>Xi [-1e9,1e9]</p><h2 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h2><p>看起来像dp</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>$dp_{i,x} = $ 在Ti分钟 恰好在x 所需要受到的最小伤害, 为了方便认为T0 = 0</p><p>那么</p><p><code>dp[0][0] = 0</code></p><p><code>dp[0][!=0] = INF</code></p><p>若Di = 0, <code>dp[i][x] = min(dp[i-1][y]) + max(0,Xi - x)</code>, 且<code>|y-x| &lt;= T[i] - T[i-1]</code></p><p>若Di = 1, <code>dp[i][x] = min(dp[i-1][y]) + max(0,x - Xi)</code>, 且<code>|y-x| &lt;= T[i] - T[i-1]</code></p><p>很明显直接算会TLE</p><hr><p>对于一个具体的i, 在二维平面上画点$(x,dp_{i,x})$, 其中横坐标范围是$[-T_i,T_i]$, 然后用线段连起来, 发现是个凸函数(下凸)</p><p>证明: 若对于i-1是下凸函数, 注意到<code>min(dp[i-1][y])</code> 依然是凸函数, 而<code>max</code>部分也是凸函数,所以对于<code>i</code> 也是凸函数</p><hr><p>因此问题变成维护那些拐点</p><p>每次min的操作,相当于把最小值的区间 向两侧 平移<code>T[i]-T[i-1]</code></p><p>注意到 最初是[0,0], 其实就是把区间最左和最有移动到<code>-Ti</code>和正<code>Ti</code></p><p>然后每次+max, 相当于一段不变, 一段 斜率+1, 还可能产生新的节点</p><p>如何维护呢?</p><p>注意到每次 min的过程核心等于向两侧平移, 如果以 和<code>-Ti</code>,<code>Ti</code>的距离来看, 甚至是没有变化</p><p>每次 +max, 是区间内斜率增加1, 那不妨直接记录 斜率1的起始点,斜率2的起始点, 斜率3的起始点( 可能会有重合, 这些点和左侧的距离, 和右侧的距离</p><hr><p> -3 -2 -1 0 1 2 3 这样的斜率区间</p><p> 如果加上 0 1 的</p><p> 最终会变成  -3 -2 -1 0 1 2 3 4 这样的, 虽然可能有起点重合(斜率区间长度为0</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc217/submissions/33754555" target="_blank" rel="noopener">https://atcoder.jp/contests/abc217/submissions/33754555</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readpriority_queue&lt;ll&gt; ql; //大根堆,左侧, 记录斜率-1的起点,-2的起点,-3的起点,...到 -Ti的距离priority_queue&lt;ll&gt; qr; //大根堆,右侧, 记录斜率 1的起点, 2的起点, 3的起点,...到  Ti的距离int main() {  int n = read();  ll ans = 0;  rep(i, 1, n+1) {    ll t = read();    ll d = read();    ll x = read();    // 让下凸的最小值一直是0    if (d == 0) {      if (x &gt; t) { // 超出范围直接全部都加上        ans += x - t;        x = t;      }      if (qr.empty() || qr.top() &lt;= t-x) { // 不影响右侧的        ql.push(x + t);// 原来-1变-2, -2变-3,... , 新的-1的起点      } else { // ... -3 -2 -1  0 ... 0 1 2 3 ... 影响右侧的,        int pos = t - qr.top(); // 最小值的位置 右侧1斜率的起点        qr.pop();        ans += x - pos; // 让下凸的最小值 = 0        ql.push(pos-(-t)); // 成为左侧新的 -1 斜率的起点        qr.push(t - x); // 插入新的 斜率变化分割(距离右侧Ti      }    } else { // d = 1      if (x &lt; -t) { // 超出范围直接全部都加上        ans += -t - x;        x = -t;      }      if (ql.empty() || x - (-t) &gt;= ql.top()) { // 不影响左侧        qr.push(t - x); // 右侧最大点      } else {        int pos = ql.top() - t; // 最小值的位置, 左侧-1斜率的起点        ql.pop();        ans += pos-x;        qr.push(t-pos);        ql.push(x-(-t));      }    }  }  printf(&quot;%lld\n&quot;, ans);  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>G</p><p>干啊, n方dp都想不到了,我</p><p>据说有数学的 N log N 的方法</p><p>H</p><p>知识点就是凸函数, 但是变化点较少时, 只需要维护这些点即可</p><p>然后维护的时候, 想办法保持尽可能多的不变量, 让变化记录是常数级别</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://atcoder.jp/contests/abc217/editorial" target="_blank" rel="noopener">官方题解</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;G(dp)H(凸函数)&lt;/p&gt;
&lt;h1 id=&quot;G-Groups&quot;&gt;&lt;a href=&quot;#G-Groups&quot; class=&quot;headerlink&quot; title=&quot;G - Groups&quot;&gt;&lt;/a&gt;G - Groups&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://atcode
      
    
    </summary>
    
      <category term="Atcoder" scheme="http://yexiaorain.github.io/Blog/categories/Atcoder/"/>
    
    
      <category term="dp" scheme="http://yexiaorain.github.io/Blog/tags/dp/"/>
    
      <category term="凸函数" scheme="http://yexiaorain.github.io/Blog/tags/%E5%87%B8%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>POJ 3169</title>
    <link href="http://yexiaorain.github.io/Blog/2022-08-02-poj3169/"/>
    <id>http://yexiaorain.github.io/Blog/2022-08-02-poj3169/</id>
    <published>2022-08-01T20:25:14.000Z</published>
    <updated>2022-08-12T03:23:03.827Z</updated>
    
    <content type="html"><![CDATA[<p>cow game, 差分约束</p><h1 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h1><p><a href="http://poj.org/problem?id=3169" target="_blank" rel="noopener">http://poj.org/problem?id=3169</a></p><p>数轴上放N个点(按照i的顺序坐标非严格单调递增</p><p>10000 个大于限制, 点i和点j距离不超过 di (1e6)</p><p>10000 个小于限制, 点i和点j距离不小于 di (1e6)</p><p>1s</p><p>64MB</p><p>求点1 和 点N的最大距离</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>传说中日本众所周知的的cow game</p><p>也就是 全部小于号, (大于号同乘-1)</p><p>注意到上面要保证i的顺序( 所以 大-小 &lt;= Di 或者 大减小 &gt;= Di</p><p>然后说 差分约束本质上还是 最短路 只是需要建图</p><p>b-a &lt;= d</p><p>转化成 a + d &gt;= b, 所以 a -&gt; b如果有边长d的话, 那么b的距离最小就是 a+d 还可能更小</p><p>b-a &gt;= d的话</p><p>转化成 b-d &gt;= a, 也就是 b -&gt; a 如果有边长 (-d), 那么a的距离最小是 b-d, 还可能更小</p><p>总而言之转化成</p><p>点0 + ? &gt;= 点1 的形式, 然后从点0 发一条长? 的边</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="过不了编译版本"><a href="#过不了编译版本" class="headerlink" title="过不了编译版本"></a>过不了编译版本</h3><p>这poj g++版本太老了</p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (int i=a;i&lt;n;i++)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readconst int INF = 0x3f3f3f3f; // 1e9vector&lt;array&lt;int,3&gt; &gt; e; // 有向边 [u,v,weight/length]int main(){  int N = read();  int ML = read();  int MD = read();  // 建图  rep(i,1,N) e.push_back({i+1, i, 0}); // 从i+1-&gt;i权值为0的边 保证顺序i的距离不大于i+1  rep(i,0,ML){ //&#39;喜欢&#39;关系约束 &lt;= DL    int a = read();    int b = read(); // 保证 b&gt;a    int d = read(); // |距离| &lt;= DL[i]    /* b-a&lt;=d, 即 a+d&gt;=b 从a到b权值为d的边 */    e.push_back({a,b,d});  }  rep(i,0,MD){ //&#39;不喜欢&#39;关系约束 &gt;= DD    int a = read();    int b = read(); // 保证 b&gt;a    int d = read(); // |距离| &gt;= DD[i]    /* BD - AD &gt;= DD 即 BD - DD &gt;= AD,  从BD到AD权值-DD的边*/    e.push_back({b,a,-d});  }  // Bellman_Ford  vector&lt;int&gt;dist(N+1,INF);// 最短距离  dist[1] = 0;  //循环N-1次 对所有边进行松弛操作  rep(i,0,N-1) for(auto [u,v,w]: e) if(dist[u] != INF) dist[v] = min(dist[v], dist[u] + w);  //再遍历一次所有边（第N次循环）如果本次有更新，则存在负环  bool ngloop = false;  for(auto [u,v,w]: e) if(dist[u] != INF &amp;&amp; dist[u] + w &lt; dist[v] ) ngloop = true;  int ans = dist[N];  if (ngloop) ans = -1;  else if(ans == INF) ans = -2;  printf(&quot;%d\n&quot;, ans);  return 0;}</code></pre><h3 id="AC-版本"><a href="#AC-版本" class="headerlink" title="AC 版本"></a>AC 版本</h3><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define mt make_tuplell read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readconst int INF = 0x3f3f3f3f; // 1e9// 没有tuplestruct edge{  int u;  int v;  int w;  // 结构体直接赋值也没有  edge(int _u,int _v,int _w){    u = _u;    v = _v;    w = _w;  }};vector&lt;edge&gt; e; // 有向边 [u,v,weight/length]int main(){  int N = read();  int ML = read();  int MD = read();  // 建图  rep(i,1,N) e.push_back(edge(i+1, i, 0)); // 从i+1-&gt;i权值为0的边 保证顺序i的距离不大于i+1  rep(i,0,ML){ //&#39;喜欢&#39;关系约束 &lt;= DL    int a = read();    int b = read(); // 保证 b&gt;a    int d = read(); // |距离| &lt;= DL[i]    /* b-a&lt;=d, 即 a+d&gt;=b 从a到b权值为d的边 */    e.push_back(edge(a,b,d));  }  rep(i,0,MD){ //&#39;不喜欢&#39;关系约束 &gt;= DD    int a = read();    int b = read(); // 保证 b&gt;a    int d = read(); // |距离| &gt;= DD[i]    /* BD - AD &gt;= DD 即 BD - DD &gt;= AD,  从BD到AD权值-DD的边*/    e.push_back(edge(b,a,-d));  }  // Bellman_Ford  vector&lt;int&gt;dist(N+1,INF);// 最短距离  dist[1] = 0;  //循环N-1次 对所有边进行松弛操作  rep(t,0,N-1) rep(i,0,e.size()){    edge &amp;uvw = e[i]; // 不支持auto    int u = uvw.u;    int v = uvw.v;    int w = uvw.w;    if(dist[u] != INF) dist[v] = min(dist[v], dist[u] + w);  }  //再遍历一次所有边（第N次循环）如果本次有更新，则存在负环  bool ngloop = false;  rep(i,0,e.size()){    edge &amp;uvw = e[i]; // 不支持auto    int u = uvw.u;    int v = uvw.v;    int w = uvw.w;    if(dist[u] != INF &amp;&amp; dist[u] + w &lt; dist[v] ) ngloop = true;  }  int ans = dist[N];  if (ngloop) ans = -1;  else if(ans == INF) ans = -2;  printf(&quot;%d\n&quot;, ans);  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>就是如何对差分变成图</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;cow game, 差分约束&lt;/p&gt;
&lt;h1 id=&quot;Layout&quot;&gt;&lt;a href=&quot;#Layout&quot; class=&quot;headerlink&quot; title=&quot;Layout&quot;&gt;&lt;/a&gt;Layout&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://poj.org/problem?
      
    
    </summary>
    
      <category term="poj" scheme="http://yexiaorain.github.io/Blog/categories/poj/"/>
    
    
      <category term="差分约束" scheme="http://yexiaorain.github.io/Blog/tags/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/"/>
    
  </entry>
  
  <entry>
    <title>Atcoder abc216</title>
    <link href="http://yexiaorain.github.io/Blog/2022-08-01-ac_abc216/"/>
    <id>http://yexiaorain.github.io/Blog/2022-08-01-ac_abc216/</id>
    <published>2022-07-31T20:25:14.000Z</published>
    <updated>2022-08-12T03:23:03.827Z</updated>
    
    <content type="html"><![CDATA[<p>G(贪心,差分约束,最短路)H(LGV引理,状压dp)</p><h1 id="G-01Sequence"><a href="#G-01Sequence" class="headerlink" title="G - 01Sequence"></a>G - 01Sequence</h1><p><a href="https://atcoder.jp/contests/abc216/tasks/abc216_g" target="_blank" rel="noopener">https://atcoder.jp/contests/abc216/tasks/abc216_g</a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc216/submissions/33727628" target="_blank" rel="noopener">https://atcoder.jp/contests/abc216/submissions/33727628</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;(int)n;i++)int read(){int r;scanf(&quot;%d&quot;,&amp;r);return r;} // readconst int N=200000;int a[N+10]; // a[空白个数] = 到右侧点, 之间全是1int r[N+10]; // 读入int y[N+10]; // 左侧0个数vector&lt;int&gt; l2i[N+10]; // 左端点到第i个区间int main() {  int n = read();  int m = read();  rep(i,1,m+1){    int l = read();    r[i] = read();    y[i] = (r[i]-l+1) - read(); // 左侧0个数 [[....yi],1,1,1,1,1,1]    l2i[l].push_back(i);  }  int cnt = 0; // 遍历过程中 (&lt;l) 0 的个数  rep(pos,1,n+1){ // 下标    for(auto i:l2i[pos]) a[y[i]+cnt] = max(a[y[i]+cnt],r[i]);// [pos.....r[i]]    printf(&quot;%d &quot;, a[cnt] &gt;= pos); // 这一段全是1, 1尽量向右,贪心塞0    cnt += (a[cnt] &lt; pos); // 计数+1  }  return 0;}</code></pre><h1 id="H-Random-Robots"><a href="#H-Random-Robots" class="headerlink" title="H - Random Robots"></a>H - Random Robots</h1><p>数轴上k个机器人, 初始位置分别在xi</p><p>每次 每个机器人独立选择 移动(正向+1)或不动 1/2 概率</p><p>问经过N次,过程中没有任何两个robot 同时在同位置的概率</p><p>mod 998244353</p><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>k [2,10]</p><p>n 1000</p><p>xi [0,1000], 严格单增提供</p><p>2s</p><p>1024mb</p><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>一般来说 概率 = 次/总次数 可以互相转化</p><p>不相遇 可以 和相遇的容斥互相转化</p><p>k 10 的话可能和k的bitmask有关系</p><p>如果进行一次</p><p>而碰撞比不碰撞似乎好算一些</p><p>而且一般是相邻碰撞</p><p>pi 和pi+1 在t次时刻碰撞</p><p>意味着 t-1 次时距离1, t时 1/4 概率</p><p>0~t-1 时刻每次 1/4 +1, 1/4 -1, 1/2 不变</p><p>设原来距离 为d</p><p>那么 -1 次数 减去 +1 次数 = d-1, 且中间不能有负数情况</p><p>变成后缀个数统计问题</p><p>似乎可以强行算出t时刻 的概率, 实在组合排列不行, <code>dp[时刻1000][距离2000]</code> 来算也可以</p><hr><p>那么无碰撞 = 所有 - 碰撞</p><p>所以想办法容斥掉碰撞</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>用一下LGV引理相关的思路: 相交的路径 总有转化方法,成对的出现互为相反数的贡献,从而有相交的内容贡献和为0</p><p>每一个路径组方案贡献1 乘上-1的最终位置的逆序列数量次方, 其实就像当于LGV中所有边权为1 的特殊情况</p><p>$\sum_{Q} (-1)^{\sigma(Q)}\cdot(\frac{1}{2})^{NK}\cdot\prod_{i=1}^K {\rm C}(N,Q_i-x_i)$</p><p>也就是 方案 * (-1) 的幂次权, 再除以总方案数</p><p>Qi 为初始第i个机器人最终的下标</p><p>$\sigma(Q)$ 为逆序对个数</p><p>那么对于一条具体的有交的路径, 找其编号最小交点, 其中最小的起始位置,做后置路径交换(和LGV一样), 那么将得到一个新的路径组,有同样的交点,最小交点的最小起始位置依然相同, 但逆序对数变化为1, 所以总贡献为0</p><hr><p><code>f[S][j] =</code> 选起点集合在S中, 最终节点最大值 &lt;= j 的 带权 方案数和</p><p><code>ans = f[{1,...,k}][x[k] + n]</code></p><p>考虑状态转移</p><p>最终最大节点 &lt; j, <code>f[S][j] += f[S][j-1]</code></p><p>最终最大节点 = j, <code>f[S][j] += lgv中的行列式值 展开最后一列</code></p><p>所以有</p><p>$f(S, j) = f(S, j-1) + \sum_{i=1}^{|S|} (-1)^{|S|+i} e(x_{s_i}, j) f(S\setminus{s_i}, j-1).$</p><p>$f(S, j) = f(S, j-1) + \sum_{i=1}^{|S|} (-1)^{|S|+i} \binom{n}{j-x_{s_i}} f(S\setminus{s_i}, j-1).$</p><p>状态$2^k(n + x_k - x_1)$, 转移倍数$k$</p><p>总时间复杂度 $2^kk(n + x_k - x_1)$</p><hr><p>注意到j仅依赖于j-1, 所以可以滚动数组降低空间</p><p>而S依赖于的都是S子集, 所以保证顺序即可</p><p>$for(j) \\ f(S) = f(S) + \sum_{i=1}^{|S|} (-1)^{|S|+i} \binom{n}{j-x_{s_i}} f(S\setminus{s_i}).$</p><p>注意到这里的i不是X数组的i而是X选出的x按照顺序组成的S中的i, 且是1-index</p><p>也可以表示成$d(S,i) = S$中比$i$大的的个数</p><p>$for(j) \\ f(S) = f(S) + \sum_{i=1}^{|S|} (-1)^{d(S,i)} \binom{n}{j-x_{s_i}} f(S\setminus{s_i}).$</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc216/submissions/33737388" target="_blank" rel="noopener">https://atcoder.jp/contests/abc216/submissions/33737388</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;#include &lt;atcoder/modint&gt;using mint = atcoder::modint998244353;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readint x[2010]; // 初始位置mint f[2010] = {1}; // f[i] = binom(n,i)int p[(1&lt;&lt;10)+10]; // p[mask] = (-1)^(mask中1的个数)mint dp[(1&lt;&lt;10)+10] = {1}; // 第二维滚动 f(S,pos) = f(S, pos-1) + \sum_{i=1}^{|S|} (-1)^{count(S,&gt; i)} \binom{n}{pos-x_{s_i}} f(S\setminus\{s_i\}, pos-1).$int main() {  int k=read();  int n=read();  rep(i,0,k) x[i]=read();  rep(i,1,n+1) f[i]=f[i-1]*(n-i+1)/i; // binom(n,i-1) -&gt; binom(n,i)  rep(mask,0,1&lt;&lt;k) p[mask] = p[mask&gt;&gt;1] * (mask&amp;1?-1:1);  rep(pos,x[0],x[k-1]+n+1){ // 第二维滚动    per(mask,0,1&lt;&lt;k) { // 第一维 bitmask 注意顺序      rep(i,0,k) if(mask&amp;(1&lt;&lt;i)) { // 变成递推贡献, 要增加的bit位        if(x[i]&lt;=pos &amp;&amp; pos&lt;=x[i]+n) { // 保证 binom 不为0          // f(S) += f(S\i) * binom(n, pos - x[S_i]) * (-1)^count(S,&gt;i)          dp[mask] += dp[mask^(1&lt;&lt;i)] * f[pos-x[i]] * p[mask&gt;&gt;(i+1)];        }      }    }  }  printf(&quot;%d\n&quot;,(dp[(1&lt;&lt;k)-1] / ((mint)2).pow(k*n)).val()); // 频次/总次数 = 概率  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>G</p><p>贪心完全不会</p><p>题解说有个cow game</p><p>有一些 dj-di &lt;= wij 的限制</p><p>寻找最大的 dT-dS, 可以变成最短路问题</p><p><a href="http://poj.org/problem?id=3169" target="_blank" rel="noopener">http://poj.org/problem?id=3169</a></p><p>H</p><p>学了一下LGV引理, 和其思路细节</p><p>路径不相交问题首选逆序对容斥，那么可以套用 LGV 引理</p><p>相关练习: <a href="https://www.luogu.com.cn/problem/P7736" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P7736</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://atcoder.jp/contests/abc216/editorial" target="_blank" rel="noopener">官方题解</a></p><p><a href="https://yexiaorain.github.io/Blog/2022-07-22-LGVlemma/">LGV引理</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;G(贪心,差分约束,最短路)H(LGV引理,状压dp)&lt;/p&gt;
&lt;h1 id=&quot;G-01Sequence&quot;&gt;&lt;a href=&quot;#G-01Sequence&quot; class=&quot;headerlink&quot; title=&quot;G - 01Sequence&quot;&gt;&lt;/a&gt;G - 01Sequenc
      
    
    </summary>
    
      <category term="Atcoder" scheme="http://yexiaorain.github.io/Blog/categories/Atcoder/"/>
    
    
      <category term="贪心" scheme="http://yexiaorain.github.io/Blog/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="差分约束" scheme="http://yexiaorain.github.io/Blog/tags/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/"/>
    
      <category term="最短路" scheme="http://yexiaorain.github.io/Blog/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
      <category term="LGV引理" scheme="http://yexiaorain.github.io/Blog/tags/LGV%E5%BC%95%E7%90%86/"/>
    
      <category term="状压dp" scheme="http://yexiaorain.github.io/Blog/tags/%E7%8A%B6%E5%8E%8Bdp/"/>
    
  </entry>
  
  <entry>
    <title>Atcoder abc215</title>
    <link href="http://yexiaorain.github.io/Blog/2022-07-31-ac_abc215/"/>
    <id>http://yexiaorain.github.io/Blog/2022-07-31-ac_abc215/</id>
    <published>2022-07-30T20:25:14.000Z</published>
    <updated>2022-08-12T03:23:03.827Z</updated>
    
    <content type="html"><![CDATA[<p>G(概率论,组合数,期望,贡献统计)H(二分图,霍尔定理,SOSDP,子集反演)</p><h1 id="G-Colorful-Candies-2"><a href="#G-Colorful-Candies-2" class="headerlink" title="G - Colorful Candies 2"></a>G - Colorful Candies 2</h1><p>N 个 有色糖果,第i个颜色c[i]</p><p>从中选K个有 binom(N,K)种方案</p><p>等概率选一种方案</p><p>价值=所选的颜色的不同的数量</p><p>对于每个 k= 1…N 求期望价值</p><p>mod 998244353</p><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>N 5e4</p><p>c[i]  [1,1e9]</p><p>4s</p><p>1024mb</p><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>首先只关心不同值,显然c[i]可以离散化到[1..N]</p><p>答案 = sum{价值} / binom(N,K)</p><p>不同颜色互不影响</p><p>所以 选了j种颜色, 一共k个, 如果能算方案出来 f(j), 那么答案 = sum j * f(j)</p><p>指定的 c[…] 中选的话</p><p>似乎可以卷积</p><p>去表示每个颜色 选t个的方案数, 然后卷积意义是前 j 种颜色(可能有的不选) 选k个的方案数</p><p>好像无法获得选了几个颜色</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>反过来, 也就是每个颜色出现一次的概率 的贡献和</p><p>P(出现一次) = 1-P(一次都不出现)</p><p>binom(n-x,k) / binom(n,k) , 也就是x 是这个颜色的个数</p><p>其中 n-x &lt; k 的话, 必定出现p = 1</p><p>(binom(n,k) - binom(n-x,k))/binom(n,k) , 也就是x 是这个颜色的个数</p><p>可以减少计算</p><p>注意到 可以统计个数为x的有多少个, 这样最多 $\sqrt(N)$个统计</p><p>因此对于k来讲,是$O(\sqrt{N})$的</p><p>总的便是$O(N^{\frac{3}{2}})$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc215/submissions/33712411" target="_blank" rel="noopener">https://atcoder.jp/contests/abc215/submissions/33712411</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;#include &lt;atcoder/all&gt;using mint = atcoder::modint998244353;using namespace std;typedef long long ll;const int MOD = 998244353;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readint c[50010];mint fac[50010] = {1};mint invv[50010] = {0,1};mint invfac[50010] = {1};mint binom(int n,int m){  if(m &gt; n) return 0;  return fac[n] * invfac[m] * invfac[n-m];}int main(){  int n = read();  rep(i,0,n) c[i] = read();  rep(i,1,n+1) fac[i] = fac[i-1] * i;  invv[1] = 1;  rep(i,2,n+1) invv[i] = (MOD - MOD/i) * invv[MOD%i];  rep(i,1,n+1) invfac[i] = invfac[i-1] * invv[i];  sort(c,c+n);  vector&lt;int&gt; sz = {1};  rep(i,1,n){    if(c[i] != c[i-1]){      sz.push_back(1);    }else{      sz.back()++;    }  }  sort(sz.begin(),sz.end());  vector&lt;pair&lt;int,int&gt;&gt; sc; // size count  int cnt = 0;  rep(i,0,sz.size()){    cnt++;    if(i+1 == (int)sz.size() || sz[i] != sz[i+1]){      sc.push_back({sz[i],cnt});      cnt = 0;    }  }  rep(k,1,n+1){    mint bnk = binom(n,k);    mint ans = bnk * sz.size() ;    for(auto [s,t]:sc) {      if(n-s &lt; k) break; // n-s &lt; k 的话, 必定出现p = 1      ans -= binom(n-s,k) * t; // * 次数    }    ans /= bnk;    printf(&quot;%d\n&quot;,ans.val());  }  return 0;}</code></pre><h1 id="G-Cabbage-Master"><a href="#G-Cabbage-Master" class="headerlink" title="G - Cabbage Master"></a>G - Cabbage Master</h1><p>N种菜,每种 A[i] 个</p><p>M个需求, 每个需求B[i] 个, 但是限制<code>c[i][j] = 0/1</code> 表示第i个需求 是否允许得到 第j种菜</p><p>如果 能满足所有需求则 成功</p><p>现在要尽量少的删除一些菜的个数, 让它无法成功</p><p>并且求, 删除同样数量的方案数  mod 998244353</p><h2 id="限制-1"><a href="#限制-1" class="headerlink" title="限制"></a>限制</h2><p>n 20</p><p>m 1e4</p><p>a[i] 1e5</p><p>b[i] 1e5</p><p>3s</p><p>1024mb</p><h2 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h2><p>一眼感觉网络流, 但是看着这n这么少</p><p>又觉得说 会不会是 maskdp</p><p>2^20 = 1048576, 大概1e6</p><hr><p>网络流思路</p><p>就是 S -&gt; Ini 流量 A[i]</p><p>Ini -&gt; Outj 流量无限 如果<code>c[i][j] == 1</code></p><p>Outj -&gt; T 流量B[i]</p><p>那么目标是让最小割(最大流) &lt;= sum B[i] 即可</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>二分图</p><p>左侧N个颜色, 右侧M个需求</p><p>注意到 这里成功对应的是 匹配 = sum 右侧</p><p>所以是枚举右侧的的点集,看对应左侧的点集是否大于等于右侧</p><p>左侧L, 右侧R</p><p>要能完美匹配 $\forall S \subset R $</p><p>左侧对应集合并的和 $\ge S$对应需求的和</p><p>即 min (左侧对应集合并的和 - S对应需求的和) &gt;= 0</p><hr><p>n=20, 考虑枚举左侧的并,来找右侧的max</p><p>但似乎通过枚举子集可能有m 2^n 复杂度</p><p>但实际上我们要的是</p><p>min {f(L0) - g(L0)} &gt;= 0, 其中f 算的集合里左侧的和, g 算的映射到左侧包含于集合的右侧的值的和 (既然B[i] 都是正的,那就是所有的加起来让g达到最大</p><p>g中计算 子集和可以sosdp 高维前缀和</p><p>那么删除数量X = min( f(L0) - g(L0)) + 1</p><hr><p>然后问题变成如何计算方案数</p><p>ans = 0 , 不操作1种</p><p>对于ans &gt; 0</p><p>设 左侧移除的X的值 来自的点集合恰好为S</p><p>当存在 S1 满足 S 是 S1 的子集, 且 f(L0) - g(S1) + 1 == X, 这时 S移除X的方案数h(S) 会有贡献</p><p>binom(S的个数,X) = sum h(T), T 是S的子集</p><p>这就是 子集反演问题</p><p>$h(S) = \sum (-1)^{|S|-|T|} binom(T的个数,X)$, T是S的子集</p><p>又是求子集的函数和, 那么这里把和原集合有关的移动一下</p><p>$(-1)^{|S|} {h(S)} = \sum (-1)^{|T|} \binom{f(T)}{X}$, T是S的子集</p><p>同样FWT, SOSDP可以处理</p><h2 id="霍尔-Hall-定理"><a href="#霍尔-Hall-定理" class="headerlink" title="霍尔(Hall)定理"></a>霍尔(Hall)定理</h2><p>二分图 左侧n点 右侧 m 点, n&lt;= m</p><p>二分图的最大匹配个数=|n| 的充要条件, 左侧点n的任意大小(=k)的子集连到右图的点的个数都满足&gt;=k</p><p>必要性, 因为最大匹配=|n|,所以存在一个方案, 任意左侧子集(=k)的方案对应右侧的点都是k, 所以连接的一定 &gt;= k</p><p>充分性, 归纳法, 显然 n = 1时 成立</p><p>如果n时成立</p><p>对于n+1个点</p><p>假设存在k(&lt;=n)个左侧点对应可达右侧刚好是k个, 那么存在一组匹配</p><p>注意到左侧 n+1对应 右侧&gt;=n+1, 那么从左右分别去掉上面的k个</p><p>那么左侧n+1-k, 右侧 &gt;=n+1-k, 归纳有方案</p><hr><p>如果上述不存在, 则所有k(&lt;=n)个左侧 对应的是 &gt;= k+1个右侧</p><p>那么 任意取一个匹配, 那么剩下的n个左点对应的右点 &gt;= k 个, 所以归纳成立</p><h2 id="子集反演"><a href="#子集反演" class="headerlink" title="子集反演"></a>子集反演</h2><p>$g(S) = \sum f(T)$, T是S的子集合</p><p>$f(S) = \sum (-1)^{|S| - |T|} g(T)$ , T是S的子集合</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc215/submissions/33719233" target="_blank" rel="noopener">https://atcoder.jp/contests/abc215/submissions/33719233</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;#include &lt;atcoder/all&gt;using mint = atcoder::modint998244353;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readconst ll INF = 0x3f3f3f3f; // &gt; 1e9const int N = 20;const int MASK = ( 1 &lt;&lt; N ) ;const int M = N * 100000;mint fac[M+10] = {1}; // 阶乘mint ifac[M+10] ={1}; // 阶乘的逆向int f[MASK+10]; // f[1 &lt;&lt; i] = A[i], f[mask] = sum Aint g[MASK+10]; // g[左侧mask] = sum B , 通过sosdp 变成子集和mint h[MASK+10]; // h(S=bitmask) S中移除 X 个的方案数,(每个恰好一个)int cnt[MASK+10]; // mask 中1的个数int cont[MASK+10]; // cont[mask] = 多少个父集合 是满足 最小代价为X的 在mask中移除让Hall定理触发不满足int B[M+10]; // 读入int adj[M+10]; // adj[右侧] = 左侧的bitmaskmint binom( int n, int m ) { return n &lt; m ? 0 : fac[n] * ifac[m] * ifac[n - m]; }int main() {  rep(i,1,M+1) fac[i] = fac[i - 1]*i;  ifac[M] = fac[M].inv();  per(i,0,M) ifac[i] = ifac[i + 1]*(i + 1);  int n = read();  int m = read();  rep(i,0,n)f[1 &lt;&lt; i]=read();//f[1 &lt;&lt; i]=A[i]  rep(j,0,m)B[j]=read();  rep(i,0,n)rep(j,0,m) if(read())adj[j]|=1 &lt;&lt; i; // 转换成mask  rep(j,0,m)g[adj[j]] += B[j]; // g[对应左侧mask] += B[j]  rep(mask,1,1 &lt;&lt; n) cnt[mask] = cnt[mask &gt;&gt; 1] + ( mask &amp; 1 ); // 计算1个数  rep(mask,1,1 &lt;&lt; n) f[mask] = f[mask&amp;(-mask)] + f[mask&amp;(mask-1)]; // 去掉最后一个1 和最后一个1的mask之和  rep(pwr,0,n) rep(mask,1,1 &lt;&lt; n) if(mask &amp; (1 &lt;&lt; pwr)) g[mask] += g[mask ^ (1 &lt;&lt; pwr)]; // sosdp 高维前缀和  rep(mask,0,1 &lt;&lt; n) if(!g[mask]) g[mask] = -INF; // 右侧没有集合对应左侧集合是mask的子集合  int X = INF; // 答案第一部分 删除个数  rep(mask,1,1 &lt;&lt; n) X = min(X,f[mask]-g[mask]+1 ); // Hall定理, min(左子集值和 - 右侧来源子集和)  if(max(X,0) == 0) { // 本来就不合法    printf( &quot;0 1\n&quot; );    return 0;  }  // h&#39;(S) = (-1)^|S| h(S) = sum (-1)^|T| binom(f[t], X) SOSDP  rep(mask,1,1 &lt;&lt; n) h[mask] = binom(f[mask], X) * (cnt[mask] &amp; 1 ? -1 : 1);  rep(pwr,0,n) rep(mask,0,1 &lt;&lt; n) if(mask &amp; (1 &lt;&lt; pwr)) h[mask] += h[mask ^ (1 &lt;&lt; pwr)];  rep(mask,0,1 &lt;&lt; n) h[mask] = h[mask] * ((cnt[mask] &amp; 1)?-1:1);  // SOSDP 父集合反演(本质上还是 子集反演, 你只是把每个mask 看成mask的取反即可, 最外层是pwr顺序, mask每次之间没有链式依赖,都是两两依赖, 所以mask不需要换顺序  rep(mask,1,1 &lt;&lt; n) if( f[mask] - g[mask] + 1 == X ) cont[mask] = 1;  rep(pwr,0,n) rep(mask,0,1 &lt;&lt; n) if(mask &amp; (1 &lt;&lt; pwr)) cont[mask ^ (1 &lt;&lt; pwr)] += cont[mask]; // 统计父集合可行的次数  mint ans = 0;  rep(mask,0,1 &lt;&lt; n) if(cont[mask]) ans += h[mask];  printf(&quot;%d %d\n&quot;,X, ans.val());  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>G</p><p>其实还算基础知识点, 如何批量算模拟元,批量阶乘和阶乘模逆元,如何基于它们快速bionom</p><p>然后就是概率统计变形状和相同次数统计变成$\sqrt{N}$</p><p>评分 2267 也差不多</p><p>H</p><p>二分图,霍尔(Hall)定理</p><p>二分图一定程度上, 就不在意初始设计的方向了,  因为是匹配, 内部是没有关系的</p><p>霍尔定理对于这种大于1流量的也适用(因为从本质上看 左/右侧最多k个, 无非是k个点, 有无穷大边, 无非是这些拆开后的左右侧按照原来的关系两两有边, 而这个思路是不是特殊题型还能反过来思考)</p><p>这种”任意”的条件，可以考虑是在哪个部分将它破坏的</p><p>还涉及到 子集反演(以及用子集反演完成父集合反演)</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://atcoder.jp/contests/abc215/editorial" target="_blank" rel="noopener">官方题解</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;G(概率论,组合数,期望,贡献统计)H(二分图,霍尔定理,SOSDP,子集反演)&lt;/p&gt;
&lt;h1 id=&quot;G-Colorful-Candies-2&quot;&gt;&lt;a href=&quot;#G-Colorful-Candies-2&quot; class=&quot;headerlink&quot; title=&quot;G - 
      
    
    </summary>
    
      <category term="Atcoder" scheme="http://yexiaorain.github.io/Blog/categories/Atcoder/"/>
    
    
      <category term="图" scheme="http://yexiaorain.github.io/Blog/tags/%E5%9B%BE/"/>
    
      <category term="dp" scheme="http://yexiaorain.github.io/Blog/tags/dp/"/>
    
      <category term="网络流" scheme="http://yexiaorain.github.io/Blog/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
      <category term="scc" scheme="http://yexiaorain.github.io/Blog/tags/scc/"/>
    
      <category term="二分图" scheme="http://yexiaorain.github.io/Blog/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    
      <category term="排列" scheme="http://yexiaorain.github.io/Blog/tags/%E6%8E%92%E5%88%97/"/>
    
      <category term="容斥" scheme="http://yexiaorain.github.io/Blog/tags/%E5%AE%B9%E6%96%A5/"/>
    
      <category term="环" scheme="http://yexiaorain.github.io/Blog/tags/%E7%8E%AF/"/>
    
      <category term="费用流" scheme="http://yexiaorain.github.io/Blog/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/"/>
    
      <category term="霍尔定理" scheme="http://yexiaorain.github.io/Blog/tags/%E9%9C%8D%E5%B0%94%E5%AE%9A%E7%90%86/"/>
    
      <category term="SOSDP" scheme="http://yexiaorain.github.io/Blog/tags/SOSDP/"/>
    
      <category term="子集反演" scheme="http://yexiaorain.github.io/Blog/tags/%E5%AD%90%E9%9B%86%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
  <entry>
    <title>Atcoder abc214</title>
    <link href="http://yexiaorain.github.io/Blog/2022-07-30-ac_abc214/"/>
    <id>http://yexiaorain.github.io/Blog/2022-07-30-ac_abc214/</id>
    <published>2022-07-29T20:25:14.000Z</published>
    <updated>2022-08-12T03:23:03.823Z</updated>
    
    <content type="html"><![CDATA[<p>G(排列,图,容斥,dp,环)H(scc,网络流,费用流)</p><h1 id="G-Three-Permutations"><a href="#G-Three-Permutations" class="headerlink" title="G - Three Permutations"></a>G - Three Permutations</h1><p><a href="https://atcoder.jp/contests/abc214/tasks/abc214_g" target="_blank" rel="noopener">https://atcoder.jp/contests/abc214/tasks/abc214_g</a></p><p>给[1..N]的排列p和q</p><p>求多少个排列r 满足 r[i] != p[i] , r[i] != q[i], i = [0..N]</p><p>mod 1e9+7</p><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>n 3000</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h3><p>如果只是给一个排列p</p><p>要找另一个排列r让每个位置对应不等(r[i] != p[i])</p><p>一个想法是, 把它直接按照p[i]的1到n重新排序</p><p>问题变成了 找r[i] != i的排列方案数</p><p>考虑长度n的和n-1之间变化</p><p>如果i放的n,而n放的i ,那么 去掉i和n, 方案数 为f(n-2)</p><p>n 有 n-1中交替放的方案, (n-1) f(n-2)</p><p>如果i放的n,而n放的不是i, 那么,交换i和n放的, 前n-1也合法, f(n-1)</p><p>f(n-1) 每个方案每个位置和n换, 贡献(n-1)f(n-1)</p><p>f(n) = (n-1)(f(n-1) + f(n-2))</p><p>f(1) = 0</p><p>f(2) = 1</p><p>f(3) = 2(1+0) = 2</p><hr><p>那么对于两个序列</p><p>首先一样的思路按照p 来排序</p><p>那么变成 r[i] != q[i], r[i] != i</p><p>但因为q[i]的限制并不能 像上面那样转移</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>如果对于每个位置,计算ri=pi或ri=qi的排列方案数,可以考虑容斥</p><p>假设 i1,i2,…ik, 对应的下标满足, ri=pi 或 ri=qi, 那么要计算所有r[i1],r[i2]..r[ik]的值方案</p><p>对于每个 i in i[1..k],在图中,我们增加一个(pi,qi)的边, 只需计算每条边分配给其一个端点的总数，以便没有两条不同的边共享一个分配给它的顶点。(意思就是边即是i, 而给边分配的点,即是r[i]的值, 不能共享点,意味着值不重复</p><p>(注意到 如果(pi,qi)链接的话, 只可能是 链 或 环,不可能出现分叉</p><p>对于每个联通分量考虑(除去孤立点和自环)</p><p>因为环之间两两不相关, 所以每一组i的选择答案 = 不同环的方案的乘积</p><p>我们对于一个K个点的环内, 选了k条边, 的方案数</p><p>当所有边被选(所有的i都有相等关系), 那么有2种方案</p><p>不是全部都选, 考虑把环剖成链讨论首尾是否选择</p><hr><p><code>dp[i][j][s0=0/1/2][si=0/1/2]</code> 表示前i条边,选择了j条, 且第一条是s0 状态,第i条是si状态的方案数</p><p>0: 未选择</p><p>1: 该边分配了左点</p><p>2: 该边分配了右点</p><p>状态转移</p><p>不选 <code>dp[i][j][s0][0] = sum dp[i-1][j][s0][0..2]</code></p><p>向左 <code>dp[i][j][s0][1] = sum dp[i-1][j-1][s0][0..1]</code></p><p>向右 <code>dp[i][j][s0][2] = sum dp[i-1][j-1][s0][0..2]</code></p><p>这样最后长n的环选了k条链的总方案数 就是<code>sum dp[n][k][s0][s1], 且 (s0 != 1 || s1 != 2)</code></p><p>记为<code>circle[n][k]</code></p><hr><p>如果gi 表示 指定了i个不合法的选择, 剩余的n-i个任意选(可以合法也可以不合法,但始终满足是排列)</p><p>那么 $ans = \sum_{i=0}^n (-1)^i(n-i)! g_i$</p><hr><p>而gi也可以通过上面环的结果, 去做dp</p><p><code>f[i][k] =</code> 前i个环指定了k个边 的方案数</p><p><code>f[i][k] = sum{f[i-1][k-t] * circle[sz[i]][t]}</code> 前i个环指定了k个边 的方案数</p><hr><p>于是把所有环剖成链连续放在数组上</p><p><code>g[i][j][s0][s1]</code> = 前i边,指定分配了j条, i所在环的起始是s0,结束是s1的方案数, 这里也是把s0也与i做相关意义了</p><p>转移类似, 分别是跨环转移 和 环内转移</p><hr><p>感觉这题还可以改控制最大环长, 但增大总长度, 变成矩阵乘法</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc214/submissions/33643608" target="_blank" rel="noopener">https://atcoder.jp/contests/abc214/submissions/33643608</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;#include &lt;atcoder/all&gt;using namespace std;using mint = atcoder::modint1000000007;#define rep(i,a,n) for (int i=a;i&lt;(int)n;i++)int read(){int r;scanf(&quot;%d&quot;,&amp;r);return r;} // readconst int N = 3000;int p[N+10];int q[N+10];int e[N+10]; // 单向边int vis2[N+10]; // 每个环的结束位置 = 1, 例如环为 2 3 5, 那么 [2]=1,[2+3=5]=1,[5+5=10]=1, 自环结束位置=2// 0 不分配, 1 分配左点, 2分配右点mint g[N+10][N+10][3][3]; // [i][j][s0][si] 每个环剖成链以后,长度i的链 分配了j条, 当前环 首个点state 0, 最后一个点stateimint fac[N+10]; // n!int main() {  int n=read();  fac[0]=1;  rep(i,1,n+1) fac[i]=fac[i-1]*i;  rep(i,0,n) p[i] = read();  rep(i,0,n) e[p[i]] = q[i] = read(); // 建立边 p,q =&gt; e  { // e =&gt; vis2    vector&lt;bool&gt; vis(n+1,false); // 点是否被访问    int m = 0;    rep(i,1,n+1) if(!vis[i]){      if(e[i]==i) { // 自环        vis2[++m]=2;        continue;      }      for(int j=i;!vis[j];j=e[j]) {        vis[j]=1;        m++;      }      vis2[m]=1;    }  }  g[0][0][0][0] = 1; // 初始状态  vis2[0] = 1;       // 初始状态  rep(i,0,n+1) rep(j,0,i+1){ // 剖成链, 前i个边, 指定j个不合法, 第i个点所在环首个点s0,第i个点s1状态    if(vis2[i]) { // 环结束位置      g[i][j][1][2] = 0; // 环首为向左环尾向右      if(vis2[i]==2) g[i][j][1][1]=0; // 自环, 不选是一种, 选左和选右相同, 去掉一个      rep(k,0,3) rep(l,0,3) { // i+1 是新的环        auto v = g[i][j][k][l];        g[i+1][j  ][0][0] += v; // 新环 本身与i 无关, 应该是1,这里相当于全部乘上前面的倍数        g[i+1][j+1][1][1] += v;        g[i+1][j+1][2][2] += v;      }    } else { // 环内      rep(k,0,3) rep(l,0,3){        auto v = g[i][j][k][l];        g[i+1][j  ][k][0] += v;        g[i+1][j+1][k][1] += ((l == 2) ? 0 : v); // 不能下一个向左 这一个向右        g[i+1][j+1][k][2] += v;      }    }  }  mint res = 0;  rep(i,0,n+1) {    mint cnt = 0; // 方案数    rep(j,0,3) rep(k,0,3) cnt += g[n][i][j][k];    res += fac[n-i]*cnt*(i%2?-1:1); // 容斥  }  printf(&quot;%d&quot;,res.val());  return 0;}</code></pre><h1 id="H-Collecting"><a href="#H-Collecting" class="headerlink" title="H - Collecting"></a>H - Collecting</h1><p><a href="https://atcoder.jp/contests/abc214/tasks/abc214_h" target="_blank" rel="noopener">https://atcoder.jp/contests/abc214/tasks/abc214_h</a></p><p>有向图 N点, M边</p><p>xi个东西在点i上</p><p>k个人一个一个遍历graph</p><p>1开始, 遍历有限长度, 找最大可被收集的东西个数</p><h2 id="限制-1"><a href="#限制-1" class="headerlink" title="限制"></a>限制</h2><p>n2e5, m 2e5</p><p>k 10</p><p>xi [1..1e9]</p><p>4s</p><p>1024mb</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h3><p>显然 可以scc缩点, 然后问题变成 一个有向无环图</p><p>找k(&lt;=10)条路径, 被经过的点的和最大</p><p>这没啥想法了</p><p>例如</p><p>a-&gt;b-&gt;c</p><p>a-&gt;b-&gt;d</p><p>a-&gt;e-&gt;d</p><p>a-&gt;e-&gt;f</p><p>一次选择的贪心 是否对全局也是最好的?</p><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>果然也是先scc变成DAG</p><p>然后这里是最小费用流问题</p><ol><li>DAG每个点拆成out,in, 增加源S和汇T</li><li>DAG中每个u, 增加 in[u] -&gt; out[u], 流量1, 费用-val<a href="首次经过点">u</a>, 以及无限(K)流量费用0</li><li>DAG中(u,v)变成 out[u] -&gt; in[v] , 流量无限(K), 费用0</li><li>S -&gt; in[1] 容量k, 费用0 ( 这里可以简化成去掉S, 1 作为S, 通过 in[1] -&gt; out[1] 总容量k 来保证最大流 = K</li><li>out[u] -&gt; T 容量无限(k), 费用0</li></ol><p>求min cost max flow , 答案乘上 -1</p><p>我看atcoder的库是可以限制最大流的求 mincost</p><hr><p>然后这样做的话 代价有些是负的</p><p>办法是</p><ol><li>DAG中每个u, in[u] -&gt; out[u], 流量1费用0, 流量无限(费用val[u])</li><li>DAG中(u,v), out[u] -&gt; in[v], 无限流量, 费用sum X[u+1..v-1]</li><li>out[u] -&gt; T, 无限流量, 代价sum X[u+1..N]</li></ol><p>ans = s-&gt;t 流=K 的最小代价 - K * sum X</p><hr><p>原理</p><p>本质上希望每个流的代价增加 sum X</p><p>那么整体形式就是 从 in[u0] -&gt; out[u0] -&gt; in[v1] -&gt; out[v1] -&gt; T</p><p>希望  每次到out[u] 的时候, 费用和的增量是 前缀和X[0..u], 这样每个 out[u] -&gt; T, 只需要是X[0..n] - X[0..u] 即可</p><p>那么自然 out[u]-&gt; in[v] -&gt; out[v]</p><p>这一整段增加为 X[0..v] - X[0..u] // 保证拓扑序 来让它非负? atcoder的scc返回保证了逆向拓扑序!!</p><p>那么, 这里设计 in[v] -&gt; out[v] 增加X[v]</p><p>所以 out[u] -&gt; in[v] 增加 X[0..v] - X[0..u] - X[v]</p><hr><p>它这个没有拓扑似乎也保证不了 cost非负?</p><p>保证的是没有负环!?</p><p>注意因为没有S所以 链增加的是 X[0..n] - X[0..start]</p><h3 id="费用流-mcmf"><a href="#费用流-mcmf" class="headerlink" title="费用流 mcmf"></a>费用流 mcmf</h3><p>费用流, 每个边有流量限制和每单位费用</p><p>最大流最小费 = 最短路</p><p>最大流最大费 = 最长路</p><p>满足正向单位费用的相反数 = 逆向单位费用</p><p>最小费用以流量的单价作为边权值跑最短路，注意因为不会有负环（否则费用是负无限大）所以用SPFA就可以了</p><p>如果增广路中出现了负环，那么在上一次选择中一定有一条更短的路径。(如果开始就有负环呢？ 那么它说明你图建错了</p><p>最小费用流, 就是在做最大流的时候, 把dfs改成 spfa, 而距离= 路径上单位cost代价之和</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p><a href="https://atcoder.jp/contests/abc214/submissions/33655383" target="_blank" rel="noopener">https://atcoder.jp/contests/abc214/submissions/33655383</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;#include &lt;atcoder/scc&gt;#include &lt;atcoder/mincostflow&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readint main() {  int N = read();  int M = read();  int K = read();  vector&lt;int&gt; A(M), B(M);  atcoder::scc_graph graph(N); // 0-index 点  rep(i,0,M){    A[i] = read() - 1; // 0-index    B[i] = read() - 1;    graph.add_edge(A[i], B[i]);  }  const vector&lt;vector&lt;int&gt;&gt; scc = graph.scc(); // 连通块 atcoder的scc返回还保证了逆拓扑序  const int V = scc.size(); // DAG节点个数  vector&lt;int&gt; belongs(N); // [节点] = 所在块  rep(i,0,V) for(int u : scc[i]) belongs[u] = i;  vector&lt;ll&gt; X(V); // 新图每个点上的值  rep(i,0,N) X[belongs[i]] += read();  vector&lt;ll&gt; accum(V + 1, 0); // 前缀和  rep(i,0,V) accum[i + 1] = accum[i] + X[i];  atcoder::mcf_graph&lt;int, ll&gt; network(2 * V + 1); // in[1]变成 S, T = 2*V  int S = 2*belongs[0];  int T = 2*V;  rep(i,0,V) {    network.add_edge(2 * i, 2 * i + 1, 1, 0); // in[i] -&gt; out[i], 容量1, 费用 -X[i] + X[i]    network.add_edge(2 * i, 2 * i + 1, K, X[i]); // in[i] -&gt; out[i], 容量K(无穷), 费用 0 + X[i]    network.add_edge(2 * i + 1, 2 * V, K, accum[V] - accum[i + 1]); // out[i] -&gt; T 费用 0 + All - X[0..i]  }  rep(i,0,M) {    int u = belongs[A[i]];    int v = belongs[B[i]];    if (u != v) network.add_edge(2 * u + 1, 2 * v, K, accum[v] - accum[u + 1]); // out[u] -&gt; in[v] , 容量k, 费用 0 + X[0..v] - X[0..u]  }  auto [maxflow, mincost] = network.flow(S,T,K/* 限流 */);  printf(&quot;%lld\n&quot;,(accum[V] - accum[belongs[0]]) * K - mincost);}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>G</p><p>容斥还是不熟 感觉这个式子需要记忆 $ans = \sum_{i=0}^n (-1)^i c_i$</p><p>然后这个排列会构成多个环感觉很常用虽然知道, 但是这里通过边表示i, 分配点表示取值还是没有想到, 感觉也是一种转化思路</p><p>然后环拆成链+两头也是很经典的方法了</p><p>实现上把 环变成链 再在数组上连续性, 去做dp的方法, 比多重再算g更神奇</p><p>另外这里递推贡献更新时没有保证正确性, 有的在处理时才修复正确性 比如<code>[1][2]</code> 和自环</p><p>H</p><p>网络流完全不会, 学了一手费用流, 看起来就是正常最大流 变了spfa和 路径cost和</p><p>atcoder 内置的scc 和mincostflow</p><pre><code class="cpp">#include &lt;atcoder/scc&gt;#include &lt;atcoder/mincostflow&gt;</code></pre><p>然后这个神奇的让 所有费用变正的 前缀和变化法 , 感觉其它地方似乎也能用</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://atcoder.jp/contests/abc214/editorial" target="_blank" rel="noopener">官方题解</a></p><p><a href="https://oi-wiki.org/graph/flow/min-cost/" target="_blank" rel="noopener">oi wiki 费用流</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;G(排列,图,容斥,dp,环)H(scc,网络流,费用流)&lt;/p&gt;
&lt;h1 id=&quot;G-Three-Permutations&quot;&gt;&lt;a href=&quot;#G-Three-Permutations&quot; class=&quot;headerlink&quot; title=&quot;G - Three Permu
      
    
    </summary>
    
      <category term="Atcoder" scheme="http://yexiaorain.github.io/Blog/categories/Atcoder/"/>
    
    
      <category term="图" scheme="http://yexiaorain.github.io/Blog/tags/%E5%9B%BE/"/>
    
      <category term="dp" scheme="http://yexiaorain.github.io/Blog/tags/dp/"/>
    
      <category term="网络流" scheme="http://yexiaorain.github.io/Blog/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
      <category term="scc" scheme="http://yexiaorain.github.io/Blog/tags/scc/"/>
    
      <category term="排列" scheme="http://yexiaorain.github.io/Blog/tags/%E6%8E%92%E5%88%97/"/>
    
      <category term="容斥" scheme="http://yexiaorain.github.io/Blog/tags/%E5%AE%B9%E6%96%A5/"/>
    
      <category term="环" scheme="http://yexiaorain.github.io/Blog/tags/%E7%8E%AF/"/>
    
      <category term="费用流" scheme="http://yexiaorain.github.io/Blog/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>Atcoder abc261</title>
    <link href="http://yexiaorain.github.io/Blog/2022-07-29-ac_abc261/"/>
    <id>http://yexiaorain.github.io/Blog/2022-07-29-ac_abc261/</id>
    <published>2022-07-28T20:25:14.000Z</published>
    <updated>2022-08-12T03:23:03.823Z</updated>
    
    <content type="html"><![CDATA[<p>G(dp, 字符串),H/Ex(图,dp,拓扑排序,dij,拆点)</p><h1 id="G-Replace"><a href="#G-Replace" class="headerlink" title="G - Replace"></a>G - Replace</h1><p>字符串S,T包含小写英文</p><p>可以执行k种 操作, 任意次 任意顺序</p><p>第i种 操作: 1代价, 把一个字符Ci 换成 字符串Ai</p><p>问S变成T 的最小代价 或不可能</p><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>|S|&lt;=|T| &lt;= 50</p><p>k &lt;= 50</p><p>|Ai| &lt;= 50</p><p>2s</p><p>1024mb</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h3><p>既然是字符(离散)换成字符串</p><p>那么岂不是 <code>dp[i][j]</code> 表示 S前i 个换成 T前j个</p><p><code>dp[i][j]</code> = <code>dp[i-1][j-k]</code>, <code>s[i] -&gt; T[j-k+1..j]</code> 可行</p><p>那么问题是如何判断可行</p><p>换句话说, 如果我们能算出 <code>T[j-k+1..j]</code> 能否逆向变成<code>s[i]</code> 也是办法</p><p>但是感觉这个会分叉很多</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p><code>dp[i][j][c]</code> = 最小代价<code>T[i..j] =&gt; 字符 c</code></p><p><code>f[i][j][k][l]</code> = 最小代价<code>T[i..j]</code> =&gt; 字符串 <code>A[k][1..l]</code> (这个很关键, 是把字符中前缀设置成状态)</p><pre><code>for i = N -&gt; 1:  for j = i -&gt; N:    计算 f[i][j][k][l], f[i][j][c], f[i][j][k][1]</code></pre><hr><p>计算<code>f[i][j][k][l]</code> 时 (<code>T[i..j] =&gt; A[k][1..l]</code>)</p><p>注意到替换时顺序不会变相当于</p><p>时 (<code>T[i.m][m+1.j] =&gt; A[k][1..l-1] A[k][l]</code>)</p><p>$f[i][j][k][l] = min(f[i][m][k][l-1] + dp[m+1][j][A[k][l]])$</p><hr><p>计算<code>dp[i][j][c] / f[i][j][k][1]</code></p><ol><li>本身就是c字符, i==j, Ti = c, 0</li><li>一步到位 <code>T[i..j] = A[k], C[k] = c</code></li><li>先转换到某个<code>A[k]</code> 再转一步, <code>min(f[i][j][k][|A[k]|]+1),C[k] = c</code></li></ol><p><code>f[i][j][k][1]</code> 从<code>dp[i][j][A[k][1]]</code> 中读即可</p><hr><p>这大概是O(n^4)的状态</p><p><code>O(n^5)</code> 的转移复杂度</p><hr><p>这其中还有一个问题是, 对于A和C都是单个字符的, 你会出现<code>T[i...j] -&gt; c0 -&gt; c1 -&gt; c2</code></p><p>你需要求最短路dij/spfa松弛 即可</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc261/submissions/33608140" target="_blank" rel="noopener">https://atcoder.jp/contests/abc261/submissions/33608140</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;(int)n;i++)#define per(i,a,n) for (int i=n;i--&gt;(int)a;)int read(){int r;scanf(&quot;%d&quot;,&amp;r);return r;} // readconst int INF = 0x3f3f3f3f; // 无穷大const int maxc = &#39;z&#39; - &#39;a&#39;; // 最大字符对应数字vector&lt;int&gt; t;int f[60][60][60][60]; // [l..r] =&gt; a[k][0...i] (prefix(a[k][i]))int dp[60][60][30]; // [l..r] =&gt; char cint c[60] = {maxc + 1}; // 不存在的字符vector&lt;int&gt; a[60]; // c[i] -&gt; a[i];vector&lt;pair&lt;int,int&gt; &gt; c2c; // 单字符映射char tmp[60];int lcStr2VecInt(vector&lt;int&gt; &amp; res){ // lower case string to vector&lt;int&gt;  scanf(&quot;%s&quot;, tmp);  int sz = strlen(tmp);  res.resize(sz);  rep(i,0,sz) res[i] = tmp[i] - &#39;a&#39;; // s 放在 c[0],a[0]  return sz;}void setMin(int &amp;v0,int v1){v0 = min(v0,v1);}int main(){  int ns = lcStr2VecInt(a[0]); // s 放在 c[0],a[0]  int nt = lcStr2VecInt(t); // t  int K = read() + 1; // 包含s  rep(i,1,K){    scanf(&quot;%s&quot;, tmp);    c[i] = tmp[0] - &#39;a&#39;;    if(lcStr2VecInt(a[i]) == 1) c2c.push_back({c[i], a[i][0]});  }  rep(l,0,nt) {    rep(r,l,nt) { // 全部设置为无穷大      rep(k,0,K) rep(i,0,50) f[l][r][k][i] = INF;      rep(c,0,maxc+1) dp[l][r][c] = INF;    }    dp[l][l][t[l]] = 0; // 本身就是字符  }  // --- init ---  per(l,0,nt) rep(r,l,nt){ // T[l..r], 各种顺序都行 保证依赖关系先被运算    rep(k,0,K){      int sz = a[k].size();      rep(i,1,sz){ // T[l..j][j+1..r] = &gt; a[k][0..i-1],a[k][i]        int &amp;v = f[l][r][k][i];        rep(j,l,r) setMin(v, f[l][j][k][i-1] + dp[j+1][r][a[k][i]]);        if(i == sz - 1) setMin(dp[l][r][c[k]], v + 1); // T[i..j] =&gt; a[k] =&gt; c[k]      }    }    // dp[l][r][c]=min(dp[l][r][k][|a[k]|]) + 1 = min(len &gt; 1(上面算了), len = 1) + 1, len = |a[k]|    rep(c,0,maxc+1) for(auto [c0, c1]: c2c) setMin(dp[l][r][c0], dp[l][r][c1] + 1); // 26 次 松弛    rep(k,0,K) setMin(f[l][r][k][0], dp[l][r][a[k][0]]); // 更新 f 中首字母  }  int &amp; ans = f[0][nt-1][0][ns-1];  printf(&quot;%d\n&quot;, ans == INF? -1: ans);  return 0;}</code></pre><h1 id="H-Ex-Game-on-Graph"><a href="#H-Ex-Game-on-Graph" class="headerlink" title="H/Ex - Game on Graph"></a>H/Ex - Game on Graph</h1><p>N点, M边</p><p>有向边 [ui,vi,weight i], 无重边 无自环</p><p>初始,点v上有个棋子</p><p>T和A交替游戏</p><ul><li>如果棋子所在点 没有向外路径 则结束游戏</li><li>如果有路径,任选一个走路径</li></ul><p>T 让weight和尽量小, A让和尽量大</p><p>T(结束游戏优先级 &gt; 和尽量小)</p><p>A(让游戏无限循环优先级 &gt; 和尽量大)</p><h2 id="限制-1"><a href="#限制-1" class="headerlink" title="限制"></a>限制</h2><p>N 2e5</p><p>M 2e5</p><p>Wi [0,1e9]</p><p>2s</p><p>1024mb</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h3><p>并不是有环就一定无限, 例如 <code>a-&gt;b-&gt;c-&gt;d-&gt;a</code></p><p>a连了个有限的, c也连了个更短的有限的</p><p>那么虽然你可以走到b,让对手走到c,这样在走到有限的 会比a直接去到有限的更短</p><p>考虑从叶子反过来, 判断是否有限,感觉bfs或者spfa/dij的感觉</p><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>图上环状dp</p><p><code>dp[x][0]</code> 从x出发 尽量小</p><p><code>dp[x][1]</code> 从x出发 尽量大</p><p><code>dp[x][0] = min (f[y][1] + weight[x][y])</code>, 相当于 反向图的最短路</p><p><code>dp[x][1] = max (f[y][0] + weight[x][y])</code>, 需要所有<code>f[y][0]</code> 被计算后才有意义</p><hr><p>然后就反图+拓扑+dij 就没了???</p><p>我感觉这个条件必要, 但总觉得没有证明到充分</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc261/submissions/33603896" target="_blank" rel="noopener">https://atcoder.jp/contests/abc261/submissions/33603896</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readll dp[2][200010];ll mx[200010]; // 只记录1的, 因为0的直接记录在pq和dp中, 而1的在子节点未完全计算时pq和dp都不会记录int deg[200010]; // 正向图出度, 反向图入度vector&lt;pair&lt;int,int&gt; &gt; g[200010]; // 反向图 v = {u, weight}template &lt;typename T&gt; using minPQ = priority_queue&lt;T,vector&lt;T&gt;, greater&lt;T&gt;&gt;; // 小根堆int main(){  int n = read();  int m = read();  int v = read();// 起点  rep(i,0,2) fill(dp[i],dp[i]+n+1,-1); // 未访问  rep(i,0,m) {    int u = read();    int v = read();    int w = read();    g[v].push_back({u, w});    deg[u] ++;  }  minPQ&lt;array&lt;ll,3&gt;&gt; q; // 小根堆, dij 每次找最小的未达点变为可达 {距离, 0/1, 点}  rep(i,1,n+1) if(deg[i] == 0) rep(j,0,2) q.push({0, j, i}); // dp[0/1][i] 反向入度为0 的节点  while(q.size()) {    auto [d, i, u] = q.top(); q.pop();    if(dp[i][u] != -1) continue; // 计算过    dp[i][u] = d; // 更新值    if(!i) { // dp[0][u] -&gt; dp[1][v]      for(auto [v, w] : g[u]) { // 更新反向边 并更新 deg[v] --        mx[v] = max(mx[v], d + w); // 更新值但是 不一定进入pq dp[x][1] = max (f[y][0] + weight[x][y])        if(--deg[v] == 0) q.push({mx[v], 1, v}); // dp[1][v] 只能所有计算都计算后才有意义      }    } else for(auto [v, w] : g[u]) q.push({d + w, 0, v}); // dp[1][u] -&gt; dp[0][v] dij  }  if(dp[0][v] == -1) printf(&quot;INFINITY\n&quot;);  else printf(&quot;%lld\n&quot;, dp[0][v]);  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>G</p><p>大小只有50的情况, <strong>对字符串中的前缀设计状态</strong>, 从而有dp的状态</p><p>第二就是 小的情况 多次松弛简单也效率满足, 不需要上dij</p><p>H/Ex</p><p>我感觉这个条件必要, 但总觉得没有证明到充分???</p><p>可能关键在于,虽然点上有 0/1两个状态,但实际上这两个状态不相关, 所以其实每个点可以拆点</p><p>这样就变成了路径的逆向dp了, 有环一定不行, 所以关键在这个拆点 -&gt; 变成dij</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://atcoder.jp/contests/abc261/editorial" target="_blank" rel="noopener">官方题解</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;G(dp, 字符串),H/Ex(图,dp,拓扑排序,dij,拆点)&lt;/p&gt;
&lt;h1 id=&quot;G-Replace&quot;&gt;&lt;a href=&quot;#G-Replace&quot; class=&quot;headerlink&quot; title=&quot;G - Replace&quot;&gt;&lt;/a&gt;G - Replace&lt;/h1&gt;
      
    
    </summary>
    
      <category term="Atcoder" scheme="http://yexiaorain.github.io/Blog/categories/Atcoder/"/>
    
    
      <category term="图" scheme="http://yexiaorain.github.io/Blog/tags/%E5%9B%BE/"/>
    
      <category term="dp" scheme="http://yexiaorain.github.io/Blog/tags/dp/"/>
    
      <category term="拓扑排序" scheme="http://yexiaorain.github.io/Blog/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    
      <category term="字符串" scheme="http://yexiaorain.github.io/Blog/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="dij" scheme="http://yexiaorain.github.io/Blog/tags/dij/"/>
    
      <category term="拆点" scheme="http://yexiaorain.github.io/Blog/tags/%E6%8B%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>Atcoder abc213</title>
    <link href="http://yexiaorain.github.io/Blog/2022-07-28-ac_abc213/"/>
    <id>http://yexiaorain.github.io/Blog/2022-07-28-ac_abc213/</id>
    <published>2022-07-27T20:25:14.000Z</published>
    <updated>2022-08-12T03:23:03.823Z</updated>
    
    <content type="html"><![CDATA[<p>F(SA,后缀数组,单调栈)G(bitmask, 集合论, 图, dp, 子集遍历),H/Ex(dp, 卷积, fft, NTT, 分治NTT)</p><h1 id="F-Common-Prefixes"><a href="#F-Common-Prefixes" class="headerlink" title="F - Common Prefixes"></a>F - Common Prefixes</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://atcoder.jp/contests/abc213/tasks/abc213_f" target="_blank" rel="noopener">https://atcoder.jp/contests/abc213/tasks/abc213_f</a></p><p>给长n字符串S</p><p>求其每个位置开始的后缀字符串, 和所有其它后缀字符串的 公共前缀和</p><h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h3><p>n 1e6</p><p>3s</p><p>1024mb</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="官方"><a href="#官方" class="headerlink" title="官方"></a>官方</h3><p>知识点 <a href="http://yexiaorain.github.io/Blog/2022-07-27-sa/">后缀数组 SA</a></p><p>那么对于 后缀i</p><p>它在SA中的位置是 rank[i]</p><p>有高度数组表示 rank[i] 和 rank[i-1]的最长公共前缀</p><p>那么就是 min(height[0..i]]) + min(height[1..i]) +… + min(height[i..i]) + (n-i) + min(height[i+1..i+1]) + .. + min(height[i+1..n])</p><p>直接枚举依然不行</p><p>考虑 可以单调栈维护计算其中一半</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc213/submissions/33587517" target="_blank" rel="noopener">https://atcoder.jp/contests/abc213/submissions/33587517</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 1000000007#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_back#define mp make_pairll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readconst int N = 1000000;char s[N+10]; // readint rk[N+10]; // rankint rk0[N+10]; // 临时int h[N+10]; // heightint sa[N+10]; // SAll pre[N+10]; // 前缀和ll suf[N+10]; // 后缀和int main(){  int n = read();  scanf(&quot;%s&quot;, s);  // sa &amp; rank  iota(sa,sa+n,0);  sort(sa,sa+n,[=](int i,int j){return s[i] &lt; s[j];});  rk[sa[0]] = 0;  rep(i,1,n) rk[sa[i]] = rk[sa[i-1]] + (s[sa[i]] != s[sa[i-1]]);  rep(pwr,0,22){    int w = 1&lt;&lt;pwr;    if(w &gt; n) break;    rep(i,0,n) rk0[i] = rk[i];    auto f = [=](int i){return i &lt; n?rk0[i]:-1;};    sort(sa,sa+n,[=](int i,int j){ return mp(f(i),f(i+w)) &lt; mp(f(j),f(j+w));});    rk[sa[0]] = 0;    rep(i,1,n) rk[sa[i]] = rk[sa[i-1]] + (mp(f(sa[i]),f(sa[i]+w)) != mp(f(sa[i-1]),f(sa[i-1]+w)));  }  // height  int hei = 0;  rep(i,0,n){    if(!rk[i]) continue;    if(hei) hei--;    while(s[i + hei] == s[sa[rk[i]-1] + hei]) hei++;    h[rk[i]] = hei;  }  // 单调栈  {    vector&lt;int&gt; stk = {};    rep(i,1,n) {      while(stk.size() &amp;&amp; h[i] &lt; h[stk.back()]) stk.pop_back();      // h[i] * length + stk[]      int last = stk.size() ? stk.back() : 0;      pre[i] = pre[last] + h[i] * (i - last);      stk.push_back(i);    }  }  {    vector&lt;int&gt; stk = {};    per(i,1,n) {      while(stk.size() &amp;&amp; h[i] &lt; h[stk.back()]) stk.pop_back();      // h[i] * length + stk[]      int last = stk.size() ? stk.back() : n;      suf[i] = suf[last] + h[i] * (last - i);      stk.push_back(i);    }  }  rep(i,0,n) printf(&quot;%lld\n&quot;,(n-i) + pre[rk[i]] + suf[rk[i]+1]);  return 0;}</code></pre><h1 id="G-Connectivity-2"><a href="#G-Connectivity-2" class="headerlink" title="G - Connectivity 2"></a>G - Connectivity 2</h1><p><a href="https://atcoder.jp/contests/abc213/tasks/abc213_g" target="_blank" rel="noopener">https://atcoder.jp/contests/abc213/tasks/abc213_g</a></p><p>无向图</p><p>n 点, m 边</p><p>考虑移除任意条边得到新图G, 有 2^M 种新图G</p><p>对于每个点, 计算在所有新图中, 和1属于同一连通块的个数</p><p>mod 9098244353</p><h2 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h2><p>n 17</p><p>无重边,无自环</p><p>3s</p><p>1024mb</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>显然, n&lt;=17 是个bitmask的题</p><p>2^17 = 131072</p><p>定义mask 为点1所在的联通块, 那么其实状态只有2^16 了</p><p>c[mask] = 包含mask的联通块个数</p><p>cnt[mask] = 边的两个端点都属于mask 的数量</p><p>对于剩下m - cnt[Mask] 条边</p><ul><li>如果端点均不在mask中, 则是否选边对mask没有影响,</li><li>如果端点一个在一个不在不在mask中, 则不可选,否则mask会变化</li></ul><p>导出子图(induced subgraph)是指，由该图顶点的一个子集和该图中两端均在该子集的所有边的集合组成的图。</p><hr><p>dp[S] = S构成连通块时, 内部的选的边端点均属于S的方案数</p><p>$dp[S] = 2^{cnt(S)} - \sum_{1\in T, T\subset S} dp[T] \cdot 2^{cnt(S-T)}$</p><p>所有方案 - 非所有点连通的方案(即是一个包含1的非所有点连通块,以及不包含1的连通块内的点的剩余边随便连)</p><hr><p>那么$ans(x) = \sum_{1\in S,x\in S} dp[S] \cdot 2^{cnt(全集 - S)}$</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc213/submissions/33590273" target="_blank" rel="noopener">https://atcoder.jp/contests/abc213/submissions/33590273</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 998244353#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // read// 2^17 =      65&#39;536// 2^17 =     131&#39;072// 3^16 =  43&#39;046&#39;721// 3^17 = 129&#39;140&#39;163const int N = 1&lt;&lt;17;int f[N+10];int c[N+10]; // 边两端 都属于mask 的数量ll p2[150]={1}; // 2**power , 17 * (17-1)/2 = 136ll ans[20];int main(){  rep(i,1,140) p2[i]=2*p2[i-1]%MOD;  int n = read();  int m = read();  // O(m 2^n)  rep(i,0,m){    int u = read() - 1; // 0-index    int v = read() - 1;    rep(mask,0,p2[n]) if((mask &amp; p2[u]) &amp;&amp; (mask &amp; p2[v])) c[mask]++; // 直接统计mask数量  }  rep(S0,0,p2[n-1]){    int S = 2*S0+1; // S一定要选0    f[S] = p2[c[S]]; // f[S] = 2^c[S] - sum{1\in T,T\subset S} f[T] 2^c[S-T]    for(int T0=S0&amp;(S0-1);S0/* 只有点0 没有真子集*/;T0=(T0-1)&amp;S0){// 真子集遍历 记住复杂度是O(3^n)      int T = 2*T0 + 1; // T一定选0      (f[S] -= f[T] * p2[c[S-T]] % MOD) %= MOD;      if(!T0)break;    }    // S包含0,i ; 时间复杂度 O(n 2^n)    rep(i,1,n) if(S &amp; p2[i]) (ans[i] += f[S]*p2[c[p2[n]-1-S]] % MOD) %= MOD;  }  rep(i,1,n) printf(&quot;%lld\n&quot;, (ans[i]+MOD) % MOD);}</code></pre><h1 id="H-Ex-Stroll"><a href="#H-Ex-Stroll" class="headerlink" title="H/Ex - Stroll"></a>H/Ex - Stroll</h1><p><a href="https://atcoder.jp/contests/abc213/tasks/abc213_h" target="_blank" rel="noopener">https://atcoder.jp/contests/abc213/tasks/abc213_h</a></p><p>N个点</p><p>M 个点对, 连接ui,vi, <code>p[i][d]</code>条路 长度d的路, (d [1,T])</p><p>找从点1开始,点1结束,长度等于T的路径方案数</p><h2 id="范围-2"><a href="#范围-2" class="headerlink" title="范围"></a>范围</h2><p>n 10</p><p>m min(10,n(n-1)/2)</p><p>t 4e4</p><p><code>p[1..m][1..T]</code> \in [0,998244353]</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h3><p>一眼递推</p><p><code>f[u][d] =</code>到u步数为T的方案数</p><p>那么每次找未贡献的最小的<code>d</code></p><p><code>f[v][d+step] += p[边[u &lt;-&gt; v]][step] * f[u][d]</code></p><p>但这样$NT$个状态, 每个状态会更新$MT$个点</p><p>看起来有$O(MNT^2)$</p><h3 id="官方-1"><a href="#官方-1" class="headerlink" title="官方"></a>官方</h3><p><code>dp[u][i]=</code> 1 出发, 长度i, 走到u 方案数</p><p>考虑最后一次转移 从v到u, 走t步</p><p>$dp[u][i] = \sum_{(u,v)\in E} \sum_{t=1}^i dp[v][i-t] * p[e_{u,v}][t]$</p><p>直接NTT依然不行</p><p>因为它们相互依赖</p><p>于是来到了分治NTT</p><hr><p>cdq 分治 + NTT/fft 框架</p><pre><code class="cpp">solve(l..r):  solve(l..mid)  // 计算(l..mid) 对(mid+1..r) 的贡献 , 这一部分将是dp[l..mid] 卷积 g[1..(r-l+1)], fft/ntt nlogn  solve(mid+1..r)</code></pre><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc213/submissions/me" target="_blank" rel="noopener">https://atcoder.jp/contests/abc213/submissions/me</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;#include &lt;atcoder/all&gt;using namespace std;using mint=atcoder::modint998244353;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readll n;ll p[20][40010]; // 系数矩阵mint dp[20][40010];vector&lt;pair&lt;int,int&gt;&gt; e[20];// cdq 分治 [l..r],// 每次分治 [l..mid], 计算[l..mid] 对 [mid+1..r]的贡献, 分治[mid+1..r]// 所以卷积代价 convolution([l..mid] x g[1..(r-l+1)]), ntt n log n, 总 =&gt; logn// 意味着每次分治solve(l..r)结束后,(l..r)的内部的贡献计算完了,(r+1...)的贡献完全没有统计void solve(ll l,ll r) {  if(l==r) return;  ll mid=(l+r)/2;  solve(l, mid);  rep(u,1,n+1) for(auto [v,eid]:e[u]) { // 枚举所有点和边    vector &lt;mint&gt; A = {};    vector &lt;mint&gt; B = {0};    // A[l..mid] , T[1..(r-l+1)], dp[i+1] = dp[i-j] * p[j] = A[i-j-l] * B[j] = C[i-l]    rep(i,l,mid+1) A.pb(dp[u][i]);    rep(i,1,(r-l+1)+1) B.pb(p[eid][i]);    auto C = atcoder::convolution(A,B); // 内部小的暴力 大的 fft    rep(i,mid+1,r+1) dp[v][i]+=C[i-l].val();  }  solve(mid+1,r);}int main() {  n = read();  ll m = read();  ll t = read();  rep(i,0,m) {    ll u = read();    ll v = read();    e[u].pb({v,i});    e[v].pb({u,i});    rep(j,1,t+1) p[i][j] = read();  }  dp[1][0] = 1;  solve(0,t);  printf(&quot;%d\n&quot;,dp[1][t].val());  return 0;}// dp[u][i] = sum{(u,v)\in E} sum{t=1..i} dp[v][i-t] * p[e_{u,v}][t]$</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>F</p><p>知识点 后缀数组 与高度数组</p><p>G</p><p>感觉有点集合论转移的思路,没有类似的练习</p><p>然后就是如何做分类和贡献统计, 这里是按照和1连通的作为一个分类的依据</p><p>分别记录内部方案数, 和 外部方案倍数, 外部倍数相对好算, 而内部方案数 需要dp推导</p><p>所有子集遍历的复杂度是$3^n$ 不是$4^n$</p><p>H</p><p>除了dp还可以数学直接表示到目标点, 从而引申出求和 有卷积</p><p>这里新知识点是分治NTT</p><p>atcoder 提供 atcoder::modint998244353, 以及卷积 atcoder::convolution</p><hr><p>关于Ubuntu 使用, 最简单就是, 克隆下来做个软链接</p><pre><code class="bash">git clone git@github.com:atcoder/ac-library.gitcd /usr/local/include/ # 切换到目录sudo ln -s 克隆路径/atcoder</code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://atcoder.jp/contests/abc213/editorial" target="_blank" rel="noopener">官方题解</a></p><p><a href="https://atcoder.jp/contests/abc213/editorial/2410" target="_blank" rel="noopener">https://atcoder.jp/contests/abc213/editorial/2410</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;F(SA,后缀数组,单调栈)G(bitmask, 集合论, 图, dp, 子集遍历),H/Ex(dp, 卷积, fft, NTT, 分治NTT)&lt;/p&gt;
&lt;h1 id=&quot;F-Common-Prefixes&quot;&gt;&lt;a href=&quot;#F-Common-Prefixes&quot; clas
      
    
    </summary>
    
      <category term="Atcoder" scheme="http://yexiaorain.github.io/Blog/categories/Atcoder/"/>
    
    
      <category term="图" scheme="http://yexiaorain.github.io/Blog/tags/%E5%9B%BE/"/>
    
      <category term="fft" scheme="http://yexiaorain.github.io/Blog/tags/fft/"/>
    
      <category term="dp" scheme="http://yexiaorain.github.io/Blog/tags/dp/"/>
    
      <category term="后缀数组" scheme="http://yexiaorain.github.io/Blog/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"/>
    
      <category term="单调栈" scheme="http://yexiaorain.github.io/Blog/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
      <category term="bitmask" scheme="http://yexiaorain.github.io/Blog/tags/bitmask/"/>
    
      <category term="NTT" scheme="http://yexiaorain.github.io/Blog/tags/NTT/"/>
    
      <category term="SA" scheme="http://yexiaorain.github.io/Blog/tags/SA/"/>
    
      <category term="集合论" scheme="http://yexiaorain.github.io/Blog/tags/%E9%9B%86%E5%90%88%E8%AE%BA/"/>
    
      <category term="子集遍历" scheme="http://yexiaorain.github.io/Blog/tags/%E5%AD%90%E9%9B%86%E9%81%8D%E5%8E%86/"/>
    
      <category term="卷积" scheme="http://yexiaorain.github.io/Blog/tags/%E5%8D%B7%E7%A7%AF/"/>
    
      <category term="分治NTT" scheme="http://yexiaorain.github.io/Blog/tags/%E5%88%86%E6%B2%BBNTT/"/>
    
  </entry>
  
  <entry>
    <title>后缀数组 SA</title>
    <link href="http://yexiaorain.github.io/Blog/2022-07-27-sa/"/>
    <id>http://yexiaorain.github.io/Blog/2022-07-27-sa/</id>
    <published>2022-07-27T02:37:14.000Z</published>
    <updated>2022-08-12T03:23:03.823Z</updated>
    
    <content type="html"><![CDATA[<h1 id="相关内容"><a href="#相关内容" class="headerlink" title="相关内容"></a>相关内容</h1><p>后缀自动机</p><h1 id="最终产物"><a href="#最终产物" class="headerlink" title="最终产物"></a>最终产物</h1><p>一个数组sa 记录下标, 按照后缀字典序排序</p><p>以及需要的话一个记录rank的数组(和sa相反)</p><p><img src="https://oi-wiki.org/string/images/sa1.png" alt="后缀数组"></p><p>h[i] 表示排名为i的和排名为i-1的最长公共前缀长度</p><h1 id="SA"><a href="#SA" class="headerlink" title="SA"></a>SA</h1><p>就是字符串所有后缀, 按照字典序排序</p><p>就是先按照每个位置开始长度为1排序, 变成数值顺序</p><p>再按照长度2的前缀顺序排, 但是此时 不需要原字符串,而直接用算出的数值顺序拼接</p><p>再按照长度4的前缀顺序排, 同上 相当于两个 长度2 的拼接</p><pre><code>for step =&gt; 2 * step:  rank = sort(pair&lt; rank[i],rank[i+step] &gt;)</code></pre><h2 id="例如代码"><a href="#例如代码" class="headerlink" title="例如代码"></a>例如代码</h2><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 1000000007#define rep(i,a,n) for (ll i=a;i&lt;n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backconst int N = 1000000;bool eq(vector&lt;int&gt;&amp; rk, int x,int y,int w){  return rk[x] == rk[y] &amp;&amp; rk[x+w] == rk[y+w];}// 0-index + 基数排序void calcsa(char *s,int n, vector&lt;int&gt; &amp;sa,vector&lt;int&gt; &amp;rk){  const int SIZE = max(512, n+1); // 字符集大小  vector&lt;int&gt;cnt(SIZE, 0); // char 2 count  rk.resize(2*n); // rank: 相等的前缀rank相等, 结束符rank = 0, 所以rank从1开始  sa.resize(n); // 后缀 index  rep(i,0,n) ++cnt[rk[i] = s[i]]; // 计数统计  rep(i,1,SIZE) cnt[i] += cnt[i - 1]; // 计数统计前缀  per(i,0,n) sa[--cnt[rk[i]]] = i; // 当前排序  { // n == 1    auto oldrk = rk;    int p = 0;    rep(i,0,n) {      if (i == 0 || oldrk[sa[i]] != oldrk[sa[i-1]]) p++;      rk[sa[i]] = p;    }  }  // rk = sort({rk[i],rk[i+w]}  for(int w = 1; w &lt; n; w *= 2) {    // 从低位到高位排序, 先排低位 rank[i+w], 再排 rank[i+0]    for(auto d:{w, 0}){      cnt = vector(SIZE,0);      rep(i,0,n) ++cnt[rk[i + d]]; // 所有 i+d 开始的计数统计      rep(i,1,SIZE) cnt[i] += cnt[i - 1];// 前缀和(基数排序      auto idx = sa;      per(i,0,n) sa[--cnt[rk[idx[i] + d]]] = idx[i]; // 保序    }    auto oldrk = rk;    int p = 0;    rep(i,0,n) {      if (i == 0 || oldrk[sa[i]] != oldrk[sa[i-1]] || oldrk[sa[i]+w] != oldrk[sa[i - 1] + w]) p++;      rk[sa[i]] = p;    }  }  rk.resize(n+1);}int main() {  char s[N+10] = &quot;aabaaaab&quot;;  int n = strlen(s) ;  printf(&quot;%d\n&quot;,n);  printf(&quot;%s\n&quot;,s);  vector&lt;int&gt; sa;  vector&lt;int&gt; rank;  calcsa(s, n, sa, rank);  rep(i,0,n) printf(&quot;%d &quot;, sa[i]);  return 0;}</code></pre><h2 id="height-数组"><a href="#height-数组" class="headerlink" title="height 数组"></a>height 数组</h2><p>而h数组, 首次相等的则 = 1</p><p>h[i] = lcp(sa[i],sa[i-1])</p><p>性质</p><p>h[rk[i]] &gt;= h[rk[i-1]] - 1</p><p>设后缀i-1 = “aAB”, a字符,A是h[i-1]对应字符串剩余部分,B是后缀的剩余部分</p><p>那么后缀i = “AB”</p><p>因为后缀i-1 = “aAB” 其实存在 “aAC”, “C &lt; B”, 且”C,B”公共前缀为空字符串</p><p>那么也就说明”AC”也存在</p><p>“AC”, “AB” 之间 如果还有其他的字符串,只能是”AD”形式 “C &lt; D &lt; B”, 那么长度至少为”|A|”, 得证</p><p>所以 可以按照i的顺序暴力算</p><pre><code class="cpp">int k = 0;rep(i,0,n) {  if (rk[i] == 0) continue;  if (k) --k;  while (s[i + k] == s[sa[rk[i] - 1] + k]) ++k;  h[rk[i]] = k;}</code></pre><h2 id="vector-sort-pair版本"><a href="#vector-sort-pair版本" class="headerlink" title="vector + sort + pair版本"></a>vector + sort + pair版本</h2><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 1000000007#define rep(i,a,n) for (ll i=a;i&lt;n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_back// 0-index + vector + sort// sa 下标按照顺序排列// rank 下标对应顺序index// h sa 中相邻后缀 最长公共前缀 h[0] = 0;template&lt;class T&gt;void calc_sa_rank(vector&lt;T&gt;&amp; arr, vector&lt;int&gt; &amp;sa,vector&lt;int&gt; &amp;rank, vector&lt;int&gt;&amp;h){  int n = arr.size();  rank = vector&lt;int&gt;(n,0);  sa = vector&lt;int&gt;(n,0);  iota(sa.begin(),sa.end(), 0);  sort(sa.begin(),sa.end(), [=](int i,int j){return arr[i] &lt; arr[j];});  rep(i,1,n) rank[sa[i]] = rank[sa[i-1]] + !(arr[sa[i]] == arr[sa[i-1]]);  for(int w = 1; w &lt; n; w *= 2) {    auto rank0 = rank;    auto rk = [=](int i){return i &lt; n ? rank0[i] : -1;};    sort(sa.begin(),sa.end(), [=](int i,int j){        return rk(i) != rk(j) ? rk(i) &lt; rk(j) : rk(i+w) &lt; rk(j+w);    });    rank[sa[0]] = 0;    rep(i,1,n) rank[sa[i]] = rank[sa[i-1]] + !(rk(sa[i]) == rk(sa[i-1]) &amp;&amp; rk(sa[i]+w) == rk(sa[i-1]+w));  }  // height  h = vector&lt;int&gt;(n,0);  int k = 0;  rep(i,0,n) {    if (rank[i] == 0) continue;    if (k) --k;    while (arr[i + k] == arr[sa[rank[i] - 1] + k]) ++k;    h[rank[i]] = k;  }}int main() {  char s[100] = &quot;aabaaaab&quot;;  int n = strlen(s) ;  printf(&quot;s:%s\n&quot;,s);  vector&lt;char&gt; arr ;  rep(i,0,n) arr.pb(s[i]);  vector&lt;int&gt; sa;  vector&lt;int&gt; rank;  vector&lt;int&gt; h;  calc_sa_rank(arr, sa, rank, h);  printf(&quot;sa:\n&quot;);  rep(i,0,n) printf(&quot;%d %s\n&quot;, sa[i], s + sa[i]);  printf(&quot;\nrk:\n&quot;);  rep(i,0,n) printf(&quot;%d %s\n&quot;, rank[i], s + i);  printf(&quot;\nhei:&quot;);  rep(i,0,n) printf(&quot;%d &quot;, h[i]);  printf(&quot;\n&quot;);  return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;相关内容&quot;&gt;&lt;a href=&quot;#相关内容&quot; class=&quot;headerlink&quot; title=&quot;相关内容&quot;&gt;&lt;/a&gt;相关内容&lt;/h1&gt;&lt;p&gt;后缀自动机&lt;/p&gt;
&lt;h1 id=&quot;最终产物&quot;&gt;&lt;a href=&quot;#最终产物&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
      <category term="algorithm" scheme="http://yexiaorain.github.io/Blog/categories/algorithm/"/>
    
    
      <category term="SAM" scheme="http://yexiaorain.github.io/Blog/tags/SAM/"/>
    
      <category term="SA" scheme="http://yexiaorain.github.io/Blog/tags/SA/"/>
    
  </entry>
  
  <entry>
    <title>从FFT 到 FWHT 快速沃尔什-阿达玛转换(Walsh Hadamard transform)</title>
    <link href="http://yexiaorain.github.io/Blog/2022-07-26-FWT/"/>
    <id>http://yexiaorain.github.io/Blog/2022-07-26-FWT/</id>
    <published>2022-07-26T14:24:00.000Z</published>
    <updated>2022-08-12T03:23:03.823Z</updated>
    
    <content type="html"><![CDATA[<h1 id="FWHT"><a href="#FWHT" class="headerlink" title="FWHT"></a>FWHT</h1><p>快速沃尔什-阿达玛转换(Fast Walsh-Hadamard transform), 一种广义傅立叶变换(FWHT)</p><h2 id="解决什么问题"><a href="#解决什么问题" class="headerlink" title="解决什么问题"></a>解决什么问题</h2><p>FWHT 是用于解决对下标进行位运算卷积问题的方法</p><p>$c_{i} = \sum_{i=j \bigoplus k}a_{j} b_{k}$</p><p>并且没有fft中会涉及到double</p><hr><p>前置知识 FFT(DFT)</p><p>DFT:</p><p>${\displaystyle {\begin{bmatrix}f_{0}\\f_{1}\\\vdots \\f_{n-1}\end{bmatrix}}={\begin{bmatrix}1&amp;1&amp;1&amp;\cdots &amp;1\\1&amp;\alpha &amp;\alpha ^{2}&amp;\cdots &amp;\alpha ^{n-1}\\1&amp;\alpha ^{2}&amp;\alpha ^{4}&amp;\cdots &amp;\alpha ^{2(n-1)}\\\vdots &amp;\vdots &amp;\vdots &amp;&amp;\vdots \\1&amp;\alpha ^{n-1}&amp;\alpha ^{2(n-1)}&amp;\cdots &amp;\alpha ^{(n-1)(n-1)}\\\end{bmatrix}}{\begin{bmatrix}v_{0}\\v_{1}\\\vdots \\v_{n-1}\end{bmatrix}}.}$</p><h2 id="回顾离散傅立叶与卷积"><a href="#回顾离散傅立叶与卷积" class="headerlink" title="回顾离散傅立叶与卷积"></a>回顾离散傅立叶与卷积</h2><p>核心等式</p><p>$\operatorname{FFT}(a * b) = \operatorname{FFT}(a) \cdot \operatorname{FFT}(b)$</p><p>快速变换, $x$原向量,$N$大小, $idx$ 下标</p><p>$idx \le \frac{N}{2}$</p><p>$f(x,N,idx) = f(even(x),\frac{N}{2},idx) + w^k \cdot f(odd(x),\frac{N}{2},idx)$</p><p>$f(x,N,idx+\frac{N}{2}) = f(even(x),\frac{N}{2},idx) - w^k \cdot f(odd(x),\frac{N}{2},idx)$</p><h2 id="Or-版本-FORT-Fast-or-transform"><a href="#Or-版本-FORT-Fast-or-transform" class="headerlink" title="Or 版本 FORT(Fast or transform)"></a>Or 版本 FORT(Fast or transform)</h2><h3 id="Or卷积-与-ForT"><a href="#Or卷积-与-ForT" class="headerlink" title="Or卷积 与 ForT"></a>Or卷积 与 ForT</h3><p>$c_{i} = \sum_{i = j | k}a_{j} b_{k}$, 这里$|$ 是按位或不是整除</p><p>令$fort[C]_ i = \sum_{i = j|i} A_j$</p><p>$\begin{aligned}<br>fort[a]_ i \cdot fort[b]_ i &amp;= (\sum_{j|i=i} a_j) \cdot (\sum_{k|i=i} b_k) \\<br>&amp;= \sum_{j|i=i} \sum_{k|i=i} a_jb_k \\<br>&amp;= \sum_{(j|k)|i = i} a_jb_k \\<br>&amp;= fort[c]_ i<br>\end{aligned}$</p><p>这证明了 $\operatorname{ForT}(\left(\sum_{i=j | k}a_{j} b_{k}\right)) = \operatorname{ForT}(a) \cdot \operatorname{ForT}(b)$</p><h3 id="快速变换"><a href="#快速变换" class="headerlink" title="快速变换"></a>快速变换</h3><p>下面问题就是如何fast, 如何让快速计算fort和它的逆变换ifort</p><p>快速变换, $x$原向量,$N$大小, $idx$ 下标</p><p>$idx &lt; \frac{N}{2}$</p><p>$f(x,N,idx) = f(x, \frac{N}{2},idx)$</p><p>$f(x,N,idx+\frac{N}{2}) = f(x[0\cdots \frac{N}{2}-1]),\frac{N}{2},idx) + f(x[\frac{N}{2}\cdots N-1],\frac{N}{2},idx)$</p><p>因为本身$fort$的第$i$位就是所有$i$的二进制子集位置的和</p><p>那么对于$idx$ 它的子集一定也是在前半数组中</p><p>那么对于$idx + \frac{N}{2}$ 它的 其实就是最高位多了一个bit, 除了这个bit, 剩余部分和$idx$一样, 所以前半后半都按照$idx$来计算求和即可</p><p>至此完成fast</p><pre><code class="cpp">void ForT(modint *f) {  for (int k = 1; k &lt; n; k *=2){    for (int i = 0; i &lt; n; i += 2*k){      for (int j = 0; j &lt; k; j++){        // f[i+j] = f[i+j];        f[i+j+k] += f[i+j];      }    }  }}</code></pre><h3 id="逆变换"><a href="#逆变换" class="headerlink" title="逆变换"></a>逆变换</h3><p>可以直接参考fast的过程, 每个位置表示它所有bit子集的和, 那么按照反过来, 可以先减去未包含最低的其它子集和bit的值,未包含了低2位bit的其她子集和,…</p><p>显然对于的向量的$v$首个值有 $fort(v)_ 0 = v_0$</p><p>所以 $a_0 = fort(a)_ 0$</p><p>因为 $fort(a)_ 1 = fort(a_0) + fort(a_1)$</p><p>所以 $a_1 = fort(a_1) = fort(a)_ 1 - fort(a_0)$</p><p>同理$idx &lt; \frac{N}{2}$</p><p>$f(x,N,idx) = f(x, \frac{N}{2},idx)$</p><p>$f(x,N,idx+\frac{N}{2}) = f(x[0\cdots \frac{N}{2}-1]),\frac{N}{2},idx) - f(x[\frac{N}{2}\cdots N-1],\frac{N}{2},idx)$</p><pre><code class="cpp">void IForT(modint *f) {  for (int k = 1; k &lt; n; k *=2){    for (int i = 0; i &lt; n; i += 2*k){      for (int j = 0; j &lt; k; j++){        f[i+j+k] -= f[i+j];      }    }  }}</code></pre><hr><p>合并</p><pre><code class="cpp">// Or卷积void ForT(vector&lt;modint&gt; &amp;f,int flag = 1/* 1:正变换,-1:逆变换 */) {  int n = f.size();  for (int k = 1; k &lt; n; k *=2){    for (int i = 0; i &lt; n; i += 2*k){      for (int j = 0; j &lt; k; j++){        f[i+j+k] += flag * f[i+j];      }    }  }}</code></pre><h2 id="And-卷积-Fast-and-transform"><a href="#And-卷积-Fast-and-transform" class="headerlink" title="And 卷积(Fast and transform)"></a>And 卷积(Fast and transform)</h2><p>$c_{i} = \sum_{i = j \&amp; k}a_{j} b_{k}$</p><p>和Or的部分同理</p><ol><li>定义变换$fandt(a)_ i = \sum_{i|j = j} a_j$</li><li>证明 $fandt(a) \odot fandt(b) = fandt(\left(\sum_{i = j \&amp; k}a_{j} b_{k}\right))$</li><li>利用分块关系,实现fast</li></ol><p>最终代码</p><pre><code class="cpp">void FandT(vector&lt;modint&gt; &amp;f, int flag = 1/* 1:正变换,-1:逆变换 */) {  int n = f.size();  for (int k = 1; k &lt; n; k *=2){    for (int i = 0; i &lt; n; i += 2*k){      for (int j = 0; j &lt; k; j++){        f[i+j] += f[i+j+k] * flag;      }    }  }}</code></pre><h2 id="Xor卷积-与-FWHT-Fast-Walsh-Hadamard-transform"><a href="#Xor卷积-与-FWHT-Fast-Walsh-Hadamard-transform" class="headerlink" title="Xor卷积 与 FWHT(Fast Walsh-Hadamard transform)"></a>Xor卷积 与 FWHT(Fast Walsh-Hadamard transform)</h2><p>$\operatorname{FWHT}(\left(\sum_{i=j \bigoplus k}a_{j} b_{k}\right)) = \operatorname{FWHT}(a) \cdot \operatorname{FWHT}(b)$</p><h3 id="定义FWHT"><a href="#定义FWHT" class="headerlink" title="定义FWHT"></a>定义FWHT</h3><p>其实和上面一样,依然是三步,定义转换,证明等式,实现fast</p><p>定义符号 $x\otimes y=\text{popcount}(x \&amp; y) \bmod 2$, 即 $x$位与$y$后的二进制表示的$1$的个数再$\bmod 2$</p><p>有性质$(i \otimes j) \oplus (i \otimes k) = i \otimes (j \oplus k)$</p><p>证明: 对于给定的一位, 如果i中0, 则都贡献0, 如果i中是1, $j,k$对应的是1 则贡献是0 则不贡献, 得证</p><p>定义: $fwht[a]_ i = \sum_{i\otimes j = 0}a_j - \sum_{i\otimes j = 1}a_j$</p><p>那么有:</p><p>$fwht[a]_ i \cdot fwht[b]_ i$</p><p>$\begin{aligned}<br>&amp;= (\sum_{i\otimes j = 0} a_j - \sum_{i\otimes j = 1} a_j)\cdot (\sum_{i\otimes k = 0} b_k - \sum_{i\otimes k = 1} b_k) \\<br>&amp;=\left((\sum_{i\otimes j=0}a_j)(\sum_{i\otimes k=0}b_k)+(\sum_{i\otimes j=1}a_j)(\sum_{i\otimes k=1}b_k) \right)-\left((\sum_{i\otimes j=0}a_j)(\sum_{i\otimes k=1}b_k)-(\sum_{i\otimes j=1}a_j)(\sum_{i\otimes kj=0}b_k)\right)\\<br>&amp;=\sum_{i\otimes(j \oplus k)=0}a_jb_k-\sum_{i\otimes(j\oplus k)=1}a_jb_k \\<br>&amp;=\sum_{i\otimes l = 0}\sum_{l = j \oplus k}a_jb_k-\sum_{i\otimes l = 1}\sum_{l = j\oplus k}a_jb_k \\<br>&amp;= fwht[\left(\sum_{i=j \bigoplus k}a_{j} b_{k}\right)]_ i<br>\end{aligned}$</p><h3 id="Walsh-matrix-and-Hadamard-transform"><a href="#Walsh-matrix-and-Hadamard-transform" class="headerlink" title="Walsh matrix and Hadamard transform"></a>Walsh matrix and Hadamard transform</h3><p>可以看看Walsh矩阵的样子</p><p>${\displaystyle H_{m}={\frac {1}{\sqrt {2}}}{\begin{pmatrix}H_{m-1}&amp;H_{m-1}\\H_{m-1}&amp;-H_{m-1}\end{pmatrix}}}$</p><p>${\begin{aligned}H_{0}&amp;=+{\begin{pmatrix}1\end{pmatrix}}\\H_{1}&amp;={\frac {1}{\sqrt {2}}}\left({\begin{array}{rr}1&amp;1\\1&amp;-1\end{array}}\right)\\H_{2}&amp;={\frac {1}{2}}\left({\begin{array}{rrrr}1&amp;1&amp;1&amp;1\\1&amp;-1&amp;1&amp;-1\\1&amp;1&amp;-1&amp;-1\\1&amp;-1&amp;-1&amp;1\end{array}}\right)\\H_{3}&amp;={\frac {1}{2^{3/2}}}\left({\begin{array}{rrrrrrrr}1&amp;1&amp;1&amp;1&amp;1&amp;1&amp;1&amp;1\\1&amp;-1&amp;1&amp;-1&amp;1&amp;-1&amp;1&amp;-1\\1&amp;1&amp;-1&amp;-1&amp;1&amp;1&amp;-1&amp;-1\\1&amp;-1&amp;-1&amp;1&amp;1&amp;-1&amp;-1&amp;1\\1&amp;1&amp;1&amp;1&amp;-1&amp;-1&amp;-1&amp;-1\\1&amp;-1&amp;1&amp;-1&amp;-1&amp;1&amp;-1&amp;1\\1&amp;1&amp;-1&amp;-1&amp;-1&amp;-1&amp;1&amp;1\\1&amp;-1&amp;-1&amp;1&amp;-1&amp;1&amp;1&amp;-1\end{array}}\right)\\(H_{n})_{i,j}&amp;={\frac {1}{2^{n/2}}}(-1)^{i\cdot j}\end{aligned}}$</p><p>对于 $(1,0,1,0,0,1,1,0)$</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/aa/1010_0110_Walsh_spectrum_%28single_row%29.svg/300px-1010_0110_Walsh_spectrum_%28single_row%29.svg.png" alt="The product of a Boolean function and a Walsh matrix"></p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/58/1010_0110_Walsh_spectrum_%28fast_WHT%29.svg/300px-1010_0110_Walsh_spectrum_%28fast_WHT%29.svg.png" alt="Fast Walsh–Hadamard transform, a faster way to calculate the Walsh spectrum"></p><h3 id="快速变换-1"><a href="#快速变换-1" class="headerlink" title="快速变换"></a>快速变换</h3><p>其实看到了矩阵之间的递推关系 这个表达式就很显然了</p><p>$idx &lt; \frac{N}{2}$</p><p>$f(x,N,idx) = f(x[0,\frac{N}{2}), \frac{N}{2},idx) + f(x[\frac{N}{2},N), \frac{N}{2}, idx)$</p><p>$f(x,N,idx+\frac{N}{2}) = f(x[0,\frac{N}{2}), \frac{N}{2},idx) - f(x[\frac{N}{2},N), \frac{N}{2}, idx)$</p><pre><code class="cpp">void FWHT(vector&lt;modint&gt; &amp;f, int flag = 1 /* 1: 正变换, 1/2: 逆变换*/) {  int n = f.size();  for (int k = 1; k &lt; n; k *=2){    for (int i = 0; i &lt; n; i += 2*k){      for (int j = 0; j &lt; k; j++){        auto U = f[i+j];        auto T = f[i+j+k];        f[i+j]   = U + T;        f[i+j+k] = U - T;        f[i+j] *= flag;        f[i+j+k] *= flag;      }    }  }}</code></pre><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;#include &quot;./modint.cpp&quot;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backusing MODINT::modint;namespace FWT{  void ForT(vector&lt;modint&gt; &amp;f,int flag = 1/* 1:正变换,-1:逆变换 */) {    int n = f.size();    for (int k = 1; k &lt; n; k *=2){      for (int i = 0; i &lt; n; i += 2*k){        for (int j = 0; j &lt; k; j++){          f[i+j+k] += f[i+j] * flag;        }      }    }  }  void IForT(vector&lt;modint&gt; &amp;f) {ForT(f, -1);}  vector&lt;modint&gt; or_convolution(vector&lt;modint&gt; &amp;v0, vector&lt;modint&gt; &amp;v1){    const int sz = v0.size();    ForT(v0);    ForT(v1);    vector&lt;modint&gt; v2(sz,0);    rep(i,0,sz) v2[i] = v0[i] * v1[i];    IForT(v2);    return v2;  }  void FandT(vector&lt;modint&gt; &amp;f, int flag = 1/* 1:正变换,-1:逆变换 */) {    int n = f.size();    for (int k = 1; k &lt; n; k *=2){      for (int i = 0; i &lt; n; i += 2*k){        for (int j = 0; j &lt; k; j++){          f[i+j] += f[i+j+k] * flag;        }      }    }  }  void IFandT(vector&lt;modint&gt; &amp;f) {FandT(f, -1);}  vector&lt;modint&gt; and_convolution(vector&lt;modint&gt; &amp;v0, vector&lt;modint&gt; &amp;v1){    const int sz = v0.size();    FandT(v0);    FandT(v1);    vector&lt;modint&gt; v2(sz,0);    rep(i,0,sz) v2[i] = v0[i] * v1[i];    IFandT(v2);    return v2;  }  modint inv2 = modint(2).inv();  void FWHT(vector&lt;modint&gt; &amp;f, modint flag = 1 /* 1: 正变换, 1/2: 逆变换*/) {    int n = f.size();    for (int k = 1; k &lt; n; k *=2){      for (int i = 0; i &lt; n; i += 2*k){        for (int j = 0; j &lt; k; j++){          auto U = f[i+j];          auto T = f[i+j+k];          f[i+j]   = U + T;          f[i+j+k] = U - T;          f[i+j] *= flag;          f[i+j+k] *= flag;        }      }    }  }  void IFWHT(vector&lt;modint&gt; &amp;f) {FWHT(f, inv2);}  void FxorT(vector&lt;modint&gt; &amp;f,int flag = 1) {FWHT(f, flag);}  void IFxorT(vector&lt;modint&gt; &amp;f) {IFWHT(f);}  vector&lt;modint&gt; xor_convolution(vector&lt;modint&gt; &amp;v0, vector&lt;modint&gt; &amp;v1){    const int sz = v0.size();    FxorT(v0);    FxorT(v1);    vector&lt;modint&gt; v2(sz,0);    rep(i,0,sz) v2[i] = v0[i] * v1[i];    IFxorT(v2);    return v2;  }};void print(vector&lt;modint&gt; &amp;arr){  for(auto &amp;v:arr) printf(&quot;%d &quot;, v.val());  printf(&quot;\n&quot;);}int main(){  // 长度2的幂次  const vector&lt;modint&gt; A0 = {1,2,3,0};  const vector&lt;modint&gt; B0 = {4,5,6,0};  // --- or ---  {    auto A = A0;    auto B = B0;    auto C = FWT::or_convolution(A,B);    print(C);  }  // --- and ---  {    auto A = A0;    auto B = B0;    auto C = FWT::and_convolution(A,B);    print(C);  }  // --- xor ---  {    auto A = A0;    auto B = B0;    auto C = FWT::xor_convolution(A,B);    print(C);  }  return 0;}</code></pre><h2 id="洛谷P4717"><a href="#洛谷P4717" class="headerlink" title="洛谷P4717"></a>洛谷P4717</h2><p><a href="https://www.luogu.com.cn/record/81332363" target="_blank" rel="noopener">https://www.luogu.com.cn/record/81332363</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;n;i++)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // read// ----------- modint -----------namespace MODINT{  const int _mod = 998244353;  class modint{    private:      ll _v;    public:      modint() :_v(0) {  }      modint(ll _a) {        _v = (_a &lt; 0)? _mod - ((-_a) % _mod) : (_a % _mod);      }      int val()const { return _v; }      modint operator+()const { return *this; }      modint operator-()const { return { _mod - _v }; }      modint operator+(const modint&amp; rhs) const { return modint(*this) += rhs; }      modint operator-(const modint&amp; rhs) const { return modint(*this) -= rhs; }      modint operator*(const modint&amp; rhs) const { return modint(*this) *= rhs; }      modint operator/(const modint&amp; rhs) const { return modint(*this) /= rhs; }      bool operator==(const modint&amp; rhs)const { return _v == rhs._v; }      bool operator!=(const modint&amp; rhs)const { return _v != rhs._v; }      bool operator&gt; (const modint&amp; rhs)const { return _v &gt;  rhs._v; }      bool operator&gt;=(const modint&amp; rhs)const { return _v &gt;= rhs._v; }      bool operator&lt;=(const modint&amp; rhs)const { return _v &lt;= rhs._v; }      bool operator&lt; (const modint&amp; rhs)const { return _v &lt;  rhs._v; }      modint&amp; operator+=(const modint&amp; rhs) {        (_v += rhs._v) %= _mod;        return *this;      }      modint&amp; operator-=(const modint&amp; rhs) {        (_v += _mod - rhs._v) %= _mod;        return *this;      }      modint&amp; operator*=(const modint&amp; rhs) {        _v = _v * rhs.val() % _mod;        return *this;      }      modint&amp; operator/=(const modint&amp; rhs) { // 费马小定理        _v = _v * rhs.inv().val() % _mod ;        return *this;      }      modint pow(ll pwr) const {        ll res(1);        ll _b(_v);        while (pwr) {          if (pwr &amp; 1) (res *= _b) %= _mod;          (_b *= _b) %= _mod;          pwr /= 2;        }        return res;      }      modint inv() const {        assert(_v != 0);        return pow(_mod - 2);      }  };};// ----------- modint -----------// ----------- fwt -----------using MODINT::modint;namespace FWT{  void ForT(vector&lt;modint&gt; &amp;f,int flag = 1/* 1:正变换,-1:逆变换 */) {    int n = f.size();    for (int k = 1; k &lt; n; k *=2){      for (int i = 0; i &lt; n; i += 2*k){        for (int j = 0; j &lt; k; j++){          f[i+j+k] += f[i+j] * flag;        }      }    }  }  void IForT(vector&lt;modint&gt; &amp;f) {ForT(f, -1);}  vector&lt;modint&gt; or_convolution(vector&lt;modint&gt; &amp;v0, vector&lt;modint&gt; &amp;v1){    const int sz = v0.size();    ForT(v0);    ForT(v1);    vector&lt;modint&gt; v2(sz,0);    rep(i,0,sz) v2[i] = v0[i] * v1[i];    IForT(v2);    return v2;  }  void FandT(vector&lt;modint&gt; &amp;f, int flag = 1/* 1:正变换,-1:逆变换 */) {    int n = f.size();    for (int k = 1; k &lt; n; k *=2){      for (int i = 0; i &lt; n; i += 2*k){        for (int j = 0; j &lt; k; j++){          f[i+j] += f[i+j+k] * flag;        }      }    }  }  void IFandT(vector&lt;modint&gt; &amp;f) {FandT(f, -1);}  vector&lt;modint&gt; and_convolution(vector&lt;modint&gt; &amp;v0, vector&lt;modint&gt; &amp;v1){    const int sz = v0.size();    FandT(v0);    FandT(v1);    vector&lt;modint&gt; v2(sz,0);    rep(i,0,sz) v2[i] = v0[i] * v1[i];    IFandT(v2);    return v2;  }  modint inv2 = modint(2).inv();  void FWHT(vector&lt;modint&gt; &amp;f, modint flag = 1 /* 1: 正变换, 1/2: 逆变换*/) {    int n = f.size();    for (int k = 1; k &lt; n; k *=2){      for (int i = 0; i &lt; n; i += 2*k){        for (int j = 0; j &lt; k; j++){          auto U = f[i+j];          auto T = f[i+j+k];          f[i+j]   = U + T;          f[i+j+k] = U - T;          f[i+j] *= flag;          f[i+j+k] *= flag;        }      }    }  }  void IFWHT(vector&lt;modint&gt; &amp;f) {FWHT(f, inv2);}  void FxorT(vector&lt;modint&gt; &amp;f,int flag = 1) {FWHT(f, flag);}  void IFxorT(vector&lt;modint&gt; &amp;f) {IFWHT(f);}  vector&lt;modint&gt; xor_convolution(vector&lt;modint&gt; &amp;v0, vector&lt;modint&gt; &amp;v1){    const int sz = v0.size();    FxorT(v0);    FxorT(v1);    vector&lt;modint&gt; v2(sz,0);    rep(i,0,sz) v2[i] = v0[i] * v1[i];    IFxorT(v2);    return v2;  }};// ----------- fwt -----------void print(vector&lt;modint&gt; &amp;arr){  for(auto &amp;v:arr) printf(&quot;%d &quot;, v.val());  printf(&quot;\n&quot;);}int main(){  const int n = read();  const int SIZE = 1&lt;&lt;n;  // 长度2的幂次  auto A0 = vector&lt;modint&gt;(SIZE,0);  auto B0 = vector&lt;modint&gt;(SIZE,0);  rep(i,0,SIZE) A0[i] = read();  rep(i,0,SIZE) B0[i] = read();  // --- or ---  {    auto A = A0;    auto B = B0;    auto C = FWT::or_convolution(A,B);    print(C);  }  // --- and ---  {    auto A = A0;    auto B = B0;    auto C = FWT::and_convolution(A,B);    print(C);  }  // --- xor ---  {    auto A = A0;    auto B = B0;    auto C = FWT::xor_convolution(A,B);    print(C);  }  return 0;}</code></pre><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="http://yexiaorain.github.io/Blog/2019-01-02-fftmul/">我的FFT笔记</a></p><p><a href="https://en.wikipedia.org/wiki/Fast_Walsh%E2%80%93Hadamard_transform" target="_blank" rel="noopener">wikipedia Fast Walsh-Hadamard transform</a></p><p><a href="https://en.wikipedia.org/wiki/Hadamard_transform" target="_blank" rel="noopener">Hadamard transform</a></p><p><a href="https://en.wikipedia.org/wiki/Walsh_matrix" target="_blank" rel="noopener">Walsh matrix</a></p><p><a href="https://codeforces.com/blog/entry/71899" target="_blank" rel="noopener">Codeforces FWHT inner working</a></p><p><a href="https://blog.csdn.net/a_forever_dream/article/details/105110089" target="_blank" rel="noopener">CSDN 快速沃尔什变换（FWT）详详详解</a></p><p><a href="https://www.luogu.com.cn/problem/solution/P4717" target="_blank" rel="noopener">luogu 模板练习</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;FWHT&quot;&gt;&lt;a href=&quot;#FWHT&quot; class=&quot;headerlink&quot; title=&quot;FWHT&quot;&gt;&lt;/a&gt;FWHT&lt;/h1&gt;&lt;p&gt;快速沃尔什-阿达玛转换(Fast Walsh-Hadamard transform), 一种广义傅立叶变换(FWHT)&lt;/p
      
    
    </summary>
    
      <category term="Codeforces" scheme="http://yexiaorain.github.io/Blog/categories/Codeforces/"/>
    
    
      <category term="fft" scheme="http://yexiaorain.github.io/Blog/tags/fft/"/>
    
      <category term="FWHT" scheme="http://yexiaorain.github.io/Blog/tags/FWHT/"/>
    
  </entry>
  
  <entry>
    <title>Atcoder abc212</title>
    <link href="http://yexiaorain.github.io/Blog/2022-07-25-ac_abc212/"/>
    <id>http://yexiaorain.github.io/Blog/2022-07-25-ac_abc212/</id>
    <published>2022-07-24T20:25:14.000Z</published>
    <updated>2022-08-12T03:23:03.823Z</updated>
    
    <content type="html"><![CDATA[<p>G(数学,数论,原根)H/Ex(沃尔什-阿达玛转换,FWT/FWHT)</p><h1 id="G-Power-Pair"><a href="#G-Power-Pair" class="headerlink" title="G - Power Pair"></a>G - Power Pair</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://atcoder.jp/contests/abc212/tasks/abc212_g" target="_blank" rel="noopener">https://atcoder.jp/contests/abc212/tasks/abc212_g</a></p><p>给定 质数$p$ </p><p>问 $x,y\in[0,p-1]$  中有多少对$(x,y)$满足</p><p>存在$n$, 使得$x^n = y \pmod p$</p><h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h3><p>p $10^{12}$</p><p>2s</p><p>1024mb</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h3><p>显然x=0 只有y = 0, y=0也只有x=0</p><p>然后如果x是原根 那么 方案数$p-1$</p><p>如果$r|(p-1)$ 那么 $x^r \pmod p$的方案数为$\frac{p-1}{r}$</p><p>或者$x$的最小幂次$t$让$x^t = 1 \pmod p$, 则答案为$t$</p><p>但是即使这样, 如果每个去枚举依然是$O(p log(p))$</p><p>反过来考虑说有没有办法求$x^t = 1$ 的方案数,</p><p>如果能快速计算出,那么 方案数减去它的t因子对应的方案数 就恰好是 = t的方案数</p><p>而$t$的取值只会是 $p-1$的因数</p><p>$t = 1$ $x = 1$</p><p>$t = 2$ $x = 1,-1$</p><p>$t = 4$</p><p>$t = 7$</p><p>$t = 8$</p><hr><p>t = 2k时, $x^{2k} - 1 = 0 \pmod p$</p><p>$(x^k+1)(x^k-1) = 0 \pmod p$, 相当于$x^k = 1 \pmod p, x^k = -1 \pmod p $的解的并</p><p>并不会</p><h3 id="官方"><a href="#官方" class="headerlink" title="官方"></a>官方</h3><p>原根的想法没问题, 然后就变成了我们指定原根</p><p>$x^i = j$, $(i,j)$ 是一一对应, 且取$[1,p-1]$范围内的所有值</p><p>这样的话</p><p>要求 $x^i$ 的最小让 幂次等于1的t</p><p>注意到 和我思路一样的 $x^i$当$i | (p-1)$时, 方案数 $=\frac{p-1}{i}$</p><p>而这里$i$可能不是$p-1$的因子, 而易证明 方案数为 $\frac{p-1}{gcd(p-1,i)}$</p><p>这里问题变成了, 统计不同 $gcd(p-1,i) = k$ 的数量即可</p><hr><p>$g | (p-1)$</p><p>$\sum_{g|(p-1)} count(g 倍数 且非(p-1)因子) $</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc212/submissions/33524525" target="_blank" rel="noopener">https://atcoder.jp/contests/abc212/submissions/33524525</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 998244353#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // read// 转质数和幂次vector&lt;pair&lt;ll,int&gt; &gt; v2ppwr(ll v){  vector&lt;pair&lt;ll,int&gt; &gt; res = {};  rep(t,2,v+1){    if(t*t &gt; v) break;    int c = 0;    while(v % t == 0){      v /= t;      c ++;    }    if(c) res.pb({t,c});  }  if(v != 1) res.pb({v, 1});  return res;}// gcd = xll dfs(ll idx, ll y, vector&lt;ll&gt; primes, const vector&lt;pair&lt;ll,int&gt; &gt; &amp; ppwr1){  if(idx == (int)ppwr1.size()) {    ll rc = y; // 容斥    for(auto p:primes) rc = rc / p * (p-1);    return y % MOD * (rc % MOD) % MOD;  }  auto [p,mi] = ppwr1[idx];  ll mul = 1; // p ** pwr  primes.push_back(p);  ll res = 0;  rep(pwr,0,mi+1){    if(pwr == mi) primes.pop_back();    (res += dfs(idx+1, y / mul, primes, ppwr1)) %= MOD;    mul *= p;  }  return res;}int main(){  ll p = read();  auto ppwr = v2ppwr(p-1);  printf(&quot;%lld\n&quot;, (1 /* (0,0) */ + dfs(0, p-1, {}, ppwr)) % MOD);  return 0;}</code></pre><h1 id="H-Ex-Nim-Counting"><a href="#H-Ex-Nim-Counting" class="headerlink" title="H/Ex - Nim Counting"></a>H/Ex - Nim Counting</h1><p><a href="https://atcoder.jp/contests/abc212/tasks/abc212_h" target="_blank" rel="noopener">https://atcoder.jp/contests/abc212/tasks/abc212_h</a></p><p>给正整数 长度k的 数组A, 值两两不同</p><p>T和A轮流游戏, T先</p><p>选一个 &gt;= 1 的石堆, 移除任意正整数个</p><p>谁取了最后一个胜利</p><hr><p>问题是</p><p>对于长度[1,N] 每个元素属于A中的一个的 初始状态, 有多少种状态是 T 胜利</p><p>模 998244353</p><h2 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h2><p>n 2e5</p><p>k 65536</p><p>$a_i$ [1, 65536]</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h3><p>首先nim游戏作为博弈的常见基础, 很明显 就是 xor 和 != 0 时 T胜利</p><p>那么无非是求 所有 !=0 的方案数, 或者 是 == 0 的方案数, 去总方案减去 ==0的方案数</p><p>那么对于一个选择来说因为Ai两两不同, 偶数次被选的Ai 不影响xor,奇数次被选的Ai影响一次</p><p>问题变成了说</p><p>选x个Ai,让它们 xor = 0, 那么</p><p>对于长度x 贡献是 x!</p><p>对长度x+2 贡献是 ?? 还是x, 但是剩余两个是一样的, 这两个一样的如果属于x个值内注意不要重复统计,不属于x个数内,则穿插即可</p><h3 id="官方-1"><a href="#官方-1" class="headerlink" title="官方"></a>官方</h3><p>对于给定的数组长度M</p><p>$C=(C_0,C_1,…C_{2^{16}-1})$ 表示 下标的值 是否存在, 相当于选择了一次</p><p>定义xor的卷积 $Z_k = \sum_{i\oplus j=k} X_i Y_j$</p><p>那么$C$的M次卷积的结果$R$中的$R_0$, 就是期望值</p><hr><p>快速沃尔什-阿达玛转换(Fast Walsh Hadamard transform), 一种广义傅立叶变换</p><p>FWT/FWHT 是用于解决对下标进行位运算卷积问题的方法, 见下面我的博客链接</p><p>$C_{i} = \sum_{i=j \bigoplus k}A_{j} B_{k}$</p><hr><p>因为 xor 的卷积满足结合率, 所以可以考虑快速幂来算</p><p>注意到$C * C = ifwt(fwt(C)\odot fwt(C))$</p><p>而$C * C * C= ifwt(fwt(C * C) \odot fwt(C))$</p><p>$= ifwt(fwt(ifwt(fwt(C)\odot fwt(C))) \odot fwt(C))$</p><p>$= ifwt(fwt(C)\odot fwt(C) \odot fwt(C))$</p><p>即是 $C^n = ifwt(\left( fwt(C)_ i^n\right))$</p><p>所以 $C$的$n$次+/xor/or/and卷积等于 正变换每个位置的$n$次方后的逆变换, <strong>这个在dft(fft)/ntt/fwt 同理</strong></p><hr><p>令 $I = C^0 = (1,0,0,0,0,0,\cdots)$</p><p>答案 $R = C + C * C + \cdots + C^n$</p><p>$R * C = C^2 + C^3 + \cdots + C^{n+1}$</p><p>$R * (C-I) = C^{n+1} - C$</p><p>$fwt(R) \odot fwt(C-I) = fwt(C^{n+1} - C)$</p><p>$fwt(R) = fwt(C^{n+1} - C) \oslash fwt(C-I)$</p><p>$R = ifwt(fwt(C^{n+1} - C) \oslash fwt(C-I))$</p><p>注意到$fwt$ 实际是线性变换, 所以也有$fwt(a+b) = fwt(a) + fwt(b),fwt(a-b) = fwt(a) - fwt(b),$</p><p>$R = ifwt( (fwt(C^{n+1}) - fwt(C)) \oslash (fwt(C)-fwt(I)))$</p><p>注意到 $fwt(I) = (1,1,1,1,1,\cdots)$</p><p>$R = ifwt(\left(\frac{fwt(C)_ i^{n+1} - fwt(C)_ i}{fwt(C)_ i - 1}\right))$</p><hr><p>至此就很好写了</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc212/submissions/33545657" target="_blank" rel="noopener">https://atcoder.jp/contests/abc212/submissions/33545657</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // read// -------------- modint ---------------namespace MODINT{  const int _mod = 998244353;  class modint{    private:      ll _v;    public:      modint() :_v(0) {  }      modint(ll _a) {        _v = (_a &lt; 0)? _mod - ((-_a) % _mod) : (_a % _mod);      }      int val()const { return _v; }      modint operator+()const { return *this; }      modint operator-()const { return { _mod - _v }; }      modint operator+(const modint&amp; rhs) const { return modint(*this) += rhs; }      modint operator-(const modint&amp; rhs) const { return modint(*this) -= rhs; }      modint operator*(const modint&amp; rhs) const { return modint(*this) *= rhs; }      modint operator/(const modint&amp; rhs) const { return modint(*this) /= rhs; }      bool operator==(const modint&amp; rhs)const { return _v == rhs._v; }      bool operator!=(const modint&amp; rhs)const { return _v != rhs._v; }      bool operator&gt; (const modint&amp; rhs)const { return _v &gt;  rhs._v; }      bool operator&gt;=(const modint&amp; rhs)const { return _v &gt;= rhs._v; }      bool operator&lt;=(const modint&amp; rhs)const { return _v &lt;= rhs._v; }      bool operator&lt; (const modint&amp; rhs)const { return _v &lt;  rhs._v; }      modint&amp; operator+=(const modint&amp; rhs) {        (_v += rhs._v) %= _mod;        return *this;      }      modint&amp; operator-=(const modint&amp; rhs) {        (_v += _mod - rhs._v) %= _mod;        return *this;      }      modint&amp; operator*=(const modint&amp; rhs) {        _v = _v * rhs.val() % _mod;        return *this;      }      modint&amp; operator/=(const modint&amp; rhs) { // 费马小定理        _v = _v * rhs.inv().val() % _mod ;        return *this;      }      modint pow(ll pwr) const {        ll res(1);        ll _b(_v);        while (pwr) {          if (pwr &amp; 1) (res *= _b) %= _mod;          (_b *= _b) %= _mod;          pwr /= 2;        }        return res;      }      modint inv() const {        assert(_v != 0);        return pow(_mod - 2);      }  };};// -------------- modint ---------------// ---------- fwt ----------using MODINT::modint;namespace FWT{  void ForT(vector&lt;modint&gt; &amp;f,int flag = 1/* 1:正变换,-1:逆变换 */) {    int n = f.size();    for (int k = 1; k &lt; n; k *=2){      for (int i = 0; i &lt; n; i += 2*k){        for (int j = 0; j &lt; k; j++){          f[i+j+k] += f[i+j] * flag;        }      }    }  }  void IForT(vector&lt;modint&gt; &amp;f) {ForT(f, -1);}  vector&lt;modint&gt; or_convolution(vector&lt;modint&gt; &amp;v0, vector&lt;modint&gt; &amp;v1){    const int sz = v0.size();    ForT(v0);    ForT(v1);    vector&lt;modint&gt; v2(sz,0);    rep(i,0,sz) v2[i] = v0[i] * v1[i];    IForT(v2);    return v2;  }  void FandT(vector&lt;modint&gt; &amp;f, int flag = 1/* 1:正变换,-1:逆变换 */) {    int n = f.size();    for (int k = 1; k &lt; n; k *=2){      for (int i = 0; i &lt; n; i += 2*k){        for (int j = 0; j &lt; k; j++){          f[i+j] += f[i+j+k] * flag;        }      }    }  }  void IFandT(vector&lt;modint&gt; &amp;f) {FandT(f, -1);}  vector&lt;modint&gt; and_convolution(vector&lt;modint&gt; &amp;v0, vector&lt;modint&gt; &amp;v1){    const int sz = v0.size();    FandT(v0);    FandT(v1);    vector&lt;modint&gt; v2(sz,0);    rep(i,0,sz) v2[i] = v0[i] * v1[i];    IFandT(v2);    return v2;  }  modint inv2 = modint(2).inv();  void FWHT(vector&lt;modint&gt; &amp;f, modint flag = 1 /* 1: 正变换, 1/2: 逆变换*/) {    int n = f.size();    for (int k = 1; k &lt; n; k *=2){      for (int i = 0; i &lt; n; i += 2*k){        for (int j = 0; j &lt; k; j++){          auto U = f[i+j];          auto T = f[i+j+k];          f[i+j]   = U + T;          f[i+j+k] = U - T;          f[i+j] *= flag;          f[i+j+k] *= flag;        }      }    }  }  void IFWHT(vector&lt;modint&gt; &amp;f) {FWHT(f, inv2);}  void FxorT(vector&lt;modint&gt; &amp;f,int flag = 1) {FWHT(f, flag);}  void IFxorT(vector&lt;modint&gt; &amp;f) {IFWHT(f);}  vector&lt;modint&gt; xor_convolution(vector&lt;modint&gt; &amp;v0, vector&lt;modint&gt; &amp;v1){    const int sz = v0.size();    FxorT(v0);    FxorT(v1);    vector&lt;modint&gt; v2(sz,0);    rep(i,0,sz) v2[i] = v0[i] * v1[i];    IFxorT(v2);    return v2;  }};// ---------- fwt ----------const int SIZE = 1 &lt;&lt; 16; // 16;vector&lt;modint&gt; C(SIZE,0);int main(){  int n = read();  int k = read();  rep(i,0,k) { C[read()] = 1; }  auto ans = k == 1? n : ((modint(k).pow(n+1)- 1)/(k-1) - 1); // 总方案数  FWT::FWHT(C);  rep(i,0,SIZE) C[i] = (C[i] == 1) ? n : ((C[i].pow(n+1) - C[i])/(C[i] - 1)); // 等比数列求和  FWT::IFWHT(C);  printf(&quot;%d\n&quot;,(ans-C[0]).val());  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>G</p><p>没观察到选了一个原根以后 整个范围 都有幂次和值的一一映射</p><p>H(Ex)</p><p>首先这个C和这个卷积 就很神奇, 完全没有向这个方向的思路</p><p>学了一手FWT/FWHT</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://atcoder.jp/contests/abc212/editorial" target="_blank" rel="noopener">官方题解</a></p><p><a href="http://yexiaorain.github.io/Blog/2022-07-26-FWT/">FWHT/FWT</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;G(数学,数论,原根)H/Ex(沃尔什-阿达玛转换,FWT/FWHT)&lt;/p&gt;
&lt;h1 id=&quot;G-Power-Pair&quot;&gt;&lt;a href=&quot;#G-Power-Pair&quot; class=&quot;headerlink&quot; title=&quot;G - Power Pair&quot;&gt;&lt;/a&gt;G - P
      
    
    </summary>
    
      <category term="Atcoder" scheme="http://yexiaorain.github.io/Blog/categories/Atcoder/"/>
    
    
      <category term="数学" scheme="http://yexiaorain.github.io/Blog/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="数论" scheme="http://yexiaorain.github.io/Blog/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="原根" scheme="http://yexiaorain.github.io/Blog/tags/%E5%8E%9F%E6%A0%B9/"/>
    
      <category term="沃尔什-阿达玛转换" scheme="http://yexiaorain.github.io/Blog/tags/%E6%B2%83%E5%B0%94%E4%BB%80-%E9%98%BF%E8%BE%BE%E7%8E%9B%E8%BD%AC%E6%8D%A2/"/>
    
      <category term="FWT" scheme="http://yexiaorain.github.io/Blog/tags/FWT/"/>
    
      <category term="FWHT" scheme="http://yexiaorain.github.io/Blog/tags/FWHT/"/>
    
  </entry>
  
</feed>
