<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog</title>
  
  
  <link href="/Blog/atom.xml" rel="self"/>
  
  <link href="http://yexiaorain.github.io/Blog/"/>
  <updated>2022-05-23T21:50:15.385Z</updated>
  <id>http://yexiaorain.github.io/Blog/</id>
  
  <author>
    <name>Xiao Ye</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Codeforces 1679E(sosdp,子集和dp,动态规划,贡献统计)</title>
    <link href="http://yexiaorain.github.io/Blog/2022-05-24-CF1679E/"/>
    <id>http://yexiaorain.github.io/Blog/2022-05-24-CF1679E/</id>
    <published>2022-05-24T02:24:00.000Z</published>
    <updated>2022-05-23T21:50:15.385Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://codeforces.com/contest/1679/problem/E" target="_blank" rel="noopener">https://codeforces.com/contest/1679/problem/E</a></p><p>长度n,前17个小写字母组成的字符串s,其中有?表示t中任意字符</p><p>q次询问,每次给17个字母中的一个子集,问把?所有填子集的填法中,原串的回文子串个数和, 答案mod 998244353</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>n 1e3</p><p>t 17</p><p>q 2e5</p><p>2s</p><p>256MB</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>首先看到q 2e5, 和 t 17, 因为2^17 == 131072,其实可以变成求所有方案的答案</p><p>统计所有回文子串 的效率最好就是选取中心,再枚举长度</p><p>那么这个题也是这样做, 枚举中心向两边搜索</p><p>其中注意到的是,当选定中心后,如果对称位置上有一个问号一个确定字符,那么这个问号必定填这个字符</p><p>如果两个都是问号,那么自由度+1, 它</p><p>如果对称都填了但是不一样,那么到此结束</p><p>也就是n方可以统计 <code>cnt[必要字符bitmask][自由度] = 次数</code></p><p>那么 每次询问bitmask 是 M 的话</p><p><code>ans[M] = sum { cnt[m 是M的子集][i = 0..] * size(M)^i }</code></p><p>那么问题来了, 朴素计算我必定超时, 但是我不知道如何dp, 看Codeforces的群里有人说sosdp</p><h2 id="SOSDP-子集和DP"><a href="#SOSDP-子集和DP" class="headerlink" title="SOSDP 子集和DP"></a>SOSDP 子集和DP</h2><p>$F[mask] =\sum_{i \in mask}A[i]$</p><h3 id="暴力枚举-O-4-n"><a href="#暴力枚举-O-4-n" class="headerlink" title="暴力枚举 $O(4^n)$"></a>暴力枚举 $O(4^n)$</h3><pre><code class="cpp">rep(mask,0,1 &lt;&lt; N){  rep(i,0,1 &lt;&lt; N){ // 枚举 mask, 检测是否是它的子集    if((i&amp;mask) == i) F[mask] += A[i];  }}</code></pre><h3 id="枚举子集和-O-3-n"><a href="#枚举子集和-O-3-n" class="headerlink" title="枚举子集和$O(3^n)$"></a>枚举子集和$O(3^n)$</h3><p>也可以dfs,当然dfs会多函数调用和堆栈 比如mask = 111, i依次为 111,110,101,100,011,010,001,000, 注意到的是mask中间穿插0对应的就是i对应位置穿插0,看起来就像每次<code>-1</code></p><pre><code class="cpp">rep(mask,0,1 &lt;&lt; N){  F[mask] = A[0]; // 所有集合包含空集 空集合也作为停止条件  for(int i = mask;i;i = (i-1)&amp;mask){ // 这就是传说中的二进制枚举子集 ,     F[mask] += A[i];  }}</code></pre><h3 id="SOSdp-O-n2-n"><a href="#SOSdp-O-n2-n" class="headerlink" title="SOSdp $O(n2^n)$"></a>SOSdp $O(n2^n)$</h3><p><code>dp[mask][i]</code> 表示 高位和mask一致, 低<code>[0..i]</code>位所有方案的和</p><p><code>dp[10110][2] = A[10000]+A[10010]+A[10100]+A[10110]</code></p><p>状态转移</p><p>第i位为0时,<code>dp[mask][i] = dp[mask][i-1]</code></p><p>第i位为1时,<code>dp[mask][i] = dp[mask][i-1] + dp[mask xor (1 &lt;&lt; i)][i-1]</code></p><p>这样变成递推 或者记忆化搜索,可以 $O(n2^n)$ 完成</p><p>上面合并一下变成,<code>dp[mask][i] = dp[mask][i-1] + (mask &amp; (1 &lt;&lt; i)?dp[mask xor (1 &lt;&lt; i)][i-1]:0)</code></p><p>注意到<code>i</code>依赖于<code>i-1</code>还可以滚动数组降低空间</p><pre><code class="cpp">rep(mask,0,1&lt;&lt;N) f[mask] = A[mask];rep(i,0,N){  // 这里不需要从大到小, 因为dp[mask]已经初始化了,只会更新1 &lt;&lt; i上为1的,而更新的来源是1 &lt;&lt; i上不是1的  rep(mask,0,1 &lt;&lt; N){    if(mask &amp; (1 &lt;&lt; i)) f[mask]+=f[mask ^ (1 &lt;&lt; i)];  }}</code></pre><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>我的暴力的代码</p><pre><code class="cpp">ans[mask] = 0;sz = bitcount(mask)rep(qmark,0,501){ // 自由的问号个数  ti = pow(sz,qmark)  for(int i = mask;i;i = (i-1)&amp;mask){    ans[mask] += cnt[i][qmark] * ti  }}</code></pre><p>这是$O(n 3^{|t|})$ 的复杂度 肯定过不了</p><p>通过sosdp降低到$O(n t 2^{|t|})$ 虽然降低了不少,但是依然过不了</p><p>这里<code>dp</code> 改一个方式设计, 变成贡献统计</p><p>先交换一下循环层级</p><pre><code class="cpp">ans[mask] = 0;sz = bitcount(mask)for(int i = mask;i;i = (i-1)&amp;mask){  rep(qmark,0,501){    ans[mask] += cnt[i][qmark] * pow(sz,qmark)  }}</code></pre><p>因为<code>{i,qmark}</code>中i是mask的子集,而<code>{i,qmark}</code>对mask 的贡献来讲 只与<code>bitcount(mask)</code> 有关,与<code>mask</code> 具体无关</p><pre><code>rep(i,0,(1 &lt;&lt; N)){  rep(sz,1,17+1){    rep(qmark,0,501){      cost[i][sz] += cnt[i][qmark] * pow(sz,qmark);    }  }}ans[mask] = 0;sz = bitcount(mask)// sosdp 优化掉for(int i = mask;i;i = (i-1)&amp;mask){  ans[mask] += cost[i][sz];}</code></pre><p>下面得到优化了, 但上面看起来复杂度并没有变好</p><p>但既然都说道贡献统计了,就去看贡献来源</p><p>在我们初始找回文时<code>[i...j]</code> 如果是一个回文,它的必须字符集为mask,自由度为qmark</p><p>那么</p><pre><code class="cpp">rep(sz,1,17+1){  cost[mask][sz] += pow(sz,qmark);}</code></pre><p>这样 初始化就变成$O(|t| n^2)$</p><hr><p>综上 $O(初始化幂次 |t|n + 初始化贡献 |t| n^2 + 初始化答案 |t|^2 2^{|t|} + 查询 |t|q )$</p><p>注意到 题目要统计 所有字符串个数,也就是说 同一个位置的回文串 在不同字符串中出现,要多次统计</p><p>所以</p><pre><code class="cpp">rep(sz,1,17+1){  cost[mask][sz] += pow(sz,qmark) * pow(sz,total qmark - used qmark);}</code></pre><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><a href="https://codeforces.com/contest/1679/submission/158244316" target="_blank" rel="noopener">https://codeforces.com/contest/1679/submission/158244316</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 998244353#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backconst int t = 17;char s[1010]; // 读入char s2[2010]; // 插入井号简化搜索int n;ll p[t+10][1010]; // 幂次预处理ll cost[(1&lt;&lt;t)+10][t+10]; // 具体的值ll ans[(1&lt;&lt;t)+10][t+10]; // 由具体值的子集和的答案char query[t+10];int main(){  rep(i,1,t+1){    p[i][0] = 1;    rep(pwr,1,1000+1){      p[i][pwr] = p[i][pwr-1]*i%MOD;    }  }  scanf(&quot;%d&quot;,&amp;n);  scanf(&quot;%s&quot;,s);  int qtotal = 0;  rep(i,0,n) qtotal += s[i] == &#39;?&#39;;  // 字符两两间插入井号方便处理奇偶  s2[0] = s[0];  rep(i,1,n){    s2[i*2-1] = &#39;#&#39;;    s2[i*2] = s[i];  }  // 中心  rep(c,0,n*2-1){    int mask = 0;    int qmark = 0;    int qcnt = 0;    rep(l,0,n*2-1){ // 长度      int il = c-l;      int ir = c+l;      if(il &lt; 0 || ir &gt;= n*2-1)break;      qcnt += s2[il] == &#39;?&#39;;      qcnt += il != ir &amp;&amp; s2[ir] == &#39;?&#39;;      if(s2[il] == &#39;#&#39;)continue; // 不贡献的      if(s2[il] == s2[ir]){        if(s2[il] == &#39;?&#39;){          qmark++;        }      }else{ // 不等        if(s2[il] == &#39;?&#39;){          mask |= (1 &lt;&lt; (s2[ir] - &#39;a&#39;));        }else if(s2[ir] == &#39;?&#39;){          mask |= (1 &lt;&lt; (s2[il] - &#39;a&#39;));        }else{ // 不同的字符          break;        }      }      // 贡献统计      rep(sz,1,17+1){        // 不同字符串 同一个位置回文串的贡献要多次统计 所以要乘上 其余位置是问号的所有放入方案 让此处的贡献倍数 sz**(qtotal - qcnt)        (cost[mask][sz] += p[sz][qmark] * p[sz][qtotal - qcnt] % MOD )%=MOD;      }    }  }  // sosdp  rep(sz,1,t+1){    rep(mask,0,1 &lt;&lt; t){      ans[mask][sz] = cost[mask][sz];    }    rep(i,0,t){      rep(mask,0,1 &lt;&lt; t){        if(mask &amp; (1 &lt;&lt; i)) (ans[mask][sz] += ans[mask ^ (1 &lt;&lt; i)][sz])%=MOD;      }    }  }  // query  int q; // 2e5  scanf(&quot;%d&quot;,&amp;q);  while(q--){    // string to mask    scanf(&quot;%s&quot;,query);    int sz = strlen(query);    int mask = 0;    rep(i,0,sz){      mask |= (1&lt;&lt;(query[i]-&#39;a&#39;));    }    printf(&quot;%lld\n&quot;, ans[mask][sz]);  }  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>回文的奇偶处理,可以用两两间插入不会出现的字符,如井号,方便枚举中心</p><p>学了一手sosdp</p><p>看ssr的twitter说有快速zeta变换, 搜下来看转移方程似乎就是sosdp, <a href="https://zhuanlan.zhihu.com/p/33328788?ivk_sa=1024320u" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/33328788?ivk_sa=1024320u</a></p><p>顺便这里的dp转化过程中 通过贡献和来优化效率</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://codeforces.com/blog/entry/102859" target="_blank" rel="noopener">官方</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1679/problem/E&quot; target=&quot;_blank
      
    
    </summary>
    
      <category term="Codeforces" scheme="http://yexiaorain.github.io/Blog/categories/Codeforces/"/>
    
    
      <category term="dp" scheme="http://yexiaorain.github.io/Blog/tags/dp/"/>
    
      <category term="贡献统计" scheme="http://yexiaorain.github.io/Blog/tags/%E8%B4%A1%E7%8C%AE%E7%BB%9F%E8%AE%A1/"/>
    
      <category term="sosdp" scheme="http://yexiaorain.github.io/Blog/tags/sosdp/"/>
    
  </entry>
  
  <entry>
    <title>Atcoder arc140 D(树的边与点,贡献统计,DP,特殊题目条件)</title>
    <link href="http://yexiaorain.github.io/Blog/2022-05-23-ac_arc140D/"/>
    <id>http://yexiaorain.github.io/Blog/2022-05-23-ac_arc140D/</id>
    <published>2022-05-23T02:37:14.000Z</published>
    <updated>2022-05-23T17:14:23.618Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://atcoder.jp/contests/arc140/tasks/arc140_d" target="_blank" rel="noopener">https://atcoder.jp/contests/arc140/tasks/arc140_d</a></p><p>初始有 n 个点，给定一个长度为 n 的数组 ai，若 ai≠−1，则有无向边 (i,ai)，若 ai=−1，则点 i 可以连向 1∼n 任意点，求所有图的联通块个数之和</p><p>n 2e3</p><p>答案mod 998244353</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>考虑G中一个联通分量</p><p>如果它有N点,N个边,那么它恰好有一个环</p><p>这关键就在题目的特殊性上,因为(i-&gt;ai),即每个点连出一条边,所以n个点组成的联通分量一定恰好N个边, 题目条件特点!</p><p>因此 题目变成统计环的 而不是统计联通分量</p><p>然后先考虑 非-1的部分已经构成的环, 这部分如果再和其它相连,那么额外连的部分一定不会再有环,是个树,所以其它和它连的部分一定不会再贡献,</p><p>所以在考虑-1构成环的话不会考虑已经初始有环的联通分量</p><p>对于目前剩余没有环的联通分量是树,把这些树标号从1到k,并且b[i]表示这些树的点的个数, 注意到它一定只有一条未连接的边</p><p>现在考虑一个环的构成, 一定是由一些树连成的</p><p>树1-&gt;树2-&gt;树3-&gt;树k-&gt;树1</p><p>我们不考虑没有参与到环中的其它树,即使它从联通分量角度连进来了, 我们之考虑对环的构成直接有贡献的树</p><p>那么 如果是由 k个构成的,每一个的树的出点是固定的,但是入点的选择是上一个树的点的个数, 而它们排成环的方案是(k-1)! </p><p>所以环的构成是$(k-1)! \times \prod_{i=1}^{k} B_{x_i}$</p><p>n 很小 n方 可以接受可以DP</p><p>说是分治计算$\prod_{i=1}^{K} (1 + B_ix)$可以做到 n log(n)</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><a href="https://atcoder.jp/contests/arc140/submissions/31923069" target="_blank" rel="noopener">https://atcoder.jp/contests/arc140/submissions/31923069</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 998244353#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backint n;int a[2010];// 读入int fa[2010]; // 并查集父节点int sz[2010]; // 点个数bool cir[2010]; // 是否有环int getfa(int x){  return x == fa[x]?x:(fa[x] = getfa(fa[x]));}void link(int u,int v){  int fu = getfa(u);  int fv = getfa(v);  if(fu == fv){    cir[fu] = true; // 有环    return;  }  sz[fv] += sz[fu]; // 大小  cir[fv] |= cir[fu]; // 环  fa[fu] = fv;}ll mypow(ll v,int pwr){  ll r = 1;  while(pwr){    if(pwr%2)(r*=v)%=MOD;    (v*=v)%=MOD;    pwr/=2;  }  return r;}ll fac[2010] = {1}; // 阶乘int main(){  cin&gt;&gt;n;  int freecnt = 0; // 自由度 -1 个数  rep(i,1,n+1){    fa[i] = i;    sz[i] = 1;    fac[i] = fac[i-1]*i%MOD;    scanf(&quot;%d&quot;,a+i);    freecnt += a[i] == -1;  }  rep(i,1,n+1){    if(a[i] == -1)continue;    link(i,a[i]);  }  vector&lt;int&gt; arr ;  int circnt = 0;  rep(i,1,n+1){    if(fa[i] != i)continue; // 非联通块根    if(cir[i]){ // 环      circnt++;      continue;    }    arr.push_back(sz[i]); // 树 有一个自由度  }  ll ans = circnt * mypow(n,freecnt) % MOD; // 本身就是环的贡献  vector&lt;ll&gt; mulsum(n+10,0); // dp mulsum[树的个数] = sz乘积和  mulsum[0] = 1;  rep(i,0,(int)arr.size()){    rep(k,0,i+1){      // 注意前面一半只是 k+1个构成环的方案数, 对于环以外的 freecnt-k-1的自由度任意搭配 才是这些环对总答案的贡献值      (ans += fac[k] * mulsum[k] % MOD * arr[i] % MOD * mypow(n,freecnt-k-1) % MOD)%=MOD;    }    per(k,0,i+1){      (mulsum[k+1] += mulsum[k]*arr[i])%=MOD;    }  }  printf(&quot;%lld\n&quot;,ans);  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我想了很久,都没有注意到题目条件特殊性带给联通分量的特殊性, 这还是不应该,应该加强这方面的反应</p><p>其实也算是树的知识没有警醒我, 边=点-1,那么就会反应到这里连通分量的边 &lt;= 点 且 &gt;= 点-1</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://atcoder.jp/contests/arc140/editorial/3971" target="_blank" rel="noopener">官方</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://atcoder.jp/contests/arc140/tasks/arc140_d&quot; target=&quot;_b
      
    
    </summary>
    
      <category term="Atcoder" scheme="http://yexiaorain.github.io/Blog/categories/Atcoder/"/>
    
    
      <category term="math" scheme="http://yexiaorain.github.io/Blog/tags/math/"/>
    
      <category term="DP" scheme="http://yexiaorain.github.io/Blog/tags/DP/"/>
    
      <category term="树" scheme="http://yexiaorain.github.io/Blog/tags/%E6%A0%91/"/>
    
      <category term="贡献统计" scheme="http://yexiaorain.github.io/Blog/tags/%E8%B4%A1%E7%8C%AE%E7%BB%9F%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 1680F(无向图,奇数环,偶数环,树上差分)</title>
    <link href="http://yexiaorain.github.io/Blog/2022-05-20-CF1680F/"/>
    <id>http://yexiaorain.github.io/Blog/2022-05-20-CF1680F/</id>
    <published>2022-05-20T12:24:00.000Z</published>
    <updated>2022-05-22T14:16:53.916Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://codeforces.com/contest/1680/problem/F" target="_blank" rel="noopener">https://codeforces.com/contest/1680/problem/F</a></p><p>给一个连通无向图,n点,m 边</p><p>点覆盖: (所有边至少一个点属于点集</p><p>lenient点覆盖: 是点覆盖,且至多一条边两个点都在点集中</p><p>找出一个 lenient点覆盖</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>t 1e4</p><p>n 1e6</p><p>5s</p><p>512MB</p><h1 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h1><p>首先 如果能黑白染色,成功,那么也就是每个边一端黑一端白, 全选黑或全选白都是一个答案</p><p>如果 黑白染色出现冲突,那么这两个点一定在一个奇环上</p><p>也就是这个奇环上存在两个点都是黑色, 最可以先把这个环上的边全部当作不存在,重新做染色,如果能成功, 计算这个环上同一个并查集点的颜色关系,</p><p>如果两两都不在同一个集合中那么说明拆了环都是独立的部分,那么任意染黑白即可</p><p>如果存在 a—–b 同集合中</p><p>a,b 同色 , [a..b]个数奇数的一半一定是黑白间隔</p><p>a,b 异色 , [a..b]个数偶数的一半一定是黑白间隔</p><p>换句话说, 其实原图去掉那个两个点都在集合中的边, 剩下的满足黑白染色,现在则是看哪些确定可以连起来</p><p>过程中检查冲突</p><p>如果剩余还有没连的 任选一个作为分割即可</p><hr><p>但是 实现上能找环但如何找奇环</p><p>独立染色可以写,但合并时如何实现?</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>前面几段和我想的一样, 奇偶黑白染色, 也就是需要在奇数环上剪断一条边,让整个染色合法</p><p>这里主要是 对无向图做dfs建立树</p><p>那么出现环的时候就是子节点指向父节点的时候</p><p>我们在dfs过程中黑白染色,那么出现回边时根据染色就可以知道它是奇环还是偶环,</p><p>如果我们统计了每条边出现在我们找到的奇环上的次数,和偶环上的次数,那么 如果一条边出现在奇数环上次数等于所有奇环次数,偶数环次数为零,那么删除这条边即可(可能有多个满足,任意删除一条)</p><p>// how proof 必要性, 充分显然</p><p>所以接下来就是当发生回环时,如何统计边在奇环偶环上出现次数了,如果直接对边计数,那么复杂度就过不了</p><p>树上差分, cnt[id]表示边id到根的所有边都 进行了+cnt[id],这样 当有点u到点v的回边时,就 cnt[faedge[u]]++,cnt[faedge[v]]–, 对于不在树上的回边<code>edge[id] = {u,v}</code>不需要差分直接统计, cnt[id]++</p><p>最后统计完后整理具体次数</p><p>然后找满足的边拆掉,再染色即可(注意拆掉边两端需要是黑色</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><a href="https://codeforces.com/contest/1680/submission/158000410" target="_blank" rel="noopener">https://codeforces.com/contest/1680/submission/158000410</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define pb push_back#define rep(i,a,b) for(int i = (a);i&lt;(b);i++)#define all(v) (v).begin(),(v).end()const int N = 1000000;int n,m;int odd; // 奇环个数int cnt0[N+10]; // cnt0[边]偶环个数，int cnt1[N+10]; // cnt1[边]奇环个数，int c[N+10]; //c节点颜色，bool vis[N+10]; // dfs中访问过, 多次复用int fe[N+10]; //fe父边// 读入pair&lt;int,int&gt; e[N+10]; // [边] = {点id,点id}vector&lt;pair&lt;int,int&gt;&gt; G[N+10]; // [点] = 数组 {点id,边id}//二分图染色同时找环void dfs(int u,int p/*父边*/,int cl /*颜色*/ ) {  c[u]=cl;  vis[u]=1; // 管的当前到根的链上是否有, 减少重复计算 简化差分统计  fe[u]=p;  for(auto [v,id]:G[u]){    if (id==p)continue;    if (c[v]==-1){ // 未访问过      dfs(v,id,cl^1);    } else if(!vis[v]){ // 非父节点      continue;    } else if (c[v]==(cl^1)) { //偶环      cnt0[id]++; // 不在树上的回边      cnt0[p]++; // 树上边 差分统计 表示这个边到根的次数都+1      if(~fe[v])cnt0[fe[v]]--; // 这个边到根的次数都-1    } else { // if (c[v]==cl) {//奇环      odd++; // 奇环个数      cnt1[id]++;      cnt1[p]++;      if(~fe[v])cnt1[fe[v]]--;    }  }  vis[u]=0;//回溯时撤销访问标记}// 整理差分数组，得到每条边的计数, 只用处理树边,递归, 不用处理非树的回边void dfs2(int u) {  vis[u]=1;  for(auto [v,_]:G[u]){    if (vis[v]) continue;    dfs2(v);    if (fe[u]!=-1&amp;&amp;fe[v]!=-1){      cnt0[fe[u]]+=cnt0[fe[v]];      cnt1[fe[u]]+=cnt1[fe[v]];    }  }}void dfs3(int u,int cl) { //二分图染色  c[u]=cl;  for(auto [v,_]:G[u]){    if (c[v]!=-1) continue;    dfs3(v,cl^1);  }}void run(){  // 一系列初始化  odd=0;  scanf(&quot;%d %d&quot;,&amp;n,&amp;m);  rep(i,0,n) G[i].clear();  fill(cnt0,cnt0+m+3,0);  fill(cnt1,cnt1+m+3,0);  fill(c,c+n+3,-1);  fill(vis,vis+n+3,0);  // 读入  rep(i,0,m){    int u,v;    scanf(&quot;%d %d&quot;,&amp;u,&amp;v);    e[i]={--u,--v};    G[u].pb({v,i});    G[v].pb({u,i});  }  dfs(0,-1,0); // 以0 为根染色0搜索  // 整理树上差分数组 变成每个边的统计  fill(vis,vis+n+3,0);  dfs2(0);  int id=-1;  if (odd) {//存在奇环    rep(i,0,m){      // 需要完全相等 所有已知奇环都覆盖了它, 且没有偶环覆盖了它, proof? 必要性显然, 充分性呢?      if (cnt1[i]==odd &amp;&amp; cnt0[i]==0) {        id = i; // 任选一条        break;      }    }    if (id == -1) {      printf(&quot;NO\n&quot;);      return;    }    //删边    auto [u,v] = e[id];    sort(all(G[v]));    sort(all(G[u]));    G[u].erase(lower_bound(all(G[u]),make_pair(v,-1)));    G[v].erase(lower_bound(all(G[v]),make_pair(u,-1)));  }  // 再次染色  fill(c,c+n+3,-1);  dfs3(0,1);  int f=(id==-1?0:c[e[id].first]^1); //保证被删边的端点颜色为1  printf(&quot;YES\n&quot;);  rep(i,0,n){    printf(&quot;%d&quot;,c[i]^f);  }  printf(&quot;\n&quot;);}int main() {  int T;  scanf(&quot;%d&quot;,&amp;T);  while(T--)run();  return 0;}// 1-2-3-4,3-1,4-1// 奇边切 3-1在回边上//// 1-2-3-4-5, 3-1, 5-1//// 奇边切 1-2或2-3,在树边上//</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>知识点</p><p>无向图 = dfs -&gt; 树+回边</p><p>而一部分无向图的环 = 多个树边+一条回边? 也可能由回边组成的环</p><p>树上差分 = 记录当前点到根的所有边的统一操作,如+1/-1</p><p>学了一手<code>fill()</code>函数,看起来很好用啊</p><p>然后 无向图 树上dfs, 的父边而不是父点 <code>dfs(int u,int fe /*father edge*/)</code></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://codeforces.com/blog/entry/102852" target="_blank" rel="noopener">官方</a></p><p><a href="https://blog.csdn.net/FelFa_1414666/article/details/124790751" target="_blank" rel="noopener">csdn</a> 修复了一些越界和等式操作, 修改了部分变量和包裹逻辑,整体</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1680/problem/F&quot; target=&quot;_blank
      
    
    </summary>
    
      <category term="Codeforces" scheme="http://yexiaorain.github.io/Blog/categories/Codeforces/"/>
    
    
      <category term="无向图" scheme="http://yexiaorain.github.io/Blog/tags/%E6%97%A0%E5%90%91%E5%9B%BE/"/>
    
      <category term="奇数环" scheme="http://yexiaorain.github.io/Blog/tags/%E5%A5%87%E6%95%B0%E7%8E%AF/"/>
    
      <category term="偶数环" scheme="http://yexiaorain.github.io/Blog/tags/%E5%81%B6%E6%95%B0%E7%8E%AF/"/>
    
      <category term="树上差分" scheme="http://yexiaorain.github.io/Blog/tags/%E6%A0%91%E4%B8%8A%E5%B7%AE%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>leetcode周赛293D (lower_bound,set, 动态开点线段树)</title>
    <link href="http://yexiaorain.github.io/Blog/2022-05-15-leetcode-weekly-contest-293-D/"/>
    <id>http://yexiaorain.github.io/Blog/2022-05-15-leetcode-weekly-contest-293-D/</id>
    <published>2022-05-15T02:37:14.000Z</published>
    <updated>2022-05-15T05:05:36.742Z</updated>
    
    <content type="html"><![CDATA[<h1 id="set-lower-bound"><a href="#set-lower-bound" class="headerlink" title="set+lower_bound"></a>set+lower_bound</h1><p><a href="http://www.cplusplus.com/reference/algorithm/lower_bound/" target="_blank" rel="noopener">http://www.cplusplus.com/reference/algorithm/lower_bound/</a></p><p>On non-random-access iterators, the iterator advances produce themselves an additional linear complexity in N on average.</p><p>set不支持随机访问,所以std::lower_bound 用在set上就不再是log级别了, 而是均摊n级别了,所以要用set::lower_bound而不是std::lower_bound</p><h1 id="动态开点线段树"><a href="#动态开点线段树" class="headerlink" title="动态开点线段树"></a>动态开点线段树</h1><p>一般来说 空间够常见是开4N大小</p><p>但是如果空间很大但是点是离散的又需要在线处理(不能离线离散化)的情况</p><p>每个点记录左右节点+lazytag+没有节点要访问时,动态开点idx, 查询时对于没有开点的直接返回空,而不是开点</p><pre><code class="cpp">int idx = 0;// N 按照预估点数而不是 l r 的范围了int lc[N]; // 点的左子点int rc[N]; // 点的右子点void update(int &amp;o,int l,int r,...){  if(!o) o = ++idx; // 动态开点  if(l == r){    // ...    return ;  }  update(lc[o],l,mid,...);  update(rc[o],mid+1,r,...);  // ...}... query(int o,int l,int r,int ql,int qr){  if(!o){ // 查询不用创建点    //....    return 空状态;//   }  if(ql &lt;= l &amp;&amp; r &lt;= qr){ // [ql.. [l..r].. qr]    // ...    return //;  }  auto resl = query(lc[o],l,mid,ql,qr);  auto resr = query(lr[o],mid+1,r,ql,qr);  return ...;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;set-lower-bound&quot;&gt;&lt;a href=&quot;#set-lower-bound&quot; class=&quot;headerlink&quot; title=&quot;set+lower_bound&quot;&gt;&lt;/a&gt;set+lower_bound&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://ww
      
    
    </summary>
    
      <category term="NowCoder" scheme="http://yexiaorain.github.io/Blog/categories/NowCoder/"/>
    
    
      <category term="lower_bound" scheme="http://yexiaorain.github.io/Blog/tags/lower-bound/"/>
    
      <category term="set" scheme="http://yexiaorain.github.io/Blog/tags/set/"/>
    
      <category term="动态开点线段树" scheme="http://yexiaorain.github.io/Blog/tags/%E5%8A%A8%E6%80%81%E5%BC%80%E7%82%B9%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>nowcoder 牛客挑战赛60,CD+总结(竞赛图, 递推)</title>
    <link href="http://yexiaorain.github.io/Blog/2022-05-14-nowcoder-11200/"/>
    <id>http://yexiaorain.github.io/Blog/2022-05-14-nowcoder-11200/</id>
    <published>2022-05-14T02:37:14.000Z</published>
    <updated>2022-05-14T01:02:15.203Z</updated>
    
    <content type="html"><![CDATA[<h1 id="比赛总结"><a href="#比赛总结" class="headerlink" title="比赛总结"></a>比赛总结</h1><p>比赛id 11200</p><p>B:</p><p>数组空间没开够等未定义行为,不会像Codeforces报overflow等,而是默认执行报WA.</p><p>D:</p><p>TLE+WA 只会报WA</p><p>竞赛图不能创造大小为2的scc</p><pre><code class="cpp">/** * @author      : cromarmot (yexiaorain@gmail.com) * @file        : D * @created     : 星期五 5月 13, 2022 20:35:36 CST */#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (int i=a;i&lt;n;i++)// 竞赛图 任意不同两点间都有恰好一条单向边int n,m; // n 1e5, m 2e5vector&lt;int&gt;p2[100010];// scc -&gt; 成链?class Tarjan{  vector&lt;int&gt; low;  vector&lt;int&gt; dfn;  stack&lt;int&gt; stk;  vector&lt;int&gt; res;  int n;  int id = 0;  void scc(int v) {    low[v] = dfn[v] = ++id;    stk.push(v);    for(auto w:p2[v]){      if(!dfn[w]){ // 未访问过        scc(w);        low[v] = min(low[v],low[w]);      } else if(!res[w]){ // 访问过但没有结果(在栈中)        low[v] = min(low[v],dfn[w]);      }    }    int u;    if(low[v] == dfn[v])  {      do{        res[u = stk.top()] = v;        stk.pop();      }while(u != v);    }  }public:  Tarjan(int SZ):n(SZ){    low = vector&lt;int&gt;(n+1,0);    dfn = vector&lt;int&gt;(n+1,0);    stk = {};    res = vector&lt;int&gt; (n+1,0);  }  vector&lt;int&gt; calc(){    rep(i,1,n+1){      if(!res[i]){        scc(i);      }    }    return res;  }};vector&lt;int&gt; p3[100010];int du[100010];void work(){  scanf(&quot;%d %d&quot;,&amp;n,&amp;m);  Tarjan tarjan(n);  rep(i,1,n+1){    p2[i] = {};    p3[i] = {};    du[i] = 0;  }  rep(i,0,m){    int u,v;    scanf(&quot;%d %d&quot;,&amp;u,&amp;v);    p2[u].push_back(v);  }  // a-&gt;b / b-&gt;a 至少满足一条  // scc 成链? 唯一拓扑顺序  vector&lt;int&gt; num = tarjan.calc(); // scc 联通分量 标识  vector&lt;int&gt; sccsz(n+1,0);  rep(i,1,n+1){    sccsz[num[i]]   ++;  }  rep(i,1,n+1){    if(sccsz[i] == 2){      // 竞赛图不能创造大小为2的scc!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!      printf(&quot;NO\n&quot;);      return ;    }  }  // rep(i,1,n+1){  //   printf(&quot;scc: %lld: %d\n&quot;,i,num[i]);  // }  // 转化为联通分量关系  rep(i,1,n+1){    for(auto item:p2[i]){      if(num[i] == num[item])continue;      p3[num[i]].push_back(num[item]);    }  }  rep(i,1,n+1){    if(num[i] != i)continue;    sort(p3[i].begin(),p3[i].end());    int itr = 0;    rep(j,0,(int)p3[i].size()){      if(j==0 || p3[i][j] != p3[i][j-1]){ // 去重        p3[i][itr++] = p3[i][j];        // i -&gt; p3[i][j]        du[p3[i][j]]++; // 入度      }    }    p3[i].resize(itr);  }  // 拓扑 联通分量中 唯一顺序  // 入度为0  vector&lt;int&gt; d0;  rep(i,1,n+1){    if(num[i] != i)continue;    if(du[i] == 0)d0.push_back(i);  }  while(d0.size()) { // == 1    if(d0.size() &gt; 1){      printf(&quot;NO\n&quot;);      return ;    }    int i = d0[0];    // printf(&quot;D0:%d\n&quot;,i);    d0.pop_back();    rep(j,0,(int)p3[i].size()){      // i -&gt; p3[i][j]      du[p3[i][j]]--;      if(du[p3[i][j]] == 0){        d0.push_back(p3[i][j]);        if(d0.size() &gt; 1){            printf(&quot;NO\n&quot;);            return ;        }      }    }  }  printf(&quot;YES\n&quot;);}int main(){  int t;  scanf(&quot;%d&quot;,&amp;t);  while(t--){    work();  }  return 0;}</code></pre><h1 id="C题目"><a href="#C题目" class="headerlink" title="C题目"></a>C题目</h1><p><a href="https://ac.nowcoder.com/acm/contest/11200/C" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/contest/11200/C</a></p><h1 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h1><p>从1开始</p><ol><li>每次可以移动 x = x+1</li><li>如果当前格子未被染色, 则染色当前格子并且设置 x = a[x]</li></ol><p>a[x]保证非严格单调递增</p><p>n&lt;=1e6</p><p>输出把所有格子都染色的方案数</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>设 f(x)把前x个格子全部染色的方案数, 注意到虽然顺序上可能 在染前x个格子过程中,已经把后面的格子染色了,但是后面这个被染色的不计入方案统计</p><ul><li>x 如果是最后一个被染色的,那么方案数为f(x-1)</li><li>x 如果不是最后一个被染色的, 那么对于f(x-1)中, 相当于 <code>? -&gt; x -&gt; y</code>, $y \in [a_x,x-1]$, 所以它可以放在$x-a_x$个位置的前面</li></ul><p>所以方案数 = $\prod_{i=1}^n(i-a_i+1)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 1000000007#define rep(i,a,n) for (ll i=a;i&lt;n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backconst double pi = acos(-1.0);int n;int a[1000010];int main(){  ll ans = 1;  cin&gt;&gt;n;  rep(i,1,n+1){    scanf(&quot;%d&quot;,a+i);    if(i-a[i]+1 &lt;= 0){      ans = 0;    }else{      (ans*=i-a[i]+1)%=MOD;    }  }  printf(&quot;%lld\n&quot;,ans);  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>状态转移的过程中, 对于上面这种,实际上也可以和方案描述不一致, 统计的时候不会包含超过当前位置的移动方案,而后面的移动方案是可以等价的插入到前面的方案中的(才可以乘法)</p><p>不过现在好的是,我能判断这个类型算是数学和转移的题了,也想到这样设计状态,但是没有细想</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://ac.nowcoder.com/discuss/952589" target="_blank" rel="noopener">https://ac.nowcoder.com/discuss/952589</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;比赛总结&quot;&gt;&lt;a href=&quot;#比赛总结&quot; class=&quot;headerlink&quot; title=&quot;比赛总结&quot;&gt;&lt;/a&gt;比赛总结&lt;/h1&gt;&lt;p&gt;比赛id 11200&lt;/p&gt;
&lt;p&gt;B:&lt;/p&gt;
&lt;p&gt;数组空间没开够等未定义行为,不会像Codeforces报overfl
      
    
    </summary>
    
      <category term="NowCoder" scheme="http://yexiaorain.github.io/Blog/categories/NowCoder/"/>
    
    
      <category term="竞赛图" scheme="http://yexiaorain.github.io/Blog/tags/%E7%AB%9E%E8%B5%9B%E5%9B%BE/"/>
    
      <category term="递推" scheme="http://yexiaorain.github.io/Blog/tags/%E9%80%92%E6%8E%A8/"/>
    
  </entry>
  
  <entry>
    <title>Atcoder agc057 C (trie树, bit flip)</title>
    <link href="http://yexiaorain.github.io/Blog/2022-05-11-ac_agc057C/"/>
    <id>http://yexiaorain.github.io/Blog/2022-05-11-ac_agc057C/</id>
    <published>2022-05-10T20:25:14.000Z</published>
    <updated>2022-05-11T03:10:54.277Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://atcoder.jp/contests/agc057/tasks/agc057_c" target="_blank" rel="noopener">https://atcoder.jp/contests/agc057/tasks/agc057_c</a></p><p><code>0~ 2^N - 1</code>的排列</p><p>问能否通过多次任选操作(每次操作独立,在上一次操作结果基础上), 让数列单调递增, 给出方案</p><p>操作1: <code>a[i] = (a[i]+1)%(2^n)</code> , 所有值循环+1</p><p>操作2: <code>a[i] = a[i] xor x</code> , 选定一个值,所有值异或它</p><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>n&lt;=18</p><h1 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h1><p>显然连续的异或没意义,甚至题目可以改成不是+1,+任意</p><p>所以问题变成 穿插的正数个+1和xor能否让数列单调递增, 若能给出方案</p><p>考虑所有+1/xor 末尾是1, 都是让所有末尾翻转, 因此结论是 末位前两个互为0/1,后面循环这两个</p><p>同理考察第二位,发现(0和2)(1和3)两对,互为0/1,后面的同样按照4个一组循环</p><p>同理考察第三位,发现(0和4)(1和5)(2和6)(3和7)四对,互为0/1,后面的同样按照8个一组循环</p><p>换句话说, 最低位1个自由元,其它由它决定,第2低位两个自由元,剩余的也是由它决定,第低3位4个自由元,低4位8个自由元…</p><p>我想先弄好一部分位再弄剩下的,从高位到低位或从低位到高位,但是 没想到实际怎么操作</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="设计结构"><a href="#设计结构" class="headerlink" title="设计结构"></a>设计结构</h2><p><img src="https://img.atcoder.jp/agc057/ae70f93e5ead40b583e634fc51e8ccef.png" alt="trie tree"></p><p>先不看方框, 看树上的边, 从根向叶子的方向, 对应值的从低到高的位</p><p>然后关注叶子方框,例如上面的6,二进制下是110,和它的路径是一样的</p><p>再看带有n的方框,意思是如果从树上截取某个点作为根来看,如果根表示的是n,那么一条边权是0子节点是2n+0,边权是1的子节点是2n+1, 注意的是这里并不是左右节点,而是由边权决定的</p><hr><p>树的结构建好以后, 那么把叶子中再填入初始每个值所在的位置,完成初始化</p><p>接下来看+1和xor操作对树进行怎样的修改</p><h2 id="1"><a href="#1" class="headerlink" title="+1"></a>+1</h2><p><img src="https://img.atcoder.jp/agc057/70285518a991e540173c7cc763f448e0.png" alt="+1"></p><p>因为我们的树是越接近根,对应的位越低,所以+1带来的进位效果也是从根向叶子前进的</p><p>如果我们以改变树上边的权值,而不是改变左右指向的视角来看,</p><p>那么对于根</p><p>0变成1</p><p>1变成0且它的子树受到和根一样的处理</p><p>这样发现改动的实际上只有log级别个</p><h2 id="xor"><a href="#xor" class="headerlink" title="xor"></a>xor</h2><p><img src="https://img.atcoder.jp/agc057/b9c3f79d227be93340d020278b2f15e5.png" alt="xor"></p><p>xor 比 +1 其实好观察,</p><p>对于xor二进制对应位为1的层级的0变成1,1变成0</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>现在我们再回头看目标呢, 也就是位置上和它对应的值是一样的</p><p>这里可以思考为啥,是按边上的值来描述而不是左右描述的, 考虑不按照涂上那样初始摆,而是按照叶子直接放初始的值,比如这里<code>0 4 2 6 1 5 3 7</code>位置上对应的值, 在放值时就能明确的知道冲突的情况,排除一些不可能</p><p>问题变成了,如何让二叉树边上的0/1 变回 完全二叉树的位置对应的值</p><hr><p>考虑把叶子变成 0,1 序列.</p><p>如果叶子是反着的1,0, 那么只需要把上面的路径变成 从根到它都是1,这样+1 就能完成修正</p><p>修正了所有叶子以后, 问题来了, 还可以通过+1/xor的组合修正非叶子吗</p><pre><code>   1       0 1   0   0   1 ( 其它位还有 不是xor 能解决的情况0 1 0 1 0 1 0 1 ( 高位全部0,1顺序了</code></pre><p>证明不可能, 首先 这种情况, 如果能修正,必定是奇数次操作到该层, 因为 xor不改相对一致性,+每次操作到这两个中的一个就会改,所以这两个操作次数总和必为奇数,考虑它们所覆盖的叶子节点,总操作次数也为奇数</p><p>因此要么 xor翻转能得到,要么就是不可能</p><hr><p>从逻辑上, 已经完成了,还有个实现问题,如果通过枚举导数第二层,再模拟xor和+1, 虽然+1代价小,但是xor的代价可能达到O(n)的级别, 总的会变成n方</p><p>简单的增加一个翻转标识记录行的翻转状态, 因为+1是对单个点翻转,xor是行翻转,翻转两次等于未翻转,都是翻转,所以+1直接让对应位置的节点翻转, 而xor 通过行标识记录, </p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><a href="https://atcoder.jp/contests/agc057/submissions/31596691" target="_blank" rel="noopener">https://atcoder.jp/contests/agc057/submissions/31596691</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)const int N = 262144;vector&lt;int&gt; lr(N*4+10,-1); // -1 unset 0:01, 1:10int a[N+10];int n;bool build(int pos,int val,int idx = 1,int pwr = 0){  if(pwr == n)return true;  int direction = pos%2;  int v = direction != val%2;  if(lr[idx] != -1 &amp;&amp; lr[idx] != v){    return false;  }  lr[idx] = v;  return build(pos/2,val/2,idx*2+direction,pwr+1);}int xorcache[20] = {0}; // 不要实际的xor, 修改代价大vector&lt;int&gt;ans;void fix(int val){  // printf(&quot;Fix %d\n&quot;,val);  int x = 0;  {    int pwr = n-1;    int v = val;    while(pwr--){      if(v%2 == (lr[v/2] ^ xorcache[pwr])){        x |= (1&lt;&lt;(pwr));      }      v/=2;    }  }  // printf(&quot;xor %d\n&quot;,x);  if(x){    ans.push_back(x);    rep(pwr,0,n){      if((1&lt;&lt;pwr) &amp; x)xorcache[pwr]^=1; // 标记    }  }  // printf(&quot;+1\n&quot;);  {    int idx = 1;    rep(pwr,0,n){      if(lr[idx]^xorcache[pwr]){        idx=idx*2;      }else{        idx=idx*2+1;      }      lr[idx/2] ^= 1;    }  }  ans.push_back(-1);}int main(){  cin&gt;&gt;n;  rep(i,0,(1&lt;&lt;n)){    scanf(&quot;%d&quot;,a+i);  }  rep(i,0,(1&lt;&lt;n)){    int r = build(i,a[i]);    if(!r){      printf(&quot;No\n&quot;);      return 0;    }  }  // rep(i,1,8){  //   printf(&quot;lr[%lld]= %d\n&quot;,i,lr[i]);  // }  rep(i,(1&lt;&lt;(n-1)),(1&lt;&lt;n)){    if(lr[i] == 0)continue;    fix(i);  }  int x = 0;  rep(pwr,0,n){    if(lr[1&lt;&lt;pwr] ^ xorcache[pwr]){      x |= 1&lt;&lt;pwr;      xorcache[pwr] ^= 1;    }  }  if(x){    ans.push_back(x);  }  rep(pwr,0,n){    rep(i,(1&lt;&lt;pwr),(1&lt;&lt;(pwr+1))){      if(lr[i]^xorcache[pwr]){        printf(&quot;No\n&quot;);        return 0;      }    }  }  printf(&quot;Yes\n&quot;);  printf(&quot;%d\n&quot;,(int)ans.size());  rep(i,0,(int)ans.size()){    printf(&quot;%d &quot;,ans[i]);  }  printf(&quot;\n&quot;);  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实我的思路和题解中trie树的结论是一致的,但是我的思路不是trie树形状的,所以再往后推导的阻力更大</p><p>一个经验就是对于这种2的幂次的 xor 或 加减操作,可以放在trie树中批量操作, 比如稍微变一变, 就可以变成给你+1/-1/xor操作序列,和询问第idx位置是什么,这样多个操作询问交替的题目</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>官方题解 <a href="https://atcoder.jp/contests/agc057/editorial/3925" target="_blank" rel="noopener">https://atcoder.jp/contests/agc057/editorial/3925</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://atcoder.jp/contests/agc057/tasks/agc057_c&quot; target=&quot;_b
      
    
    </summary>
    
      <category term="Atcoder" scheme="http://yexiaorain.github.io/Blog/categories/Atcoder/"/>
    
    
      <category term="math" scheme="http://yexiaorain.github.io/Blog/tags/math/"/>
    
      <category term="trie树" scheme="http://yexiaorain.github.io/Blog/tags/trie%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 1677E(线段树,倍数,贡献,单调栈,离线)</title>
    <link href="http://yexiaorain.github.io/Blog/2022-05-09-CF1677E/"/>
    <id>http://yexiaorain.github.io/Blog/2022-05-09-CF1677E/</id>
    <published>2022-05-09T02:24:00.000Z</published>
    <updated>2022-05-09T08:25:37.827Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://codeforces.com/contest/1677/problem/E" target="_blank" rel="noopener">https://codeforces.com/contest/1677/problem/E</a></p><p>给定1到n的排列</p><p>q个询问</p><p>每次问[l..r] 中有多少子区间, 满足 子区间存在不同的两个数的乘积 等于 子区间最大值</p><h1 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h1><p>n &lt;= 2e5</p><p>q &lt;= 1e6</p><p>4s</p><p>1024MB</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><code>a[1..n]</code>为给的排列</p><p>离线, 把所有查询<code>[l..r]</code> 按<code>r</code>升序</p><p><code>for(i = 1..n)</code> 在<code>i == r</code> 时,回答查询<code>[l..r]</code></p><p>线段树, 叶子节点记录<code>[l..j], (j&lt;=r)</code> 有多少个是满足的, 答案就是线段树的区间求和<code>query(o,1,n,l,r)</code></p><p>问题: 遍历过程中<code>i=&gt;i+1</code>时,也就是以<code>i==r</code>作为区间结束时,合法的区间<code>起始l</code>需要+1,但<code>合法的l</code>是散的,不是一个连续的区间, 这样更新复杂度高</p><hr><p>考虑加入<code>r</code>时, 左侧比它大的端点的贡献, 首先用单调栈记录(坐标增加,值减少)</p><p><code>vector&lt;pair&lt;value,position&gt;&gt; stk</code>, 其中<code>(stk[i].value = a[stk[i].position])</code></p><p>那么加入<code>{a[r],r}</code> 后会移除值比它小的, 变成</p><p><code>stk[0] ... stk[i-1] stk[i] ... stk[j] {a[r],r}</code></p><p>讨论3部分贡献</p><ol><li><p>以<code>a[r]</code> 为区间最大值, 那么必然 $(stk[j].position, r]$ 中找最右侧的位置<code>k</code>让<code>a[k..r]</code>中能有两个乘起来等于<code>a[r]</code>, 这样, 就有$k-stk[j].position$ 个合法方案</p></li><li><p>以<code>stk[i].value</code>为区间最大值, 且<code>stk[i].value</code> <strong>不是</strong><code>a[r]</code>的倍数, $max(k) ,k \in (stk[i-1].position,stk[i].position]$, 贡献为$k-stk[i-1].position$, 因为不是倍数, 显然并不会因为多了<code>a[r]</code> 影响以这个值为最大值的左侧选取的$k$, 所以换个说法就是, 它以原来的贡献又贡献了一轮</p></li><li><p>以<code>stk[i].value</code>为区间最大值, 且<code>stk[i].value</code> <strong>是</strong><code>a[r]</code>的倍数, $max(k) ,k \in (stk[i-1].position,stk[i].position]$, 贡献为$k-stk[i-1].position$, 是倍数, 所以需要看<code>stk[i].value/a[r]</code>这个值所在的位置是否会更新<code>k</code></p></li></ol><p>这样去统计, 单调队列中</p><hr><p>考虑变化</p><p>如果我们每个线段树节点记录了 <code>(对右侧贡献的左端点数量x, 总贡献数c)</code></p><p><code>(x0,c0) =&gt; (x1,c1)</code> 是怎么变化的呢</p><p><code>x1 = x0 + 那些</code>a[r]<code>倍数中超出来的长度</code></p><p><code>c1 = c0 + x1</code></p><p>注意的是, 可以lazytag记录有多少轮没有向下, 每次修改log级别个节点就行了</p><p>(这个方法感觉有实现问题, 我尝试做了一下,发现每次需要 <code>c += x</code>, 但是因为lazytag 的关系, 你一个节点上只能保存常数个x 和 常数个次数记录, 对于在 dep 层 的变化, lazytag down到dep+1层会覆盖x, 换句话说 lazy 的部分和历史每个节点内的x相关</p><hr><p>官方的代码, 记录的是<code>(x0,y0)</code></p><p><code>y0 = c0 - x0 * 轮次, y1 = c1 - x1*(轮次+1) = (x1+c0) - x1*(轮次+1) = y0 - (x1-x0) * 轮次</code></p><p>比记录<code>和</code>好的是,在不更新时(x,y)不会变,而c会变, 每次更新后所有节点都是正确的值, 因为lazy的部分只和当前轮次相关, 而这些轮次加和以后, 就是y的变化量</p><p>注意到 lazy的部分 (x1-x0) 要么是<code>len</code>要么是<code>-len</code>,  所以把符号给到<code>轮次</code>上, lazy<code>轮次</code>的和即可</p><p>而不是全覆盖的部分, 直接去更新到准确的<code>(x,y)</code></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="官方代码-注释"><a href="#官方代码-注释" class="headerlink" title="官方代码+注释"></a>官方代码+注释</h2><p><a href="https://codeforces.com/contest/1677/submission/156392477" target="_blank" rel="noopener">https://codeforces.com/contest/1677/submission/156392477</a></p><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)const int N=2e5;#define SEG_ROOT 1,1,n#define SEG_L (o&lt;&lt;1)#define SEG_R (o&lt;&lt;1|1)#define mid (l+r)/2#define SEG_L_CHILD SEG_L,l,mid#define SEG_R_CHILD SEG_R,mid+1,r#define SEG_L_CHILD_Q SEG_L,l,mid,ql,qr#define SEG_R_CHILD_Q SEG_R,mid+1,r,ql,qrint n; // 数组长度int a[N+10]; // 原始排列 1-indexint a2i[N+10]; // 值到下标 a2i[value] = indexint di; // 单调栈的尾部下标int d[N+10]; // 单调栈,存的原数组的下标 1-index, d[stack-index] = a-indexint i2di[N+10]; // [a中下标] = 栈中下标 映射  i2di[a-index] = stack-index , 0(表示不在栈中)int ti; // 当前遍历的个数 = i-1 or iint p[N+10]; // p[stack-index] = 左侧最大合法a-indexll ans[1000005]; // 询问的答案数组vector&lt;pair&lt;int,int&gt; &gt;q[1000005]; // 询问 q[right] = vector&lt;pair&lt;left,query index&gt; &gt;vector&lt;int&gt; w[N + 10]; // 因数分解 w[value]= vector&lt;value的因数&gt;struct seg {  // 答案 = x * ti + y  ll x; // 合法的左端点位置数  ll y; // (真实答案 与 x*ti 之间补充的差), 辅助变量, 因为直接记录答案无法维护x, 同理也可以记录(真实答案,x), y = 该段贡献 - x*ti, (x0,y0)=&gt;(x1,y1) : (y0+x0*ti) + x1 = (y1+x1*(ti+1)), y1 = y0 - (x1-x0)*ti  ll tg; // 未向下传递的ti的和, y += (+/- ti) * len  ll len; // 对应区间长度 简化书写} tr[N*4 + 10];// 初始化 线段树, 只有设置len = 区间长度,其它x,y,tg全为0void make(int o,int l,int r){  tr[o].len=r-l+1;  if (l==r) return;  make(SEG_L_CHILD);  make(SEG_R_CHILD);}// lazy tag 下降void down(int o) {  // x  if (tr[o].x == tr[o].len) {    tr[SEG_L].x = tr[SEG_L].len;    tr[SEG_R].x = tr[SEG_R].len;  }  if (tr[o].x==0) {    tr[SEG_L].x=0;    tr[SEG_R].x=0;  }  // 能向下的tag一定是区间全覆盖的  if(tr[o].tg != 0){    assert(tr[o].x == tr[o].len || tr[o].x == 0);    // y, 如下clear和add 同样的 y += tg * len    tr[SEG_L].y+=tr[o].tg*tr[SEG_L].len;    tr[SEG_R].y+=tr[o].tg*tr[SEG_R].len;    // tg    tr[SEG_L].tg+=tr[o].tg;    tr[SEG_R].tg+=tr[o].tg;    tr[o].tg=0;  }}// 更新 ovoid up(int o) {  tr[o].x=tr[SEG_L].x+tr[SEG_R].x; // 贡献数  tr[o].y=tr[SEG_L].y+tr[SEG_R].y; // 修正值}// 保证 tr[o].x == tr[o].lenvoid clear(int o,int l,int r,int ql,int qr) {  if (ql &lt;= l &amp;&amp; r &lt;= qr) {    // 贡献变化 tr[o].x * ti + tr[o].y =&gt; 0 * ti (当前轮) + (tr[o].y + ti * tr[o].len)    // (tr[o].y + ti * tr[o].len) - (tr[o].x * ti + tr[o].y)    // = ti * (tr[o].len - tr[o].x)    // = 0    assert(tr[o].x == tr[o].len);    tr[o].tg+=ti; // 选中 -&gt; 未选 未向下传递的, 对于下一级来说,也是 y+=ti*(len-x), 所以+ti传下去    tr[o].y += ti*tr[o].len;// y += ti * x =&gt; y += ti * len    tr[o].x=0;    return;  }  down(o);  if (ql&lt;=mid) clear(SEG_L_CHILD_Q);  if (qr&gt;mid) clear(SEG_R_CHILD_Q);  up(o);}// [ql..qr] 现在合法// 保证了 tr[o].x == 0void add(int o,int l,int r,int ql,int qr) {  if (ql &lt;= l &amp;&amp; r &lt;= qr) {    // 贡献变化 tr[o].x * ti + tr[o].y =&gt; tr[o].len * (ti+1) 下一轮 + (tr[o].y - ti * tr[o].len)    // (tr[o].len * (ti+1) + tr[o].y - ti * tr[o].len) - (tr[o].x * ti + tr[o].y)    // = tr[o].len - (tr[o].x * ti)    // = tr[o].len    assert(tr[o].x == 0);    tr[o].tg += -ti; // 未选 -&gt; 选中 未向下传递的    tr[o].y += -ti*tr[o].len; // y += -ti*(len - x) =&gt; y+= -ti * len    tr[o].x=tr[o].len;    return;  }  down(o);  if (ql&lt;=mid) add(SEG_L_CHILD_Q);  if (qr&gt;mid) add(SEG_R_CHILD_Q);  up(o);}ll find(int o,int l,int r,int ql,int qr) {  if (ql &lt;= l &amp;&amp; r &lt;= qr) return tr[o].y+ti*tr[o].x; // 如segtree的设计定义  down(o);  ll ret = 0;  if (ql&lt;=mid) ret+=find(SEG_L_CHILD_Q);  if (qr&gt;mid) ret+=find(SEG_R_CHILD_Q);  return ret;}int main() {  int m; // 询问次数  scanf(&quot;%d%d&quot;,&amp;n,&amp;m);  // 读入排列  rep(i,1,n+1){    scanf(&quot;%d&quot;,&amp;a[i]);    a2i[a[i]]=i;  }  // 读入询问  rep(i,1,m+1) {    int l,r;    scanf(&quot;%d%d&quot;,&amp;l,&amp;r);    q[r].emplace_back(l,i);  }  // 因数  rep(i,1,n+1)    for (int j=i;j&lt;=n;j+=i)      w[j].emplace_back(i);  // 初始化 线段树, 只有设置len = 区间长度,其它x,y,tg全为0  make(SEG_ROOT);  rep(i,1,n+1) { // a[i]    while (di &amp;&amp; a[d[di]]&lt;a[i]) { // 新加入的值, 比单调栈中的最小的小, 移除操作      if (p[di]&gt;d[di-1]) clear(SEG_ROOT,d[di-1]+1,p[di]); // 从贡献标记为不贡献, 但是对于总的贡献不变      // 出栈      i2di[d[di]]=0;      di--;    }    for (int j=a[i];j&lt;=n;j+=a[i]) { // j = a[i] 的倍数, j 作为最大值时      int k=i2di[a2i[j]]; // j在栈中下标      if (!k) continue; // 不在栈中      int l=d[k-1]+1,r=d[k]; // 左端点在范围 a[l..r] 中      int e=a2i[j/a[i]]; // 乘起来等于j的另一个因数在a中的下标      if (e&lt;l || e&gt;=i) continue; // e 在范围 a[l..i) 中, 不能选同一个ie平方      e=min(e,r); // 左端点范围的最大值 a[l..e]      if (e&lt;=p[k]) continue; // p[k] 最大值不更新      // a[l..p[k]] 合法 =&gt; a[l..e] 合法      add(SEG_ROOT,p[k]+1,e); // 把[p[k]+1,e] 从不贡献变成贡献, 更新到本轮结束时该有的(x,y)      p[k]=e;    }    // 入栈    d[++di]=i;    i2di[i]=di;    p[di]=d[di-1]; // 初始化p[di]表示以a[i]作为峰, 左侧端点不贡献    for (auto j:w[a[i]]) { // 枚举 因子对 (j,a[i]/j)      int l=d[di-1]+1;      // int r=i;      int e1=a2i[j];      int e2=a2i[a[i]/j];      if (e2&lt;=e1) continue; // 减少重复计算,主要是不等于      if (e1&lt;l || e2&gt;i) continue; // [l-1..e1..e2..i+1]      if (e1&lt;=p[di]) continue; // 不会更新可行值 [p[di] .. e1 .. i]      add(SEG_ROOT,p[di]+1,e1); // 从不贡献记为贡献, 更新到本轮结束时该有的(x,y)      p[di]=e1; // 更新    }    ti++;    for (auto t:q[i]) ans[t.second] = find(SEG_ROOT,t.first,i); // 查询[l = t.first,r = i]  }  rep(i,1,m+1) printf(&quot;%lld\n&quot;,ans[i]);  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>学会了一下新的线段树写法,以前我在左右拆点的时候, 会根据覆盖决定是</p><p><code>(ql,qr) =&gt; (ql,qr)</code> 还是<code>(ql,qr) =&gt; (ql,mid)</code> 还是 <code>(ql,qr) =&gt; (mid+1,qr)</code>  终止条件是<code>l == ql &amp;&amp; r == qr</code></p><p>这里学到了把终止条件改成<code>ql &lt;= l &amp;&amp; r &lt;= qr</code>, 这样的话, 传参就不用拆了<code>(ql,qr) =&gt; (ql,qr)</code></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://codeforces.com/contest/1678/attachments/download/16086/Codeforces%20Round%20789%20Editorial%20in%20Chinese.pdf" target="_blank" rel="noopener">https://codeforces.com/contest/1678/attachments/download/16086/Codeforces%20Round%20789%20Editorial%20in%20Chinese.pdf</a></p><p><a href="https://codeforces.com/blog/entry/102631" target="_blank" rel="noopener">https://codeforces.com/blog/entry/102631</a></p><p><a href="https://www.bilibili.com/video/BV1GS4y1b7SD" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1GS4y1b7SD</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1677/problem/E&quot; target=&quot;_blank
      
    
    </summary>
    
      <category term="Codeforces" scheme="http://yexiaorain.github.io/Blog/categories/Codeforces/"/>
    
    
      <category term="math" scheme="http://yexiaorain.github.io/Blog/tags/math/"/>
    
      <category term="线段树" scheme="http://yexiaorain.github.io/Blog/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="贡献" scheme="http://yexiaorain.github.io/Blog/tags/%E8%B4%A1%E7%8C%AE/"/>
    
      <category term="单调栈" scheme="http://yexiaorain.github.io/Blog/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
      <category term="离线" scheme="http://yexiaorain.github.io/Blog/tags/%E7%A6%BB%E7%BA%BF/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 1677D(冒泡排序, 排列)</title>
    <link href="http://yexiaorain.github.io/Blog/2022-05-09-CF1677D/"/>
    <id>http://yexiaorain.github.io/Blog/2022-05-09-CF1677D/</id>
    <published>2022-05-09T00:40:36.000Z</published>
    <updated>2022-05-09T02:24:28.752Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://codeforces.com/contest/1677/problem/D" target="_blank" rel="noopener">https://codeforces.com/contest/1677/problem/D</a></p><p>1到n的排列,进行k次冒泡排序<code>(for i = 0..n-1{if a[i] &gt; a[i+1]: swap(a[i],a[i+1])})</code>以后</p><p>每一位与它前面的逆序对个数为<code>v[i]</code></p><p><code>v[i] = count(a[j] &gt; a[i] &amp;&amp; j &lt; i)</code></p><p>现在给定数组<code>v</code>,其中<code>-1</code>表示任意值, 求有多少个原始序列 能k次冒泡排序后,逆序对满足v</p><p>答案<code>mod 998244353</code></p><p>保证<code>-1&lt;= vi &lt;=i</code></p><h1 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h1><p>t &lt;= 1000</p><p>k &lt; n &lt;= 1e6</p><p>2s</p><p>256MB</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>观察冒泡排序过程中 逆对的变化</p><p>如果<code>a[i]</code>前面有比它大的, 那么一次冒泡排序后,至多有一个移动到它后面, 且<code>a[i]</code>移动到了<code>a[i-1]</code></p><p>因此对于逆序对 <code>v[0] v[1] v[2] ... v[n]</code> 的变化是</p><p>如果<code>v[i] &gt; 0</code> , 那么一次排序后 <code>v[i-1] = v[i]-1</code></p><p>对于<code>v[i] == 0</code>, <code>0 v[i+1] v[i+2] v[i+3] ... v[j-2] v[j-1] 0</code>, 两个0之间其它非零</p><p>注意到上面 非0的结论, <code>(v[i+1]-1) (v[i+2]-1) (v[i+3]-1) ... (v[j-2]-1) (v[j-1]-1) 0 (v[?j+1]-1)</code>,</p><p>即是这个<code>0</code>会移动到下一个<code>0</code>的前一个位置,<code>a[j-1] = a[i]</code></p><hr><p>所以<code>0-index</code></p><p>最终<code>v[i] == 0</code> 操作前 <code>v[i+k] &lt;= k</code>(反证法) , <code>&lt;= min(k,i)</code></p><p>最终<code>v[i] &gt; 0</code> 操作前 <code>v[i+k] = k</code></p><p>最终<code>v[i] == -1</code> 操作前 <code>v[i+k]</code> 任意(<code>&lt;=i</code>)</p><p>最后k位一定是<code>0</code></p><hr><p>综上, 我们可以求得初始的<code>v</code>数组</p><p>其中 <code>[0..k-1]</code> 任意</p><p>其中 <code>[k..n]</code> 由按上述 平移确定具体情况</p><p>接下来讨论排列方案计算方式</p><p>如果完全自由就是<code>n!</code>,</p><p>考虑从<strong>后向前选</strong>, 如果位置<code>i</code>不受限制, 那么它有<code>i+1</code>种选法, 相当于每个位置的方案数和下标同增 <code>w[i] = i+1</code>(0-index)</p><p>如果它明确知道前面有几个比它小的, 那么只有唯一选法</p><p>如果它前面比它小的允许<code>&lt;=k</code>, 那么它有<code>k+1</code>种选法, 相当于<code>[0..k]</code>每个一种</p><hr><p>题目保证了<code>v[i]</code> 的范围,所以最多判断一下后k位是否为0即可</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><a href="https://codeforces.com/contest/1677/submission/156367090" target="_blank" rel="noopener">https://codeforces.com/contest/1677/submission/156367090</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 998244353#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)int n,k;int v[1000010];int main(){  int t;  cin&gt;&gt;t;  while(t--){    scanf(&quot;%d %d&quot;,&amp;n,&amp;k);    rep(i,0,n){      scanf(&quot;%d&quot;,v+i);    }    ll ans = 1;    rep(i,0,n){      if(i &lt; k){ // 前k个自由        (ans*=i+1)%=MOD;      }else if(v[i-k] == -1){ // -1 自由        (ans*=i+1)%=MOD;      }else if(v[i-k] == 0){ // &lt;=k 即 [0..k] , k+1种        (ans*=k+1)%=MOD;      } // v[i-k] != 0 , 唯一选择(从后向前)    }    // 最后k个一定是0(也可以-1表示0)    rep(i,0,k){      if(v[n-1-i] &gt; 0)ans = 0;    }    printf(&quot;%lld\n&quot;,ans);  }  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>感觉还是考察 冒泡排序及其性质</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.bilibili.com/video/BV1GS4y1b7SD" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1GS4y1b7SD</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1677/problem/D&quot; target=&quot;_blank
      
    
    </summary>
    
      <category term="Codeforces" scheme="http://yexiaorain.github.io/Blog/categories/Codeforces/"/>
    
    
      <category term="math" scheme="http://yexiaorain.github.io/Blog/tags/math/"/>
    
      <category term="冒泡排序及其性质" scheme="http://yexiaorain.github.io/Blog/tags/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E5%8F%8A%E5%85%B6%E6%80%A7%E8%B4%A8/"/>
    
  </entry>
  
  <entry>
    <title>Atcoder arc139 D 频率频次, 贡献统计, 二项式分布</title>
    <link href="http://yexiaorain.github.io/Blog/2022-04-25-ac_arc139D/"/>
    <id>http://yexiaorain.github.io/Blog/2022-04-25-ac_arc139D/</id>
    <published>2022-04-25T17:06:14.000Z</published>
    <updated>2022-05-10T20:55:35.692Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://atcoder.jp/contests/arc139/tasks/arc139_d" target="_blank" rel="noopener">https://atcoder.jp/contests/arc139/tasks/arc139_d</a></p><p>长度为n的有序数组a</p><p>每次操作, 选择[1~m]中的一个插入并<strong>保持有序</strong>, 删除下标为X的数(1-index)</p><p>进行k次操作的所有结果的剩余数组元素的和, 模 998244353</p><h1 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h1><p>n,m,k &lt;= 2000</p><p>$X \in [1,n]$</p><p>$a_i \in [1,m]$</p><p>2s</p><p>1024MB</p><h1 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h1><p>如果知道 最后结果数组中, 位置i 为v 的出现次数,那么 最后只需要求和即可</p><p><code>cnt(a[i] == v)</code></p><p>注意到 a一直是有序的,也就是 <code>cnt(a[i] == v)</code> 也意味着 <code>a[i..n] &gt;= v</code></p><p><code>cnt(a[i] == v) = cnt(a[i..n] &gt;= v) - cnt(a[i..n] &gt;= v-1)</code></p><p>把<code>指定位置等于</code> 转化成 <code>指定范围大于等于</code>, 就能更容易进行状态转移了</p><p><code>dp[0..k][1..n][1..m]</code></p><p><code>dp[itr][idx][v] =</code> 第itr次操作后, 从idx到n 都大于等于v的方案数</p><p>注意到 转移的系数和 itr 无关,所以可能可以矩阵快速幂</p><blockquote><p>但是我没推出来</p></blockquote><h1 id="官方题解翻译"><a href="#官方题解翻译" class="headerlink" title="官方题解翻译"></a>官方题解翻译</h1><p>如果 对于$\forall v \in [1..m]$ 我们能找到结果中 $\leq v$ 的数出现的次数 的期望(频次 = 总次数 * 频率), 那么就能计算答案了(和上面我思路同理 都是 等于转化成 大于等于/小于等于)</p><p>题意转换:</p><blockquote><p>对于一个指定的$v$</p></blockquote><p>给定 $x \in [0,N]$</p><blockquote><p>$x$的意义是初始数组中 $\leq v$的个数</p></blockquote><p>操作: 概率$p = \frac{v}{m}$ 让<code>x=x+1</code>, 如果 $x\ge X$ , 让<code>x=x-1</code></p><blockquote><p>意义是 有概率$p$ 选择不超过$v$的数, 那么个数加一</p></blockquote><blockquote><p>如果 总个数 大于 删除下标, 那么 必定被删除一个, 那么个数减一</p></blockquote><p>找到执行了$K$次操作后, $x$的期望值</p><blockquote><p>也就是 剩下 $\leq v$ 的个数</p></blockquote><p>注意到$|x - (X-1)|$ 会单调递减</p><blockquote><p>换句话说, 如果 $初始x &gt; (X-1)$ 那么$初始x \ge 最终x \ge (X-1)$</p></blockquote><blockquote><p>如果 $初始x &lt; (X-1)$ 那么$初始x \leq 最终x \leq (X-1)$</p></blockquote><blockquote><p>$初始x$ 是从输入的a中统计的</p></blockquote><p>如果我们指定了最终的x, 那么得到这个x的 概率可以用二项式系数和幂次得到</p><hr><p>设 初始值为$x_0$, 最终为$x_1$</p><p>若 $x_0 \leq x_1 &lt; X-1$</p><p>也就是$k$次 操作中 $x_1 - x_0$ 次增加了1, 其它时候全未增加</p><p>概率为 $C(k, x_1-x_0) \cdot p^{x_1-x_0}(1-p)^{k-(x_1-x_0)}$</p><p>若 $x_0 &lt; x_1 = X-1$ (如果 都是$X-1$那概率就是1)</p><p>也就是$k$次 操作中 至少$x_1 - x_0$ 次增加了1, 其它时候任意</p><p>概率为 $\sum_{i=0}^{k-(x_1-x_0)} C(k, x_1-x_0 + i) \cdot p^{x_1-x_0 + i}(1-p)^{k-(x_1-x_0 + i)}$</p><p>看起来难算, 但是因为 上面的$x_1 \neq X-1$的和$x_1 = X-1$构成了所有情况, 所以实际上直接 1减去上面概率和就是剩下概率</p><hr><p>对于$初始x_0$大于$X-1$的同理</p><p>其中组合数可以预处理,幂次可以快速幂</p><p>综上 可算</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><a href="https://atcoder.jp/contests/arc139/submissions/31271889" target="_blank" rel="noopener">https://atcoder.jp/contests/arc139/submissions/31271889</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 998244353#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)ll a[2010];ll pro[2010][2010]; // [v][cnt] 结果 &lt;= v 的有cnt个的概率ll c[2010][2010];ll mypow(ll v,ll pwr){  v=(v+MOD)%MOD;  ll r = 1;  while(pwr){    if(pwr%2)(r*=v)%=MOD;    (v*=v)%=MOD;    pwr/=2;  }  return r;}// C(m,n) = m!/(n!(m-n)!)ll C(ll m,ll n){  if(n &gt; m)return 0;  return c[m][n];}int main(){  rep(i,1,2005){    c[i][0] = c[i][i] = 1;    rep(j,1,i){      c[i][j] = (c[i-1][j-1] + c[i-1][j])%MOD;    }  }  ll n,m,k,x;  cin&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;x;  ll invm = mypow(m,MOD-2);  x--; // 先减1  rep(i,0,n){    scanf(&quot;%lld&quot;,a+i);  }  sort(a,a+n);  rep(v,1,m+1){    int stx = 0;    rep(i,0,n){      if(a[i] &lt;= v)stx++;      else break;    }    if(stx == x){ // 结果必定 x      pro[v][x] = 1;      continue;    }    // p = v/m    ll p = v * invm %MOD;    rep(endx,0,n+1){      if(stx &lt; x){ // stx &lt;= endx &lt;= x        if(stx &lt;= endx &amp;&amp; endx &lt; x){          // C(k,endx-stx) * p^(endx-stx) * (1-p)^(k-(endx-stx))          pro[v][endx] = C(k,endx-stx) * mypow(p,endx-stx) %MOD * mypow(1-p,k-(endx-stx)) % MOD;        }      }else { // stx &gt; x =&gt; stx &gt;= endx &gt;= x        if(stx &gt;= endx &amp;&amp; endx &gt; x){          // C(k,stx-endx) * (1-p)^(stx-endx) * p^(k-(stx-endx))          pro[v][endx] = C(k,stx-endx) * mypow(1-p,stx-endx) %MOD * mypow(p,k-(stx-endx)) % MOD;        }      }    }    // 最后处理 (endx == x) , 等于 1-其它概率和    pro[v][x] = 1;    rep(endx,0,n+1){      if(endx == x)continue;      (pro[v][x] -= pro[v][endx])%=MOD;    }  }  ll leqv[2010] = {0};  ll ans = 0;  rep(v,1,m+1){    rep(cnt,0,n+1){      (leqv[v] += cnt*pro[v][cnt]%MOD)%=MOD; // 期望长度 = sum{期望*长度}    }    (ans += v*(leqv[v] - leqv[v-1]) %MOD)%=MOD; // count( == v) = count(&lt;= v) - count(&lt;= v-1)  }  printf(&quot;%lld\n&quot;, ((ans * mypow(m,k)%MOD)+MOD)%MOD); // 频次 = 总次数 * 频率  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p> 相对于以前不会 <code>count(x = v) = count(x &gt;= v) - count(x &gt;= v+1) = count(x &lt;= v) - count(x &lt;= v-1)</code> , 已经算是有进步,能想到转换了</p><ol><li><p>但是 对于上面 转换成概率 和 小于统计的想法还是不够, 一个是 想用坐标表示而不是明确的值的分界线表示, 题解就没有坐标作为键,只是把坐标作为值</p></li><li><p>虽然从频次上也能算,但是上到概率,推概率公式,算出概率再转换成频次都会容易进入思路, 需要增加 频次和概率之间的转换意识</p></li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>官方题解 <a href="https://atcoder.jp/contests/arc139/editorial/3860" target="_blank" rel="noopener">https://atcoder.jp/contests/arc139/editorial/3860</a></p><p>Youtube官方 <a href="https://www.youtube.com/watch?v=tIdPBN2x6KU" target="_blank" rel="noopener">https://www.youtube.com/watch?v=tIdPBN2x6KU</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://atcoder.jp/contests/arc139/tasks/arc139_d&quot; target=&quot;_b
      
    
    </summary>
    
      <category term="Atcoder" scheme="http://yexiaorain.github.io/Blog/categories/Atcoder/"/>
    
    
      <category term="math" scheme="http://yexiaorain.github.io/Blog/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 1671F(暴力 组合数)</title>
    <link href="http://yexiaorain.github.io/Blog/2022-04-25-CF1671F/"/>
    <id>http://yexiaorain.github.io/Blog/2022-04-25-CF1671F/</id>
    <published>2022-04-25T05:40:36.000Z</published>
    <updated>2022-04-25T05:34:45.283Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://codeforces.com/contest/1671/problem/F" target="_blank" rel="noopener">https://codeforces.com/contest/1671/problem/F</a></p><p>t 组测试</p><p>问 [1~n]的所有排列中</p><p>x个相邻逆序对, k个逆序对 有多少个, 答案取mod 998244353</p><h1 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h1><p>t&lt;=3e4</p><p>n &lt;= 998244353 - 1</p><p>k &lt;= 11</p><p>x &lt;= 11</p><p>4s</p><p>512MB</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>k和x很小</p><p>直接暴力算出 12! 的所有排列,记录 其中 (k,x) 和长度</p><p>那么答案相当于 把这些排列 插入到有序数字中</p><p>所以 再计算一个组合数</p><p>需要注意的是, [1~10] 的排列 可能是由 [1-4][1-6]的排列组成的, 所以 要注意不可分割的排列统计, 或者插入的时候 不支持相邻</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>暂无</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>暴力和关联性的思路对了, 但为啥我在想矩阵乘法而不是组合数,让我自己卡住了</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1671/problem/F&quot; target=&quot;_blank
      
    
    </summary>
    
      <category term="Codeforces" scheme="http://yexiaorain.github.io/Blog/categories/Codeforces/"/>
    
    
      <category term="math" scheme="http://yexiaorain.github.io/Blog/tags/math/"/>
    
      <category term="暴力" scheme="http://yexiaorain.github.io/Blog/tags/%E6%9A%B4%E5%8A%9B/"/>
    
      <category term="组合数" scheme="http://yexiaorain.github.io/Blog/tags/%E7%BB%84%E5%90%88%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>Atcoder arc139 C 构造</title>
    <link href="http://yexiaorain.github.io/Blog/2022-04-25-ac_arc139C/"/>
    <id>http://yexiaorain.github.io/Blog/2022-04-25-ac_arc139C/</id>
    <published>2022-04-25T05:25:14.000Z</published>
    <updated>2022-05-10T20:55:27.804Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://atcoder.jp/contests/arc139/tasks/arc139_c" target="_blank" rel="noopener">https://atcoder.jp/contests/arc139/tasks/arc139_c</a></p><p>nxm格子选尽可能多的点</p><p>让每个点(x,y)的(x+3y)互不相等</p><p>且每个点(x,y)的(3x+y)互不相等</p><p>n,m &lt;= 1e5</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>我的思路是, 这相当于做的线性变换</p><p>每个点变成 (x,y) =&gt; (3x+y,x+3y)</p><p>要结果的点 的横纵坐标互不相等</p><p>那么原来是矩形的点, 映射后变成了斜着平行四边形的点</p><p>然后想办法尽可能多的找点, 但是我可能点画得不算多, 没有找到规律</p><pre><code class="py">import matplotlib.pyplot as pltx = []y = []for i in range(1, 10):    for j in range(1, 10):        x.append(3*i+j)        y.append(i+3*j)plt.plot(x, y, &#39;ro&#39;)ax = plt.gca()ax.set_xlim(0)ax.set_ylim(0)ax.xaxis.set_minor_locator(plt.MultipleLocator(1))ax.yaxis.set_minor_locator(plt.MultipleLocator(1))plt.grid(which=&#39;minor&#39;)plt.show()</code></pre><p><img src="/Blog/img/AC_AGC_139_1.png" alt="1"></p><hr><p>先考虑特殊情况足够大</p><p>那么对于 3x+y 有没有可能尽量排满</p><p>两种办法让3x+y 的增量为1</p><p>(x,y) =&gt; (x,y+1)</p><p>(x,y) =&gt; (x+1,y-2)</p><p>比较神奇的是</p><p>如果你考虑<code>x+3y</code>每次增加1的方案,是对称的</p><p>(x,y) =&gt; (x+1,y)</p><p>(x,y) =&gt; (x-2,y+1)</p><p>那么如图, 两个方法选的点(蓝色路线 和 绿色路线) 是一样的</p><p><img src="/Blog/img/AC_AGC_139_2.png" alt="2"></p><p>因此, 如果刚好 N=M, 且N是奇数, 就按照这个方法去选即可, 这样相当于把所有可能的(x+3y),(3x+y)的值都取到了</p><hr><p>非一般情况, 首先N,M 是可以轮换</p><p>所以不妨设 N&lt;=M</p><p>注意最大的个数,会被min(3n+m,n+3m) 限制, 也就是点的上界</p><p>但是如果短的边也是奇数的话</p><p>可以这样操作</p><p><img src="/Blog/img/AC_AGC_139_3.png" alt="3"></p><p>这样即满足题意, 又达到了上界</p><hr><p>两边不等,但是短边是 偶数长度</p><p><img src="/Blog/img/AC_AGC_139_5.png" alt="5"></p><p>这样即满足题意, 又达到了上界</p><hr><p>还有一个情况</p><p>两边相等,但是 是偶数长度</p><p><img src="/Blog/img/AC_AGC_139_4.png" alt="4"></p><p>如图, 距离上界还差4个, 但是看起来按现有的选法最多再选3个</p><p>下面证明 就是差一个</p><p>首先如果 N=2 , 那么M=2 最多选取 NM = 3N+M-4个</p><p>对于 N &gt;= 4,且为偶数</p><p>S = 从(3,1)开始, 通过多次 (+1,-3) / (+3,-1) 到达的所有点</p><p>注意到 这个集合中 其实就是 转换坐标轴后以 (3,1) 开始,同纵坐标,和同横坐标,反复关联的点</p><p><img src="/Blog/img/AC_AGC_139_6.png" alt="6"></p><p>而这些点,在x上的可选值 为 N/2-1, y上的可选值为N/2, 也就是S中的点本身是互相影响的点,而这些点占了N/2个位置,最多却只能选N/2-1, 因此 总的上界也是比范围小一</p><p>所以 不论N=2还是N&gt;=4 的偶数情况, 上述少选一个的方案 既能达到 又是上界</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>(无)</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>官方题解 <a href="https://atcoder.jp/contests/arc139/editorial/3863" target="_blank" rel="noopener">https://atcoder.jp/contests/arc139/editorial/3863</a></p><p>Youtube官方 <a href="https://www.youtube.com/watch?v=tIdPBN2x6KU" target="_blank" rel="noopener">https://www.youtube.com/watch?v=tIdPBN2x6KU</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://atcoder.jp/contests/arc139/tasks/arc139_c&quot; target=&quot;_b
      
    
    </summary>
    
      <category term="Atcoder" scheme="http://yexiaorain.github.io/Blog/categories/Atcoder/"/>
    
    
      <category term="math" scheme="http://yexiaorain.github.io/Blog/tags/math/"/>
    
      <category term="构造" scheme="http://yexiaorain.github.io/Blog/tags/%E6%9E%84%E9%80%A0/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 1661F(你真的会二分吗)</title>
    <link href="http://yexiaorain.github.io/Blog/2022-04-15-CF1661F/"/>
    <id>http://yexiaorain.github.io/Blog/2022-04-15-CF1661F/</id>
    <published>2022-04-15T05:48:36.000Z</published>
    <updated>2022-04-15T07:12:29.287Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://pbs.twimg.com/media/FQXM2cgVUAAVXpe?format=png&amp;name=360x360" alt></p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://codeforces.com/contest/1661/problem/F" target="_blank" rel="noopener">https://codeforces.com/contest/1661/problem/F</a></p><p>给你n个线段</p><p>问最少切多少次,让切割后所有线段长度平方和不大于m</p><h1 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h1><p>n&lt;=1e5</p><p>线段长度和 &lt;= 1e9</p><p>m &lt;= 1e18</p><p>7s</p><p>512MB</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="尝试"><a href="#尝试" class="headerlink" title="尝试"></a>尝试</h2><p>对于最外层的答案, 显然二分答案</p><p>那么问题变成了 如果指定切割k次, 能否满足条件</p><p>贪心: 从小到大, 判断剩余期望与已切割, 显然如果 当前 乘上段数 不大于剩余值, 那么不需要切割, 否则任意不合法必定存在比当前段更大的值, 要切也是切更大的</p><p>一定不切割的状态 能证明了, 但是不是这种状态时,可能切割也可能不切割, 即使切割, 怎么计算次数也不知道</p><p><a href="https://codeforces.com/contest/1661/submission/153691360" target="_blank" rel="noopener">https://codeforces.com/contest/1661/submission/153691360</a></p><p>例如两个线段 <code>3,4</code>, 要结果小于17, 最好的办法是均分4, 而这种没有对应的贪心规则, 上述方法不能判断</p><hr><p>另一个正确但是会超时的思路是</p><p>我们如果知道一个具体的段,要切割成多少份, 那么显然可以数学O(1)就算出这一段切割的最小值,(切割出来的尽量相等)</p><p>那么一个段 从 k次变成k+1次 它带来的变化量也是 上述计算相减,也是O(1)的</p><p>那么 我们直接维护优先队列 <code>(多切割一次代价,线段编号,当前切割次数)</code>, 这样每次取最大的切一下,放回去</p><p>复杂度就是 O(线段长度和), 也能直接计算出k次最优</p><p>问题是O(线段长度和)的计算代价, 甚至说这就是枚举答案了,外层的二分都没意义了</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>注意到 一个线段 随着切割次数变多, 每次贡献的代价也是单调递减的!!!!!!</p><p>再结合上面的 优先队列思路, 其实就是选取了k次最大值, 那么也就是 被选的 &gt;=x, 未被选的 &lt;= x</p><p>也就变成了找x, 满足如果被选的都是 大于x 则不满足题意,且如果被选的都是 大于等于 x 则满足题意</p><p>那么个数也就自然 是 大于x的个数,加上 与目标差距 除以 x 向上取整了</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 1000000007#define rep(i,a,n) for (ll i=a;i&lt;n;i++)#define per(i,a,n) for (ll i=n;i--&gt;a;)#define pb push_backconst double pi = acos(-1.0);// 0 &lt; a1 &lt; a2 &lt; a3..an 传送点// 传送消耗 (ai-aj)**2 能量// + 一些整数点 =&gt; a0 -&gt; an 能量消耗 &lt;= m// 最小整数点个数ll a[200010];vector&lt;ll&gt; segs ;int n;ll m;ll f(ll len, ll part){  if(part &gt; len)return len;  ll minv = len/part;  ll maxcnt = len%part;  // printf(&quot;f(%lld %lld) =&gt; %lld %lld =&gt; %lld\n&quot;,len,part,minv,maxcnt,minv*minv*(part - maxcnt) + (minv+1)*(minv+1) * maxcnt);  return minv*minv*(part - maxcnt) + (minv+1)*(minv+1) * maxcnt;}// 大于等于x的贡献都选pair&lt;ll,ll&gt; calc(ll x){ // 切割次数, 消耗平方值  assert(x &gt; 0);  ll cnt = 0; // 个数  ll sum = 0; // 消耗  rep(i,0,n){    if(x &lt;= 2){      sum += f(segs[i],1) - f(segs[i],segs[i]); // 1*1*segs[i];      cnt += segs[i] - 1;      continue;    }    // 最大的都不满足    if(f(segs[i],1) - f(segs[i],2) &lt; x){      continue;    }    // 二分切割的段    int l = 1, r = segs[i]; // l 满足 r 不满足    while(l+1&lt;r){      int mid = (l+r)/2;      if(f(segs[i],mid) - f(segs[i],mid+1)&gt;= x){        l = mid;      }else{        r = mid;      }    }    sum += f(segs[i],1) - f(segs[i],r);    cnt += l;  }  return {cnt,sum};}int main(){  ll cost = 0;  scanf(&quot;%d&quot;,&amp;n);  rep(i,1,n+1){    scanf(&quot;%lld&quot;,a+i);    segs.push_back(a[i]-a[i-1]);    cost += (a[i] - a[i-1])*(a[i] - a[i-1]);  }  scanf(&quot;%lld&quot;,&amp;m);  if(cost &lt;= m){    printf(&quot;0\n&quot;);    return 0;  }  // 找的是 x 不是答案  // l 满足 r 不满足  ll l = 0, r = 1&#39;000&#39;000&#39;000&#39;000&#39;000&#39;000;  while(l+1&lt;r){    // printf(&quot;[%lld %lld]\n&quot;,l,r);    ll mid = (l+r)/2;    if(calc(mid).second &gt;= cost - m){      l = mid;    }else{      r = mid;    }  }  assert(l != 0);  auto [c,s] = calc(r); // x+1 的所有  printf(&quot;%lld\n&quot;,c + (cost - m - s)/l + !!((cost - m - s)%l));  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>里面这个 二分好像很有用, 感觉之前做PE应该遇到过类似的,但是没想到二分,唉 我好蠢啊</p><h1 id="数学证明"><a href="#数学证明" class="headerlink" title="数学证明"></a>数学证明</h1><p>其实这里有一个东西 没有严格证明</p><p>就是 f(x,k) - f(x,k+1) 随着k增大而减小</p><p>难就难在它是整数划分, 如果是实数的话, 直接分析导数即可</p><p><a href="https://codeforces.com/blog/entry/101790?#comment-903251" target="_blank" rel="noopener">dreamoon</a></p><p><a href="https://codeforces.com/blog/entry/101790?#comment-903475" target="_blank" rel="noopener">jiangly</a></p><p>简单的说, 把 (x,k-1)的方案 和 (x,k+1)的方案拼在一起, 那么它一定是 2x 分割2k块的一个方案</p><p>那么 显然 (x,k)的方案的两倍 恰好是(2x,2k)的最优解</p><p>因此 2f(x,k) &lt;= f(x,k-1) + f(x,k+1) 即</p><p>f(x,k-1) - f(x,k) &gt;= f(x,k) - f(x,k+1) 得证</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/Code92007/article/details/124089868" target="_blank" rel="noopener">https://blog.csdn.net/Code92007/article/details/124089868</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://pbs.twimg.com/media/FQXM2cgVUAAVXpe?format=png&amp;amp;name=360x360&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="Codeforces" scheme="http://yexiaorain.github.io/Blog/categories/Codeforces/"/>
    
    
      <category term="math" scheme="http://yexiaorain.github.io/Blog/tags/math/"/>
    
      <category term="二分" scheme="http://yexiaorain.github.io/Blog/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>洛谷 P1036(prime)</title>
    <link href="http://yexiaorain.github.io/Blog/2022-04-11-luoguP1036/"/>
    <id>http://yexiaorain.github.io/Blog/2022-04-11-luoguP1036/</id>
    <published>2022-04-11T01:24:36.000Z</published>
    <updated>2022-04-11T01:46:37.204Z</updated>
    
    <content type="html"><![CDATA[<p>好久不登洛谷了, 最近翻了一下之前的一个帖子, 当时应该有其他事 没后续跟进了</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://www.luogu.com.cn/problem/P1036" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P1036</a></p><p>n个数</p><p>选k个出来和是质数的方案数</p><h1 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h1><p>n&lt;=20</p><p>ai&lt;=5e6</p><p>1s</p><p>128MB</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="数筛TLE"><a href="#数筛TLE" class="headerlink" title="数筛TLE"></a>数筛TLE</h2><p><a href="https://www.luogu.com.cn/record/25067342" target="_blank" rel="noopener">https://www.luogu.com.cn/record/25067342</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define ten5 100000+10#define MOD 1000000007#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define iif(c,t,f) ((c)?(t):(f))#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)#define pb push_back#define mp make_pairconst double pi = acos(-1.0);bool p[100000010];int ans = 0;int a[30];int n,k;void dfs(int idx,int picked,int cnt){  if(picked == k){    ans+=!p[cnt];    return ;  }  if(n - idx &lt; k-picked)return ;  dfs(idx+1,picked+1,cnt+a[idx]);  dfs(idx+1,picked,cnt);}int main(){  cin&gt;&gt;n&gt;&gt;k;  rep(i,0,n){    scanf(&quot;%d&quot;,a+i);  }  p[1] = 1;  rep(i,2,10001){    if(p[i] == 1)continue;    for(int j=i*i;j&lt;100000001;j+=i){      p[j] = 1;    }  }  dfs(0,0,0);  cout&lt;&lt;ans&lt;&lt;endl;  return 0;}</code></pre><h2 id="循环到根号n判质数竟然过了-而且搜到的一堆题解都是这样做"><a href="#循环到根号n判质数竟然过了-而且搜到的一堆题解都是这样做" class="headerlink" title="循环到根号n判质数竟然过了?而且搜到的一堆题解都是这样做"></a>循环到根号n判质数竟然过了?而且搜到的一堆题解都是这样做</h2><p><a href="https://www.luogu.com.cn/record/25067748" target="_blank" rel="noopener">https://www.luogu.com.cn/record/25067748</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define ten5 100000+10#define MOD 1000000007#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define iif(c,t,f) ((c)?(t):(f))#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)#define pb push_back#define mp make_pairconst double pi = acos(-1.0);//bool p[100000010];int ans = 0;int a[30];int n,k;bool pp(int v){  if(v==1)return 1;  int maxv = int(sqrt(v))+2;  rep(i,2,maxv){    if(v%i==0 &amp;&amp; v!=i){      return 1;    }  }  return 0;}void dfs(int idx,int picked,int cnt){  if(picked == k){    // ans+=!p[cnt];    ans+=!pp(cnt);    return ;  }  if(n - idx &lt; k-picked)return ;  dfs(idx+1,picked+1,cnt+a[idx]);  dfs(idx+1,picked,cnt);}int main(){  cin&gt;&gt;n&gt;&gt;k;  rep(i,0,n){    scanf(&quot;%d&quot;,a+i);  }  // p[1] = 1;  // rep(i,2,10001){  //   if(p[i] == 1)continue;  //   for(int j=i*i;j&lt;100000001;j+=i){  //     p[j] = 1;  //   }  // }  dfs(0,0,0);  cout&lt;&lt;ans&lt;&lt;endl;  return 0;}</code></pre><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>虽然当时发了帖子, 但是里面都在喷我表达不规范 XD, 没人给我说是数据其实很小的问题</p><p><a href="https://www.luogu.com.cn/discuss/153208" target="_blank" rel="noopener">https://www.luogu.com.cn/discuss/153208</a></p><p>数筛 是$O(sum + 2^n)$</p><p>而上面AC的代码是$O(max(2^n, sqrt(sum) \cdot 2^k))$</p><p>如果真如题目所说的数据范围, 其实数筛更有可能过大数据, 然而实际数筛TLE了</p><p>也有老哥说n实测出来最大是7,(7的话那的确第二种没啥问题), 那题目说你妈<code>n&lt;=20</code>呢?</p><p><a href="https://www.luogu.com.cn/discuss/347995" target="_blank" rel="noopener">https://www.luogu.com.cn/discuss/347995</a></p><h2 id="造数据"><a href="#造数据" class="headerlink" title="造数据"></a>造数据</h2><p>通过简单的尝试,生成了以下数列</p><pre><code class="py">for i in range(20):  print(5000000-1-6*i)</code></pre><pre><code>20 114999999 4999993 4999987 4999981 4999975 4999969 4999963 4999957 4999951 4999945 4999939 4999933 4999927 4999921 4999915 4999909 4999903 4999897 4999891 4999885</code></pre><p>这数据下</p><p>数筛<code>0.88s</code></p><p>后面方法<code>1.022s</code></p><p>电脑配置<code>i7-7700HQ</code></p><p>编译命令<code>clang++ -o Main Main.cpp -std=gnu++17 -O2 -g -Wall -Wcomma -Wextra -fsanitize=integer,undefined,null,alignment</code></p><h2 id="真题解-Miller-robin-特殊判定序列-这个可以极快判定64位以内的质数"><a href="#真题解-Miller-robin-特殊判定序列-这个可以极快判定64位以内的质数" class="headerlink" title="真题解 Miller robin + 特殊判定序列, 这个可以极快判定64位以内的质数"></a>真题解 Miller robin + 特殊判定序列, 这个可以极快判定64位以内的质数</h2><p><a href="https://www.luogu.com.cn/record/73708925" target="_blank" rel="noopener">https://www.luogu.com.cn/record/73708925</a></p><p><a href="https://yexiaorain.github.io/Blog/2021-06-12-project-euler216/">关于质数判别之前做PE时也写过</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef uint64_t ull;#define pb push_back#define rep(i,a,n) for (ll i=a;i&lt;n;i++)ll quick_p(ll b, ll p,const ll mod){  ll r = 1;  while(p){    if(p%2)(r*=b)%=mod;    (b*=b)%=mod;    p/=2;  }  return r%mod;}ll mr(ll base,ll v){  if(base &gt; v)return true;  ll startp = v-1;  while(startp%2 == 0)startp&gt;&gt;=1;  ll p = startp;  ll r = quick_p(base,p,v);  while(p != v-1){    if(r == v-1)return true;    if(r == 1)return p == startp;    p*=2;    // overflow    (r*=r)%=v;  }  return false;}bool is_prime_64(ll v){  if(v &lt; 2)return false;  if(v &lt; 4)return true;  // %6 = 1 or 5  if((v % 6) % 4 != 1)return false;  ll test_g[] = {2, 325, 9375, 28178, 450775, 9780504, 1795265022};  rep(i,0,7){    if(!(mr(test_g[i],v)))return false;  }  return true;}int ans = 0;int a[30];int n,k;void dfs(int idx,int picked,int cnt){  if(picked == k){    ans+=is_prime_64(cnt);    return ;  }  if(n - idx &lt; k-picked)return ;  dfs(idx+1,picked+1,cnt+a[idx]);  dfs(idx+1,picked,cnt);}int main(){  cin&gt;&gt;n&gt;&gt;k;  rep(i,0,n){    scanf(&quot;%d&quot;,a+i);  }  dfs(0,0,0);  cout&lt;&lt;ans&lt;&lt;endl;  return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;好久不登洛谷了, 最近翻了一下之前的一个帖子, 当时应该有其他事 没后续跟进了&lt;/p&gt;
&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.lu
      
    
    </summary>
    
      <category term="luogu" scheme="http://yexiaorain.github.io/Blog/categories/luogu/"/>
    
    
      <category term="math" scheme="http://yexiaorain.github.io/Blog/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 1658F(Math only)</title>
    <link href="http://yexiaorain.github.io/Blog/2022-04-08-CF1658F/"/>
    <id>http://yexiaorain.github.io/Blog/2022-04-08-CF1658F/</id>
    <published>2022-04-08T03:24:36.000Z</published>
    <updated>2022-04-08T03:39:00.442Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://codeforces.com/contest/1658/problem/F" target="_blank" rel="noopener">https://codeforces.com/contest/1658/problem/F</a></p><p>长度n的0/1串</p><p>找多个不重叠子串满足</p><ol><li>0/1比例和原串一致</li><li>长度和为m</li></ol><h1 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h1><p>m &lt;= n &lt;= 2e5</p><p>1s</p><p>256MB</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h2><p><a href="https://t.bilibili.com/646605883381383189" target="_blank" rel="noopener">https://t.bilibili.com/646605883381383189</a></p><ol><li>字符串拼成环</li><li>长度为m的1的个数,在相邻统计中变化最多为1, 所有的1个数和=m乘总的1的个数, 因此对于长度为m的1的个数 不会都大于目标也不会都小于目标,至少一个等于目标</li></ol><p>长度为m的在原数组内则一个, 跨了原数组边界则两个</p><hr><p>很明显不满足的我想到了,一个的很好做滑动窗口入门</p><p>但是我一直在想怎么证明 两个一定可以, 想了 单测大于小于, 全局不满足,但始终没想到 拼成环就容易搞了, 哎</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define pb push_backchar s[200010];int n,m;void work(){  scanf(&quot;%d %d&quot;,&amp;n,&amp;m);  scanf(&quot;%s&quot;,s);  int cnt1 = 0;  rep(i,0,n){    cnt1+=s[i] == &#39;1&#39;;  }  if((cnt1 * m ) % n != 0){    printf(&quot;-1\n&quot;);    return ;  }  int x = (cnt1*m)/n;  int c = 0;  rep(i,0,m){    c += s[i]==&#39;1&#39;;  }  rep(i,0,n){    if(c == x){      if(i &lt;= n-m){        printf(&quot;1\n&quot;);        printf(&quot;%d %d\n&quot;,i+1,i+m);      }else{        printf(&quot;2\n&quot;);        printf(&quot;%d %d\n&quot;,1,m-(n-i));        printf(&quot;%d %d\n&quot;,i+1,n);      }      return ;    }    c += s[(i+m)%n]==&#39;1&#39;;    c -= s[i]==&#39;1&#39;;  }}int main(){  int t;  cin&gt;&gt;t;  while(t--)work();  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Math啊 Math, 我怎么就想不出呢</p><p>看<a href="https://www.bilibili.com/video/BV1Ur4y1W7Rd" target="_blank" rel="noopener">jiangly老哥的视频,他只想了15min</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://codeforces.com/blog/entry/101302" target="_blank" rel="noopener">官方题解</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1658/problem/F&quot; target=&quot;_blank
      
    
    </summary>
    
      <category term="Codeforces" scheme="http://yexiaorain.github.io/Blog/categories/Codeforces/"/>
    
    
      <category term="math" scheme="http://yexiaorain.github.io/Blog/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 1657F(2-SAT,tarjan,scc)</title>
    <link href="http://yexiaorain.github.io/Blog/2022-04-03-CF1657F/"/>
    <id>http://yexiaorain.github.io/Blog/2022-04-03-CF1657F/</id>
    <published>2022-04-03T02:37:14.000Z</published>
    <updated>2022-04-03T09:44:08.760Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://codeforces.com/contest/1657/problem/F" target="_blank" rel="noopener">https://codeforces.com/contest/1657/problem/F</a></p><p>一个树上,每个点有小写字母</p><p>q个描述(&lt;=4e5)</p><p>ai,bi 的简单路径得到字符串si , 注意方向可能a到b,也可能b到a</p><p>求一种满足上述所有描述的一种方案,或输出无法满足</p><h1 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h1><p>点数不超过4e5</p><p>字符串长度和不超过4e5</p><p>9s</p><p>1GB</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="2-SAT"><a href="#2-SAT" class="headerlink" title="2-SAT"></a>2-SAT</h2><p>对于被字符串覆盖到的点, 如果正反字符相等,那么必定是这个字符</p><p>如果不等那么它也只有两种可能</p><p>于是问题变成了每个点有两种可能,并且选中其中一个时会决定它被覆盖的字符串上其它点的选择</p><p>这就是2-sat问题(每个点0/1 , 选定情况会决定其它的点情况,找一种可行方案)</p><p>2-sat问题的解法就是 建立有向图(注意这里是全部双向关系) ,求最大联通分量缩点,看是否有矛盾(一个点同时选了两个不同字符)</p><p>注意这里字符串在转化成图之前, 额外操作就是多个字符串覆盖到同一个点时, 有时能直接确定哪个字符是有效的,无效字符可以在转化前确定一部分</p><p>处理也很直白,同字符唯一确定,不同字符两个可能,多个字符串覆盖, 需要一个字符出现次数刚好是多个字符出现总次数一半</p><h2 id="最大联通分量scc"><a href="#最大联通分量scc" class="headerlink" title="最大联通分量scc"></a>最大联通分量scc</h2><p>上述处理以后就是scc的求解,这直接上tarjan</p><p>tarjan 主要就是</p><p>dfn 深度搜索访问记号</p><p>low 最小可达的前向点记号</p><p>stk 当前访问栈</p><p>res 结果数组</p><pre><code>tarjan(u){    DFN[u] = Low[u] = ++Index//为节点u设定次序编号和Low初值    Stack.push(u) //将节点u压入栈中    for each(u,v) in E //枚举每一条边        if (v not visited) //如果节点v未被访问过            tarjan(v) //继续向下找            Low[u]=min(Low[u],Low[v])        else if (v in S) //如果节点v还在栈内                Low[u]=min(Low[u], DFN[v])    if ( DFN[u] == Low[u] ){ //如果节点u是强连通分量的根        component = {}        repeat{            v = S.pop//将v退栈，为该强连通分量中一个顶点            component.append(v)            until( u == v)        }        print component    }}</code></pre><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(n);i++)#define per(i,a,n) for (ll i=(ll)n-1;i&gt;=a;i--)#define pb push_backconst int N = 400000;vector&lt;int&gt; p2[N+10];int dep[N+10];int fa[N+10];char s[N+10];map&lt;char,vector&lt;int&gt; &gt; p2charid[N+10];vector&lt;pair&lt;int,char&gt; &gt; id2pchar;vector&lt;int&gt; id2scc;vector&lt;vector&lt;int&gt; &gt; scc2ids ;vector&lt;bool&gt; vis ;char ans[N+10];class Tarjan{  vector&lt;int&gt; low;  vector&lt;int&gt; dfn;  stack&lt;int&gt; stk;  vector&lt;int&gt; res;  vector&lt;vector&lt;int&gt; &gt; p;  int n;  void scc(int v) {    static int id = 0;    low[v] = dfn[v] = ++id;    stk.push(v);    for(auto w:p[v]){      if(!dfn[w]){ // 未访问过        scc(w);        low[v] = min(low[v],low[w]);      } else if(!res[w]){ // 访问过但没有结果(在栈中)        low[v] = min(low[v],dfn[w]);      }    }    int u;    if(low[v] == dfn[v])  {      do{        res[u = stk.top()] = v;        stk.pop();      }while(u != v);    }  }public:  Tarjan(int SZ):n(SZ){    low = vector&lt;int&gt;(n+1);    dfn = vector&lt;int&gt;(n+1);    stk = {};    res = vector&lt;int&gt; (n+1);    p = vector&lt;vector&lt;int&gt; &gt;(n+1);  }  vector&lt;int&gt; calc(){    rep(i,1,n+1){      if(!res[i]){        scc(i);      }    }    return res;  }  void p2(int i,int j){    p[i].pb(j);  }};void build(int idx,int father){  fa[idx] = father;  dep[idx] = dep[father]+1;  for(auto x:p2[idx]) {    if(x == father)continue;    build(x, idx);  }}// 因为要具体路径, LCA帮不上忙,直接暴力找vector&lt;int&gt; getpath(int u,int v){  if(dep[u] &gt; dep[v])swap(u,v);  vector&lt;int&gt; r1 = {};  vector&lt;int&gt; r2 = {};  while(dep[v] &gt; dep[u]){    r1.push_back(v);    v = fa[v];  }  while(u != v){    r1.push_back(v);    v = fa[v];    r2.push_back(u);    u = fa[u];  }  r1.push_back(u);  per(i,0,r2.size()){    r1.push_back(r2[i]);  }  return r1;}bool add(int u,int v, Tarjan &amp;t){  vector&lt;int&gt; path = getpath(u, v);  // 只记录不确定的  vector&lt;int&gt;inc;  vector&lt;int&gt;dec;  rep(i,0,(int)path.size()){    int p = path[i];    char ch1 = s[i];    char ch2 = s[path.size() - 1 -i];    if(ch1 == ch2){ // 直接确定      if(ans[p] != 0 &amp;&amp; ans[p] != ch1){        return false;      }      ans[p] = ch1; // 一个的改值, 两个的是 增加统计    }else{ // 先建立关系 不关心冲突      int id = id2pchar.size();      id2pchar.push_back({p,ch1});      p2charid[p][ch1].push_back(id);      inc.pb(id);      id = id2pchar.size();      id2pchar.push_back({p,ch2});      p2charid[p][ch2].push_back(id);      dec.pb(id);    }  }  assert(dec.size() == inc.size());  rep(i,0,(int)inc.size()){    t.p2(inc[i],inc[(i+1)%inc.size()]);    t.p2(dec[i],dec[(i+1)%dec.size()]);  }  return true;}bool checkscc(int scc){  vector&lt;pair&lt;int,char&gt;&gt; pch;  for(auto id:scc2ids[scc]){    auto [p, ch] = id2pchar[id];    if(ans[p] == ch || ans[p] == 0){      pch.push_back({p,ch});    }else{      return false;    }  }  sort(pch.begin(),pch.end());  rep(i,1,(int)pch.size()){    if(pch[i-1].first != pch[i].first) continue; // 同一个点    if(pch[i-1].second != pch[i].second) return false; // 不同字符  }  return true;}bool applyscc(int scc){  vis[scc] = true;  for(auto id:scc2ids[scc]){    auto [p, ch] = id2pchar[id];    if(ans[p] == ch)continue;    if(ans[p] == 0){      ans[p] = ch;    }else{      return false;    }  }  return true;}bool rmscc(int scc){  vis[scc] = true;  for(auto id:scc2ids[scc]){    if(id == 1)continue;    auto [p, ch] = id2pchar[id];    if(ans[p] == ch) return false; // 失效和已经填入的冲突    if(p2charid[p].count(ch)){      p2charid[p].erase(ch);      if(ans[p] == 0 &amp;&amp; p2charid[p].size() == 0)return false; //      if(p2charid[p].size() == 1){        auto [ch,ids] = *p2charid[p].begin();        if(ans[p] != 0 &amp;&amp; ans[p] != ch)return false;        ans[p] = ch;        for(auto id:ids){          if(!vis[id2scc[id]]){            int r = applyscc(id2scc[id]);            if(!r)return r;          }        }      }    }  }  return true;}int main(){  id2pchar.push_back({-1,&#39;X&#39;}); // 占位0  id2pchar.push_back({-1,&#39;X&#39;}); // 建立特殊失效节点, 下标为1  int n,q;  cin&gt;&gt;n&gt;&gt;q;  rep(i,0,n-1){    int u,v;    scanf(&quot;%d %d&quot;,&amp;u,&amp;v);    p2[u].push_back(v);    p2[v].push_back(u);  }  build(1,0); // 父节点和深度  Tarjan t(2*N+2);  rep(i,0,q){    int u,v;    scanf(&quot;%d %d&quot;,&amp;u,&amp;v);    scanf(&quot;%s&quot;,s);    bool r = add(u,v,t);    if(!r){      printf(&quot;NO\n&quot;);      return 0;    }  }  // 处理每个点明确不可能的情况  rep(i,1,n+1) {    if(ans[i]){ // 已确定的      for(auto [ch,ids]:p2charid[i]){        if(ch == ans[i])continue;        for(auto id: ids){          t.p2(1,id); // 失效的          t.p2(id,1); // 失效的        }      }    }else{ // 未确定的      if(p2charid[i].size() == 0){        ans [i] = &#39;a&#39;; // 没有限制      }else { // 每次贡献两个不同的,那么答案要占恰好一半出现        int total = 0;        for(auto [ch,ids]:p2charid[i]){          total+=ids.size();        }        for(auto [ch,ids]:p2charid[i]){          if((int)ids.size()*2 != total){            for(auto id: ids){              t.p2(1,id); // 建立不可能              t.p2(id,1);            }          }        }      }    }  }  id2scc = t.calc();  scc2ids = vector&lt;vector&lt;int&gt;&gt;(id2pchar.size());  vis = vector&lt;bool&gt;(id2pchar.size());  rep(i,1,(int)id2pchar.size()){    scc2ids[id2scc[i]].pb(i);  }  // 处理掉直接不可能  bool r = rmscc(1);  if(!r){    printf(&quot;NO\n&quot;);    return 0;  }  rep(scc,2,(int)id2pchar.size()){    if(!scc2ids[scc].size())continue;    if(vis[scc])continue;    if(!checkscc(scc)){      bool r = rmscc(scc);      if(!r){        printf(&quot;NO\n&quot;);        return 0;      }    }else{      bool r = applyscc(scc);      if(!r){        printf(&quot;NO\n&quot;);        return 0;      }    }  }  rep(i,1,n+1){    if(!ans[i]){      printf(&quot;NO\n&quot;);      return 0;    }  }  printf(&quot;YES\n&quot;);  rep(i,1,n+1){    printf(&quot;%c&quot;,ans[i]);  }  printf(&quot;\n&quot;);  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>还是知识点不够, 一个是太久没写tarjan scc,一个是没搞过2-sat</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://codeforces.com/blog/entry/101161" target="_blank" rel="noopener">官方题解</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1657/problem/F&quot; target=&quot;_blank
      
    
    </summary>
    
      <category term="Codeforces" scheme="http://yexiaorain.github.io/Blog/categories/Codeforces/"/>
    
    
      <category term="scc" scheme="http://yexiaorain.github.io/Blog/tags/scc/"/>
    
      <category term="tarjan" scheme="http://yexiaorain.github.io/Blog/tags/tarjan/"/>
    
      <category term="最大联通分量" scheme="http://yexiaorain.github.io/Blog/tags/%E6%9C%80%E5%A4%A7%E8%81%94%E9%80%9A%E5%88%86%E9%87%8F/"/>
    
      <category term="2-SAT" scheme="http://yexiaorain.github.io/Blog/tags/2-SAT/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 1654F(神奇的逐位排序, 基数排序, 后缀数组)</title>
    <link href="http://yexiaorain.github.io/Blog/2022-03-30-CF1654F/"/>
    <id>http://yexiaorain.github.io/Blog/2022-03-30-CF1654F/</id>
    <published>2022-03-30T02:37:14.000Z</published>
    <updated>2022-03-30T11:33:50.403Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://codeforces.com/contest/1654/problem/F" target="_blank" rel="noopener">https://codeforces.com/contest/1654/problem/F</a></p><p>给一个字符串,长度$2^n$</p><p>找一个$j &lt;= 2^n$, 让<code>s[i^j]</code> 字典序最小</p><h1 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h1><p>n &lt;= 18</p><p>3s</p><p>512MB</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="我的尝试"><a href="#我的尝试" class="headerlink" title="我的尝试"></a>我的尝试</h2><p>我想到,j的位是0或1实际上意味着 原字符串 的长度2^k 区间是否交换</p><p>而判断是否交换,可以局部贪心</p><p>问题是,存在字符相等的情况, 不知道怎么记录, 试了一下random 并不能骗分哈哈</p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 1000000007#define rep(i,a,n) for (ll i=a;i&lt;n;i++)#define per(i,a,n) for (ll i=n-1;i&gt;=a;i--)#define pb push_backconst double pi = acos(-1.0);// n =&gt; 2^n length lowercase letters//// t[i] = s[i ^ j]//// find j =&gt; minimal string// n &lt;= 18// 2^n &lt;= 262144// bit1 ,一个一组,相邻交换// bit2 ,2个一组,相邻交换// bit3 ,3个一组,相邻交换// bit4 ,4个一组,相邻交换// ans(0..x)// =&gt; min(ans(0..x/2),ans(x/2+1...x)) 最小的作为前缀// 3**18 =&gt; 387420489int n;char s[270010];int ans[270010][20];int cmp(int p,int pwr,int l,int r){  // 自己所在的那一节  rep(i,0,(1&lt;&lt;pwr)){    if(s[(p + i) ^ l] &lt; s[(p + (1&lt;&lt;pwr) + i) ^ r]) return -1;    if(s[(p + i) ^ l] &gt; s[(p + (1&lt;&lt;pwr) + i) ^ r]) return 1;  }  // 对手那一行  rep(i,0,(1&lt;&lt;pwr)){    if(s[(p + (1&lt;&lt;pwr) + i) ^ l] &lt; s[(p + i) ^ r]) return -1;    if(s[(p + (1&lt;&lt;pwr) + i) ^ l] &gt; s[(p + i) ^ r]) return 1;  }  return 0;}ll tryRand(){  rep(i,1,n+1){    for(int p = 0;p &lt; (1&lt;&lt;n); p += (1&lt;&lt;i)){      int lans = ans[p][i-1];      int rans = ans[p+(1&lt;&lt;(i-1))][i-1];      int res = cmp(p,i-1,lans,rans);      // TODO 相等的情况??????      if(res == 0){        // printf(&quot;fuck?\n&quot;);        if(rand()%2){          ans[p][i] = lans;        }else{          ans[p][i] = (rans | (1&lt;&lt;(i-1)));        }      } else if(res == -1){        ans[p][i] = lans;      }else{        ans[p][i] = (rans | (1&lt;&lt;(i-1)));      }    }  }  return ans[0][n];}int main(){  srand(time(NULL));  cin&gt;&gt;n;  scanf(&quot;%s&quot;,s);  int j = tryRand();  rep(t,0,180){    int k = tryRand();    rep(i,0,(1&lt;&lt;n)){      if(s[i ^ j] &lt; s[i ^ k])break;      if(s[i ^ j] == s[i ^ k])continue;      j = k;      break;    }  }  rep(i,0,(1&lt;&lt;n)){    printf(&quot;%c&quot;, s[i ^ j]);  }  printf(&quot;\n&quot;);  return 0;}</code></pre><h2 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h2><p>实际上可以看成, 把 <code>0~n-1</code>排序</p><p>而排序是按照<code>f(s,i)</code>的字典序来比较大小的</p><p>这里的问题是 如果两两比较 依然复杂度完成不了, 如何减少比较和处理相等</p><p>考虑样例1: <code>acba</code></p><pre><code>0: acba1: caab2: baac3: abca</code></pre><p>最终期望得到</p><pre><code>3: abca0: acba2: baac1: caab</code></pre><p>然而注意到, </p><p>首位的比较 就是 s[i]</p><p>第2位的比较 就是 s[i ^ (1&lt;&lt;0)]</p><p>第3位的比较 就是 s[i ^ (1&lt;&lt;1)]</p><p>第4位的比较 就是 s[i ^ (1&lt;&lt;2)]</p><p>而 一旦首位有非相等的大小关系了,之后也就不会改变相对顺序, 不想等时 才考虑后续排序</p><hr><p>于是, 按首位排序</p><pre><code>0: a1: c2: b3: a</code></pre><p>变为</p><pre><code>0: a3: a2: b1: c</code></pre><p>记录大小顺序</p><pre><code>0: a(0)3: a(0)2: b(1)1: c(2)</code></pre><p>按照第二位排序</p><pre><code>0: ?c1: ?a2: ?a3: ?b</code></pre><p>得到</p><pre><code>1: ?a2: ?a3: ?b0: ?c</code></pre><p>整体变为(注意首位不相等的要保持顺序)</p><pre><code>3: ab0: ac2: ba1: ca</code></pre><p>记录大小顺序</p><pre><code>3: ab(0)0: ac(1)2: ba(2)1: ca(3)</code></pre><p>这样所有位排序, 更新顺序即可</p><p>换句话说就是类似基数排序, 每次是对前缀相等的一系列值的下一位 进行排序</p><p>这里注意到看上去字符串长度,有<code>1 &lt;&lt; n</code>, 但是实际上,上述排序只需要考虑2的幂次的</p><p>因为,[2..3] 的排序 实际是 ([0..1]^2)得到的排序</p><p>因为,[4..7] 的排序 实际是 ([0..3]^4)得到的排序</p><p>所以 虽然是基数排序,但是 能通过幂次 和记录大小的排序值 优化比较次数</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 1000000007#define rep(i,a,n) for (ll i=a;i&lt;n;i++)#define per(i,a,n) for (ll i=n-1;i&gt;=a;i--)#define pb push_backconst int N = 1 &lt;&lt; 18;int n, a[N], val[N], tmp[N], now;char s[N];// x 在 y 前面bool cmp(int x, int y) {  return (val[x] == val[y]) ?    val[x ^ now] &lt; val[y ^ now] :    val[x] &lt; val[y];}int main() {  cin&gt;&gt;n;  scanf(&quot;%s&quot;, s);  rep(i,0,1&lt;&lt;n){    val[i] = s[i] - &#39;a&#39;; // [0,26), 实际表示的是以 (1&lt;&lt;pwr) 跨度排序 的 顺序下标,    a[i] = i; // 相当于 0 ~ 2^n-1 中 让s字典序最小的  }  rep(pwr,0,n) {    now = 1 &lt;&lt; pwr; // 比较区间长度    sort(a, a + (1 &lt;&lt; n), cmp);    int num = 0; // 离散化顺序值    rep(j,0,1&lt;&lt;n){      if (j &gt; 0 &amp;&amp; cmp(a[j - 1], a[j])) num ++; // f(a[j-1]) &lt; f(a[j]) =&gt; num++; 明确j比前一个大      tmp[a[j]] = num;    }    rep(j,0,1&lt;&lt;n){      val[j] = tmp[j]; // 记录的是 now*2 长度 的 排序 序号    }  }  rep(i,0,1&lt;&lt;n){    putchar(s[i ^ a[0]]);  }  return 0;}</code></pre><p>pwr = 0, now = 1</p><p>如果字符 更小,则排在前面</p><p>如果字符 相等,则它^1位置的更小就排在前面, 如果依然相等,则认为当前论次比较它们两相等</p><p>修改val[i] = 表示选定异或值<code>i</code>, 让 <code>s</code>在i 的转换下, 前两位 在所有i 中的 顺序</p><p>pwr = 1, now = 2</p><p>注意到上面val意义已经变化</p><p>val[i] 表示的是 i 引起的转换 的前两位的排序值</p><p>如果排序值更小,则排在前面</p><p>如果排序值相等,则它^2位置的更小就排在前面, 如果依然相等,则认为当前论次比较它们两相等</p><p>修改val[i] = 表示选定异或值<code>i</code>, 让 <code>s</code>在i 的转换下, 前4位 在所有i 中的 顺序</p><p>pwr = 2, now = 4</p><p>val[i] 表示的是 i 引起的转换 的前4位的排序值</p><p>如果排序值更小,则排在前面</p><p>如果排序值相等,则它^4位置的更小就排在前面, 如果依然相等,则认为当前论次比较它们两相等</p><p>修改val[i] = 表示选定异或值<code>i</code>, 让 <code>s</code>在i 的转换下, 前8位 在所有i 中的 顺序</p><p><code>pwr = n, now = 2**n</code></p><p>val[i] 表示的是 i 引起的转换 的前now位的排序值</p><p>如果排序值更小,则排在前面</p><p>如果排序值相等,则它xor now 位置的更小就排在前面, 如果依然相等,则认为当前论次比较它们两相等</p><p>修改val[i] = 表示选定异或值<code>i</code>, 让 <code>s</code>在i 的转换下, 前<code>now*2</code>位 在所有i 中的 顺序</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>每次排序,再记录顺序, 方便后续比较,而不仅仅排序就完了, 这个记录顺序很重要</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://codeforces.com/blog/entry/100127" target="_blank" rel="noopener">官方题解</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1654/problem/F&quot; target=&quot;_blank
      
    
    </summary>
    
      <category term="Codeforces" scheme="http://yexiaorain.github.io/Blog/categories/Codeforces/"/>
    
    
      <category term="基数排序" scheme="http://yexiaorain.github.io/Blog/tags/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    
      <category term="后缀数组" scheme="http://yexiaorain.github.io/Blog/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 1654E(按类别分治)</title>
    <link href="http://yexiaorain.github.io/Blog/2022-03-29-CF1654E/"/>
    <id>http://yexiaorain.github.io/Blog/2022-03-29-CF1654E/</id>
    <published>2022-03-29T02:37:14.000Z</published>
    <updated>2022-03-29T15:31:53.009Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://codeforces.com/contest/1654/problem/E" target="_blank" rel="noopener">https://codeforces.com/contest/1654/problem/E</a></p><p>给一数列,修改尽量少的值让整个数列等差</p><h1 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h1><p>n &lt;= 1e5</p><p>1&lt;= ai &lt;= 1e5</p><p>5s</p><p>1GB</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>实际上是二维点(i,ai),找直线经过最多的点</p><p>考虑增量 小于 sqrtn,那么选中斜率, 计算每个点沿着斜率与y轴交点 出现的最多次即可, 不要用map,用数组和清理数组实现</p><p>考虑增量 大于 sqrtn,以每个点作为起点,那么最多尝试这个点向后n/sqrt(n) 个点, 把这些点计算出现最多次数的斜率, 数量不多,可以用map</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 1000000007#define rep(i,a,n) for (ll i=a;i&lt;n;i++)#define per(i,a,n) for (ll i=n-1;i&gt;=a;i--)#define pb push_backconst double pi = acos(-1.0);const int N = 100000;int a[N+10];int used[32000010];int n;int work(){  int SQRT = 316;  int ans = 0;  // 增量 &lt;= SQRT;  rep(i,0,SQRT+1){    vector&lt;int&gt; rm;    rep(j,0,n){      // 非负便宜量      int v = a[j] + SQRT*N- j*i; // max = 31600000+100000      if(!used[v])rm.push_back(v);      ans = max(ans,++used[v]);    }    // clear    for(auto v:rm){      used[v] = 0;    }  }  // 增量 大于 SQRT  rep(j,0,n){ // 下标    map&lt;int,int&gt; kcnt;    rep(i,j+1,n){ // 增量      if(a[j] + (i-j) * SQRT &gt; N) break;      if( (a[i] - a[j]) % (i-j) == 0){        kcnt[(a[i] - a[j]) / (i-j)]++;      }    }    for(auto [k,cnt]:kcnt){      // printf(&quot;a[%lld] = %d : k=%d cnt = %d\n&quot;,j,a[j],k,cnt+1);      ans = max(ans, cnt+1);    }  }  return ans;}int main(){  cin&gt;&gt;n;  rep(i,0,n){    scanf(&quot;%d&quot;,a+i);  }  int ans = work();  // 翻转  rep(i,0,n/2){    swap(a[i],a[n-1-i]);  }  printf(&quot;%d\n&quot;,n - max(ans,work()));  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>按照一个值,分段处理,每一段都是性能满足的</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://codeforces.com/blog/entry/100127" target="_blank" rel="noopener">官方题解</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1654/problem/E&quot; target=&quot;_blank
      
    
    </summary>
    
      <category term="Codeforces" scheme="http://yexiaorain.github.io/Blog/categories/Codeforces/"/>
    
    
      <category term="分治" scheme="http://yexiaorain.github.io/Blog/tags/%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 1648D(二分，单调队列，前缀和，线段树，区间覆盖，动态规划)</title>
    <link href="http://yexiaorain.github.io/Blog/2022-03-21-cfP1648D/"/>
    <id>http://yexiaorain.github.io/Blog/2022-03-21-cfP1648D/</id>
    <published>2022-03-21T02:37:14.000Z</published>
    <updated>2022-03-22T15:18:45.204Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://codeforces.com/contest/1648/problem/D" target="_blank" rel="noopener">https://codeforces.com/contest/1648/problem/D</a></p><p><code>3xn</code> 左上角 走到 右下角，只能右和下两个方向的走，价值= 经过块的值的和</p><p>第一行，第三行直接可走，第二行需要额外代价<code>v</code>,开启<code>[l,r]</code>一段</p><p>问总获得价值最大值</p><h1 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h1><p>n &lt;= 5e5</p><p>块上值 -1e9 ~ 1e9</p><p>可选扩展 5e5 个，扩展代价 1~1e9</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="行走代价简化"><a href="#行走代价简化" class="headerlink" title="行走代价简化"></a>行走代价简化</h2><p>走过的样子无非是</p><pre><code>xxxxxx     xxxxxxx           xxxxxxxxx</code></pre><p>拆分一下, </p><p>第一段： 第一行+，第二行-</p><p>第二段： 第二行+，第三行+</p><pre><code>     i++++++-----            j+++++++++++++            +++++++++</code></pre><p>那么行走代价为<code>s[i]+t[j]</code></p><p>剩下就是开放(i,j)的最小代价 </p><h2 id="状态与转移与范围最值"><a href="#状态与转移与范围最值" class="headerlink" title="状态与转移与范围最值"></a>状态与转移与范围最值</h2><p>考虑从<code>(1,1)</code>走到<code>(2,i)</code>, 其中当前使用的最右侧的开放端点是<code>i</code></p><pre><code>     ?xxxxxx      i     xxxxxxxx        [   ]      [  ]    [  ]</code></pre><p><code>dp[i]</code> = <code>(1,1) -&gt; (2,i)</code> 且<code>i</code> 是当前最右侧开放的点, 上述条件下 , 最大的 <code>s[?] - cost(?,i)</code></p><p>这里两点</p><ol><li><code>i</code> 是某个区间右侧端点, 且走到了这个位置</li><li>dp表示的是这样范围中最大的, 包含<code>s</code> 和 <code>cost</code> , 这里很神奇，没有t意味着，下面转移时并不用考虑第二行所选位置对dp的影响</li></ol><p>也就是一个准确，一个范围最值</p><hr><p>状态转移，</p><p>要么是通过第一行直接进入所选区间走到i,</p><p>要么就是先走到<code>(2,j)</code>, 再在一个区间内走到i, 所以 j 在 <code>[l-1,r]</code> 内</p><pre><code>     ?xxxxxx       j     xxxxxxxxx           [      ]xxxxxx            i     xxxxxxxxxxxxxx</code></pre><p><code>dp[i] = max(dp[j] - cost(i,j).value)</code></p><hr><p>剩下的就是最终的答案, 因为可能走到不是某个区间的终点，就去第三行了</p><pre><code>     ?xxxxxx         i  j     xxxxxxxxxxxxxx                  xxxxxxx              [      ]</code></pre><p><code>ans = max(dp[i] - cost(i,j).value + t[j])</code>， <code>i</code>,<code>j</code> 在某个区间内，<code>i &lt; j</code>, 对于相等的情况 上面直接<code>+t[i]</code>就更新</p><p>换个角度，先固定一个区间,<code>cost</code>确定,再在这个区间里找 <code>max(dp[i]+t[j])</code></p><p>其中<code>i</code> 在<code>[l-1,r]</code>内</p><hr><p>注意到上面的方案，一定经过了某个开放区间的终点，开放区间为 &gt;= 1 个 ，所以还有一种情况，只开放了一个区间，i和j都在区间之中</p><p>上面最重要的是控制成了<strong>一个</strong>区间,但不一定是唯一一个区间</p><p>而上面的操作和只开放一个区间十分的像，都是开放一个区间，左dp[i],右t[j] 和(i &lt; j) 左s[i],右t[j] (i &lt;= j)</p><p>注意到对于左dp,右t的情况，i==j只会产生比最优更小的答案，所以可以考虑在最值处理时合并<code>left[i] = min(dp[i],dp[i-1],s[i])</code></p><p>最后特化成只开放一个区间的问题</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 1000000007#define rep(i, a, n) for (ll i = a; i &lt; n; i++)#define pb push_back#define SEG_ROOT 1,0,n-1#define SEG_L o&lt;&lt;1,l,m#define SEG_R o&lt;&lt;1|1,m+1,rconst double pi = acos(-1.0);const int N = 500&#39;000;ll s[N + 10];ll t[N + 10];ll dp[N + 10];ll a[3][N + 10];vector&lt;tuple&lt;int, int, ll&gt; &gt; rlv;ll seg[2][N * 4 + 10];ll segans[N * 4 + 10];const ll INF = 0x3f3f3f3f3f3f3f3f;ll query(int o, int l, int r, int ql, int qr) {  if (l == ql &amp;&amp; r == qr)    return seg[0][o];  int m = (l + r) / 2;  if (qr &lt;= m) {    return query(SEG_L, ql, qr);  } else if (ql &gt; m) {    return query(SEG_R, ql, qr);  } else {    return max(query(SEG_L, ql, m),               query(SEG_R, m + 1, qr));  }}void update(int o, int l, int r, int pos) {  if (l == r) {    seg[0][o] = dp[l];    return;  }  int m = (l + r) / 2;  if (pos &lt;= m)    update(SEG_L, pos);  else    update(SEG_R, pos);  seg[0][o] = max(seg[0][o &lt;&lt; 1], seg[0][o &lt;&lt; 1 | 1]);}void build(int o, int l, int r) {  if (l == r) {    seg[0][o] = dp[l];    return;  }  int m = (l + r) / 2;  build(SEG_L);  build(SEG_R);  seg[0][o] = max(seg[0][o &lt;&lt; 1], seg[0][o &lt;&lt; 1 | 1]);}// [l,r]为开放段void buildans(int o, int l, int r) {  if (l == r) {    // 可以dp到[l-1] 或[l]    seg[0][o] = max(max(dp[l], s[l]), l &gt; 0 ? dp[l-1] : -INF);    seg[1][o] = t[l];    segans[o] = seg[0][o] + t[l];    return;  }  int m = (l + r) / 2;  buildans(SEG_L);  buildans(SEG_R);  seg[0][o] = max(seg[0][o &lt;&lt; 1], seg[0][o &lt;&lt; 1 | 1]);  seg[1][o] = max(seg[1][o &lt;&lt; 1], seg[1][o &lt;&lt; 1 | 1]);  segans[o] = max(seg[0][o &lt;&lt; 1] + seg[1][o &lt;&lt; 1 | 1],                  max(segans[o &lt;&lt; 1], segans[o &lt;&lt; 1 | 1]));};// {最大值, 最大dp, 最大t}vector&lt;ll&gt; qans(int o, int l, int r, int ql, int qr) {  if (ql == l &amp;&amp; qr == r) {    return {segans[o], seg[0][o], seg[1][o]};  }  int m = (l + r) / 2;  if (qr &lt;= m) {    return qans(SEG_L, ql, qr);  } else if (ql &gt; m) {    return qans(SEG_R, ql, qr);  }  auto lres = qans(SEG_L, ql, m);  auto rres = qans(SEG_R, m + 1, qr);  return {max(max(lres[0], rres[0]), lres[1] + rres[2]), max(lres[1], rres[1]),          max(lres[2], rres[2])};}int main() {  int n, q;  scanf(&quot;%d %d&quot;, &amp;n, &amp;q);  ll a2 = 0;  rep(i, 0, 3) {    rep(j, 0, n) { scanf(&quot;%lld&quot;, &amp;a[i][j]); }  }  rep(i, 0, n) a2 += a[2][i];  s[0] = a[0][0];  rep(i, 1, n) { s[i] = s[i - 1] + a[0][i] - a[1][i - 1]; }  t[0] = a2 + a[1][0];  rep(i, 1, n) { t[i] = t[i - 1] + a[1][i] - a[2][i - 1]; }  rep(i, 0, q) {    int r, l;    ll v;    scanf(&quot;%d %d %lld&quot;, &amp;l, &amp;r, &amp;v);    rlv.pb({r - 1, l - 1, v});  }  ll ans = -INF;  // 按右端点排序  sort(rlv.begin(), rlv.end());  // 处理 使用一次区间直接进入的  vector&lt;int&gt; pos;  // 单调队列  unsigned long itr = 0;  rep(i, 0, n){    dp[i] = -INF;  }  rep(i, 0, n) {  // 下标    while (pos.size() &amp;&amp; s[pos.back()] &lt;= s[i]) {      pos.pop_back();    }    pos.pb(i);    while (itr &lt; rlv.size() &amp;&amp; get&lt;0&gt;(rlv[itr]) == i) {      // 区间内最大值      dp[i] = max(          dp[i],          s[*lower_bound(pos.begin(), pos.end(), get&lt;1&gt;(rlv[itr]))] -              get&lt;2&gt;(rlv[itr]));  // cost &gt; 0选自己没影响      if (dp[i] != -INF) {        ans = max(ans, dp[i] + t[i]);        // printf(&quot;dp[%lld] =&gt; %lld\n&quot;, i, dp[i]);      }      itr++;    }  }  build(SEG_ROOT);  itr = 0;  for(auto [r,l,v]:rlv){    // 注意可以上一个结束的位置[?..l-1] 和当前 [l..r] 是相邻而不是重叠    // dp[i] = max(dp[&lt;i] - cost);    ll newdpi = query(SEG_ROOT, max(0,l-1), max(0,r-1)) - v;    if (newdpi &gt; dp[r]) {      dp[r] = newdpi;      ans = max(ans, dp[r] + t[r]);      // printf(&quot;update: dp[%lld] =&gt; %lld\n&quot;, i, dp[i]);      update(SEG_ROOT, r);    }  }  buildans(SEG_ROOT);  // [l...r] =&gt; [l..m] [m+1,r]  for (auto [r, l, v] : rlv) {    auto qres = qans(SEG_ROOT, l, r);    if (qres[0] &lt;= -INF)      continue;    ans = max(ans, qres[0] - v);  }  printf(&quot;%lld\n&quot;, ans);  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>一个核心的点就是区间覆盖，转换成刚好走到以某个区间结束的动规，感觉要是一个纯的动规还可能想到，合在一起竟然卡住了</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://codeforces.com/blog/entry/100592" target="_blank" rel="noopener">官方题解</a></p><p><a href="https://www.cnblogs.com/C202044zxy/p/15980776.html#!comments" target="_blank" rel="noopener">C202044zxy</a></p><p><a href="https://blog.csdn.net/cggghh/article/details/123322440" target="_blank" rel="noopener">cggghh</a></p><p><a href="https://www.cnblogs.com/Sstee1XD/p/15974290.html" target="_blank" rel="noopener">Sstee1XD</a></p><p><a href="https://www.shuizilong.com/house/archives/codeforces-round-775/" target="_blank" rel="noopener">某岛</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1648/problem/D&quot; target=&quot;_blank
      
    
    </summary>
    
      <category term="Codeforces" scheme="http://yexiaorain.github.io/Blog/categories/Codeforces/"/>
    
    
      <category term="线段树" scheme="http://yexiaorain.github.io/Blog/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="动态规划" scheme="http://yexiaorain.github.io/Blog/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="二分" scheme="http://yexiaorain.github.io/Blog/tags/%E4%BA%8C%E5%88%86/"/>
    
      <category term="前缀和" scheme="http://yexiaorain.github.io/Blog/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
      <category term="单调队列" scheme="http://yexiaorain.github.io/Blog/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    
      <category term="区间覆盖" scheme="http://yexiaorain.github.io/Blog/tags/%E5%8C%BA%E9%97%B4%E8%A6%86%E7%9B%96/"/>
    
  </entry>
  
  <entry>
    <title>CF 1641 D (字典树,集合,贡献统计)</title>
    <link href="http://yexiaorain.github.io/Blog/2022-03-08-cf1641D/"/>
    <id>http://yexiaorain.github.io/Blog/2022-03-08-cf1641D/</id>
    <published>2022-03-08T02:37:14.000Z</published>
    <updated>2022-03-22T15:21:07.583Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p><a href="https://codeforces.com/contest/1641/problem/D" target="_blank" rel="noopener">https://codeforces.com/contest/1641/problem/D</a></p><p><code>n(1e5)</code>个数组</p><p>每个数组长度为<code>m(&lt;=5)</code>, 包含值<code>(&lt;1e9)</code>, 每个数组有总代价<code>w(&lt;=1e9)</code></p><p>找出两个数组，让它们的值没有重复，且代价和最小，求最小代价</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><ol><li><p>随机映射到0-15,注意同一个数一定映射到相同数，不同数可能映射到相同数, 多次运行提高概率期望到2, orz(见YB Lin 的链接)</p></li><li><p>集合数学性质</p></li></ol><p>一个集合属于A,又属于B，</p><p>如果该集合个数为奇数，则+1</p><p>如果该集合个数为偶数(包含空集合)，则-1</p><p>那么，如果A,B有公共元素，则结果为0，否则为1</p><p>然后维护一个Trie树，上面是所有子集</p><hr><p>把原数组按照w排序</p><p>利用Trie树找到首个合法的组合i,j</p><p>因为要答案最小，所以 i &lt; i’, 则有 j’&lt; j</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i, a, n) for (ll i = a; i &lt; n; i++)#define pb push_back#define all(a) a.begin(), a.end()// trie 树， 用index取代指针// 集合按照从小到大 展开存成树节点struct node {  // 只会新增不会移除， cnt为0 和 移除等价  unordered_map&lt;int, int&gt; next;  // [值] =&gt; 树节点index  int cnt;};vector&lt;node&gt; g;int new_node() {  g.push_back(node{{}, 0});  return g.size() - 1;}// 新把数组变化 放入trie树void add(const vector&lt;int&gt;&amp; x,         int c /* 1(加入) or -1(移除) */,         int v = 0 /* trie 树 节点 index*/,         int i = 0 /* 遍历数组下标 */) {  if (i == x.size()) {    g[v].cnt += c;  // 在trie树 的所有集合表示的位置都+1    return;  }  // 不存在创建新节点  if (!g[v].next.count(x[i]))    g[v].next[x[i]] = new_node();  add(x, c, v, i + 1);                // 不选择当前的情况  add(x, c, g[v].next[x[i]], i + 1);  // 选择当前的情况}// 初始全是0// 如果和 已经加入的 某个数组重合，那么与这个数组贡献的cnt 的结果为 0// 如果和 已经加入的 某个数组不重合，那么与这个数组贡献的cnt 的结果为 1// 而trie上的贡献是满足**累加**性质，所以与 trie树直接计算cnt// 如果为0，则和所有数组现有的都冲突，否则存在一个数组和它没有重合int get_cnt(const vector&lt;int&gt;&amp; x, int v = 0, int i = 0) {  if (i == x.size()) {    return g[v].cnt;  }  int res = get_cnt(x, v, i + 1);  // 第i位 不选  if (g[v].next.count(x[i]))       // 第i位 存在（集合存在） 并选择    res -= get_cnt(x, g[v].next[x[i]] /* trie 树的下一个节点 */,                   i + 1);  // 奇偶加减交替  return res;}int main() {  int n, k;  ios::sync_with_stdio(0);  cin.tie(0);  cout.tie(0);  cin &gt;&gt; n &gt;&gt; k;  vector&lt;pair&lt;int, vector&lt;int&gt;&gt;&gt; a = vector(n, make_pair(0, vector&lt;int&gt;(k, 0)));  rep(i, 0, n) {    rep(j, 0, k) {      cin &gt;&gt; a[i].second[j];  // 读入每个数组    }    cin &gt;&gt; a[i].first;  // 数组权重  }  rep(i, 0, n) {  // 数组内按照值排序    sort(all(a[i].second));  }  sort(all(a));  // 按权重排序  new_node();    // trie 根节点 空集合  int res = -1;  int i = 0;  // 和 trie 树中 任何一个重复 都会 让 get_cnt &gt; 0  while (i &lt; n &amp;&amp; !get_cnt(a[i].second)) {    // 首个一定加入, 如果和现有所有数组都冲突，那么加入trie树    // 如果存在一个不是和所有都冲突的 , 会触发 get_cnt 不为0    add(a[i].second, 1);    i += 1;  }  if (i &gt;= n) {    cout &lt;&lt; -1 &lt;&lt; &quot;\n&quot;;    return 0;  }  // i 是首个 与 [0...i-1]中某个不会冲突的  int j = i;  // 从i倒向查找  while (get_cnt(a[i].second)) {  // 直到所有都冲突，找到一个最小的j    j -= 1;    add(a[j].second, -1);  // 每次从trie树中移除一个  }  // j &lt; i 互相不冲突, 最小的i对应的最小的j  res = a[i].first + a[j].first;  // j&#39; &lt; j &lt; i &lt; i&#39;  for (i += 1; i &lt; n &amp;&amp; j &gt; 0; ++i) {    while (get_cnt(a[i].second)) {  // 循环直到 和 前面都冲突      j -= 1;                       // 找一个 最小的j 让 i和j不冲突      add(a[j].second, -1);         // 移除    }    // 不一定是有效值（可能i,j是冲突的），但是因为代价排序关系，保证不会影响最小值    res = min(res, a[i].first + a[j].first);  }  cout &lt;&lt; res &lt;&lt; &quot;\n&quot;;  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>先按照价值排序，</li><li>再从小到大找到首个和前面某个不冲突的</li><li>找到前面最小的与当前不冲突的，确定一个合法j &lt; i</li><li>i增加，每次找更小的j与新的i不冲突的，或者找不到跳过这个i, 每次更新最小值</li></ol><p>关键的核心就是,trie树保存的是两两冲突的数组的所有集合，而与trie树 做子集重合get_cnt运算，如果与已加入的所有都有重合则总结果为0，否则大于0, 相当于trie能帮助完成批量判断</p><h1 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h1><p><a href="https://codeforces.com/blog/entry/100249" target="_blank" rel="noopener">官方题解</a></p><p><a href="https://blog.csdn.net/m0_51068403/article/details/123140941" target="_blank" rel="noopener">YB Lin 概率映射 sosdp 乱搞</a></p><p><a href="https://blog.csdn.net/neweryyy/article/details/123214206" target="_blank" rel="noopener">neweryyy</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1641/problem/D&quot; target=&quot;_blank
      
    
    </summary>
    
      <category term="algorithm" scheme="http://yexiaorain.github.io/Blog/categories/algorithm/"/>
    
    
      <category term="math" scheme="http://yexiaorain.github.io/Blog/tags/math/"/>
    
      <category term="algorithm" scheme="http://yexiaorain.github.io/Blog/tags/algorithm/"/>
    
      <category term="codeforces" scheme="http://yexiaorain.github.io/Blog/tags/codeforces/"/>
    
  </entry>
  
  <entry>
    <title>project euler 516 (5-smooth,二分,前缀和,prime)</title>
    <link href="http://yexiaorain.github.io/Blog/2022-02-11-project-euler516/"/>
    <id>http://yexiaorain.github.io/Blog/2022-02-11-project-euler516/</id>
    <published>2022-02-11T02:37:14.000Z</published>
    <updated>2022-03-22T15:18:45.204Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://projecteuler.net/problem=516" target="_blank" rel="noopener">https://projecteuler.net/problem=516</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>求<code>n &lt; 10^12</code>, <code>phi(n)</code>的值仅包含质因数2,3,5的所有<code>n</code>的和，mod<code>2^32</code></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h2><p>$\phi(n) = n(1-\frac{1}{p_0})(1-\frac{1}{p_1})(1-\frac{1}{p_2})\cdots$</p><p>其中$p_i$均为$n$的质数因数</p><p>性质:</p><p>$\phi(x)\phi(y)=\phi(xy), gcd(x,y)==1$</p><p>$\phi(prime)\phi(x)=(prime-1)\phi(x), gcd(x,prime)==1$</p><h2 id="题目转换"><a href="#题目转换" class="headerlink" title="题目转换"></a>题目转换</h2><p>$n = 2^{q_0}3^{q_1}5^{q_2} p_0p_1p_2\cdots$</p><p>其中$p_i + 1$ 是只包含$2,3,5$ 质因子的数</p><h2 id="广搜2-3-5"><a href="#广搜2-3-5" class="headerlink" title="广搜2,3,5"></a>广搜2,3,5</h2><p>$x =&gt; 2x,3x,5x$</p><p>广搜小于$10^{12}$的所有只包含质因数$2,3,5$的数</p><h2 id="质数判别"><a href="#质数判别" class="headerlink" title="质数判别"></a>质数判别</h2><p>小于$2^{64}$里的质因数可以 Miller-Robin算法 常数级别 判别</p><h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h2><p>$n = 2^{q_0}3^{q_1}5^{q_2} p_0p_1p_2\cdots$</p><p>后面又可以拆分成$2^{q_0}3^{q_1}5^{q_2}$ 和 $p_0p_1p_2\cdots$</p><p>右边每个质数最多一次方，直接生成所有的积，左边还是上面求的</p><p>要两部分数组内容乘积小于n, 可以左侧枚举二分右侧，右侧枚举二分左侧都一样的, 通过前缀和辅助得到和</p><h1 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h1><p><a href="https://en.wikipedia.org/wiki/Euler%27s_totient_function" target="_blank" rel="noopener">Euler’s totient function</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://projecteuler.net/problem=516&quot; target=&quot;_blank&quot; rel=&quot;no
      
    
    </summary>
    
      <category term="Project Euler" scheme="http://yexiaorain.github.io/Blog/categories/Project-Euler/"/>
    
    
      <category term="pe" scheme="http://yexiaorain.github.io/Blog/tags/pe/"/>
    
      <category term="project euler" scheme="http://yexiaorain.github.io/Blog/tags/project-euler/"/>
    
      <category term="math" scheme="http://yexiaorain.github.io/Blog/tags/math/"/>
    
  </entry>
  
</feed>
