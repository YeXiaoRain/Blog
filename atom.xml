<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog</title>
  
  
  <link href="/Blog/atom.xml" rel="self"/>
  
  <link href="http://yexiaorain.github.io/Blog/"/>
  <updated>2022-07-30T19:50:12.118Z</updated>
  <id>http://yexiaorain.github.io/Blog/</id>
  
  <author>
    <name>Xiao Ye</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Atcoder abc214</title>
    <link href="http://yexiaorain.github.io/Blog/2022-07-30-ac_abc214/"/>
    <id>http://yexiaorain.github.io/Blog/2022-07-30-ac_abc214/</id>
    <published>2022-07-29T20:25:14.000Z</published>
    <updated>2022-07-30T19:50:12.118Z</updated>
    
    <content type="html"><![CDATA[<p>G(排列,图,容斥,dp,环)H()</p><h1 id="G-Three-Permutations"><a href="#G-Three-Permutations" class="headerlink" title="G - Three Permutations"></a>G - Three Permutations</h1><p><a href="https://atcoder.jp/contests/abc214/tasks/abc214_g" target="_blank" rel="noopener">https://atcoder.jp/contests/abc214/tasks/abc214_g</a></p><p>给[1..N]的排列p和q</p><p>求多少个排列r 满足 r[i] != p[i] , r[i] != q[i], i = [0..N]</p><p>mod 1e9+7</p><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>n 3000</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h3><p>如果只是给一个排列p</p><p>要找另一个排列r让每个位置对应不等(r[i] != p[i])</p><p>一个想法是, 把它直接按照p[i]的1到n重新排序</p><p>问题变成了 找r[i] != i的排列方案数</p><p>考虑长度n的和n-1之间变化</p><p>如果i放的n,而n放的i ,那么 去掉i和n, 方案数 为f(n-2)</p><p>n 有 n-1中交替放的方案, (n-1) f(n-2)</p><p>如果i放的n,而n放的不是i, 那么,交换i和n放的, 前n-1也合法, f(n-1)</p><p>f(n-1) 每个方案每个位置和n换, 贡献(n-1)f(n-1)</p><p>f(n) = (n-1)(f(n-1) + f(n-2))</p><p>f(1) = 0</p><p>f(2) = 1</p><p>f(3) = 2(1+0) = 2</p><hr><p>那么对于两个序列</p><p>首先一样的思路按照p 来排序</p><p>那么变成 r[i] != q[i], r[i] != i</p><p>但因为q[i]的限制并不能 像上面那样转移</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>如果对于每个位置,计算ri=pi或ri=qi的排列方案数,可以考虑容斥</p><p>假设 i1,i2,…ik, 对应的下标满足, ri=pi 或 ri=qi, 那么要计算所有r[i1],r[i2]..r[ik]的值方案</p><p>对于每个 i in i[1..k],在图中,我们增加一个(pi,qi)的边, 只需计算每条边分配给其一个端点的总数，以便没有两条不同的边共享一个分配给它的顶点。(意思就是边即是i, 而给边分配的点,即是r[i]的值, 不能共享点,意味着值不重复</p><p>(注意到 如果(pi,qi)链接的话, 只可能是 链 或 环,不可能出现分叉</p><p>对于每个联通分量考虑(除去孤立点和自环)</p><p>因为环之间两两不相关, 所以每一组i的选择答案 = 不同环的方案的乘积</p><p>我们对于一个K个点的环内, 选了k条边, 的方案数</p><p>当所有边被选(所有的i都有相等关系), 那么有2种方案</p><p>不是全部都选, 考虑把环剖成链讨论首尾是否选择</p><hr><p><code>dp[i][j][s0=0/1/2][si=0/1/2]</code> 表示前i条边,选择了j条, 且第一条是s0 状态,第i条是si状态的方案数</p><p>0: 未选择</p><p>1: 该边分配了左点</p><p>2: 该边分配了右点</p><p>状态转移</p><p>不选 <code>dp[i][j][s0][0] = sum dp[i-1][j][s0][0..2]</code></p><p>向左 <code>dp[i][j][s0][1] = sum dp[i-1][j-1][s0][0..1]</code></p><p>向右 <code>dp[i][j][s0][2] = sum dp[i-1][j-1][s0][0..2]</code></p><p>这样最后长n的环选了k条链的总方案数 就是<code>sum dp[n][k][s0][s1], 且 (s0 != 1 || s1 != 2)</code></p><p>记为<code>circle[n][k]</code></p><hr><p>如果gi 表示 指定了i个不合法的选择, 剩余的n-i个任意选(可以合法也可以不合法,但始终满足是排列)</p><p>那么 $ans = \sum_{i=0}^n (-1)^i(n-i)! g_i$</p><hr><p>而gi也可以通过上面环的结果, 去做dp</p><p><code>f[i][k] =</code> 前i个环指定了k个边 的方案数</p><p><code>f[i][k] = sum{f[i-1][k-t] * circle[sz[i]][t]}</code> 前i个环指定了k个边 的方案数</p><hr><p>于是把所有环剖成链连续放在数组上</p><p><code>g[i][j][s0][s1]</code> = 前i边,指定分配了j条, i所在环的起始是s0,结束是s1的方案数, 这里也是把s0也与i做相关意义了</p><p>转移类似, 分别是跨环转移 和 环内转移</p><hr><p>感觉这题还可以改控制最大环长, 但增大总长度, 变成矩阵乘法</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc214/submissions/33643608" target="_blank" rel="noopener">https://atcoder.jp/contests/abc214/submissions/33643608</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;#include &lt;atcoder/all&gt;using namespace std;using mint = atcoder::modint1000000007;#define rep(i,a,n) for (int i=a;i&lt;(int)n;i++)int read(){int r;scanf(&quot;%d&quot;,&amp;r);return r;} // readconst int N = 3000;int p[N+10];int q[N+10];int e[N+10]; // 单向边int vis2[N+10]; // 每个环的结束位置 = 1, 例如环为 2 3 5, 那么 [2]=1,[2+3=5]=1,[5+5=10]=1, 自环结束位置=2// 0 不分配, 1 分配左点, 2分配右点mint g[N+10][N+10][3][3]; // [i][j][s0][si] 每个环剖成链以后,长度i的链 分配了j条, 当前环 首个点state 0, 最后一个点stateimint fac[N+10]; // n!int main() {  int n=read();  fac[0]=1;  rep(i,1,n+1) fac[i]=fac[i-1]*i;  rep(i,0,n) p[i] = read();  rep(i,0,n) e[p[i]] = q[i] = read(); // 建立边 p,q =&gt; e  { // e =&gt; vis2    vector&lt;bool&gt; vis(n+1,false); // 点是否被访问    int m = 0;    rep(i,1,n+1) if(!vis[i]){      if(e[i]==i) { // 自环        vis2[++m]=2;        continue;      }      for(int j=i;!vis[j];j=e[j]) {        vis[j]=1;        m++;      }      vis2[m]=1;    }  }  g[0][0][0][0] = 1; // 初始状态  vis2[0] = 1;       // 初始状态  rep(i,0,n+1) rep(j,0,i+1){ // 剖成链, 前i个边, 指定j个不合法, 第i个点所在环首个点s0,第i个点s1状态    if(vis2[i]) { // 环结束位置      g[i][j][1][2] = 0; // 环首为向左环尾向右      if(vis2[i]==2) g[i][j][1][1]=0; // 自环, 不选是一种, 选左和选右相同, 去掉一个      rep(k,0,3) rep(l,0,3) { // i+1 是新的环        auto v = g[i][j][k][l];        g[i+1][j  ][0][0] += v; // 新环 本身与i 无关, 应该是1,这里相当于全部乘上前面的倍数        g[i+1][j+1][1][1] += v;        g[i+1][j+1][2][2] += v;      }    } else { // 环内      rep(k,0,3) rep(l,0,3){        auto v = g[i][j][k][l];        g[i+1][j  ][k][0] += v;        g[i+1][j+1][k][1] += ((l == 2) ? 0 : v); // 不能下一个向左 这一个向右        g[i+1][j+1][k][2] += v;      }    }  }  mint res = 0;  rep(i,0,n+1) {    mint cnt = 0; // 方案数    rep(j,0,3) rep(k,0,3) cnt += g[n][i][j][k];    res += fac[n-i]*cnt*(i%2?-1:1); // 容斥  }  printf(&quot;%d&quot;,res.val());  return 0;}</code></pre><h1 id="H-Collecting"><a href="#H-Collecting" class="headerlink" title="H - Collecting"></a>H - Collecting</h1><p><a href="https://atcoder.jp/contests/abc214/tasks/abc214_h" target="_blank" rel="noopener">https://atcoder.jp/contests/abc214/tasks/abc214_h</a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>G</p><p>容斥还是不熟 感觉这个式子需要记忆 $ans = \sum_{i=0}^n (-1)^i c_i$</p><p>然后这个排列会构成多个环感觉很常用虽然知道, 但是这里通过边表示i, 分配点表示取值还是没有想到, 感觉也是一种转化思路</p><p>然后环拆成链+两头也是很经典的方法了</p><p>实现上把 环变成链 再在数组上连续性, 去做dp的方法, 比多重再算g更神奇</p><p>另外这里递推贡献更新时没有保证正确性, 有的在处理时才修复正确性 比如<code>[1][2]</code> 和自环</p><p>H</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://atcoder.jp/contests/abc214/editorial" target="_blank" rel="noopener">官方题解</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;G(排列,图,容斥,dp,环)H()&lt;/p&gt;
&lt;h1 id=&quot;G-Three-Permutations&quot;&gt;&lt;a href=&quot;#G-Three-Permutations&quot; class=&quot;headerlink&quot; title=&quot;G - Three Permutations&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="Atcoder" scheme="http://yexiaorain.github.io/Blog/categories/Atcoder/"/>
    
    
      <category term="图" scheme="http://yexiaorain.github.io/Blog/tags/%E5%9B%BE/"/>
    
      <category term="dp" scheme="http://yexiaorain.github.io/Blog/tags/dp/"/>
    
      <category term="排列" scheme="http://yexiaorain.github.io/Blog/tags/%E6%8E%92%E5%88%97/"/>
    
      <category term="容斥" scheme="http://yexiaorain.github.io/Blog/tags/%E5%AE%B9%E6%96%A5/"/>
    
      <category term="环" scheme="http://yexiaorain.github.io/Blog/tags/%E7%8E%AF/"/>
    
  </entry>
  
  <entry>
    <title>Atcoder abc261</title>
    <link href="http://yexiaorain.github.io/Blog/2022-07-29-ac_abc261/"/>
    <id>http://yexiaorain.github.io/Blog/2022-07-29-ac_abc261/</id>
    <published>2022-07-28T20:25:14.000Z</published>
    <updated>2022-07-30T19:50:12.118Z</updated>
    
    <content type="html"><![CDATA[<p>G(dp, 字符串),H/Ex(图,dp,拓扑排序,dij,拆点)</p><h1 id="G-Replace"><a href="#G-Replace" class="headerlink" title="G - Replace"></a>G - Replace</h1><p>字符串S,T包含小写英文</p><p>可以执行k种 操作, 任意次 任意顺序</p><p>第i种 操作: 1代价, 把一个字符Ci 换成 字符串Ai</p><p>问S变成T 的最小代价 或不可能</p><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>|S|&lt;=|T| &lt;= 50</p><p>k &lt;= 50</p><p>|Ai| &lt;= 50</p><p>2s</p><p>1024mb</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h3><p>既然是字符(离散)换成字符串</p><p>那么岂不是 <code>dp[i][j]</code> 表示 S前i 个换成 T前j个</p><p><code>dp[i][j]</code> = <code>dp[i-1][j-k]</code>, <code>s[i] -&gt; T[j-k+1..j]</code> 可行</p><p>那么问题是如何判断可行</p><p>换句话说, 如果我们能算出 <code>T[j-k+1..j]</code> 能否逆向变成<code>s[i]</code> 也是办法</p><p>但是感觉这个会分叉很多</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p><code>dp[i][j][c]</code> = 最小代价<code>T[i..j] =&gt; 字符 c</code></p><p><code>f[i][j][k][l]</code> = 最小代价<code>T[i..j]</code> =&gt; 字符串 <code>A[k][1..l]</code> (这个很关键, 是把字符中前缀设置成状态)</p><pre><code>for i = N -&gt; 1:  for j = i -&gt; N:    计算 f[i][j][k][l], f[i][j][c], f[i][j][k][1]</code></pre><hr><p>计算<code>f[i][j][k][l]</code> 时 (<code>T[i..j] =&gt; A[k][1..l]</code>)</p><p>注意到替换时顺序不会变相当于</p><p>时 (<code>T[i.m][m+1.j] =&gt; A[k][1..l-1] A[k][l]</code>)</p><p>$f[i][j][k][l] = min(f[i][m][k][l-1] + dp[m+1][j][A[k][l]])$</p><hr><p>计算<code>dp[i][j][c] / f[i][j][k][1]</code></p><ol><li>本身就是c字符, i==j, Ti = c, 0</li><li>一步到位 <code>T[i..j] = A[k], C[k] = c</code></li><li>先转换到某个<code>A[k]</code> 再转一步, <code>min(f[i][j][k][|A[k]|]+1),C[k] = c</code></li></ol><p><code>f[i][j][k][1]</code> 从<code>dp[i][j][A[k][1]]</code> 中读即可</p><hr><p>这大概是O(n^4)的状态</p><p><code>O(n^5)</code> 的转移复杂度</p><hr><p>这其中还有一个问题是, 对于A和C都是单个字符的, 你会出现<code>T[i...j] -&gt; c0 -&gt; c1 -&gt; c2</code></p><p>你需要求最短路dij/spfa松弛 即可</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc261/submissions/33608140" target="_blank" rel="noopener">https://atcoder.jp/contests/abc261/submissions/33608140</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;(int)n;i++)#define per(i,a,n) for (int i=n;i--&gt;(int)a;)int read(){int r;scanf(&quot;%d&quot;,&amp;r);return r;} // readconst int INF = 0x3f3f3f3f; // 无穷大const int maxc = &#39;z&#39; - &#39;a&#39;; // 最大字符对应数字vector&lt;int&gt; t;int f[60][60][60][60]; // [l..r] =&gt; a[k][0...i] (prefix(a[k][i]))int dp[60][60][30]; // [l..r] =&gt; char cint c[60] = {maxc + 1}; // 不存在的字符vector&lt;int&gt; a[60]; // c[i] -&gt; a[i];vector&lt;pair&lt;int,int&gt; &gt; c2c; // 单字符映射char tmp[60];int lcStr2VecInt(vector&lt;int&gt; &amp; res){ // lower case string to vector&lt;int&gt;  scanf(&quot;%s&quot;, tmp);  int sz = strlen(tmp);  res.resize(sz);  rep(i,0,sz) res[i] = tmp[i] - &#39;a&#39;; // s 放在 c[0],a[0]  return sz;}void setMin(int &amp;v0,int v1){v0 = min(v0,v1);}int main(){  int ns = lcStr2VecInt(a[0]); // s 放在 c[0],a[0]  int nt = lcStr2VecInt(t); // t  int K = read() + 1; // 包含s  rep(i,1,K){    scanf(&quot;%s&quot;, tmp);    c[i] = tmp[0] - &#39;a&#39;;    if(lcStr2VecInt(a[i]) == 1) c2c.push_back({c[i], a[i][0]});  }  rep(l,0,nt) {    rep(r,l,nt) { // 全部设置为无穷大      rep(k,0,K) rep(i,0,50) f[l][r][k][i] = INF;      rep(c,0,maxc+1) dp[l][r][c] = INF;    }    dp[l][l][t[l]] = 0; // 本身就是字符  }  // --- init ---  per(l,0,nt) rep(r,l,nt){ // T[l..r], 各种顺序都行 保证依赖关系先被运算    rep(k,0,K){      int sz = a[k].size();      rep(i,1,sz){ // T[l..j][j+1..r] = &gt; a[k][0..i-1],a[k][i]        int &amp;v = f[l][r][k][i];        rep(j,l,r) setMin(v, f[l][j][k][i-1] + dp[j+1][r][a[k][i]]);        if(i == sz - 1) setMin(dp[l][r][c[k]], v + 1); // T[i..j] =&gt; a[k] =&gt; c[k]      }    }    // dp[l][r][c]=min(dp[l][r][k][|a[k]|]) + 1 = min(len &gt; 1(上面算了), len = 1) + 1, len = |a[k]|    rep(c,0,maxc+1) for(auto [c0, c1]: c2c) setMin(dp[l][r][c0], dp[l][r][c1] + 1); // 26 次 松弛    rep(k,0,K) setMin(f[l][r][k][0], dp[l][r][a[k][0]]); // 更新 f 中首字母  }  int &amp; ans = f[0][nt-1][0][ns-1];  printf(&quot;%d\n&quot;, ans == INF? -1: ans);  return 0;}</code></pre><h1 id="H-Ex-Game-on-Graph"><a href="#H-Ex-Game-on-Graph" class="headerlink" title="H/Ex - Game on Graph"></a>H/Ex - Game on Graph</h1><p>N点, M边</p><p>有向边 [ui,vi,weight i], 无重边 无自环</p><p>初始,点v上有个棋子</p><p>T和A交替游戏</p><ul><li>如果棋子所在点 没有向外路径 则结束游戏</li><li>如果有路径,任选一个走路径</li></ul><p>T 让weight和尽量小, A让和尽量大</p><p>T(结束游戏优先级 &gt; 和尽量小)</p><p>A(让游戏无限循环优先级 &gt; 和尽量大)</p><h2 id="限制-1"><a href="#限制-1" class="headerlink" title="限制"></a>限制</h2><p>N 2e5</p><p>M 2e5</p><p>Wi [0,1e9]</p><p>2s</p><p>1024mb</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h3><p>并不是有环就一定无限, 例如 <code>a-&gt;b-&gt;c-&gt;d-&gt;a</code></p><p>a连了个有限的, c也连了个更短的有限的</p><p>那么虽然你可以走到b,让对手走到c,这样在走到有限的 会比a直接去到有限的更短</p><p>考虑从叶子反过来, 判断是否有限,感觉bfs或者spfa/dij的感觉</p><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>图上环状dp</p><p><code>dp[x][0]</code> 从x出发 尽量小</p><p><code>dp[x][1]</code> 从x出发 尽量大</p><p><code>dp[x][0] = min (f[y][1] + weight[x][y])</code>, 相当于 反向图的最短路</p><p><code>dp[x][1] = max (f[y][0] + weight[x][y])</code>, 需要所有<code>f[y][0]</code> 被计算后才有意义</p><hr><p>然后就反图+拓扑+dij 就没了???</p><p>我感觉这个条件必要, 但总觉得没有证明到充分</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc261/submissions/33603896" target="_blank" rel="noopener">https://atcoder.jp/contests/abc261/submissions/33603896</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readll dp[2][200010];ll mx[200010]; // 只记录1的, 因为0的直接记录在pq和dp中, 而1的在子节点未完全计算时pq和dp都不会记录int deg[200010]; // 正向图出度, 反向图入度vector&lt;pair&lt;int,int&gt; &gt; g[200010]; // 反向图 v = {u, weight}template &lt;typename T&gt;using minPQ = priority_queue&lt;T,vector&lt;T&gt;, greater&lt;T&gt;&gt;; // 小根堆int main(){  int n = read();  int m = read();  int v = read();// 起点  rep(i,0,2) fill(dp[i],dp[i]+n+1,-1); // 未访问  rep(i,0,m) {    int u = read();    int v = read();    int w = read();    g[v].push_back({u, w});    deg[u] ++;  }  minPQ&lt;array&lt;ll,3&gt;&gt; q; // 小根堆, dij 每次找最小的未达点变为可达 {距离, 0/1, 点}  rep(i,1,n+1) if(deg[i] == 0) rep(j,0,2) q.push({0, j, i}); // dp[0/1][i] 反向入度为0 的节点  while(q.size()) {    auto [d, i, u] = q.top(); q.pop();    if(dp[i][u] != -1) continue; // 计算过    dp[i][u] = d; // 更新值    if(!i) { // dp[0][u] -&gt; dp[1][v]      for(auto [v, w] : g[u]) { // 更新反向边 并更新 deg[v] --        mx[v] = max(mx[v], d + w); // 更新值但是 不一定进入pq dp[x][1] = max (f[y][0] + weight[x][y])        if(--deg[v] == 0) q.push({mx[v], 1, v}); // dp[1][v] 只能所有计算都计算后才有意义      }    } else for(auto [v, w] : g[u]) q.push({d + w, 0, v}); // dp[1][u] -&gt; dp[0][v] dij  }  if(dp[0][v] == -1) printf(&quot;INFINITY\n&quot;);  else printf(&quot;%lld\n&quot;, dp[0][v]);  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>G</p><p>大小只有50的情况, <strong>对字符串中的前缀设计状态</strong>, 从而有dp的状态</p><p>第二就是 小的情况 多次松弛简单也效率满足, 不需要上dij</p><p>H/Ex</p><p>我感觉这个条件必要, 但总觉得没有证明到充分???</p><p>可能关键在于,虽然点上有 0/1两个状态,但实际上这两个状态不相关, 所以其实每个点可以拆点</p><p>这样就变成了路径的逆向dp了, 有环一定不行, 所以关键在这个拆点 -&gt; 变成dij</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://atcoder.jp/contests/abc261/editorial" target="_blank" rel="noopener">官方题解</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;G(dp, 字符串),H/Ex(图,dp,拓扑排序,dij,拆点)&lt;/p&gt;
&lt;h1 id=&quot;G-Replace&quot;&gt;&lt;a href=&quot;#G-Replace&quot; class=&quot;headerlink&quot; title=&quot;G - Replace&quot;&gt;&lt;/a&gt;G - Replace&lt;/h1&gt;
      
    
    </summary>
    
      <category term="Atcoder" scheme="http://yexiaorain.github.io/Blog/categories/Atcoder/"/>
    
    
      <category term="图" scheme="http://yexiaorain.github.io/Blog/tags/%E5%9B%BE/"/>
    
      <category term="dp" scheme="http://yexiaorain.github.io/Blog/tags/dp/"/>
    
      <category term="拓扑排序" scheme="http://yexiaorain.github.io/Blog/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    
      <category term="字符串" scheme="http://yexiaorain.github.io/Blog/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="dij" scheme="http://yexiaorain.github.io/Blog/tags/dij/"/>
    
      <category term="拆点" scheme="http://yexiaorain.github.io/Blog/tags/%E6%8B%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>Atcoder abc213</title>
    <link href="http://yexiaorain.github.io/Blog/2022-07-28-ac_abc213/"/>
    <id>http://yexiaorain.github.io/Blog/2022-07-28-ac_abc213/</id>
    <published>2022-07-27T20:25:14.000Z</published>
    <updated>2022-07-30T19:50:12.118Z</updated>
    
    <content type="html"><![CDATA[<p>F(SA,后缀数组,单调栈)G(bitmask, 集合论, 图, dp, 子集遍历),H/Ex(dp, 卷积, fft, NTT, 分治NTT)</p><h1 id="F-Common-Prefixes"><a href="#F-Common-Prefixes" class="headerlink" title="F - Common Prefixes"></a>F - Common Prefixes</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://atcoder.jp/contests/abc213/tasks/abc213_f" target="_blank" rel="noopener">https://atcoder.jp/contests/abc213/tasks/abc213_f</a></p><p>给长n字符串S</p><p>求其每个位置开始的后缀字符串, 和所有其它后缀字符串的 公共前缀和</p><h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h3><p>n 1e6</p><p>3s</p><p>1024mb</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="官方"><a href="#官方" class="headerlink" title="官方"></a>官方</h3><p>知识点 <a href="http://yexiaorain.github.io/Blog/2022-07-27-sa/">后缀数组 SA</a></p><p>那么对于 后缀i</p><p>它在SA中的位置是 rank[i]</p><p>有高度数组表示 rank[i] 和 rank[i-1]的最长公共前缀</p><p>那么就是 min(height[0..i]]) + min(height[1..i]) +… + min(height[i..i]) + (n-i) + min(height[i+1..i+1]) + .. + min(height[i+1..n])</p><p>直接枚举依然不行</p><p>考虑 可以单调栈维护计算其中一半</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc213/submissions/33587517" target="_blank" rel="noopener">https://atcoder.jp/contests/abc213/submissions/33587517</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 1000000007#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_back#define mp make_pairll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readconst int N = 1000000;char s[N+10]; // readint rk[N+10]; // rankint rk0[N+10]; // 临时int h[N+10]; // heightint sa[N+10]; // SAll pre[N+10]; // 前缀和ll suf[N+10]; // 后缀和int main(){  int n = read();  scanf(&quot;%s&quot;, s);  // sa &amp; rank  iota(sa,sa+n,0);  sort(sa,sa+n,[=](int i,int j){return s[i] &lt; s[j];});  rk[sa[0]] = 0;  rep(i,1,n) rk[sa[i]] = rk[sa[i-1]] + (s[sa[i]] != s[sa[i-1]]);  rep(pwr,0,22){    int w = 1&lt;&lt;pwr;    if(w &gt; n) break;    rep(i,0,n) rk0[i] = rk[i];    auto f = [=](int i){return i &lt; n?rk0[i]:-1;};    sort(sa,sa+n,[=](int i,int j){ return mp(f(i),f(i+w)) &lt; mp(f(j),f(j+w));});    rk[sa[0]] = 0;    rep(i,1,n) rk[sa[i]] = rk[sa[i-1]] + (mp(f(sa[i]),f(sa[i]+w)) != mp(f(sa[i-1]),f(sa[i-1]+w)));  }  // height  int hei = 0;  rep(i,0,n){    if(!rk[i]) continue;    if(hei) hei--;    while(s[i + hei] == s[sa[rk[i]-1] + hei]) hei++;    h[rk[i]] = hei;  }  // 单调栈  {    vector&lt;int&gt; stk = {};    rep(i,1,n) {      while(stk.size() &amp;&amp; h[i] &lt; h[stk.back()]) stk.pop_back();      // h[i] * length + stk[]      int last = stk.size() ? stk.back() : 0;      pre[i] = pre[last] + h[i] * (i - last);      stk.push_back(i);    }  }  {    vector&lt;int&gt; stk = {};    per(i,1,n) {      while(stk.size() &amp;&amp; h[i] &lt; h[stk.back()]) stk.pop_back();      // h[i] * length + stk[]      int last = stk.size() ? stk.back() : n;      suf[i] = suf[last] + h[i] * (last - i);      stk.push_back(i);    }  }  rep(i,0,n) printf(&quot;%lld\n&quot;,(n-i) + pre[rk[i]] + suf[rk[i]+1]);  return 0;}</code></pre><h1 id="G-Connectivity-2"><a href="#G-Connectivity-2" class="headerlink" title="G - Connectivity 2"></a>G - Connectivity 2</h1><p><a href="https://atcoder.jp/contests/abc213/tasks/abc213_g" target="_blank" rel="noopener">https://atcoder.jp/contests/abc213/tasks/abc213_g</a></p><p>无向图</p><p>n 点, m 边</p><p>考虑移除任意条边得到新图G, 有 2^M 种新图G</p><p>对于每个点, 计算在所有新图中, 和1属于同一连通块的个数</p><p>mod 9098244353</p><h2 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h2><p>n 17</p><p>无重边,无自环</p><p>3s</p><p>1024mb</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>显然, n&lt;=17 是个bitmask的题</p><p>2^17 = 131072</p><p>定义mask 为点1所在的联通块, 那么其实状态只有2^16 了</p><p>c[mask] = 包含mask的联通块个数</p><p>cnt[mask] = 边的两个端点都属于mask 的数量</p><p>对于剩下m - cnt[Mask] 条边</p><ul><li>如果端点均不在mask中, 则是否选边对mask没有影响,</li><li>如果端点一个在一个不在不在mask中, 则不可选,否则mask会变化</li></ul><p>导出子图(induced subgraph)是指，由该图顶点的一个子集和该图中两端均在该子集的所有边的集合组成的图。</p><hr><p>dp[S] = S构成连通块时, 内部的选的边端点均属于S的方案数</p><p>$dp[S] = 2^{cnt(S)} - \sum_{1\in T, T\subset S} dp[T] \cdot 2^{cnt(S-T)}$</p><p>所有方案 - 非所有点连通的方案(即是一个包含1的非所有点连通块,以及不包含1的连通块内的点的剩余边随便连)</p><hr><p>那么$ans(x) = \sum_{1\in S,x\in S} dp[S] \cdot 2^{cnt(全集 - S)}$</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc213/submissions/33590273" target="_blank" rel="noopener">https://atcoder.jp/contests/abc213/submissions/33590273</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 998244353#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // read// 2^17 =      65&#39;536// 2^17 =     131&#39;072// 3^16 =  43&#39;046&#39;721// 3^17 = 129&#39;140&#39;163const int N = 1&lt;&lt;17;int f[N+10];int c[N+10]; // 边两端 都属于mask 的数量ll p2[150]={1}; // 2**power , 17 * (17-1)/2 = 136ll ans[20];int main(){  rep(i,1,140) p2[i]=2*p2[i-1]%MOD;  int n = read();  int m = read();  // O(m 2^n)  rep(i,0,m){    int u = read() - 1; // 0-index    int v = read() - 1;    rep(mask,0,p2[n]) if((mask &amp; p2[u]) &amp;&amp; (mask &amp; p2[v])) c[mask]++; // 直接统计mask数量  }  rep(S0,0,p2[n-1]){    int S = 2*S0+1; // S一定要选0    f[S] = p2[c[S]]; // f[S] = 2^c[S] - sum{1\in T,T\subset S} f[T] 2^c[S-T]    for(int T0=S0&amp;(S0-1);S0/* 只有点0 没有真子集*/;T0=(T0-1)&amp;S0){// 真子集遍历 记住复杂度是O(3^n)      int T = 2*T0 + 1; // T一定选0      (f[S] -= f[T] * p2[c[S-T]] % MOD) %= MOD;      if(!T0)break;    }    // S包含0,i ; 时间复杂度 O(n 2^n)    rep(i,1,n) if(S &amp; p2[i]) (ans[i] += f[S]*p2[c[p2[n]-1-S]] % MOD) %= MOD;  }  rep(i,1,n) printf(&quot;%lld\n&quot;, (ans[i]+MOD) % MOD);}</code></pre><h1 id="H-Ex-Stroll"><a href="#H-Ex-Stroll" class="headerlink" title="H/Ex - Stroll"></a>H/Ex - Stroll</h1><p><a href="https://atcoder.jp/contests/abc213/tasks/abc213_h" target="_blank" rel="noopener">https://atcoder.jp/contests/abc213/tasks/abc213_h</a></p><p>N个点</p><p>M 个点对, 连接ui,vi, <code>p[i][d]</code>条路 长度d的路, (d [1,T])</p><p>找从点1开始,点1结束,长度等于T的路径方案数</p><h2 id="范围-2"><a href="#范围-2" class="headerlink" title="范围"></a>范围</h2><p>n 10</p><p>m min(10,n(n-1)/2)</p><p>t 4e4</p><p><code>p[1..m][1..T]</code> \in [0,998244353]</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h3><p>一眼递推</p><p><code>f[u][d] =</code>到u步数为T的方案数</p><p>那么每次找未贡献的最小的<code>d</code></p><p><code>f[v][d+step] += p[边[u &lt;-&gt; v]][step] * f[u][d]</code></p><p>但这样$NT$个状态, 每个状态会更新$MT$个点</p><p>看起来有$O(MNT^2)$</p><h3 id="官方-1"><a href="#官方-1" class="headerlink" title="官方"></a>官方</h3><p><code>dp[u][i]=</code> 1 出发, 长度i, 走到u 方案数</p><p>考虑最后一次转移 从v到u, 走t步</p><p>$dp[u][i] = \sum_{(u,v)\in E} \sum_{t=1}^i dp[v][i-t] * p[e_{u,v}][t]$</p><p>直接NTT依然不行</p><p>因为它们相互依赖</p><p>于是来到了分治NTT</p><hr><p>cdq 分治 + NTT/fft 框架</p><pre><code class="cpp">solve(l..r):  solve(l..mid)  // 计算(l..mid) 对(mid+1..r) 的贡献 , 这一部分将是dp[l..mid] 卷积 g[1..(r-l+1)], fft/ntt nlogn  solve(mid+1..r)</code></pre><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc213/submissions/me" target="_blank" rel="noopener">https://atcoder.jp/contests/abc213/submissions/me</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;#include &lt;atcoder/all&gt;using namespace std;using mint=atcoder::modint998244353;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readll n;ll p[20][40010]; // 系数矩阵mint dp[20][40010];vector&lt;pair&lt;int,int&gt;&gt; e[20];// cdq 分治 [l..r],// 每次分治 [l..mid], 计算[l..mid] 对 [mid+1..r]的贡献, 分治[mid+1..r]// 所以卷积代价 convolution([l..mid] x g[1..(r-l+1)]), ntt n log n, 总 =&gt; logn// 意味着每次分治solve(l..r)结束后,(l..r)的内部的贡献计算完了,(r+1...)的贡献完全没有统计void solve(ll l,ll r) {  if(l==r) return;  ll mid=(l+r)/2;  solve(l, mid);  rep(u,1,n+1) for(auto [v,eid]:e[u]) { // 枚举所有点和边    vector &lt;mint&gt; A = {};    vector &lt;mint&gt; B = {0};    // A[l..mid] , T[1..(r-l+1)], dp[i+1] = dp[i-j] * p[j] = A[i-j-l] * B[j] = C[i-l]    rep(i,l,mid+1) A.pb(dp[u][i]);    rep(i,1,(r-l+1)+1) B.pb(p[eid][i]);    auto C = atcoder::convolution(A,B); // 内部小的暴力 大的 fft    rep(i,mid+1,r+1) dp[v][i]+=C[i-l].val();  }  solve(mid+1,r);}int main() {  n = read();  ll m = read();  ll t = read();  rep(i,0,m) {    ll u = read();    ll v = read();    e[u].pb({v,i});    e[v].pb({u,i});    rep(j,1,t+1) p[i][j] = read();  }  dp[1][0] = 1;  solve(0,t);  printf(&quot;%d\n&quot;,dp[1][t].val());  return 0;}// dp[u][i] = sum{(u,v)\in E} sum{t=1..i} dp[v][i-t] * p[e_{u,v}][t]$</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>F</p><p>知识点 后缀数组 与高度数组</p><p>G</p><p>感觉有点集合论转移的思路,没有类似的练习</p><p>然后就是如何做分类和贡献统计, 这里是按照和1连通的作为一个分类的依据</p><p>分别记录内部方案数, 和 外部方案倍数, 外部倍数相对好算, 而内部方案数 需要dp推导</p><p>所有子集遍历的复杂度是$3^n$ 不是$4^n$</p><p>H</p><p>除了dp还可以数学直接表示到目标点, 从而引申出求和 有卷积</p><p>这里新知识点是分治NTT</p><p>atcoder 提供 atcoder::modint998244353, 以及卷积 atcoder::convolution</p><hr><p>关于Ubuntu 使用, 最简单就是, 克隆下来做个软链接</p><pre><code class="bash">git clone git@github.com:atcoder/ac-library.gitcd /usr/local/include/ # 切换到目录sudo ln -s 克隆路径/atcoder</code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://atcoder.jp/contests/abc213/editorial" target="_blank" rel="noopener">官方题解</a></p><p><a href="https://atcoder.jp/contests/abc213/editorial/2410" target="_blank" rel="noopener">https://atcoder.jp/contests/abc213/editorial/2410</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;F(SA,后缀数组,单调栈)G(bitmask, 集合论, 图, dp, 子集遍历),H/Ex(dp, 卷积, fft, NTT, 分治NTT)&lt;/p&gt;
&lt;h1 id=&quot;F-Common-Prefixes&quot;&gt;&lt;a href=&quot;#F-Common-Prefixes&quot; clas
      
    
    </summary>
    
      <category term="Atcoder" scheme="http://yexiaorain.github.io/Blog/categories/Atcoder/"/>
    
    
      <category term="图" scheme="http://yexiaorain.github.io/Blog/tags/%E5%9B%BE/"/>
    
      <category term="fft" scheme="http://yexiaorain.github.io/Blog/tags/fft/"/>
    
      <category term="dp" scheme="http://yexiaorain.github.io/Blog/tags/dp/"/>
    
      <category term="后缀数组" scheme="http://yexiaorain.github.io/Blog/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"/>
    
      <category term="单调栈" scheme="http://yexiaorain.github.io/Blog/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
      <category term="bitmask" scheme="http://yexiaorain.github.io/Blog/tags/bitmask/"/>
    
      <category term="NTT" scheme="http://yexiaorain.github.io/Blog/tags/NTT/"/>
    
      <category term="SA" scheme="http://yexiaorain.github.io/Blog/tags/SA/"/>
    
      <category term="集合论" scheme="http://yexiaorain.github.io/Blog/tags/%E9%9B%86%E5%90%88%E8%AE%BA/"/>
    
      <category term="子集遍历" scheme="http://yexiaorain.github.io/Blog/tags/%E5%AD%90%E9%9B%86%E9%81%8D%E5%8E%86/"/>
    
      <category term="卷积" scheme="http://yexiaorain.github.io/Blog/tags/%E5%8D%B7%E7%A7%AF/"/>
    
      <category term="分治NTT" scheme="http://yexiaorain.github.io/Blog/tags/%E5%88%86%E6%B2%BBNTT/"/>
    
  </entry>
  
  <entry>
    <title>后缀数组 SA</title>
    <link href="http://yexiaorain.github.io/Blog/2022-07-27-sa/"/>
    <id>http://yexiaorain.github.io/Blog/2022-07-27-sa/</id>
    <published>2022-07-27T02:37:14.000Z</published>
    <updated>2022-07-30T19:50:12.118Z</updated>
    
    <content type="html"><![CDATA[<h1 id="相关内容"><a href="#相关内容" class="headerlink" title="相关内容"></a>相关内容</h1><p>后缀自动机</p><h1 id="最终产物"><a href="#最终产物" class="headerlink" title="最终产物"></a>最终产物</h1><p>一个数组sa 记录下标, 按照后缀字典序排序</p><p>以及需要的话一个记录rank的数组(和sa相反)</p><p><img src="https://oi-wiki.org/string/images/sa1.png" alt="后缀数组"></p><p>h[i] 表示排名为i的和排名为i-1的最长公共前缀长度</p><h1 id="SA"><a href="#SA" class="headerlink" title="SA"></a>SA</h1><p>就是字符串所有后缀, 按照字典序排序</p><p>就是先按照每个位置开始长度为1排序, 变成数值顺序</p><p>再按照长度2的前缀顺序排, 但是此时 不需要原字符串,而直接用算出的数值顺序拼接</p><p>再按照长度4的前缀顺序排, 同上 相当于两个 长度2 的拼接</p><pre><code>for step =&gt; 2 * step:  rank = sort(pair&lt; rank[i],rank[i+step] &gt;)</code></pre><h2 id="例如代码"><a href="#例如代码" class="headerlink" title="例如代码"></a>例如代码</h2><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 1000000007#define rep(i,a,n) for (ll i=a;i&lt;n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backconst int N = 1000000;bool eq(vector&lt;int&gt;&amp; rk, int x,int y,int w){  return rk[x] == rk[y] &amp;&amp; rk[x+w] == rk[y+w];}// 0-index + 基数排序void calcsa(char *s,int n, vector&lt;int&gt; &amp;sa,vector&lt;int&gt; &amp;rk){  const int SIZE = max(512, n+1); // 字符集大小  vector&lt;int&gt;cnt(SIZE, 0); // char 2 count  rk.resize(2*n); // rank: 相等的前缀rank相等, 结束符rank = 0, 所以rank从1开始  sa.resize(n); // 后缀 index  rep(i,0,n) ++cnt[rk[i] = s[i]]; // 计数统计  rep(i,1,SIZE) cnt[i] += cnt[i - 1]; // 计数统计前缀  per(i,0,n) sa[--cnt[rk[i]]] = i; // 当前排序  { // n == 1    auto oldrk = rk;    int p = 0;    rep(i,0,n) {      if (i == 0 || oldrk[sa[i]] != oldrk[sa[i-1]]) p++;      rk[sa[i]] = p;    }  }  // rk = sort({rk[i],rk[i+w]}  for(int w = 1; w &lt; n; w *= 2) {    // 从低位到高位排序, 先排低位 rank[i+w], 再排 rank[i+0]    for(auto d:{w, 0}){      cnt = vector(SIZE,0);      rep(i,0,n) ++cnt[rk[i + d]]; // 所有 i+d 开始的计数统计      rep(i,1,SIZE) cnt[i] += cnt[i - 1];// 前缀和(基数排序      auto idx = sa;      per(i,0,n) sa[--cnt[rk[idx[i] + d]]] = idx[i]; // 保序    }    auto oldrk = rk;    int p = 0;    rep(i,0,n) {      if (i == 0 || oldrk[sa[i]] != oldrk[sa[i-1]] || oldrk[sa[i]+w] != oldrk[sa[i - 1] + w]) p++;      rk[sa[i]] = p;    }  }  rk.resize(n+1);}int main() {  char s[N+10] = &quot;aabaaaab&quot;;  int n = strlen(s) ;  printf(&quot;%d\n&quot;,n);  printf(&quot;%s\n&quot;,s);  vector&lt;int&gt; sa;  vector&lt;int&gt; rank;  calcsa(s, n, sa, rank);  rep(i,0,n) printf(&quot;%d &quot;, sa[i]);  return 0;}</code></pre><h2 id="height-数组"><a href="#height-数组" class="headerlink" title="height 数组"></a>height 数组</h2><p>而h数组, 首次相等的则 = 1</p><p>h[i] = lcp(sa[i],sa[i-1])</p><p>性质</p><p>h[rk[i]] &gt;= h[rk[i-1]] - 1</p><p>设后缀i-1 = “aAB”, a字符,A是h[i-1]对应字符串剩余部分,B是后缀的剩余部分</p><p>那么后缀i = “AB”</p><p>因为后缀i-1 = “aAB” 其实存在 “aAC”, “C &lt; B”, 且”C,B”公共前缀为空字符串</p><p>那么也就说明”AC”也存在</p><p>“AC”, “AB” 之间 如果还有其他的字符串,只能是”AD”形式 “C &lt; D &lt; B”, 那么长度至少为”|A|”, 得证</p><p>所以 可以按照i的顺序暴力算</p><pre><code class="cpp">int k = 0;rep(i,0,n) {  if (rk[i] == 0) continue;  if (k) --k;  while (s[i + k] == s[sa[rk[i] - 1] + k]) ++k;  h[rk[i]] = k;}</code></pre><h2 id="vector-sort-pair版本"><a href="#vector-sort-pair版本" class="headerlink" title="vector + sort + pair版本"></a>vector + sort + pair版本</h2><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 1000000007#define rep(i,a,n) for (ll i=a;i&lt;n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_back// 0-index + vector + sort// sa 下标按照顺序排列// rank 下标对应顺序index// h sa 中相邻后缀 最长公共前缀 h[0] = 0;template&lt;class T&gt;void calc_sa_rank(vector&lt;T&gt;&amp; arr, vector&lt;int&gt; &amp;sa,vector&lt;int&gt; &amp;rank, vector&lt;int&gt;&amp;h){  int n = arr.size();  rank = vector&lt;int&gt;(n,0);  sa = vector&lt;int&gt;(n,0);  iota(sa.begin(),sa.end(), 0);  sort(sa.begin(),sa.end(), [=](int i,int j){return arr[i] &lt; arr[j];});  rep(i,1,n) rank[sa[i]] = rank[sa[i-1]] + !(arr[sa[i]] == arr[sa[i-1]]);  for(int w = 1; w &lt; n; w *= 2) {    auto rank0 = rank;    auto rk = [=](int i){return i &lt; n ? rank0[i] : -1;};    sort(sa.begin(),sa.end(), [=](int i,int j){        return rk(i) != rk(j) ? rk(i) &lt; rk(j) : rk(i+w) &lt; rk(j+w);    });    rank[sa[0]] = 0;    rep(i,1,n) rank[sa[i]] = rank[sa[i-1]] + !(rk(sa[i]) == rk(sa[i-1]) &amp;&amp; rk(sa[i]+w) == rk(sa[i-1]+w));  }  // height  h = vector&lt;int&gt;(n,0);  int k = 0;  rep(i,0,n) {    if (rank[i] == 0) continue;    if (k) --k;    while (arr[i + k] == arr[sa[rank[i] - 1] + k]) ++k;    h[rank[i]] = k;  }}int main() {  char s[100] = &quot;aabaaaab&quot;;  int n = strlen(s) ;  printf(&quot;s:%s\n&quot;,s);  vector&lt;char&gt; arr ;  rep(i,0,n) arr.pb(s[i]);  vector&lt;int&gt; sa;  vector&lt;int&gt; rank;  vector&lt;int&gt; h;  calc_sa_rank(arr, sa, rank, h);  printf(&quot;sa:\n&quot;);  rep(i,0,n) printf(&quot;%d %s\n&quot;, sa[i], s + sa[i]);  printf(&quot;\nrk:\n&quot;);  rep(i,0,n) printf(&quot;%d %s\n&quot;, rank[i], s + i);  printf(&quot;\nhei:&quot;);  rep(i,0,n) printf(&quot;%d &quot;, h[i]);  printf(&quot;\n&quot;);  return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;相关内容&quot;&gt;&lt;a href=&quot;#相关内容&quot; class=&quot;headerlink&quot; title=&quot;相关内容&quot;&gt;&lt;/a&gt;相关内容&lt;/h1&gt;&lt;p&gt;后缀自动机&lt;/p&gt;
&lt;h1 id=&quot;最终产物&quot;&gt;&lt;a href=&quot;#最终产物&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
      <category term="algorithm" scheme="http://yexiaorain.github.io/Blog/categories/algorithm/"/>
    
    
      <category term="SAM" scheme="http://yexiaorain.github.io/Blog/tags/SAM/"/>
    
      <category term="SA" scheme="http://yexiaorain.github.io/Blog/tags/SA/"/>
    
  </entry>
  
  <entry>
    <title>从FFT 到 FWHT 快速沃尔什-阿达玛转换(Walsh Hadamard transform)</title>
    <link href="http://yexiaorain.github.io/Blog/2022-07-26-FWT/"/>
    <id>http://yexiaorain.github.io/Blog/2022-07-26-FWT/</id>
    <published>2022-07-26T14:24:00.000Z</published>
    <updated>2022-07-30T19:50:12.118Z</updated>
    
    <content type="html"><![CDATA[<h1 id="FWHT"><a href="#FWHT" class="headerlink" title="FWHT"></a>FWHT</h1><p>快速沃尔什-阿达玛转换(Fast Walsh-Hadamard transform), 一种广义傅立叶变换(FWHT)</p><h2 id="解决什么问题"><a href="#解决什么问题" class="headerlink" title="解决什么问题"></a>解决什么问题</h2><p>FWHT 是用于解决对下标进行位运算卷积问题的方法</p><p>$c_{i} = \sum_{i=j \bigoplus k}a_{j} b_{k}$</p><p>并且没有fft中会涉及到double</p><hr><p>前置知识 FFT(DFT)</p><p>DFT:</p><p>${\displaystyle {\begin{bmatrix}f_{0}\\f_{1}\\\vdots \\f_{n-1}\end{bmatrix}}={\begin{bmatrix}1&amp;1&amp;1&amp;\cdots &amp;1\\1&amp;\alpha &amp;\alpha ^{2}&amp;\cdots &amp;\alpha ^{n-1}\\1&amp;\alpha ^{2}&amp;\alpha ^{4}&amp;\cdots &amp;\alpha ^{2(n-1)}\\\vdots &amp;\vdots &amp;\vdots &amp;&amp;\vdots \\1&amp;\alpha ^{n-1}&amp;\alpha ^{2(n-1)}&amp;\cdots &amp;\alpha ^{(n-1)(n-1)}\\\end{bmatrix}}{\begin{bmatrix}v_{0}\\v_{1}\\\vdots \\v_{n-1}\end{bmatrix}}.}$</p><h2 id="回顾离散傅立叶与卷积"><a href="#回顾离散傅立叶与卷积" class="headerlink" title="回顾离散傅立叶与卷积"></a>回顾离散傅立叶与卷积</h2><p>核心等式</p><p>$\operatorname{FFT}(a * b) = \operatorname{FFT}(a) \cdot \operatorname{FFT}(b)$</p><p>快速变换, $x$原向量,$N$大小, $idx$ 下标</p><p>$idx \le \frac{N}{2}$</p><p>$f(x,N,idx) = f(even(x),\frac{N}{2},idx) + w^k \cdot f(odd(x),\frac{N}{2},idx)$</p><p>$f(x,N,idx+\frac{N}{2}) = f(even(x),\frac{N}{2},idx) - w^k \cdot f(odd(x),\frac{N}{2},idx)$</p><h2 id="Or-版本-FORT-Fast-or-transform"><a href="#Or-版本-FORT-Fast-or-transform" class="headerlink" title="Or 版本 FORT(Fast or transform)"></a>Or 版本 FORT(Fast or transform)</h2><h3 id="Or卷积-与-ForT"><a href="#Or卷积-与-ForT" class="headerlink" title="Or卷积 与 ForT"></a>Or卷积 与 ForT</h3><p>$c_{i} = \sum_{i = j | k}a_{j} b_{k}$, 这里$|$ 是按位或不是整除</p><p>令$fort[C]_ i = \sum_{i = j|i} A_j$</p><p>$\begin{aligned}<br>fort[a]_ i \cdot fort[b]_ i &amp;= (\sum_{j|i=i} a_j) \cdot (\sum_{k|i=i} b_k) \\<br>&amp;= \sum_{j|i=i} \sum_{k|i=i} a_jb_k \\<br>&amp;= \sum_{(j|k)|i = i} a_jb_k \\<br>&amp;= fort[c]_ i<br>\end{aligned}$</p><p>这证明了 $\operatorname{ForT}(\left(\sum_{i=j | k}a_{j} b_{k}\right)) = \operatorname{ForT}(a) \cdot \operatorname{ForT}(b)$</p><h3 id="快速变换"><a href="#快速变换" class="headerlink" title="快速变换"></a>快速变换</h3><p>下面问题就是如何fast, 如何让快速计算fort和它的逆变换ifort</p><p>快速变换, $x$原向量,$N$大小, $idx$ 下标</p><p>$idx &lt; \frac{N}{2}$</p><p>$f(x,N,idx) = f(x, \frac{N}{2},idx)$</p><p>$f(x,N,idx+\frac{N}{2}) = f(x[0\cdots \frac{N}{2}-1]),\frac{N}{2},idx) + f(x[\frac{N}{2}\cdots N-1],\frac{N}{2},idx)$</p><p>因为本身$fort$的第$i$位就是所有$i$的二进制子集位置的和</p><p>那么对于$idx$ 它的子集一定也是在前半数组中</p><p>那么对于$idx + \frac{N}{2}$ 它的 其实就是最高位多了一个bit, 除了这个bit, 剩余部分和$idx$一样, 所以前半后半都按照$idx$来计算求和即可</p><p>至此完成fast</p><pre><code class="cpp">void ForT(modint *f) {  for (int k = 1; k &lt; n; k *=2){    for (int i = 0; i &lt; n; i += 2*k){      for (int j = 0; j &lt; k; j++){        // f[i+j] = f[i+j];        f[i+j+k] += f[i+j];      }    }  }}</code></pre><h3 id="逆变换"><a href="#逆变换" class="headerlink" title="逆变换"></a>逆变换</h3><p>可以直接参考fast的过程, 每个位置表示它所有bit子集的和, 那么按照反过来, 可以先减去未包含最低的其它子集和bit的值,未包含了低2位bit的其她子集和,…</p><p>显然对于的向量的$v$首个值有 $fort(v)_ 0 = v_0$</p><p>所以 $a_0 = fort(a)_ 0$</p><p>因为 $fort(a)_ 1 = fort(a_0) + fort(a_1)$</p><p>所以 $a_1 = fort(a_1) = fort(a)_ 1 - fort(a_0)$</p><p>同理$idx &lt; \frac{N}{2}$</p><p>$f(x,N,idx) = f(x, \frac{N}{2},idx)$</p><p>$f(x,N,idx+\frac{N}{2}) = f(x[0\cdots \frac{N}{2}-1]),\frac{N}{2},idx) - f(x[\frac{N}{2}\cdots N-1],\frac{N}{2},idx)$</p><pre><code class="cpp">void IForT(modint *f) {  for (int k = 1; k &lt; n; k *=2){    for (int i = 0; i &lt; n; i += 2*k){      for (int j = 0; j &lt; k; j++){        f[i+j+k] -= f[i+j];      }    }  }}</code></pre><hr><p>合并</p><pre><code class="cpp">// Or卷积void ForT(vector&lt;modint&gt; &amp;f,int flag = 1/* 1:正变换,-1:逆变换 */) {  int n = f.size();  for (int k = 1; k &lt; n; k *=2){    for (int i = 0; i &lt; n; i += 2*k){      for (int j = 0; j &lt; k; j++){        f[i+j+k] += flag * f[i+j];      }    }  }}</code></pre><h2 id="And-卷积-Fast-and-transform"><a href="#And-卷积-Fast-and-transform" class="headerlink" title="And 卷积(Fast and transform)"></a>And 卷积(Fast and transform)</h2><p>$c_{i} = \sum_{i = j \&amp; k}a_{j} b_{k}$</p><p>和Or的部分同理</p><ol><li>定义变换$fandt(a)_ i = \sum_{i|j = j} a_j$</li><li>证明 $fandt(a) \odot fandt(b) = fandt(\left(\sum_{i = j \&amp; k}a_{j} b_{k}\right))$</li><li>利用分块关系,实现fast</li></ol><p>最终代码</p><pre><code class="cpp">void FandT(vector&lt;modint&gt; &amp;f, int flag = 1/* 1:正变换,-1:逆变换 */) {  int n = f.size();  for (int k = 1; k &lt; n; k *=2){    for (int i = 0; i &lt; n; i += 2*k){      for (int j = 0; j &lt; k; j++){        f[i+j] += f[i+j+k] * flag;      }    }  }}</code></pre><h2 id="Xor卷积-与-FWHT-Fast-Walsh-Hadamard-transform"><a href="#Xor卷积-与-FWHT-Fast-Walsh-Hadamard-transform" class="headerlink" title="Xor卷积 与 FWHT(Fast Walsh-Hadamard transform)"></a>Xor卷积 与 FWHT(Fast Walsh-Hadamard transform)</h2><p>$\operatorname{FWHT}(\left(\sum_{i=j \bigoplus k}a_{j} b_{k}\right)) = \operatorname{FWHT}(a) \cdot \operatorname{FWHT}(b)$</p><h3 id="定义FWHT"><a href="#定义FWHT" class="headerlink" title="定义FWHT"></a>定义FWHT</h3><p>其实和上面一样,依然是三步,定义转换,证明等式,实现fast</p><p>定义符号 $x\otimes y=\text{popcount}(x \&amp; y) \bmod 2$, 即 $x$位与$y$后的二进制表示的$1$的个数再$\bmod 2$</p><p>有性质$(i \otimes j) \oplus (i \otimes k) = i \otimes (j \oplus k)$</p><p>证明: 对于给定的一位, 如果i中0, 则都贡献0, 如果i中是1, $j,k$对应的是1 则贡献是0 则不贡献, 得证</p><p>定义: $fwht[a]_ i = \sum_{i\otimes j = 0}a_j - \sum_{i\otimes j = 1}a_j$</p><p>那么有:</p><p>$fwht[a]_ i \cdot fwht[b]_ i$</p><p>$\begin{aligned}<br>&amp;= (\sum_{i\otimes j = 0} a_j - \sum_{i\otimes j = 1} a_j)\cdot (\sum_{i\otimes k = 0} b_k - \sum_{i\otimes k = 1} b_k) \\<br>&amp;=\left((\sum_{i\otimes j=0}a_j)(\sum_{i\otimes k=0}b_k)+(\sum_{i\otimes j=1}a_j)(\sum_{i\otimes k=1}b_k) \right)-\left((\sum_{i\otimes j=0}a_j)(\sum_{i\otimes k=1}b_k)-(\sum_{i\otimes j=1}a_j)(\sum_{i\otimes kj=0}b_k)\right)\\<br>&amp;=\sum_{i\otimes(j \oplus k)=0}a_jb_k-\sum_{i\otimes(j\oplus k)=1}a_jb_k \\<br>&amp;=\sum_{i\otimes l = 0}\sum_{l = j \oplus k}a_jb_k-\sum_{i\otimes l = 1}\sum_{l = j\oplus k}a_jb_k \\<br>&amp;= fwht[\left(\sum_{i=j \bigoplus k}a_{j} b_{k}\right)]_ i<br>\end{aligned}$</p><h3 id="Walsh-matrix-and-Hadamard-transform"><a href="#Walsh-matrix-and-Hadamard-transform" class="headerlink" title="Walsh matrix and Hadamard transform"></a>Walsh matrix and Hadamard transform</h3><p>可以看看Walsh矩阵的样子</p><p>${\displaystyle H_{m}={\frac {1}{\sqrt {2}}}{\begin{pmatrix}H_{m-1}&amp;H_{m-1}\\H_{m-1}&amp;-H_{m-1}\end{pmatrix}}}$</p><p>${\begin{aligned}H_{0}&amp;=+{\begin{pmatrix}1\end{pmatrix}}\\H_{1}&amp;={\frac {1}{\sqrt {2}}}\left({\begin{array}{rr}1&amp;1\\1&amp;-1\end{array}}\right)\\H_{2}&amp;={\frac {1}{2}}\left({\begin{array}{rrrr}1&amp;1&amp;1&amp;1\\1&amp;-1&amp;1&amp;-1\\1&amp;1&amp;-1&amp;-1\\1&amp;-1&amp;-1&amp;1\end{array}}\right)\\H_{3}&amp;={\frac {1}{2^{3/2}}}\left({\begin{array}{rrrrrrrr}1&amp;1&amp;1&amp;1&amp;1&amp;1&amp;1&amp;1\\1&amp;-1&amp;1&amp;-1&amp;1&amp;-1&amp;1&amp;-1\\1&amp;1&amp;-1&amp;-1&amp;1&amp;1&amp;-1&amp;-1\\1&amp;-1&amp;-1&amp;1&amp;1&amp;-1&amp;-1&amp;1\\1&amp;1&amp;1&amp;1&amp;-1&amp;-1&amp;-1&amp;-1\\1&amp;-1&amp;1&amp;-1&amp;-1&amp;1&amp;-1&amp;1\\1&amp;1&amp;-1&amp;-1&amp;-1&amp;-1&amp;1&amp;1\\1&amp;-1&amp;-1&amp;1&amp;-1&amp;1&amp;1&amp;-1\end{array}}\right)\\(H_{n})_{i,j}&amp;={\frac {1}{2^{n/2}}}(-1)^{i\cdot j}\end{aligned}}$</p><p>对于 $(1,0,1,0,0,1,1,0)$</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/aa/1010_0110_Walsh_spectrum_%28single_row%29.svg/300px-1010_0110_Walsh_spectrum_%28single_row%29.svg.png" alt="The product of a Boolean function and a Walsh matrix"></p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/58/1010_0110_Walsh_spectrum_%28fast_WHT%29.svg/300px-1010_0110_Walsh_spectrum_%28fast_WHT%29.svg.png" alt="Fast Walsh–Hadamard transform, a faster way to calculate the Walsh spectrum"></p><h3 id="快速变换-1"><a href="#快速变换-1" class="headerlink" title="快速变换"></a>快速变换</h3><p>其实看到了矩阵之间的递推关系 这个表达式就很显然了</p><p>$idx &lt; \frac{N}{2}$</p><p>$f(x,N,idx) = f(x[0,\frac{N}{2}), \frac{N}{2},idx) + f(x[\frac{N}{2},N), \frac{N}{2}, idx)$</p><p>$f(x,N,idx+\frac{N}{2}) = f(x[0,\frac{N}{2}), \frac{N}{2},idx) - f(x[\frac{N}{2},N), \frac{N}{2}, idx)$</p><pre><code class="cpp">void FWHT(vector&lt;modint&gt; &amp;f, int flag = 1 /* 1: 正变换, 1/2: 逆变换*/) {  int n = f.size();  for (int k = 1; k &lt; n; k *=2){    for (int i = 0; i &lt; n; i += 2*k){      for (int j = 0; j &lt; k; j++){        auto U = f[i+j];        auto T = f[i+j+k];        f[i+j]   = U + T;        f[i+j+k] = U - T;        f[i+j] *= flag;        f[i+j+k] *= flag;      }    }  }}</code></pre><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;#include &quot;./modint.cpp&quot;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backusing MODINT::modint;namespace FWT{  void ForT(vector&lt;modint&gt; &amp;f,int flag = 1/* 1:正变换,-1:逆变换 */) {    int n = f.size();    for (int k = 1; k &lt; n; k *=2){      for (int i = 0; i &lt; n; i += 2*k){        for (int j = 0; j &lt; k; j++){          f[i+j+k] += f[i+j] * flag;        }      }    }  }  void IForT(vector&lt;modint&gt; &amp;f) {ForT(f, -1);}  vector&lt;modint&gt; or_convolution(vector&lt;modint&gt; &amp;v0, vector&lt;modint&gt; &amp;v1){    const int sz = v0.size();    ForT(v0);    ForT(v1);    vector&lt;modint&gt; v2(sz,0);    rep(i,0,sz) v2[i] = v0[i] * v1[i];    IForT(v2);    return v2;  }  void FandT(vector&lt;modint&gt; &amp;f, int flag = 1/* 1:正变换,-1:逆变换 */) {    int n = f.size();    for (int k = 1; k &lt; n; k *=2){      for (int i = 0; i &lt; n; i += 2*k){        for (int j = 0; j &lt; k; j++){          f[i+j] += f[i+j+k] * flag;        }      }    }  }  void IFandT(vector&lt;modint&gt; &amp;f) {FandT(f, -1);}  vector&lt;modint&gt; and_convolution(vector&lt;modint&gt; &amp;v0, vector&lt;modint&gt; &amp;v1){    const int sz = v0.size();    FandT(v0);    FandT(v1);    vector&lt;modint&gt; v2(sz,0);    rep(i,0,sz) v2[i] = v0[i] * v1[i];    IFandT(v2);    return v2;  }  modint inv2 = modint(2).inv();  void FWHT(vector&lt;modint&gt; &amp;f, modint flag = 1 /* 1: 正变换, 1/2: 逆变换*/) {    int n = f.size();    for (int k = 1; k &lt; n; k *=2){      for (int i = 0; i &lt; n; i += 2*k){        for (int j = 0; j &lt; k; j++){          auto U = f[i+j];          auto T = f[i+j+k];          f[i+j]   = U + T;          f[i+j+k] = U - T;          f[i+j] *= flag;          f[i+j+k] *= flag;        }      }    }  }  void IFWHT(vector&lt;modint&gt; &amp;f) {FWHT(f, inv2);}  void FxorT(vector&lt;modint&gt; &amp;f,int flag = 1) {FWHT(f, flag);}  void IFxorT(vector&lt;modint&gt; &amp;f) {IFWHT(f);}  vector&lt;modint&gt; xor_convolution(vector&lt;modint&gt; &amp;v0, vector&lt;modint&gt; &amp;v1){    const int sz = v0.size();    FxorT(v0);    FxorT(v1);    vector&lt;modint&gt; v2(sz,0);    rep(i,0,sz) v2[i] = v0[i] * v1[i];    IFxorT(v2);    return v2;  }};void print(vector&lt;modint&gt; &amp;arr){  for(auto &amp;v:arr) printf(&quot;%d &quot;, v.val());  printf(&quot;\n&quot;);}int main(){  // 长度2的幂次  const vector&lt;modint&gt; A0 = {1,2,3,0};  const vector&lt;modint&gt; B0 = {4,5,6,0};  // --- or ---  {    auto A = A0;    auto B = B0;    auto C = FWT::or_convolution(A,B);    print(C);  }  // --- and ---  {    auto A = A0;    auto B = B0;    auto C = FWT::and_convolution(A,B);    print(C);  }  // --- xor ---  {    auto A = A0;    auto B = B0;    auto C = FWT::xor_convolution(A,B);    print(C);  }  return 0;}</code></pre><h2 id="洛谷P4717"><a href="#洛谷P4717" class="headerlink" title="洛谷P4717"></a>洛谷P4717</h2><p><a href="https://www.luogu.com.cn/record/81332363" target="_blank" rel="noopener">https://www.luogu.com.cn/record/81332363</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;n;i++)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // read// ----------- modint -----------namespace MODINT{  const int _mod = 998244353;  class modint{    private:      ll _v;    public:      modint() :_v(0) {  }      modint(ll _a) {        _v = (_a &lt; 0)? _mod - ((-_a) % _mod) : (_a % _mod);      }      int val()const { return _v; }      modint operator+()const { return *this; }      modint operator-()const { return { _mod - _v }; }      modint operator+(const modint&amp; rhs) const { return modint(*this) += rhs; }      modint operator-(const modint&amp; rhs) const { return modint(*this) -= rhs; }      modint operator*(const modint&amp; rhs) const { return modint(*this) *= rhs; }      modint operator/(const modint&amp; rhs) const { return modint(*this) /= rhs; }      bool operator==(const modint&amp; rhs)const { return _v == rhs._v; }      bool operator!=(const modint&amp; rhs)const { return _v != rhs._v; }      bool operator&gt; (const modint&amp; rhs)const { return _v &gt;  rhs._v; }      bool operator&gt;=(const modint&amp; rhs)const { return _v &gt;= rhs._v; }      bool operator&lt;=(const modint&amp; rhs)const { return _v &lt;= rhs._v; }      bool operator&lt; (const modint&amp; rhs)const { return _v &lt;  rhs._v; }      modint&amp; operator+=(const modint&amp; rhs) {        (_v += rhs._v) %= _mod;        return *this;      }      modint&amp; operator-=(const modint&amp; rhs) {        (_v += _mod - rhs._v) %= _mod;        return *this;      }      modint&amp; operator*=(const modint&amp; rhs) {        _v = _v * rhs.val() % _mod;        return *this;      }      modint&amp; operator/=(const modint&amp; rhs) { // 费马小定理        _v = _v * rhs.inv().val() % _mod ;        return *this;      }      modint pow(ll pwr) const {        ll res(1);        ll _b(_v);        while (pwr) {          if (pwr &amp; 1) (res *= _b) %= _mod;          (_b *= _b) %= _mod;          pwr /= 2;        }        return res;      }      modint inv() const {        assert(_v != 0);        return pow(_mod - 2);      }  };};// ----------- modint -----------// ----------- fwt -----------using MODINT::modint;namespace FWT{  void ForT(vector&lt;modint&gt; &amp;f,int flag = 1/* 1:正变换,-1:逆变换 */) {    int n = f.size();    for (int k = 1; k &lt; n; k *=2){      for (int i = 0; i &lt; n; i += 2*k){        for (int j = 0; j &lt; k; j++){          f[i+j+k] += f[i+j] * flag;        }      }    }  }  void IForT(vector&lt;modint&gt; &amp;f) {ForT(f, -1);}  vector&lt;modint&gt; or_convolution(vector&lt;modint&gt; &amp;v0, vector&lt;modint&gt; &amp;v1){    const int sz = v0.size();    ForT(v0);    ForT(v1);    vector&lt;modint&gt; v2(sz,0);    rep(i,0,sz) v2[i] = v0[i] * v1[i];    IForT(v2);    return v2;  }  void FandT(vector&lt;modint&gt; &amp;f, int flag = 1/* 1:正变换,-1:逆变换 */) {    int n = f.size();    for (int k = 1; k &lt; n; k *=2){      for (int i = 0; i &lt; n; i += 2*k){        for (int j = 0; j &lt; k; j++){          f[i+j] += f[i+j+k] * flag;        }      }    }  }  void IFandT(vector&lt;modint&gt; &amp;f) {FandT(f, -1);}  vector&lt;modint&gt; and_convolution(vector&lt;modint&gt; &amp;v0, vector&lt;modint&gt; &amp;v1){    const int sz = v0.size();    FandT(v0);    FandT(v1);    vector&lt;modint&gt; v2(sz,0);    rep(i,0,sz) v2[i] = v0[i] * v1[i];    IFandT(v2);    return v2;  }  modint inv2 = modint(2).inv();  void FWHT(vector&lt;modint&gt; &amp;f, modint flag = 1 /* 1: 正变换, 1/2: 逆变换*/) {    int n = f.size();    for (int k = 1; k &lt; n; k *=2){      for (int i = 0; i &lt; n; i += 2*k){        for (int j = 0; j &lt; k; j++){          auto U = f[i+j];          auto T = f[i+j+k];          f[i+j]   = U + T;          f[i+j+k] = U - T;          f[i+j] *= flag;          f[i+j+k] *= flag;        }      }    }  }  void IFWHT(vector&lt;modint&gt; &amp;f) {FWHT(f, inv2);}  void FxorT(vector&lt;modint&gt; &amp;f,int flag = 1) {FWHT(f, flag);}  void IFxorT(vector&lt;modint&gt; &amp;f) {IFWHT(f);}  vector&lt;modint&gt; xor_convolution(vector&lt;modint&gt; &amp;v0, vector&lt;modint&gt; &amp;v1){    const int sz = v0.size();    FxorT(v0);    FxorT(v1);    vector&lt;modint&gt; v2(sz,0);    rep(i,0,sz) v2[i] = v0[i] * v1[i];    IFxorT(v2);    return v2;  }};// ----------- fwt -----------void print(vector&lt;modint&gt; &amp;arr){  for(auto &amp;v:arr) printf(&quot;%d &quot;, v.val());  printf(&quot;\n&quot;);}int main(){  const int n = read();  const int SIZE = 1&lt;&lt;n;  // 长度2的幂次  auto A0 = vector&lt;modint&gt;(SIZE,0);  auto B0 = vector&lt;modint&gt;(SIZE,0);  rep(i,0,SIZE) A0[i] = read();  rep(i,0,SIZE) B0[i] = read();  // --- or ---  {    auto A = A0;    auto B = B0;    auto C = FWT::or_convolution(A,B);    print(C);  }  // --- and ---  {    auto A = A0;    auto B = B0;    auto C = FWT::and_convolution(A,B);    print(C);  }  // --- xor ---  {    auto A = A0;    auto B = B0;    auto C = FWT::xor_convolution(A,B);    print(C);  }  return 0;}</code></pre><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="http://yexiaorain.github.io/Blog/2019-01-02-fftmul/">我的FFT笔记</a></p><p><a href="https://en.wikipedia.org/wiki/Fast_Walsh%E2%80%93Hadamard_transform" target="_blank" rel="noopener">wikipedia Fast Walsh-Hadamard transform</a></p><p><a href="https://en.wikipedia.org/wiki/Hadamard_transform" target="_blank" rel="noopener">Hadamard transform</a></p><p><a href="https://en.wikipedia.org/wiki/Walsh_matrix" target="_blank" rel="noopener">Walsh matrix</a></p><p><a href="https://codeforces.com/blog/entry/71899" target="_blank" rel="noopener">Codeforces FWHT inner working</a></p><p><a href="https://blog.csdn.net/a_forever_dream/article/details/105110089" target="_blank" rel="noopener">CSDN 快速沃尔什变换（FWT）详详详解</a></p><p><a href="https://www.luogu.com.cn/problem/solution/P4717" target="_blank" rel="noopener">luogu 模板练习</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;FWHT&quot;&gt;&lt;a href=&quot;#FWHT&quot; class=&quot;headerlink&quot; title=&quot;FWHT&quot;&gt;&lt;/a&gt;FWHT&lt;/h1&gt;&lt;p&gt;快速沃尔什-阿达玛转换(Fast Walsh-Hadamard transform), 一种广义傅立叶变换(FWHT)&lt;/p
      
    
    </summary>
    
      <category term="Codeforces" scheme="http://yexiaorain.github.io/Blog/categories/Codeforces/"/>
    
    
      <category term="fft" scheme="http://yexiaorain.github.io/Blog/tags/fft/"/>
    
      <category term="FWHT" scheme="http://yexiaorain.github.io/Blog/tags/FWHT/"/>
    
  </entry>
  
  <entry>
    <title>Atcoder abc212</title>
    <link href="http://yexiaorain.github.io/Blog/2022-07-25-ac_abc212/"/>
    <id>http://yexiaorain.github.io/Blog/2022-07-25-ac_abc212/</id>
    <published>2022-07-24T20:25:14.000Z</published>
    <updated>2022-07-30T19:50:12.118Z</updated>
    
    <content type="html"><![CDATA[<p>G(数学,数论,原根)H/Ex(沃尔什-阿达玛转换,FWT/FWHT)</p><h1 id="G-Power-Pair"><a href="#G-Power-Pair" class="headerlink" title="G - Power Pair"></a>G - Power Pair</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://atcoder.jp/contests/abc212/tasks/abc212_g" target="_blank" rel="noopener">https://atcoder.jp/contests/abc212/tasks/abc212_g</a></p><p>给定 质数$p$ </p><p>问 $x,y\in[0,p-1]$  中有多少对$(x,y)$满足</p><p>存在$n$, 使得$x^n = y \pmod p$</p><h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h3><p>p $10^{12}$</p><p>2s</p><p>1024mb</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h3><p>显然x=0 只有y = 0, y=0也只有x=0</p><p>然后如果x是原根 那么 方案数$p-1$</p><p>如果$r|(p-1)$ 那么 $x^r \pmod p$的方案数为$\frac{p-1}{r}$</p><p>或者$x$的最小幂次$t$让$x^t = 1 \pmod p$, 则答案为$t$</p><p>但是即使这样, 如果每个去枚举依然是$O(p log(p))$</p><p>反过来考虑说有没有办法求$x^t = 1$ 的方案数,</p><p>如果能快速计算出,那么 方案数减去它的t因子对应的方案数 就恰好是 = t的方案数</p><p>而$t$的取值只会是 $p-1$的因数</p><p>$t = 1$ $x = 1$</p><p>$t = 2$ $x = 1,-1$</p><p>$t = 4$</p><p>$t = 7$</p><p>$t = 8$</p><hr><p>t = 2k时, $x^{2k} - 1 = 0 \pmod p$</p><p>$(x^k+1)(x^k-1) = 0 \pmod p$, 相当于$x^k = 1 \pmod p, x^k = -1 \pmod p $的解的并</p><p>并不会</p><h3 id="官方"><a href="#官方" class="headerlink" title="官方"></a>官方</h3><p>原根的想法没问题, 然后就变成了我们指定原根</p><p>$x^i = j$, $(i,j)$ 是一一对应, 且取$[1,p-1]$范围内的所有值</p><p>这样的话</p><p>要求 $x^i$ 的最小让 幂次等于1的t</p><p>注意到 和我思路一样的 $x^i$当$i | (p-1)$时, 方案数 $=\frac{p-1}{i}$</p><p>而这里$i$可能不是$p-1$的因子, 而易证明 方案数为 $\frac{p-1}{gcd(p-1,i)}$</p><p>这里问题变成了, 统计不同 $gcd(p-1,i) = k$ 的数量即可</p><hr><p>$g | (p-1)$</p><p>$\sum_{g|(p-1)} count(g 倍数 且非(p-1)因子) $</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc212/submissions/33524525" target="_blank" rel="noopener">https://atcoder.jp/contests/abc212/submissions/33524525</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 998244353#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // read// 转质数和幂次vector&lt;pair&lt;ll,int&gt; &gt; v2ppwr(ll v){  vector&lt;pair&lt;ll,int&gt; &gt; res = {};  rep(t,2,v+1){    if(t*t &gt; v) break;    int c = 0;    while(v % t == 0){      v /= t;      c ++;    }    if(c) res.pb({t,c});  }  if(v != 1) res.pb({v, 1});  return res;}// gcd = xll dfs(ll idx, ll y, vector&lt;ll&gt; primes, const vector&lt;pair&lt;ll,int&gt; &gt; &amp; ppwr1){  if(idx == (int)ppwr1.size()) {    ll rc = y; // 容斥    for(auto p:primes) rc = rc / p * (p-1);    return y % MOD * (rc % MOD) % MOD;  }  auto [p,mi] = ppwr1[idx];  ll mul = 1; // p ** pwr  primes.push_back(p);  ll res = 0;  rep(pwr,0,mi+1){    if(pwr == mi) primes.pop_back();    (res += dfs(idx+1, y / mul, primes, ppwr1)) %= MOD;    mul *= p;  }  return res;}int main(){  ll p = read();  auto ppwr = v2ppwr(p-1);  printf(&quot;%lld\n&quot;, (1 /* (0,0) */ + dfs(0, p-1, {}, ppwr)) % MOD);  return 0;}</code></pre><h1 id="H-Ex-Nim-Counting"><a href="#H-Ex-Nim-Counting" class="headerlink" title="H/Ex - Nim Counting"></a>H/Ex - Nim Counting</h1><p><a href="https://atcoder.jp/contests/abc212/tasks/abc212_h" target="_blank" rel="noopener">https://atcoder.jp/contests/abc212/tasks/abc212_h</a></p><p>给正整数 长度k的 数组A, 值两两不同</p><p>T和A轮流游戏, T先</p><p>选一个 &gt;= 1 的石堆, 移除任意正整数个</p><p>谁取了最后一个胜利</p><hr><p>问题是</p><p>对于长度[1,N] 每个元素属于A中的一个的 初始状态, 有多少种状态是 T 胜利</p><p>模 998244353</p><h2 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h2><p>n 2e5</p><p>k 65536</p><p>$a_i$ [1, 65536]</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h3><p>首先nim游戏作为博弈的常见基础, 很明显 就是 xor 和 != 0 时 T胜利</p><p>那么无非是求 所有 !=0 的方案数, 或者 是 == 0 的方案数, 去总方案减去 ==0的方案数</p><p>那么对于一个选择来说因为Ai两两不同, 偶数次被选的Ai 不影响xor,奇数次被选的Ai影响一次</p><p>问题变成了说</p><p>选x个Ai,让它们 xor = 0, 那么</p><p>对于长度x 贡献是 x!</p><p>对长度x+2 贡献是 ?? 还是x, 但是剩余两个是一样的, 这两个一样的如果属于x个值内注意不要重复统计,不属于x个数内,则穿插即可</p><h3 id="官方-1"><a href="#官方-1" class="headerlink" title="官方"></a>官方</h3><p>对于给定的数组长度M</p><p>$C=(C_0,C_1,…C_{2^{16}-1})$ 表示 下标的值 是否存在, 相当于选择了一次</p><p>定义xor的卷积 $Z_k = \sum_{i\oplus j=k} X_i Y_j$</p><p>那么$C$的M次卷积的结果$R$中的$R_0$, 就是期望值</p><hr><p>快速沃尔什-阿达玛转换(Fast Walsh Hadamard transform), 一种广义傅立叶变换</p><p>FWT/FWHT 是用于解决对下标进行位运算卷积问题的方法, 见下面我的博客链接</p><p>$C_{i} = \sum_{i=j \bigoplus k}A_{j} B_{k}$</p><hr><p>因为 xor 的卷积满足结合率, 所以可以考虑快速幂来算</p><p>注意到$C * C = ifwt(fwt(C)\odot fwt(C))$</p><p>而$C * C * C= ifwt(fwt(C * C) \odot fwt(C))$</p><p>$= ifwt(fwt(ifwt(fwt(C)\odot fwt(C))) \odot fwt(C))$</p><p>$= ifwt(fwt(C)\odot fwt(C) \odot fwt(C))$</p><p>即是 $C^n = ifwt(\left( fwt(C)_ i^n\right))$</p><p>所以 $C$的$n$次+/xor/or/and卷积等于 正变换每个位置的$n$次方后的逆变换, <strong>这个在dft(fft)/ntt/fwt 同理</strong></p><hr><p>令 $I = C^0 = (1,0,0,0,0,0,\cdots)$</p><p>答案 $R = C + C * C + \cdots + C^n$</p><p>$R * C = C^2 + C^3 + \cdots + C^{n+1}$</p><p>$R * (C-I) = C^{n+1} - C$</p><p>$fwt(R) \odot fwt(C-I) = fwt(C^{n+1} - C)$</p><p>$fwt(R) = fwt(C^{n+1} - C) \oslash fwt(C-I)$</p><p>$R = ifwt(fwt(C^{n+1} - C) \oslash fwt(C-I))$</p><p>注意到$fwt$ 实际是线性变换, 所以也有$fwt(a+b) = fwt(a) + fwt(b),fwt(a-b) = fwt(a) - fwt(b),$</p><p>$R = ifwt( (fwt(C^{n+1}) - fwt(C)) \oslash (fwt(C)-fwt(I)))$</p><p>注意到 $fwt(I) = (1,1,1,1,1,\cdots)$</p><p>$R = ifwt(\left(\frac{fwt(C)_ i^{n+1} - fwt(C)_ i}{fwt(C)_ i - 1}\right))$</p><hr><p>至此就很好写了</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc212/submissions/33545657" target="_blank" rel="noopener">https://atcoder.jp/contests/abc212/submissions/33545657</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // read// -------------- modint ---------------namespace MODINT{  const int _mod = 998244353;  class modint{    private:      ll _v;    public:      modint() :_v(0) {  }      modint(ll _a) {        _v = (_a &lt; 0)? _mod - ((-_a) % _mod) : (_a % _mod);      }      int val()const { return _v; }      modint operator+()const { return *this; }      modint operator-()const { return { _mod - _v }; }      modint operator+(const modint&amp; rhs) const { return modint(*this) += rhs; }      modint operator-(const modint&amp; rhs) const { return modint(*this) -= rhs; }      modint operator*(const modint&amp; rhs) const { return modint(*this) *= rhs; }      modint operator/(const modint&amp; rhs) const { return modint(*this) /= rhs; }      bool operator==(const modint&amp; rhs)const { return _v == rhs._v; }      bool operator!=(const modint&amp; rhs)const { return _v != rhs._v; }      bool operator&gt; (const modint&amp; rhs)const { return _v &gt;  rhs._v; }      bool operator&gt;=(const modint&amp; rhs)const { return _v &gt;= rhs._v; }      bool operator&lt;=(const modint&amp; rhs)const { return _v &lt;= rhs._v; }      bool operator&lt; (const modint&amp; rhs)const { return _v &lt;  rhs._v; }      modint&amp; operator+=(const modint&amp; rhs) {        (_v += rhs._v) %= _mod;        return *this;      }      modint&amp; operator-=(const modint&amp; rhs) {        (_v += _mod - rhs._v) %= _mod;        return *this;      }      modint&amp; operator*=(const modint&amp; rhs) {        _v = _v * rhs.val() % _mod;        return *this;      }      modint&amp; operator/=(const modint&amp; rhs) { // 费马小定理        _v = _v * rhs.inv().val() % _mod ;        return *this;      }      modint pow(ll pwr) const {        ll res(1);        ll _b(_v);        while (pwr) {          if (pwr &amp; 1) (res *= _b) %= _mod;          (_b *= _b) %= _mod;          pwr /= 2;        }        return res;      }      modint inv() const {        assert(_v != 0);        return pow(_mod - 2);      }  };};// -------------- modint ---------------// ---------- fwt ----------using MODINT::modint;namespace FWT{  void ForT(vector&lt;modint&gt; &amp;f,int flag = 1/* 1:正变换,-1:逆变换 */) {    int n = f.size();    for (int k = 1; k &lt; n; k *=2){      for (int i = 0; i &lt; n; i += 2*k){        for (int j = 0; j &lt; k; j++){          f[i+j+k] += f[i+j] * flag;        }      }    }  }  void IForT(vector&lt;modint&gt; &amp;f) {ForT(f, -1);}  vector&lt;modint&gt; or_convolution(vector&lt;modint&gt; &amp;v0, vector&lt;modint&gt; &amp;v1){    const int sz = v0.size();    ForT(v0);    ForT(v1);    vector&lt;modint&gt; v2(sz,0);    rep(i,0,sz) v2[i] = v0[i] * v1[i];    IForT(v2);    return v2;  }  void FandT(vector&lt;modint&gt; &amp;f, int flag = 1/* 1:正变换,-1:逆变换 */) {    int n = f.size();    for (int k = 1; k &lt; n; k *=2){      for (int i = 0; i &lt; n; i += 2*k){        for (int j = 0; j &lt; k; j++){          f[i+j] += f[i+j+k] * flag;        }      }    }  }  void IFandT(vector&lt;modint&gt; &amp;f) {FandT(f, -1);}  vector&lt;modint&gt; and_convolution(vector&lt;modint&gt; &amp;v0, vector&lt;modint&gt; &amp;v1){    const int sz = v0.size();    FandT(v0);    FandT(v1);    vector&lt;modint&gt; v2(sz,0);    rep(i,0,sz) v2[i] = v0[i] * v1[i];    IFandT(v2);    return v2;  }  modint inv2 = modint(2).inv();  void FWHT(vector&lt;modint&gt; &amp;f, modint flag = 1 /* 1: 正变换, 1/2: 逆变换*/) {    int n = f.size();    for (int k = 1; k &lt; n; k *=2){      for (int i = 0; i &lt; n; i += 2*k){        for (int j = 0; j &lt; k; j++){          auto U = f[i+j];          auto T = f[i+j+k];          f[i+j]   = U + T;          f[i+j+k] = U - T;          f[i+j] *= flag;          f[i+j+k] *= flag;        }      }    }  }  void IFWHT(vector&lt;modint&gt; &amp;f) {FWHT(f, inv2);}  void FxorT(vector&lt;modint&gt; &amp;f,int flag = 1) {FWHT(f, flag);}  void IFxorT(vector&lt;modint&gt; &amp;f) {IFWHT(f);}  vector&lt;modint&gt; xor_convolution(vector&lt;modint&gt; &amp;v0, vector&lt;modint&gt; &amp;v1){    const int sz = v0.size();    FxorT(v0);    FxorT(v1);    vector&lt;modint&gt; v2(sz,0);    rep(i,0,sz) v2[i] = v0[i] * v1[i];    IFxorT(v2);    return v2;  }};// ---------- fwt ----------const int SIZE = 1 &lt;&lt; 16; // 16;vector&lt;modint&gt; C(SIZE,0);int main(){  int n = read();  int k = read();  rep(i,0,k) { C[read()] = 1; }  auto ans = k == 1? n : ((modint(k).pow(n+1)- 1)/(k-1) - 1); // 总方案数  FWT::FWHT(C);  rep(i,0,SIZE) C[i] = (C[i] == 1) ? n : ((C[i].pow(n+1) - C[i])/(C[i] - 1)); // 等比数列求和  FWT::IFWHT(C);  printf(&quot;%d\n&quot;,(ans-C[0]).val());  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>G</p><p>没观察到选了一个原根以后 整个范围 都有幂次和值的一一映射</p><p>H(Ex)</p><p>首先这个C和这个卷积 就很神奇, 完全没有向这个方向的思路</p><p>学了一手FWT/FWHT</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://atcoder.jp/contests/abc212/editorial" target="_blank" rel="noopener">官方题解</a></p><p><a href="http://yexiaorain.github.io/Blog/2022-07-26-FWT/">FWHT/FWT</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;G(数学,数论,原根)H/Ex(沃尔什-阿达玛转换,FWT/FWHT)&lt;/p&gt;
&lt;h1 id=&quot;G-Power-Pair&quot;&gt;&lt;a href=&quot;#G-Power-Pair&quot; class=&quot;headerlink&quot; title=&quot;G - Power Pair&quot;&gt;&lt;/a&gt;G - P
      
    
    </summary>
    
      <category term="Atcoder" scheme="http://yexiaorain.github.io/Blog/categories/Atcoder/"/>
    
    
      <category term="数学" scheme="http://yexiaorain.github.io/Blog/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="数论" scheme="http://yexiaorain.github.io/Blog/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="原根" scheme="http://yexiaorain.github.io/Blog/tags/%E5%8E%9F%E6%A0%B9/"/>
    
      <category term="沃尔什-阿达玛转换" scheme="http://yexiaorain.github.io/Blog/tags/%E6%B2%83%E5%B0%94%E4%BB%80-%E9%98%BF%E8%BE%BE%E7%8E%9B%E8%BD%AC%E6%8D%A2/"/>
    
      <category term="FWT" scheme="http://yexiaorain.github.io/Blog/tags/FWT/"/>
    
      <category term="FWHT" scheme="http://yexiaorain.github.io/Blog/tags/FWHT/"/>
    
  </entry>
  
  <entry>
    <title>从FFT 到 NTT(快速数论变换)</title>
    <link href="http://yexiaorain.github.io/Blog/2022-07-24-NTT/"/>
    <id>http://yexiaorain.github.io/Blog/2022-07-24-NTT/</id>
    <published>2022-07-24T14:24:00.000Z</published>
    <updated>2022-07-30T19:50:12.118Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NTT"><a href="#NTT" class="headerlink" title="NTT"></a>NTT</h1><p>竟然Div2能出现NTT 虽然是在最后一题, 还是得学一学</p><h2 id="解决什么问题"><a href="#解决什么问题" class="headerlink" title="解决什么问题"></a>解决什么问题</h2><p>是多项式乘法带模数的情况计算卷积</p><p>并且没有fft中会涉及到double,</p><p>NTT 也就是关于任意 环(数学术语) 上的离散傅立叶变化(DFT), 有限域的情况下,通常成为数论变换</p><h2 id="离散傅立叶变换"><a href="#离散傅立叶变换" class="headerlink" title="离散傅立叶变换"></a>离散傅立叶变换</h2><p>回顾离散傅立叶变换, 就是</p><p>原函数(原向量) $\to$ DFT(离散傅立叶) $\to$ 点乘 $\to$ IDFT(逆傅立叶) $\to$ 结果函数(结果向量)</p><p>DFT:</p><p>$\hat{x}[k]=\sum_{n=0}^{N-1} e^{-i\frac{2\pi}{N}nk}x[n] \qquad k = 0,1,\ldots,N-1.$</p><p>IDFT:</p><p>$x\left[n\right]={1 \over N}\sum_{k=0}^{N-1} e^{ i\frac{2\pi}{N}nk}\hat{x}[k] \qquad n = 0,1,\ldots,N-1.$</p><p>有时系数可以是两个$\frac{1}{\sqrt{N}}$</p><p>矩阵表示的DFT, 是一个线性算子</p><p>${\displaystyle {\begin{bmatrix}f_{0}\\f_{1}\\\vdots \\f_{n-1}\end{bmatrix}}={\begin{bmatrix}1&amp;1&amp;1&amp;\cdots &amp;1\\1&amp;\alpha &amp;\alpha ^{2}&amp;\cdots &amp;\alpha ^{n-1}\\1&amp;\alpha ^{2}&amp;\alpha ^{4}&amp;\cdots &amp;\alpha ^{2(n-1)}\\\vdots &amp;\vdots &amp;\vdots &amp;&amp;\vdots \\1&amp;\alpha ^{n-1}&amp;\alpha ^{2(n-1)}&amp;\cdots &amp;\alpha ^{(n-1)(n-1)}\\\end{bmatrix}}{\begin{bmatrix}v_{0}\\v_{1}\\\vdots \\v_{n-1}\end{bmatrix}}.}$</p><h2 id="阶"><a href="#阶" class="headerlink" title="阶"></a>阶</h2><p>若 $gcd(a,p) = 1, p &gt; 1$</p><p>最小的$n &gt; 0$ 使得 $a^n \equiv 1 \pmod{p}$, 则$\delta_p(a) = n$ 称作$a$模$p$的阶</p><p>显然, 对于$i\in [0,\delta_p(a))$, $a^i \pmod p$ 两两不同</p><h2 id="原根"><a href="#原根" class="headerlink" title="原根"></a>原根</h2><p>$p &gt; 0, a$ 是整数, $\delta_p(a) = \varphi(a), gcd(p,a) = 1$, 则$a$为$p$的一个原根</p><p>其中$\varphi(n)$ 为欧拉函数, 表示$1$到$n$中与$n$互质的数的个数</p><p>若$gcd(a,p) = 1, p &gt; 0$ 则$a$为$p$的一个原根的充要条件 ${a^1,a^2,a^3,\cdots,a^{\varphi(p)}}$ 是p的简化剩余系</p><p>必要: $a$是$p$的原根, 根据阶中结论模n两两不同</p><p>充分: 因为是简化剩余系, 所以两两不同, 所以说明 $ &lt; \varphi(p)$ 的都不为1, 也说明$\delta_p(a) = \varphi(a)$</p><p>完全剩余系: n的完全剩余系, 在模n的剩余类中各取一个元素，则这n个数就构成了模n的一个完全剩余系。例如{0,1,2,3,…,n-1} 是n的一个完全剩余系</p><p>简化剩余系: 完全剩余系中 与n互质 构成的</p><h2 id="回到NTT"><a href="#回到NTT" class="headerlink" title="回到NTT"></a>回到NTT</h2><p>$p$为素数,$a$为$p$的一个原根, 有$\varphi(p) = p-1$</p><p>$n = 2^k, n | (p-1), k &gt; 0$</p><p>令 $g_n = a^{\frac{p-1}{n}}$</p><p>$g_n^n = (a^{\frac{p-1}{n}})^n = a^{p-1} = 1 \pmod p$</p><p>$g_n^{\frac{n}{2}} = a^{\frac{p-1}{2}} = -1 \pmod p$</p><p>$g_{tn}^{tk} = a^{\frac{tk(p-1)}{tn}}=a^{\frac{k(p-1)}{n}}=g_n^k$</p><p>这里想用 $g_n^k$ 来替代$w_n^k$ </p><p>(然后就直接可以替换了??? 不严格的语言证明是, 可以看成w为未知数, 那么$a * b = c$ 不过是变成了c = IFFT(FFT(a) FFT(b)) = a * b</p><p>也就是 最终的只和$w$的$n$和$\frac{n}{2}$有关,否则 会有复平面的偏移</p><p>所以$w_n^k = e^{- i \frac{2 \pi}{N} nk}$ 也好</p><p>所以$w_n^k = g_n^k \pmod p$ 也好, 只要满足了$n$和$\frac{n}{2}$次方的性质即可</p><hr><p>注意的是 $g_n^k \neq 1 \pmod p , k &lt; \varphi_p(g)$</p><p>例如</p><p>$p=998244353=7 \times 17 \times 2^{23}+1$</p><p>有$g_{2^{23}} = 3^{\frac{p-1}{2^{23}}}$</p><hr><p>据说$g$都挺小, 可以枚举$g$</p><hr><p>然后INTT, 和IFFT对应, IFFT 相当于乘上了$e^{i \frac{2 \pi}{N} nk} = \frac{1}{w_n^k}$</p><p>所以这里就是$g$的逆元,</p><h2 id="代码-模板"><a href="#代码-模板" class="headerlink" title="代码, 模板"></a>代码, 模板</h2><p><a href="https://github.com/CroMarmot/OICode/blob/master/functions/ntt998244353.cpp" target="_blank" rel="noopener">https://github.com/CroMarmot/OICode/blob/master/functions/ntt998244353.cpp</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (int i=a;i&lt;n;i++)const int MOD = 998244353; // 7*17*2^23 + 1const int MAXPWR = 22; // 随着MOD改变, 2的幂次, 对应复平面单位向量的N = 2 &amp;&amp; MAXPWR;const int g = 3;// 原根 随着MOD改变const int invg = 332748118;// 原根模逆元 随着MOD 和 g 改变// bit 翻转int rev(int x, int len) {  int ans = 0;  while(len -- ){    ans &lt;&lt;= 1;    ans |= x &amp; 1;    x &gt;&gt;= 1;  }  return ans;}inline int getlog2(int n){ return 31 - __builtin_clz(n);}ll mypow(ll a, ll k) { //快速幂，a**k  ll res = 1;  while (k) {    if (k &amp; 1) (res *= a) %= MOD;    (a *= a) %= MOD;    k &gt;&gt;= 1;  }  return res;}void NTT(vector&lt;ll&gt; &amp;A, int flag = 1 /* 1: NTT, -1: INTT*/ ) {  int n = A.size();  if(n == 1) return ;  // assert((n &amp; (n-1)) == 0); // 2 的幂次  int lgn = getlog2(n);  // assert(lgn &lt;= MAXPWR);  rep(i, 0, n) { // 同FFT    int j = rev(i, lgn);    if (j &gt; i) swap(A[i], A[j]);  }  rep(pwr,0,lgn){    int m = 1 &lt;&lt; pwr;    // assert((MOD - 1) % (m&lt;&lt;1) == 0);    ll gn = mypow(flag == 1 ? g : invg, (MOD - 1) / (m &lt;&lt; 1)); // 单位原根g_n    for (int k = 0; k &lt; n; k += (m&lt;&lt;1)) {      ll gi = 1;      rep(j,0,m) {        auto U = A[k + j];        auto T = gi * A[k + j + m] % MOD;        A[k + j] = (U + T) % MOD;        A[k + j + m] = (U - T + MOD) % MOD;        (gi *= gn) %= MOD;      }    }  }  if(flag == -1){ // 内置 / N    const ll INVSIZE = mypow(n, MOD-2);    rep(i,0,n) (A[i] *= INVSIZE) %= MOD;  }}void INTT(vector&lt;ll&gt; &amp;A){ NTT(A,-1);}int main(){  // 123*456 = 56088  const int SIZE = 8; // 一定要是2的幂次  auto a = vector&lt;ll&gt;{3,2,1,0,0,0,0,0};  auto b = vector&lt;ll&gt;{6,5,4,0,0,0,0,0};  // 计算  NTT(a);  NTT(b);  auto c = vector&lt;ll&gt;(SIZE,0);  rep(i,0,SIZE) c[i] = a[i] * b[i];  INTT(c);  // 输出  rep(i,0,SIZE) printf(&quot;(%lld)&quot;, c[i]);  printf(&quot;\n&quot;);  rep(i,0,SIZE-1) {// 进位    c[i+1] += c[i] / 10;    c[i] -= (c[i] / 10) * 10;  }  rep(i,0,SIZE) printf(&quot;(%lld)&quot;, c[i]);  printf(&quot;\n&quot;);  return 0;}</code></pre><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="http://yexiaorain.github.io/Blog/2019-01-02-fftmul/">我的FFT笔记</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;NTT&quot;&gt;&lt;a href=&quot;#NTT&quot; class=&quot;headerlink&quot; title=&quot;NTT&quot;&gt;&lt;/a&gt;NTT&lt;/h1&gt;&lt;p&gt;竟然Div2能出现NTT 虽然是在最后一题, 还是得学一学&lt;/p&gt;
&lt;h2 id=&quot;解决什么问题&quot;&gt;&lt;a href=&quot;#解决什么问题
      
    
    </summary>
    
      <category term="Codeforces" scheme="http://yexiaorain.github.io/Blog/categories/Codeforces/"/>
    
    
      <category term="fft" scheme="http://yexiaorain.github.io/Blog/tags/fft/"/>
    
      <category term="ntt" scheme="http://yexiaorain.github.io/Blog/tags/ntt/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 1709</title>
    <link href="http://yexiaorain.github.io/Blog/2022-07-23-CF1709/"/>
    <id>http://yexiaorain.github.io/Blog/2022-07-23-CF1709/</id>
    <published>2022-07-23T14:24:00.000Z</published>
    <updated>2022-07-30T19:50:12.118Z</updated>
    
    <content type="html"><![CDATA[<p>E(树,xor,贪心,树上启发式合并)F(dp,NTT,前缀和)</p><h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><p><a href="https://codeforces.com/contest/1709/problem/E" target="_blank" rel="noopener">https://codeforces.com/contest/1709/problem/E</a></p><p>给你个一个树, 每个点上有值, 修改尽量少的点为任意值</p><p>让任何简单路径的 xor都不为零</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>n 2e5</p><p>ai [1,2^30]</p><p>3s</p><p>256MB</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h3><p>显然啊, 类似树上差分的思想,  a…b xor = 0</p><p>意味着 a…root ^ root …b = 0</p><p>所以直接变成 计算每个数到根的xor</p><p>然后问题变成, 任意两个相同值之间的连线, 需要至少选一个点</p><p>或者说, 需要xor树最终两两不等 </p><p>不知道往后怎么搞</p><hr><p>一个思路是dp</p><p>但是 遇到同值点不是 祖先关系,而是分叉的关系 ,也不知打怎么记录</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>虽然的确有前缀意义,但其实 我想的总思路没问题, 但是细节有问题</p><p>并不是简单路径 = 到根的 路径 xor</p><p>因为它们的lca 被算了两次 </p><p>所以其实是 path[u]^path[v] = a[lca[u,v]]</p><hr><p>那么 对于一个点x  = lca(u,v) , 且 u..v 的xor = 0</p><p>那么 (x,y) 上至少有一点需要改变</p><p>然后 我们对所有的有这种情况的x 按深度从深到浅考虑</p><p>找深度最深的x, 那么修改 x的方案不会比修改 u…v 的更差</p><p>因为是最深的, 所以其它满足的链 如果经过它的子树 则必定经过它,因为它需要修改, 所以而至少一个, 而对于其它经过它的链来说是至多一个</p><hr><p>dfs(u){<br> 对于u的所有子树 dfs(v)</p><p> 每个点获取 从根到它的子节点 能得到的 xor 集合</p><p> 一旦有来自两个子树 中有值 xor == u 那么u就必然被选<br> 而被选的u对于它的父节点的返回是 空集合<br> 未被选的u对于它的父节点的返回是它所有子集合可达值 xor 它自身<br>}</p><hr><p>怎么看都是n^2 啊 , 为啥 O(nlog^2 n)</p><p>因为虽然dfs一次就可以把所有点到根的xor 算完</p><p>但是每次做 set 的合并时, 一个点就是会在它的 父节点 中被运算</p><p>那每个点被参与比较的次数可以达到 链的长度 不就是 n^2 吗</p><hr><p>然后神奇的是 这个启发式合并的复杂度不是n方</p><h3 id="启发式合并-DSU-on-Tree"><a href="#启发式合并-DSU-on-Tree" class="headerlink" title="启发式合并(DSU on Tree)"></a>启发式合并(DSU on Tree)</h3><p><a href="https://oi-wiki.org/graph/dsu-on-tree/#_3" target="_blank" rel="noopener">oi-wiki 树上启发式合并</a></p><p>重儿子, 儿子节点子节点个数最多的</p><p>重边, 当前点连向其中一个重儿子的边</p><p>轻边 非重边</p><hr><p>根到任意点 轻边不超过log n 条</p><p>反证法, 如果大于log n 条,</p><p>则最深的轻边的根至少还额外连了一个点大小为1的子树</p><p>第二深的轻边的根至少还额外连了一个点大小为3的子树</p><p>第三深的轻边的根至少还额外连了一个点大小为7的子树</p><p>…</p><p>第m深的轻边的根至少还额外连了一个点大小为2^m-1的子树</p><p>显然 m &gt; log n , 则 2^m - 1 &gt; n - 1 &gt;= n</p><p>性质得证</p><hr><p>那么每个节点 只有在它的某个祖先u的视角, 它是u的轻边的那一部分时, 才会作为被遍历的</p><p>所以每个节点的被遍历次数 = 它到根的 轻边数</p><p>所以 O(n log n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://codeforces.com/contest/1709/submission/165472602" target="_blank" rel="noopener">https://codeforces.com/contest/1709/submission/165472602</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readconst int N = 200000;int ans=0;int a[N+10]; // readint p[N+10]; // 当前每个节点对应st节点下标 pos[u]vector&lt;int&gt; e[N+10]; // edgeset&lt;int&gt; st[N+10]; // st[顶点] = {链到根的xor集合}void dfs(int u,int f, int x) {  int &amp;iu = p[u]; // 真的u  int bu = x^a[u]; // 从根下来的xor 链  st[iu].insert(bu);  bool delu = false; // delete u  for(auto v:e[u]) if(v != f){    dfs(v,u,bu);    int &amp;iv = p[v];    // 把小的向大的合并, 结果存在st[iu] 中    if(st[iu].size() &lt; st[iv].size()) swap(iu, iv);    for(auto val:st[iv]){      if(delu) break;      if(st[iu].count(val ^ a[u])) delu = true;    }    if(!delu) for(auto val:st[iv]) st[iu].insert(val);    st[iv] = {};  }  if(delu){    st[iu] = {};    ans++;  }}int main() {  int n = read();  rep(i,1,n+1) {    a[i] = read();    p[i] = i;  }  rep(i,1,n){    int u = read();    int v = read();    e[u].pb(v);    e[v].pb(u);  }  dfs(1,0,0);  printf(&quot;%d\n&quot;,ans);}</code></pre><h1 id="F"><a href="#F" class="headerlink" title="F"></a>F</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://codeforces.com/contest/1709/problem/F" target="_blank" rel="noopener">https://codeforces.com/contest/1709/problem/F</a></p><p>读入 n, k ,f</p><p>包含长度等于n的字符串 的可重集合 beautiful 定义为</p><p>对于长度 [1,n] 之间任意字符串s, c[s] &gt;= 集合中以s为前缀的字符串个数</p><p>任务 对于[1,n] 的所有字符串s, 你需要计算有多少 中映射c[s] 的选择方式</p><p>max(beautiful的集合的元素个数 )= f</p><p>其中 0 &lt;= c[s] &lt;= k</p><h3 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h3><p>n 15</p><p>k,f 2e5</p><p>6s</p><p>512ms</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h3><p>显然关于前缀</p><p>如果 s0 是 s1的前缀</p><p>那么显然 s0 出现的次数 &gt;= s1 出现的次数</p><p>那么 如果 c[s0] &lt;= c[s1] , c[s1] 就没什么作用</p><p>反过来, 如果 c[s0] &gt;= sum c[s0的所有下一级后缀], 那么c[s0] 也不是紧限制</p><p>因此 真正有效的内容是</p><p>c[s1] &lt;= c[s0] ,c[s0] &lt;= sum c[s0的所有下一级后缀], </p><hr><p>而这样约束以后, 方案数 就 = c[0] + c[1], 因为每个都表示<strong>能达到</strong>的最大个数</p><p>问题来了, 这样如何 算原始的c呢</p><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>转化一下题目</p><p>高度n的满二叉树</p><p>你需要对每个父子之间做最大流量限制,[0,k] 之间整数</p><p>让根源, 所有叶子汇, 的最大流恰好 = f</p><p>求方案数 % 998244353</p><hr><p>对于给定k</p><p>a(n,f) = 高度n, 最大恰好f的方案数</p><p>考虑状态转移</p><p>那么也就是 左边的n-1高度 最大流为v的时候,右边为f-v</p><p>但是这个 左边的最大流 可能是被根到左边这个边限制的, 也可能是本身n-1,v 的方案</p><p>定义 b(n,f) 等于 高度n 且根上多一个[0,k] 的限制的最大流 = k,方案数</p><p>如果是下面子树最大f, 那么对于根上可以选择 f~k, 所以有(k-f+1)a(n,f) 种</p><p>如果是下面子树最大 &gt; f, 那么对于根上仅可选择f, 所以有 $\sum_{i=f+1}^{2k} a(n,i) 种</p><p>综上$b(n,f) = (k-f+1)a(n,f) + \sum_{i=f+1}^{2k} a(n,i)$ , 前缀和每个状态 均摊O(1) 可算</p><p>那么对于a就是最开始的转移</p><p>$a(n,f) = \sum_{i=0}^f b(n-1,i)\cdot b(n-1,f-i)$, 卷积, 需要FFT或者NTT就可以搞</p><hr><p>那么答案 = $a(n,f)$, 也说明 $f &gt; 2k$ 无解</p><hr><p>最后边界处理, $b(n,f) = 0, f &gt; k$</p><hr><p>关于实现, 似乎直接NTT c++17会被卡, 可能要c++20</p><p>因为这里 相当于 是$a[n] = b[n-1]^2$, 所以平方可以少算一次NTT</p><p>然后 注意计算前把 末尾0删了, 不然可能长度倍增</p><p>以及我本地测 带了<code>-fsanitize</code>的编译, c++17/20 都4.5s, 而不带的都是1s</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p><a href="https://codeforces.com/contest/1709/submission/165613575" target="_blank" rel="noopener">https://codeforces.com/contest/1709/submission/165613575</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // read// ------------------------------- NTT --------------------------------namespace NTT998{  const int MOD = 998244353; // 7*17*2^23 + 1  const int MAXPWR = 22; // 随着MOD改变, 2的幂次, 对应复平面单位向量的N = 2 &amp;&amp; MAXPWR;  const int g = 3;// 原根 随着MOD改变  const int invg = 332748118;// 原根模逆元 随着MOD 和 g 改变  // bit 翻转  int rev(int x, int len) {    int ans = 0;    while(len -- ){      ans &lt;&lt;= 1;      ans |= x &amp; 1;      x &gt;&gt;= 1;    }    return ans;  }  inline int getlog2(int n){ return 31 - __builtin_clz(n);}  ll mypow(ll a, ll k) { //快速幂，a**k    ll res = 1;    while (k) {      if (k &amp; 1) (res *= a) %= MOD;      (a *= a) %= MOD;      k &gt;&gt;= 1;    }    return res;  }  void NTT(vector&lt;ll&gt; &amp;A, int flag = 1 /* 1: NTT, -1: INTT*/ ) {    int n = A.size();    if(n == 1) return ;    // assert((n &amp; (n-1)) == 0); // 2 的幂次    int lgn = getlog2(n);    // assert(lgn &lt;= MAXPWR);    rep(i, 0, n) { // 同FFT      int j = rev(i, lgn);      if (j &gt; i) swap(A[i], A[j]);    }    rep(pwr,0,lgn){      int m = 1 &lt;&lt; pwr;      // assert((MOD - 1) % (m&lt;&lt;1) == 0);      ll gn = mypow(flag == 1 ? g : invg, (MOD - 1) / (m &lt;&lt; 1)); // 单位原根g_n      for (int k = 0; k &lt; n; k += (m&lt;&lt;1)) {        ll gi = 1;        rep(j,0,m) {          auto U = A[k + j];          auto T = gi * A[k + j + m] % MOD;          A[k + j] = (U + T) % MOD;          A[k + j + m] = (U - T + MOD) % MOD;          (gi *= gn) %= MOD;        }      }    }    if(flag == -1){ // 内置 / N      const ll INVSIZE = mypow(n, MOD-2);      rep(i,0,n) (A[i] *= INVSIZE) %= MOD;    }  }  void INTT(vector&lt;ll&gt; &amp;A){ NTT(A,-1);}  // 平方 少一次 NTT  vector&lt;ll&gt; poly_sq(vector&lt;ll&gt; &amp;v0) {    int sz = v0.size() * 2;    if(sz == 0)return {};    sz = 1 &lt;&lt; (getlog2(sz) + !!(sz &amp; (sz-1))); // 非2的幂次    v0.resize(sz,0);    NTT(v0);    vector&lt;ll&gt; a2(sz,0);    rep(i,0,sz) a2[i] = v0[i] * v0[i] % MOD;    INTT(a2);    return a2;  }}// ------------------------------- NTT --------------------------------int n;vector&lt;ll&gt; a;vector&lt;ll&gt; b; // 滚动int main(){  const int MOD = NTT998::MOD;  int n = read(); // 15  int k = read(); // 2e5  int f = read(); // 2e5  if(f &gt; 2 * k){    printf(&quot;0\n&quot;);    return 0;  }  b = vector&lt;ll&gt;(k+1,1);  rep(i,1,n+1){    // a    a = NTT998::poly_sq(b); // 非平方也会TLE    if(a.size() &lt;= 2*k+1) a.resize(2*k+1,0);    vector&lt;ll&gt; prea(2*k+2, 0); // prefix sum of a    rep(j,0,2*k+1) prea[j+1] = (prea[j] + a[j]) % MOD;    b = vector&lt;ll&gt;(k+1,0);    rep(j,0,k+1) b[j] = (k-j+1) * a[j] % MOD + (prea[2*k+1] - prea[j+1]);    while(!b.empty() &amp;&amp; b.back() == 0) b.pop_back(); // 重要, 否则多出来的0 会导致 长度倍增 TLE  }  printf(&quot;%lld\n&quot;, a[f]);  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>E</p><p>一个是细节想错, lca多算一次 没想到</p><p>另一个是 考虑最深的lca的根 ,而不是考虑端点</p><p>这两点都是能想到没想到</p><p>然后关键的来了, 就是启发式合并的知识点, 这下学会了又</p><p>F</p><p>一个是变成树的 “流计算”, 很神奇 我好想 竖着觉得是树 ,横着就没发现了,</p><p>一个是学一下NTT, 以及NTT中的平方</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://codeforces.com/blog/entry/105164" target="_blank" rel="noopener">官方</a></p><p><a href="http://yexiaorain.github.io/Blog/2022-07-24-NTT/">NTT</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;E(树,xor,贪心,树上启发式合并)F(dp,NTT,前缀和)&lt;/p&gt;
&lt;h1 id=&quot;E&quot;&gt;&lt;a href=&quot;#E&quot; class=&quot;headerlink&quot; title=&quot;E&quot;&gt;&lt;/a&gt;E&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://codeforces.com/co
      
    
    </summary>
    
      <category term="Codeforces" scheme="http://yexiaorain.github.io/Blog/categories/Codeforces/"/>
    
    
      <category term="dp" scheme="http://yexiaorain.github.io/Blog/tags/dp/"/>
    
      <category term="贪心" scheme="http://yexiaorain.github.io/Blog/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="树" scheme="http://yexiaorain.github.io/Blog/tags/%E6%A0%91/"/>
    
      <category term="前缀和" scheme="http://yexiaorain.github.io/Blog/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
      <category term="xor" scheme="http://yexiaorain.github.io/Blog/tags/xor/"/>
    
      <category term="树上启发式合并" scheme="http://yexiaorain.github.io/Blog/tags/%E6%A0%91%E4%B8%8A%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/"/>
    
      <category term="NTT" scheme="http://yexiaorain.github.io/Blog/tags/NTT/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 1707</title>
    <link href="http://yexiaorain.github.io/Blog/2022-07-18-CF1707/"/>
    <id>http://yexiaorain.github.io/Blog/2022-07-18-CF1707/</id>
    <published>2022-07-18T14:24:00.000Z</published>
    <updated>2022-07-30T19:50:12.118Z</updated>
    
    <content type="html"><![CDATA[<p>C(最小生成树,LCA,树上差分)D(组合数,树上DP,DP,前缀和)E(数学,倍增)</p><h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><p><a href="https://codeforces.com/contest/1707/problem/C" target="_blank" rel="noopener">https://codeforces.com/contest/1707/problem/C</a></p><p>给你个n点,m边的连通图,边两两不等</p><p>有个错误的dfs算法, 每次找未选择的点中最短边进行dfs</p><p>问,从哪些点开始dfs,能得到正确的最小生成树</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>n 1e5</p><p>m [n-1,2e5]</p><p>2s</p><p>256MB</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>首先边两两不等,说明正确的最小生成树唯一</p><p>第二以一个点作为根, 按正确的最小生成树建树, 那么树边以外的其它边都是回边,没有跨边,则这个点做dfs合法</p><p>但这样每次枚举就是 O(n^2), TLE</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>先找到最小生成树</p><p>如果有连接 u v的非树边</p><p>那么 通过树边的简单路径 u—–v 通过树边的中间的点, 不可能, 且沿着树边扩展的点也不可能</p><hr><p>变成了树上染色问题</p><p>然后剩下就LCA,树上差分了</p><hr><p>LCA + 树上差分 思想就是</p><p>初始是对不可能的+1</p><p>然后因为批量+1 复杂度大</p><p>变成了记录每个数和它父节点的差(根节点表示自身的值), 就是树上差分了</p><p>那么对于 u,v 是非祖先关系, c[根]+=1,c[u]-=1,c[v]-=1</p><p>u和v是祖先关系, 假设u是v的祖先</p><p>c[u向v的子节点]+=1, c[v]-=1</p><p>最后还原差分成真实树即可, 判断 &gt; 0?</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://codeforces.com/contest/1707/submission/164711832" target="_blank" rel="noopener">https://codeforces.com/contest/1707/submission/164711832</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backconst int POWER = 20;const int N = 100000;const int M = 200000;ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readint n;int m;vector&lt;int&gt;p2[N+10]; // MSTpair&lt;int,int&gt; e[M+10]; // 边bool treee[M+10]; // tree edgeint f[N+10]; // 并查集int find(int v) {return f[v]==v?v:(f[v] = find(f[v]));}void link(int u,int v){ f[find(v)] = find(u);}ll x[N+10]; // 差分 和最终值int fa[N+10][POWER]; // 树上倍增int d[N+10]; // 深度// 一级父节点 和 深度void build(int u,int p = 1,int dep = 1){  fa[u][0] = p;  d[u] = dep;  for(auto v:p2[u]) if(v != p) build(v,u,dep+1);}// 还原差分void dfs(int u, int p = 1, int s = 0){  x[u] += s;  for(auto v:p2[u]) if(v != p) dfs(v,u,x[u]);}// 最近公共祖先int lca(int u,int v){  if(d[u] &lt; d[v])swap(u,v); // d[u] &gt; d[v]  per(i,0,POWER) if(d[u] - d[v] &gt;= (1 &lt;&lt; i)) u = fa[u][i];  if(u == v) return u;  per(i,0,POWER) {    if(fa[u][i] != fa[v][i]){      u = fa[u][i];      v = fa[v][i];    }  }  return fa[u][0];}// u 向上走d步int fa_d(int u,int d){  per(i,0,POWER) if(d &gt;= (1 &lt;&lt; i)) {    d -= (1&lt;&lt;i);    u = fa[u][i];  }  return u;}int main(){  // read  n = read();  m = read();  rep(i,0,m){    int u = read();    int v = read();    e[i] = {u,v};  }  // MST  iota(f+1,f+n+1,1);  rep(i,0,m){    auto [u,v] = e[i];    if(find(u) != find(v)) {      treee[i] = true;      link(u,v);      p2[u].pb(v);      p2[v].pb(u);    }  }  // 建立倍增  build(1); // 深度 和 1级父节点  rep(pwr,1,POWER) rep(i,1,n+1) fa[i][pwr] = fa[fa[i][pwr-1]][pwr-1];  // 树上差分  rep(i,0,m) if(!treee[i]){    auto [u,v] = e[i];    if(d[u] &gt; d[v]) swap(u,v); // d[u] &lt; d[v];    int r = lca(u,v);    if(u == r){      int w = fa_d(v, d[v] - d[u] - 1);      x[w]++;      x[v]--;    } else {      x[1]++;      x[u]--;      x[v]--;    }  }  // 差分还原成值  dfs(1);  // 输出答案  rep(i,1,n+1) printf(&quot;%d&quot;, (int)(x[i] == 0));  return 0;}</code></pre><h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><p><a href="https://codeforces.com/contest/1707/problem/D" target="_blank" rel="noopener">https://codeforces.com/contest/1707/problem/D</a></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>n 点 根为1树</p><p>初始 U = 1..n 点集合</p><p>一次操作, 取点集T, T 是U的部分虚树(T是U的真子集, 且T中任意两点的LCA也属于T), 令U=T</p><p>求 恰好k次操作后 集合只有根节点的操作路径有多少种</p><p>方案数 mod p </p><p>要求 k=1,2,…,n-1 所有的结果</p><h3 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h3><p>n 2000</p><p>p [1e8+7 ~ 1e9+9] 是 质数</p><p>2s</p><p>256mb</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h3><p>可能可以倒过来</p><p>初始只有根,每次增加至少一个点, 增加后要满足LCA的在集合中的关系, 一共k次</p><p>考虑一个叶子节点, 它可以任意时候被加入</p><p>一个非叶子只有一个分支的节点, 它也是任意时刻被加入</p><p>一个非叶子,多分支节点那么它加入的时机 需要 早于或等于 它的第二个被加入的子树</p><p>换句话说, 假设点i为多叉点,在t时刻被加入,那么 1..t-1 中至多只能存在点i 的其中一个子树中的点</p><p>f(t..k, all子树)</p><ul><li><p>f(1..k, 子树1, 至少一个在[1..t-1]) * f(t..k, all子树-子树1) + </p></li><li><p>f(1..k, 子树2, 至少一个在[1..t-1]) * f(t..k, all子树-子树2) + </p></li><li><p>…</p></li></ul><p>但似乎 注意到一个子树放在区间至于区间长度有关, 这样至少后面一半状态上是nk的</p><p>前面一节, 可以变成f(1..k,子树1) - f(t..k, 子树1) 这样剩下的至少一个不属于(t..k)</p><p>f(根u, 长度l) = for t = 1..l</p><p>转移还要n, 这样n^3, 而且还有k, 一眼TLE</p><p>考虑到本来状态就是 f(根u, 长度l) 也就是对于不同k可以复用, 那么问题来到了如何把转移优化到 log或者常数级别, 或者均摊常数级别</p><p>f(u,l) = f(v0, k - t + 1) * f(v1)</p><p>如果干掉这个t就好了</p><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>如果每次点数不严格下降结果为f,原答案为ans</p><p>有 $f_i=\sum_{j=0}^i\binom{i}{j}ans_j$, 因为j步意味着j+1个不同的集合, 要用这j+1个不同的集合按原顺序,可重复的产生i+1个集合, 那么其实就是选择每个开始的位置</p><p>既然是带系数前缀和,那也可以从 f反向推ans, 所以问题怎么球不严格下降的结果</p><hr><p>然后又是来到和我讨论类似的对删除时间的讨论</p><p>当一个节点u有分叉时</p><p>那么它的删除时间就会受到 子树的限制</p><ol><li><p>子树里所有节点 早于等于 u</p></li><li><p>u的某个子树以外的子树都删完了 早于等于 u, 早于剩下的子树最后一个节点</p></li></ol><p>状态 <code>dp[u][t]</code> , u以及它的子树,恰好第i次操作后删除完的方案数</p><hr><p>转移 $dp_{u,t}$</p><p>$C_u$ 是 $u$ 的子节点集合</p><p>前缀 $S_{u,t} = \sum_{i\le t} dp_{u,i}$</p><p>$u$子集前缀关于$t$的乘积 $M_{u,t} = \prod_{v \in C_u} S_{v,t}$</p><ol><li>$u$在$t$时刻删, 则 剩下的都在$[1,t]$时刻删</li></ol><p>$M_{u,t}$</p><ol start="2"><li>$u$在$t_0 &lt; t$ 时刻删, 因为要恰好, 则至少有个在$t$时刻删, 其它在$[1,t_0]$时刻删</li></ol><p>$ \sum_{v\in C_u} (dp_{v,t} \cdot \prod_{w \in C_u, w \neq v}^N S_{w,t_0})$</p><p>$ = \sum_{v\in C_u} (dp_{v,t} \cdot \frac{\prod_{w\in C_u} S_{w,t_0}}{S_{v,t_0}})$</p><p>$ = \sum_{v\in C_u} dp_{v,t} \cdot \frac{M_{u,t_0}}{S_{v,t_0}}$</p><p>对于所有$t_0 \in [1..t-1]$ 加和</p><p>$ = \sum_{t_0 = 1}^{t-1} (\sum_{v\in C_u} dp_{v,t} \cdot \frac{M_{u,t_0}}{S_{v,t_0}})$</p><p>$ = \sum_{v\in C_u} (dp_{v,t} \cdot (\sum_{t_0 = 1}^{t-1} \cdot \frac{M_{u,t_0}}{S_{v,t_0}}))$</p><hr><p>综上</p><p>$ dp_{u,t} = M_{u,t} + \sum_{v\in C_u} (dp_{v,t} \cdot (\sum_{t_0 = 1}^{t-1} \cdot \frac{M_{u,t_0}}{S_{v,t_0}}))$</p><p>每个$S_{u,t}$, 均摊只需要O(1), $S$总状态$O(n^2)$, 所以时间复杂度$O(n^2)$</p><p>然后每个$M_{u,t}$ 均摊需要$O(|C_u|)$, 对于所有$u$的$|C_u|$和为 节点数,所以时间复杂度也是$O(n^2)$</p><p>再看 $\sum_{t_0 = 1}^{t-1} \cdot \frac{M_{u,t_0}}{S_{v,t_0}}$</p><p>注意和$u,v,t$ 有关,但v只能是u的子节点集, 所以状态数为$O(|C_u|n)$, 总状态数依然是$O(n^2)$, 同样通过t的前缀和, 均摊$O(1)$, 所以总时间复杂度也是$O(n^2k)$</p><p>最后$dp_{u,t}$, 状态显然$O(n^2)$, 时间复杂度$O(|C_u|)$, 所以总时间复杂度$O(n^2)$;</p><p>可做……….</p><hr><p>咦,看起来和我的很像啊, 是不是我的那个t也可以干掉</p><p>可能不一定,别人通过恰好来简化了转移方便了前缀和实现</p><hr><p>最后的最后, 通过$ans_i = f_i - \sum_{j=0}^{i-1} \binom{i}{j} ans_j $反推即可</p><hr><p>实际写起来有几点坑,</p><ol><li><p>时间卡得紧, 不要频繁的用费马小定理 计算inv, TLE11</p></li><li><p>Wa31 第31个点 会出现S是MOD的倍数…..</p></li></ol><p>然后Wa31需要小学数学, 因为本身是乘法, 变成除法只是为了简化运算, 所以本身不会有除0, 但 变化后 加上mod 就可能除以0</p><p>注意到这里其实就是M和S之间,所以统计一下M中少乘一个零的结果, 当S=0时取那个结果即可</p><p>然后 因为量级很大, 不能去 大量做mod除法, 所以一个办法是记录 分子分母, 另一个办法是</p><p>M/S也变成前缀+后缀的形式来算, 当然前缀+后缀形式会常数更小</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>分数+除法 857ms 158MB</p><p><a href="https://codeforces.com/contest/1707/submission/164894672" target="_blank" rel="noopener">https://codeforces.com/contest/1707/submission/164894672</a></p><p>前后缀 + longlong 733ms 81MB</p><p><a href="https://codeforces.com/contest/1707/submission/164900140" target="_blank" rel="noopener">https://codeforces.com/contest/1707/submission/164900140</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backint MOD = -1;ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readll mpow(ll v,ll mi){ll r = 1;while(mi){if(mi%2)(r*=v)%=MOD;(v*=v)%=MOD;mi&gt;&gt;=1;};return r;} // quick power with MODint n;vector&lt;int&gt; e[2010];void dfs(int u,int fa){  vector&lt;int&gt; arr = {};  for(auto v: e[u]) if(v != fa) arr.pb(v);  e[u] = arr;  for(auto v: e[u]) dfs(v, u);}struct ModInt{  int v;  ModInt(ll val = 0) :v(val) { }};ll real(const ModInt &amp; v0){  return (v0.v + MOD) % MOD;}ModInt operator+(const ModInt &amp; v0, const ModInt &amp;v1){  return (v0.v + v1.v) % MOD;}ModInt operator-(const ModInt &amp; v0, const ModInt &amp;v1){  return (v0.v - v1.v) % MOD;}ModInt operator*(const ModInt &amp; v0, const ModInt &amp;v1){  return ((ll)v0.v * (ll)v1.v) % MOD;}ModInt dp[2010][2010];vector&lt;ModInt&gt; preMu[2010]; // 每次只会具体 u 可以复用vector&lt;ModInt&gt; sufMu[2010];ModInt S[2010][2010];ModInt W[2010][2010];ModInt fac[2010] = {1};ModInt invv[2010] = {1};ModInt invfac[2010] = {1};ModInt C(int n,int m) { return fac[n] * invfac[m] * invfac[n-m]; }ModInt ans[2010];int main(){  n = read();  MOD = read();  rep(i,1,n){    int u = read();    int v = read();    e[u].pb(v);    e[v].pb(u);  }  // 30 ms  rep(i,1,n+1) fac[i] = fac[i-1] * i;  invv[1] = 1;  rep(i,2,n+1) invv[i] = (MOD-MOD/i) * invv[MOD % i];  rep(i,1,n+1) invfac[i] = invfac[i-1] * invv[i];  dfs(1, 1);  // 61ms  // bfs on tree  vector&lt;int&gt; vorder = {1};  rep(i, 0, vorder.size()) {    int u = vorder[i];    for(auto v: e[u]) vorder.pb(v);  }  reverse(vorder.begin(), vorder.end());  for(auto u: vorder) {    rep(t,1,n) {      ModInt &amp;dput = dp[u][t] = 1; // 叶子      if(!e[u].empty()) {        // 优化成 前后缀        preMu[t] = vector&lt;ModInt&gt; (e[u].size() + 1, 1);        sufMu[t] = vector&lt;ModInt&gt; (e[u].size() + 1, 1);        rep(i,0,e[u].size()){          auto v = e[u][i];          preMu[t][i+1] = preMu[t][i] * S[v][t];        }        per(i,0,e[u].size()){          auto v = e[u][i];          sufMu[t][i] = sufMu[t][i+1] * S[v][t];        }        dput = preMu[t][e[u].size()];        if(t &gt; 1) rep(i,0,e[u].size()) {          auto v = e[u][i];          ModInt &amp;Wvt = W[v][t-1] = ((t-1 &gt; 1) ? W[v][t-2] : 0) + (preMu[t-1][i] * sufMu[t-1][i+1]);          dput = dput + dp[v][t] * Wvt;        }      }      S[u][t] = ((t &gt; 1) ? S[u][t-1] : 0) + dput;    }  }  rep(t,1,n) ans[t] = preMu[t][e[1].size()];  rep(t,1,n) rep(t0,1,t) ans[t] = ans[t] - ans[t0] * C(t,t0) ;  rep(t,1,n) printf(&quot;%lld &quot;, real(ans[t]));  return 0;}</code></pre><h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><p><a href="https://codeforces.com/contest/1707/problem/E" target="_blank" rel="noopener">https://codeforces.com/contest/1707/problem/E</a></p><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>长度n数组 a</p><p>$ai \in [1,n]$</p><p>f((l,r)) = (min(a[l..r]) , max(a[l..r])), 传入区间范围, 返回最小值和最大值</p><p>每次调用 (l,r) = f((l,r))</p><p>q个询问</p><p>每次问如果初始 li,ri, 需要反复调用 多少次 让l和r 最终变成(1,n) 或不可能</p><h3 id="范围-2"><a href="#范围-2" class="headerlink" title="范围"></a>范围</h3><p>q 1e5</p><p>n 1e5</p><h2 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路-2"><a href="#我的思路-2" class="headerlink" title="我的思路"></a>我的思路</h3><p>显然对于给定l,r 输出的f是一定的</p><p>所以对于所有的输入, 全部成环</p><p>那么f( (1,n) ) 一定要等于 (1,n), 否则 只有直接传入1,n 才会满足</p><p>想倒着找, 但是显然有最坏情况, 2 3 4 5 6, 这样一共有$O(n^2)$种不同输入和结果</p><h3 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h3><p>如果 区间A 包含于区间B</p><p>那么 f(A) 包含于 f(B)</p><p>证明, min(B) &lt;= min(A) &lt;= max(A) &lt;= max(B)</p><p>并且高阶f也有这个包含关系</p><hr><p>因此如果 [l,r] = ([l,r0] 并 [l0,r]), 其中 (l0 &lt;= r0) </p><p>那么 f(l,r) 包含 (f(l,r0) 并 f(l0,r)), </p><p>注意到 f(l,r0) 包含 f(l0,r0), f(l0,r) 也包含 f(l0,r0)</p><p>所以 f(l,r0) 和 f(l0,r) 本身就重叠, 所以 f(l,r0) 并 f(l0,r) = 连续的区间</p><p>那么 f(l,r) 的最小值 至少包含于 f(l,r0) 和 f(l0,r) 的其中一个, 最大值也是, 所以最小值最大值都存在,且连续, 包含于 f(l,r)</p><p>综上 f(l,r0) 并 f(l0,r) = f(l,r)</p><p>同样高阶也满足</p><p>例如2阶段, f(f(l,r)) = f(f(l,r0)) 并 f(f(l0,r)) , 思路同上, 包含于关系, 最小 最大值, 连续 推出相等</p><hr><p>注意到 一旦能到整个长度,那么一定 f(1,n) = (1,n)</p><p>如果链很长, 根据状态数 可能达到n^2</p><p>那么 办法就是倍增, 倍增到&gt; n^2 如果还不行那就真不行了</p><p>可以的话就二分倍增的倍数</p><p>为了效率, 用倍增记录每个位置开始的长度的 多少轮跳跃的结果</p><hr><p>然后实现上几点注意, 别二分, 每次二分会导致 长度不是幂次 依然需要log, 多层log过不了</p><p>找结果依然是倍增的找</p><p>然后就是cpu缓存和tlb机制, 注意循环顺序访问顺序和数组定义顺序</p><p>这导致常数影响非常明显, tle的代码和600+ms过的代码 就是把顺序换了换</p><hr><p>然后我看有人 长度开的2^18 也过了!!!, 不知道数学上是否有办法证明或者找反例</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><p><a href="https://codeforces.com/contest/1707/submission/164951002" target="_blank" rel="noopener">https://codeforces.com/contest/1707/submission/164951002</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readconst int N = 100000;const int PLEN = 19; // power length math.log(100000) / math.log(2) 16.609640474436812const int POP = 35; // power operation math.log(4999950000) / math.log(2) 32.219266521851075ll n;int L[POP][PLEN][N+10]; // 次数不用记录零次int R[POP][PLEN][N+10];int LG2[N+10]; // 0 和 1 都对应0次方, 需要减的 1&lt;&lt;LG2[r-l]的偏移量int a[N+10];inline pii f(int l,int r,int p1){  if(l == r) return {    L[p1][0][l],    R[p1][0][r]  };  int sz = LG2[r-l];  return {    min(L[p1][sz+1][l],L[p1][sz+1][r-(1&lt;&lt;sz)]),    max(R[p1][sz+1][l],R[p1][sz+1][r-(1&lt;&lt;sz)])  };}inline int query(int l,int r){  if(l == 1 &amp;&amp; r == n) return 0;  if(l == r) return -1;  // 不要二分, 二分是 log(n^2) = 2 log(n) * log(n)  // 直接binary 倍增做, log(r-l+1)*O(1) &lt; log(n)  ll ret = 0;  per(i, 0, POP){    // printf(&quot;%d = %d\n&quot;,r-l,p0);    int l0, r0;    tie(l0, r0) = f(l, r, i);    if(l0 != 1 || r0 != n){      // checklrk(l, r, 1ll &lt;&lt; i, l0, r0);      l = l0;      r = r0;      ret += (1ll &lt;&lt; i);      if(l == r) return -1;    }  }  tie(l,r) = f(l, r, 0);  return (l == 1 &amp;&amp; r == n) ? (ret + 1) : -1;}int main(){  n = read();  rep(i,2,N) LG2[i] = LG2[i/2] + 1;  int q = read();  rep(i,1,n+1) L[0][0][i] = R[0][0][i] = a[i] = read();  {    const int p1 = 0;    rep(p0,1,PLEN) rep(i,1,n+1) {      L[p1][p0][i] = min(L[p1][p0-1][i],L[p1][p0-1][min(n,i+(1ll &lt;&lt; max(0ll, p0-2)))]);      R[p1][p0][i] = max(R[p1][p0-1][i],R[p1][p0-1][min(n,i+(1ll &lt;&lt; max(0ll, p0-2)))]);      // check(i,p0,p1);    }  }  rep(p1, 1, POP) rep(p0, 0, PLEN) rep(i,1,n+1){    tie(        L[p1][p0][i] ,        R[p1][p0][i]       ) = f(         L[p1 - 1][p0][i],         R[p1 - 1][p0][i],         p1 - 1         );  }  while(q--){    int l = read();    int r = read();    printf(&quot;%d\n&quot;, query(l,r));  }  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>C</p><p>有想到, 环的最大边的 两点以外的点不可能,但是有反例, 就是没有把最小生成树 和 这个合在一起考虑</p><p>后面LCA和树上差分倒是没啥问题掌握了</p><p>D</p><p>感觉真有可能能做出来, 多习惯在dp时 分别恰好,和 小于等于 ,以及 前缀和方程与逆方程之间的联系</p><p>被小学数学教育了$a \neq \frac{a\cdot b}{b}$</p><p>然后就是 大量的inv还是不要, 一个办法就是 分数表示, 一个办法是想办法消除掉除法</p><p>E</p><p>数学推出性质以后 就是倍增倍增倍增了</p><p>实现上也有一些坑</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://codeforces.com/blog/entry/104930" target="_blank" rel="noopener">官方</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;C(最小生成树,LCA,树上差分)D(组合数,树上DP,DP,前缀和)E(数学,倍增)&lt;/p&gt;
&lt;h1 id=&quot;C&quot;&gt;&lt;a href=&quot;#C&quot; class=&quot;headerlink&quot; title=&quot;C&quot;&gt;&lt;/a&gt;C&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://codefo
      
    
    </summary>
    
      <category term="Codeforces" scheme="http://yexiaorain.github.io/Blog/categories/Codeforces/"/>
    
    
      <category term="LCA" scheme="http://yexiaorain.github.io/Blog/tags/LCA/"/>
    
      <category term="DP" scheme="http://yexiaorain.github.io/Blog/tags/DP/"/>
    
      <category term="前缀和" scheme="http://yexiaorain.github.io/Blog/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
      <category term="组合数" scheme="http://yexiaorain.github.io/Blog/tags/%E7%BB%84%E5%90%88%E6%95%B0/"/>
    
      <category term="树上差分" scheme="http://yexiaorain.github.io/Blog/tags/%E6%A0%91%E4%B8%8A%E5%B7%AE%E5%88%86/"/>
    
      <category term="数学" scheme="http://yexiaorain.github.io/Blog/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="倍增" scheme="http://yexiaorain.github.io/Blog/tags/%E5%80%8D%E5%A2%9E/"/>
    
      <category term="最小生成树" scheme="http://yexiaorain.github.io/Blog/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
      <category term="树上DP" scheme="http://yexiaorain.github.io/Blog/tags/%E6%A0%91%E4%B8%8ADP/"/>
    
  </entry>
  
  <entry>
    <title>Atcoder arc144</title>
    <link href="http://yexiaorain.github.io/Blog/2022-07-17-ac_arc144/"/>
    <id>http://yexiaorain.github.io/Blog/2022-07-17-ac_arc144/</id>
    <published>2022-07-16T20:25:14.000Z</published>
    <updated>2022-07-30T19:50:12.118Z</updated>
    
    <content type="html"><![CDATA[<p>D(数学,组合数),E(有向图,并查集,gcd,所有环,树回边)</p><h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://atcoder.jp/contests/arc144/tasks/arc144_d" target="_blank" rel="noopener">https://atcoder.jp/contests/arc144/tasks/arc144_d</a></p><p>有多少个映射f满足</p><p>定义域[0..2^n-1]</p><p>值域[0..k]</p><p>且值域内任意值x,y满足</p><p>f(x) + f(y) = f(x &amp; y) + f(x | y)</p><h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h3><p>n 3e5</p><p>k 1e18</p><p>2s</p><p>1024mb</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h3><p>f(…0) + f(1) = f(…1) + f(0)</p><p>f(…0.) + f(10) = f(…1.) + f(0)</p><p>因此 自由元素 f(0) f(1) f(2) f(4) …</p><p>把 f(0..2^{n-1}-1)看作整体, 那么 f(2^{n-1}..2^{n}-1) 可以看作它的平移</p><p>显然有</p><p><code>dp[i][min][max] = sum{dp[i-1][min][min..max]} + sum{dp[i-1][min..max][max]} - dp[i-1][min][max]</code></p><p>然而这 $O(nk^2)$ 显然时间空间都接受不了</p><p>不知道怎么化简</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>跟着上面思路 如果 f(0) = 0 , 那么 f(x) = 按二进制拆开x的 sum f(bit)</p><p>相当于 f(1) + f(2) + f(4) + f(8) … &lt;= k 插板组合数</p><p>如果f(0) != 0, 令 f(0) = V</p><p>那么令 g(x) = f(x) - V</p><p>那么g(x) 也满足条件,  -V &lt;= g(x) &lt;= K - V</p><p>0 &lt;= sum g(任意2幂)  + V &lt;= k</p><p>sum 正g(2幂) + V &lt;= k</p><p>sum 负g(2幂) + V &gt;= 0</p><hr><p>然后就是</p><p>枚举<code>f(0)</code> 的值V</p><p>枚举正数个数i, i个正的和 $\le k-V$, 因为小于等于 所以不妨把<code>k-V-和+1</code> 看作一个新的正数,相当于 i+1个正数 和 = k-V+1, 那就是k-V空隙插i个板子</p><p>枚举负数个数j,同理</p><p>$\sum_{V=0}^k \sum_{i=0}^n \sum_{j=0}^{n-i} \binom{n}{i} \binom{n-i}{j} \binom{k-V}{i} \binom{V}{j}$</p><p>$\sum_{i=0}^n \sum_{j=0}^{n-i} \binom{n}{i} \binom{n-i}{j} (\sum_{V=0}^k  \binom{k-V}{i} \binom{V}{j})$</p><p>$\sum_{i=0}^n \sum_{j=0}^{n-i} \binom{n}{i} \binom{n-i}{j} (\sum_{V=j}^{k-i}  \binom{k-V}{i} \binom{V}{j})$</p><p>右侧括号里,可以想成$k+1$个球, 选出$i+j+1$个球的组合方案数</p><p>我们去枚举被选的第$i+1$个球的位置$p$, $p \in [i+1,k+1-j]$</p><p>那么左侧有$p-1$个, 需要选出$i$个, 右侧有$k + 1 - p$个需要选出$j$个</p><p>令$V = k + 1 - p$即和现在表达式一致了</p><p>所以</p><p>$\sum_{i=0}^n \sum_{j=0}^{n-i} \binom{n}{i} \binom{n-i}{j} \binom{k+1}{i+j+1}$</p><p>$\sum_{i=0}^n \sum_{j=0}^{n-i} \binom{i+j}{i} \binom{n}{i+j} \binom{k+1}{i+j+1}$</p><p>$\sum_{i+j \le n} \binom{i+j}{i} \binom{n}{i+j} \binom{k+1}{i+j+1}$</p><p>二项式和</p><p>$\sum_{s = 0}^n 2^s \binom{n}{s} \binom{k+1}{s+1}$</p><p>就可以做了</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/arc144/submissions/33279666" target="_blank" rel="noopener">https://atcoder.jp/contests/arc144/submissions/33279666</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 998244353#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readll mul(ll a,ll b){  a %= MOD;  b %= MOD;  return a * b % MOD;}ll add(ll a,ll b){  a %= MOD;  b %= MOD;  return (a + b) % MOD;}ll normal(ll a){  return (a%MOD + MOD)%MOD;}ll mypow(ll v,ll pwr){  v%=MOD;  ll r = 1;  while(pwr){    if(pwr%2) (r*=v)%=MOD;    (v*=v)%=MOD;    pwr/=2;  }  return r;}ll fac[300010] = {1};ll binom(ll n,ll m){  if(m &gt; n) return 0;  return fac[n] * mypow(fac[m],MOD-2) % MOD * mypow(fac[n-m],MOD-2) % MOD;}int main(){  rep(i,1,300005) fac[i] = mul(fac[i-1],i);  int n = read();  ll k = read();  ll ans = 0;  ll binomk1s1 = 1; // k 很大  rep(s,0,n+1){    if(s &gt; k) break;    binomk1s1 = mul(binomk1s1,mul(k+1-s,mypow(s+1,MOD-2)));    ans = add(ans,mul(mul(mypow(2,s),binom(n,s)),binomk1s1) );  }  printf(&quot;%lld\n&quot;, normal(ans));  return 0;}</code></pre><h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>N点,M边有向图</p><p>有向边 都是从小节点指向大节点的(无自环,无重边)</p><p>输入一个初始W[1..N],其中如果是Wi=-1,就可以取任何值,否则按给定的来</p><p>点i 权重 Wi</p><p>求最大从1到N的所有路径的权重和的gcd</p><p>如果gcd可能无限大则输出-1</p><p>不需要输出W的方案</p><h3 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h3><p>N 3e5</p><p>M 3e5</p><p>至少存在一条路径</p><p>初始Wi [1…10e12]</p><p>2s</p><p>1024MB</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h3><p>首先 如果存在一条完全给定的 <code>1-&gt;N</code>的权重和则有限大,否则可能无限大(<code>A-&gt;B, B-&gt;C-&gt;D, B-&gt;D</code>, 其中<code>B</code>任意,而后面指定两条路径不等, 那么gcd也是有限大)</p><p>对于有限大, 因为有向边全是从小指向大, 所以不成环只有拓扑关系</p><p>在没有具体值的情况, 并不能对求和的表达式计算gcd</p><p>所以考虑有没有可能反过来</p><p>反过来指定gcd, 1个问题是并没有二分性质, 每条边的可能性是考虑mod gcd,也是gcd个, 量级也不会太小</p><p>对于直接有指定W路径的相对好一些, 其中gcd一定是它的约数,这样情况会少一些,但是Ai和M都很大,即使给定的路径W和也可以达到3e17</p><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>首先干掉 1不能到达, 和 不能到达N的点(无效的点), 防止无效的点影响找环的结果</p><p>如果k是答案,那么也就是所有路径 和 %k == 0</p><p>那么假设 到点u, <code>(1 -&gt; u)%k = p[u]</code> 是唯一的</p><p>那么所有直接相邻的 <code>vi-&gt;u</code>, 有 <code>p[vi] + w[u] = p[u] (mod k)</code></p><p>说明<code>p[vi]</code> 全部一样</p><p>这样, 就并查集了!</p><p>然后<code>p[n] = 0</code>, 所以可以加0号点 <code>W[0] = 0</code>, 路径<code>0-&gt;1</code></p><hr><p>有直接相邻<code>u-&gt;v</code>,且<code>w[v]</code>给定,</p><p>说明 两个并查集里的 的<code>union[u] + 3 = union[v]</code></p><hr><p>变成了 一些点, 和一些有权有向边</p><p>找所有环, 求gcd, 并不能找所有环,但是gcd性质上, 所有环gcd = 所有(树+回边) gcd</p><p>所以就可以搞了</p><p>环即可能由0产生, 也会有形如<code>A-&gt;B-&gt;C-&gt;D, A-&gt;D</code>, 这样产生</p><hr><p>无环 就任意都可以, -1</p><hr><p>然后有向图找环 我真不会写</p><p>学了一下apiad巨佬的代码, 发现是所有边建立正向和负向, 保证任何简单复杂路径 = 端点简单路径和即 全部像是无向图的有向图, 这样任何一个点可以作为根</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/arc144/submissions/33329393" target="_blank" rel="noopener">https://atcoder.jp/contests/arc144/submissions/33329393</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (int i=a;i&lt;(int)n;i++)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readll gcd(ll a,ll b){return b == 0?a:gcd(b,a%b);}const int N = 300000;int n,m;vector&lt;int&gt; u2v[N+10]; // 正向边vector&lt;int&gt; v2u[N+10]; // 反向边ll w[N+10];int invalid[N+10]; // 1 无效, 0 有效, -1 未访问int fa[N+10]; // 并查集// 并查集int getfa(int v){ return v == fa[v]?v:(fa[v] = getfa(fa[v]));}void link(int u,int v){ fa[getfa(u)] = getfa(v);}// 计算不可达bool dfs1n(int u){  int &amp;r = invalid[u];  if(r != -1) return r;  if(u == n) return r = 0;  r = 1;  for(auto v:u2v[u]) if(!dfs1n(v)) r = 0;  return r;}// 移除不合法vector&lt;int&gt; rminvalid(const vector&lt;int&gt; &amp;arr){  vector&lt;int&gt; ret = {};  for(auto u: arr) if(!invalid[u]) ret.pb(u);  return ret;}vector&lt;pair&lt;int,ll&gt; &gt; p2[N+10];int vis[N+10];ll dis[N+10]; // 和根的距离, root distancevoid dfs(int idx,ll d,ll &amp; ans) {  if(vis[idx]) {    // (环长 = 多树边 + 1回边), (重边), 多回边的环 gcd = 拆分的多个单回边环的gcd的gcd    ans = gcd(ans, abs(d - dis[idx]) );    return ;  }  vis[idx] = true;  dis[idx] = d;  for(auto [v,s]:p2[idx]) dfs(v, d + s, ans);}int main(){  n = read();  m = read();  iota(fa,fa+n+1,0); // fa[i] = i  fill(invalid+1,invalid+n+1,-1); // invalid[i] = -1  rep(i,1,m+1) { // u -&gt; v    int u = read();    int v = read();    u2v[u].push_back(v);    v2u[v].push_back(u);  }  rep(i,1,n+1) w[i] = read();  // 筛无效点  dfs1n(1);  rep(u,1,n+1) if(!invalid[u]) u2v[u] = rminvalid(u2v[u]);  rep(v,1,n+1) if(!invalid[v]) v2u[v] = rminvalid(v2u[v]);  // n -&gt; 1  u2v[n].pb(1);  v2u[1].pb(n);  // 找所有点的源点, 计算并查集  rep(v,1,n+1) if(!invalid[v]) rep(i,1,v2u[v].size()) link(v2u[v][i-1], v2u[v][i]);  // 根据给定w 建立新的图  rep(v,1,n+1) if(!invalid[v] &amp;&amp; w[v] != -1){    int tov = getfa(v); // 并查集中的点    int fromv = getfa(v2u[v][0]); // assert(v2u[tov].size()); 因为都可达所以每个点一定有前置点    // 全部双向边 辅助在有向图中找所有环的gcd    p2[fromv].pb({tov, w[v]}); // 正向    p2[tov].pb({fromv, -w[v]}); // 负向  }  // 找环  ll ans = 0;  rep(i,1,n+1) if(!invalid[i] &amp;&amp; !vis[i]) dfs(i,0,ans);  printf(&quot;%lld\n&quot;,ans == 0? -1: abs(ans));  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>D</p><p>这个对f(0) = 0特殊讨论 ,在 讨论f(0) 不为零的转化, 就是 一个特殊边界讨论 + 向特殊转移的问题</p><p>然后什么神奇的范德蒙恒等式(这里并不是, 但有一点思路相近的感觉</p><p>$\binom{n+m}{k} = \sum_{i=0}^k \binom{m}{i} \binom{n}{k-i}$</p><p>其实就是考虑$(1+x)^{m+n}$的$x^k$系数和 $(1+x)^m\cdot (1+x)^n$的$x^k$的系数</p><p>总之还有一些组合数的技巧,不是光有了初始表达式就可以的</p><p>E</p><p>讨论满足目标条件的 相邻转移</p><p>然后这个有向找所有环的gcd 也是学了一手, 改成正负双向</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://atcoder.jp/contests/arc144/editorial" target="_blank" rel="noopener">官方题解</a></p><p><a href="https://www.bilibili.com/video/BV1aB4y1a74j" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1aB4y1a74j</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;D(数学,组合数),E(有向图,并查集,gcd,所有环,树回边)&lt;/p&gt;
&lt;h1 id=&quot;D&quot;&gt;&lt;a href=&quot;#D&quot; class=&quot;headerlink&quot; title=&quot;D&quot;&gt;&lt;/a&gt;D&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;head
      
    
    </summary>
    
      <category term="Atcoder" scheme="http://yexiaorain.github.io/Blog/categories/Atcoder/"/>
    
    
      <category term="并查集" scheme="http://yexiaorain.github.io/Blog/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="gcd" scheme="http://yexiaorain.github.io/Blog/tags/gcd/"/>
    
      <category term="组合数" scheme="http://yexiaorain.github.io/Blog/tags/%E7%BB%84%E5%90%88%E6%95%B0/"/>
    
      <category term="数学" scheme="http://yexiaorain.github.io/Blog/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="有向图" scheme="http://yexiaorain.github.io/Blog/tags/%E6%9C%89%E5%90%91%E5%9B%BE/"/>
    
      <category term="所有环" scheme="http://yexiaorain.github.io/Blog/tags/%E6%89%80%E6%9C%89%E7%8E%AF/"/>
    
      <category term="树回边" scheme="http://yexiaorain.github.io/Blog/tags/%E6%A0%91%E5%9B%9E%E8%BE%B9/"/>
    
  </entry>
  
  <entry>
    <title>Atcoder abc259</title>
    <link href="http://yexiaorain.github.io/Blog/2022-07-11-ac_abc259/"/>
    <id>http://yexiaorain.github.io/Blog/2022-07-11-ac_abc259/</id>
    <published>2022-07-10T20:25:14.000Z</published>
    <updated>2022-07-30T19:50:12.118Z</updated>
    
    <content type="html"><![CDATA[<p>G(网络流)H/Ex(分块,讨论)</p><h1 id="G"><a href="#G" class="headerlink" title="G"></a>G</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://atcoder.jp/contests/abc259/tasks/abc259_g" target="_blank" rel="noopener">https://atcoder.jp/contests/abc259/tasks/abc259_g</a></p><p>HxW的数阵</p><p>选择任意的一些行和一些列, 让被选到的所有格子的和最大(同时被行和列选只统计一次)</p><p>且 限制条件,如果格子上的值为负那么 不能同时选它的行和列</p><h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h3><p>H,W [1,100]</p><p>Aij [-1e9,+1e9]</p><p>2s</p><p>1024mb</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h3><p>显然 纯非负的行和列一定被选,</p><p>所以可以预处理让剩下的所有行列至少包含一个负数</p><p>然后考虑说纯选行或选列</p><p>但是显然有反例</p><pre><code>  1     -1    100 -1      1 -10000100 -10000      1</code></pre><p>这种情况 最优的是选1行和1列</p><hr><p>然后另一个性质是, 显然 和为非正的行和列不会被选, 因为 如果即选了行又选了列,重叠部分非负 两个都选的和是 小于 两个分别的和的</p><p>然后没思路了</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>首先我们令 结果 = 全部正值 都被选了, 考虑变化对结果的影响</p><ol><li>如果一个正的没有被选, 那么它的行列没有直接被选, -Aij</li><li>如果一个负值被选了, 那么它的行和列有一个被选, Aij</li></ol><p>如果 Aij &lt; 0 被选了, </p><ul><li><p>如果是行被选, 那么 影响的是 加上 i行的所有负数</p></li><li><p>如果是列被选, 那么 影响的是 加上 j列的所有负数</p></li></ul><hr><p>于是改变题目</p><p>初始分 = 正数和</p><p>那么如果 选了i行, 则 损失 i行的所有负值的和</p><p>那么如果 选了j列, 则 损失 j列的所有负值的和</p><p>对于正的单元没被选的 损失上面值的代价</p><p>对于负的单元, 不恩那个同时选行和列</p><p>答案 = 正数和 减去 下面网络流的最小割</p><p>点:</p><p>R[1..H]</p><p>C[1..W]</p><p>源S,汇T</p><p>边:</p><p><code>S-&gt;R[i]</code>, 容量 行i的所有负值和的绝对值</p><p><code>C[j]-&gt;T</code>, 容量 行j的所有负值和的绝对值</p><p><code>R[i] -&gt; C[j]</code> 如果是 Aij &gt; 0, 则 权重 Aij</p><p><code>C[j] -&gt; R[i]</code> 如果是 Aij &lt; 0, 则 权重 无限大</p><p>这样考虑</p><p>对于 Aij &gt; 0</p><p><code>S-&gt;R[i]-&gt;C[j]-&gt;T</code> 在最小割中, 至少有一条边被割(说至少是因为, 可能 R和T一个集合,S和C一个集合)</p><p>对 Aij &lt; 0</p><p>也就是最小割一定不会同时割<code>S-&gt;R[i]</code>,和<code>C[j]-&gt;T</code>, 因为如果这样割了</p><p>意味着, <code>S,C[j]</code> 是一个集合,<code>R[i],T</code>是一个集合, 就有 <code>C[j] -&gt; R[i]</code> 的无限大, 就不会是最小割了</p><p>对于<code>Aij &lt; 0</code> 一定是 <code>S-&gt;R[i]</code> 或 <code>C[j]-&gt;T</code>, 表示</p><p>也就是对于Aij &lt; 0, 至多一个成为割边</p><hr><p>然后最小割 = 最大流 Dinic, 或者直接调用官方的maxflow</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc259/submissions/33171094" target="_blank" rel="noopener">https://atcoder.jp/contests/abc259/submissions/33171094</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;#include &lt;atcoder/maxflow&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readint n;int m;const int N = 100;const ll inf = 0x3f3f3f3f3f3f3f3f;int h, w; // 输入ll a[N+10][N+10]; // 输入ll rsum[N+10], csum[N+10]; // 行列负数绝对值和int main() {  h = read();  w = read();  rep(i,1,h+1){    rep(j,1,w+1) a[i][j] = read();  }  atcoder::mf_graph&lt;ll&gt; g(h+w+2); // 传入点数  int S = 0; // 源  int T = h+w+1; // 汇  ll ans = 0;  rep(i,1,h+1){    rep(j,1,w+1){      if(a[i][j] &gt;= 0){        ans += a[i][j];        g.add_edge(i, h+j, a[i][j]); // R[i] -&gt; C[j], a[i][j]      } else {        g.add_edge(h+j, i, inf); // C[j] -&gt; R[i], inf        rsum[i] += -a[i][j];        csum[j] += -a[i][j];      }    }  }  rep(i,1,h+1) g.add_edge(S, i, rsum[i]); // S -&gt; R[i], 行负数和的绝对值  rep(j,1,w+1) g.add_edge(h+j, T, csum[j]); // C[j] -&gt; T, 列负数和的绝对值  printf(&quot;%lld\n&quot;, ans - g.flow(S, T));  return 0;}</code></pre><h1 id="H-Ex"><a href="#H-Ex" class="headerlink" title="H/Ex"></a>H/Ex</h1><p><a href="https://atcoder.jp/contests/abc259/tasks/abc259_h" target="_blank" rel="noopener">https://atcoder.jp/contests/abc259/tasks/abc259_h</a></p><p>NxN的矩阵</p><p>每次向右或向下走</p><p>问有多少种路径,头和尾所在位置的数字相同</p><h2 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h2><p>n 400</p><p>aij [1,N^2]</p><p>2s</p><p>1024 MB</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h3><p>最朴素就是 对不同值分开处理,直接变成 每个值=&gt; 所有位置</p><p>然后 (i0,j0) =&gt; (i1,j1) 就是组合数</p><p>问题是, 如果一个一算,是(N^4)的样子会TLE</p><p>考虑是否有办法把结果变成统计合并</p><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>分块</p><p>更朴素的纯色+dp是, O(n^2)的</p><p>所以对于每个颜色根据个数来做不同处理</p><p>如果当前颜色点个数 &lt;= n</p><p>显然用我的思路里两两去算, 复杂度不超过O(个数^2),这一类的总复杂度小于O(sum{个数^2}) &lt;= O(sum{n <em> 个数})&lt;= O(n </em> sum{个数}) &lt;= O(n^3)</p><p>如果当前颜色个数 &gt; n , 那就直接dp,也不超过O(n^2), 而这种最多n种颜色最多O(n^3)</p><p>综上</p><p>都在n^3内</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>无</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>G</p><p>感觉 完全对网络流类型不熟,即使看了答案也仅是证明, 感觉没有系统的练习相关的建图, 还是不知道从何而起</p><p>这里相当于网络流求的是尽可能删除得小的, 利用了 最小割 = 最大流 , 这也是一个点,要求最小值的时候可以考虑让图能含义到最小割</p><p>然后就是atcoder内置的maxflow真香啊</p><p>Ex</p><p>有一说一感觉比G简单</p><p>这个分类的第一个复杂度上限推导还是很有意思,有点像之前树上左右部分平方的dp总复杂度是n3不是n4的感觉</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://atcoder.jp/contests/abc259/editorial" target="_blank" rel="noopener">官方题解</a></p><p><a href="https://www.bilibili.com/video/BV1KW4y1S7NA" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1KW4y1S7NA</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;G(网络流)H/Ex(分块,讨论)&lt;/p&gt;
&lt;h1 id=&quot;G&quot;&gt;&lt;a href=&quot;#G&quot; class=&quot;headerlink&quot; title=&quot;G&quot;&gt;&lt;/a&gt;G&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
      <category term="Atcoder" scheme="http://yexiaorain.github.io/Blog/categories/Atcoder/"/>
    
    
      <category term="网络流" scheme="http://yexiaorain.github.io/Blog/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
      <category term="分块" scheme="http://yexiaorain.github.io/Blog/tags/%E5%88%86%E5%9D%97/"/>
    
      <category term="讨论" scheme="http://yexiaorain.github.io/Blog/tags/%E8%AE%A8%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 1699</title>
    <link href="http://yexiaorain.github.io/Blog/2022-07-05-CF1699/"/>
    <id>http://yexiaorain.github.io/Blog/2022-07-05-CF1699/</id>
    <published>2022-07-05T14:24:00.000Z</published>
    <updated>2022-07-30T19:50:12.118Z</updated>
    
    <content type="html"><![CDATA[<p>D(dp)E(双指针,部分更新,1/2+1/3+1/4+…)</p><p>这次Div2的D,E都不会了</p><h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><p><a href="https://codeforces.com/contest/1699/problem/D" target="_blank" rel="noopener">https://codeforces.com/contest/1699/problem/D</a></p><p>长度n数组A</p><p>每次操作可以删除相邻且不同的两个值, 剩下的拼在一起, 多次操作</p><p>要让最终的数组值全部相同,求最大长度</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>n 5000</p><p>2s</p><p>256MB</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>如果我们指定哪个值留下来</p><p>假设是v</p><p>那么 考虑两个v之间的其它值 v …. v</p><p>如果其中有值x出现次数超过一半, 那么剩下的必然是x - 非x</p><p>否则,如果是奇数个剩下任意一个, 偶数个则全部清除</p><p>最后可以得到一个 v 非v v 非v v …</p><p>的多段结果</p><p>然后我并没有什么办法 处理这个</p><p>如果有办法就是n^2 的总复杂度了</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>首先如果一个数出现次数超过一半,那最终剩下的一定是它,所以这种情况不用猜留哪个</p><p>如果整个长度是偶, 且没有数出现次数超过一半,那么可以被完全删除</p><p>然后通过O(n^2) 计算所有区间 最多出现的数字,或者全部可消除</p><p>啊 我知道啊</p><hr><p>dp[i] 表示a[0…i]删除以后 结果包含a[i] 的最大长度</p><p>初始化 如果[0..i-1] 能完全删除 dp[i] = 1, 否则 dp[i] = -INF</p><p>如果<code>j &lt; i, a[i] == a[j]</code> 且 <code>[j+1..i-1]</code> 能完全删除</p><p><code>dp[i] = max(dp[j]+1)</code></p><p>所以最后就是求所有中的最大的且后缀可删除<code>rm[j..end] == true</code>, 相当于找结果的末尾位置</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://codeforces.com/contest/1699/submission/162852461" target="_blank" rel="noopener">https://codeforces.com/contest/1699/submission/162852461</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readint n;int a[5010];  // 5000 n^2bool rm[5010][5010]; // rm[i][j] = [i..j] 完全删除int dp[5010]; // 前[0..i] 删完剩下 a[i] 的个数const int INF = 0x3f3f3f3f;void w(){  n = read();  rep(i,0,n) a[i] = read();  rep(i,0,n){    fill(rm[i],rm[i]+n,false);    vector&lt;int&gt;cnt(n+1,0); // 次数统计    int maxc = -1; // 出现最多的    rep(j,i,n){      cnt[a[j]]++;      if(maxc == -1 || cnt[maxc] &lt; cnt[a[j]]) maxc = a[j];      if((j-i)%2 == 0)continue;      if(cnt[maxc] &lt;= (j-i+1)/2) rm[i][j] = true;    }  }  rep(i,0,n) dp[i] = (i == 0 || rm[0][i-1]) ? 1: -INF; // 初始化  int ans = 0;  rep(i,0,n){    rep(j,0,i){      if((i-j)%2==0)continue;      if(a[i] != a[j]) continue;      if(j == i-1 || rm[j+1][i-1]) dp[i] = max(dp[i], dp[j]+1);    }    if(i == n-1 || rm[i+1][n-1]) ans = max(ans,dp[i]); // 后续可删  }  printf(&quot;%d\n&quot;,ans);}int main(){  int t = read();  while(t--) w();  return 0;}</code></pre><h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><p>给你长度n数组a</p><p>每次你可以把任意一个值v=a乘b,拆成a,b,</p><p>求 min(max(数组) - min(数组))</p><h2 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h2><p>n 1e6</p><p>ai [1..5e6]</p><p>4s</p><p>256MB</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h3><p>直接想 有点像是说, 能否把每个数拆分进[l..r] 之间</p><p>变个方向就是 给定l,求最小的r</p><p>那么考虑l的变化</p><p>因为任意两个ai,aj的拆分方案互不影响, 考虑单个 v 拆成最小&gt;=l时,最大r的最小值的</p><p>显然l增大时,r 非严格单增, 且l &lt;= min(ai)的</p><p>而问题是让区间尽量小</p><p>区间长度并没有单调性或凹凸性, 想法方向GG</p><hr><p>第二个想法是</p><p>我直接拆每个数, 去计算每个数的<code>map[间隔] = vector&lt; pair&lt;最小,最大&gt; &gt;</code></p><p>比如 <code>4: [0] = { { 2 , 2 } , { 4 , 4 } }</code></p><p>但不知道怎么拆, dfs暴力?</p><p>以及拆分后怎么在不同ai之间组合</p><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>和我第一个想法类似但是倒着for最小的因子</p><p>因为不同v的拆法互不影响,考虑一个具体的原数组中出现过的 v</p><p>若当前最小因子恰好为i, 那么</p><p>如果 v不是i的倍数, 则,之前v怎么拆分就怎么拆分</p><p>如果 <code>v &lt; i^2</code>, 显然不能拆,如果拆了 另一个因子就会小于i</p><p><code>v &gt;= i^2</code> 且<code>v = ik</code> , 那么会拆成<code>i 和 k</code>, 而对于<code>k</code>可能也有拆的方案</p><p>我们直接记录<code>dp[k] =</code>当前拆分方案中, 最大的因子</p><p>有<code>dp[ik] = min(old dp[ik], dp[k])</code>, 其中<code>k &gt;= i</code></p><p>这里要注意的是当一个数<code>v=ik</code>是i的倍数,它按i拆开仅是可能让最大因子更小,而不是一定, 所以要和之前的<code>dp[v]</code> 比较</p><hr><p>而最大值, 显然是非严格单调递减, 我们只需要 统计每个值拆分后的最大因子(也是非严格单调递减)出现次数, 就能知道最大值</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p><a href="https://codeforces.com/contest/1699/submission/162860620" target="_blank" rel="noopener">https://codeforces.com/contest/1699/submission/162860620</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readconst int N = 5000000;bool appear[N+10]; // 在数列中出现过int mxval[N+10]; // [v] = v当前被拆分出来的更大的因子 , 运算过程中每个值的变化是非严格单调递减int cnt[N+10]; // 遍历过程中 每个ai拆分后对应最大因子 的 次数统计int n;int m;void w(){  // clear  fill(appear,appear+m+1,false);  fill(cnt,cnt+m+1,0);  fill(mxval,mxval+m+1,0);  n = read();  m = read();  int mn = m; // 最小  int mx = 0; // 最大  rep(i,0,n){    int x = read();    appear[x] = true;    cnt[x] = 1;    mn = min(mn, x);    mx = max(mx, x);  }  iota(mxval,mxval+mx+1,0); // mxval[i] = i; 默认都未被拆分  int ptr = mx; // 最大值  ll ans = mx - mn;  per(i,1,mx+1){    for (ll j = i * i; j &lt;= mx; j += i) { // j = i * (k&gt;=i) , j 拆分成 i 和 k, k可能继续能拆      // 移除原有拆分方案      if (appear[j]) cnt[mxval[j]]--; // 从真的统计上讲 应该是 [i]--, [mxval[j]]--, 但i &lt;= mxval[j] 所以 这里 中间一段不影响结果      // 计算新的最优方案      mxval[j] = min(mxval[j], mxval[j / i]); // i 不一定是最小的, 所以吆喝之前的比较      // 加入新的拆分方案      if (appear[j]) cnt[mxval[j]]++;    }    while (cnt[ptr] == 0) ptr--;    if (i &lt;= mn) ans = min(ans, ptr - i); // 最小值为i, 最大值为ptr  }  printf(&quot;%lld\n&quot;,ans);}int main() {  int t = read();  while (t--) w();}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>D</p><p>核心其实还是dpi可以和ai挂钩,因为其它什么区间可删除都想到了, 感觉应该还很常见的</p><p>E</p><p>倒着处理</p><p>只更新会影响的部分内容</p><p>因为遍历的i就是最小, 所以拆分统计, 不需要统计非最大因子以外的内容, 优化统计</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://codeforces.com/blog/entry/104088" target="_blank" rel="noopener">官方</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;D(dp)E(双指针,部分更新,1/2+1/3+1/4+…)&lt;/p&gt;
&lt;p&gt;这次Div2的D,E都不会了&lt;/p&gt;
&lt;h1 id=&quot;D&quot;&gt;&lt;a href=&quot;#D&quot; class=&quot;headerlink&quot; title=&quot;D&quot;&gt;&lt;/a&gt;D&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https
      
    
    </summary>
    
      <category term="Codeforces" scheme="http://yexiaorain.github.io/Blog/categories/Codeforces/"/>
    
    
      <category term="DP" scheme="http://yexiaorain.github.io/Blog/tags/DP/"/>
    
      <category term="双指针" scheme="http://yexiaorain.github.io/Blog/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="部分更新" scheme="http://yexiaorain.github.io/Blog/tags/%E9%83%A8%E5%88%86%E6%9B%B4%E6%96%B0/"/>
    
      <category term="1/2+1/3+1/4+..." scheme="http://yexiaorain.github.io/Blog/tags/1-2-1-3-1-4/"/>
    
  </entry>
  
  <entry>
    <title>Atcoder abc258</title>
    <link href="http://yexiaorain.github.io/Blog/2022-07-03-ac_abc258/"/>
    <id>http://yexiaorain.github.io/Blog/2022-07-03-ac_abc258/</id>
    <published>2022-07-02T20:25:14.000Z</published>
    <updated>2022-07-30T19:50:12.118Z</updated>
    
    <content type="html"><![CDATA[<p>F(暴力)G(bitset)H/Ex(dp,矩阵快速幂)</p><h1 id="F"><a href="#F" class="headerlink" title="F"></a>F</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://atcoder.jp/contests/abc258/tasks/abc258_f" target="_blank" rel="noopener">https://atcoder.jp/contests/abc258/tasks/abc258_f</a></p><p>网格,4临移动</p><p>如果 x=Bn的线上移动或者y=Bn的线上移动,(B的倍数), 单位距离代价1</p><p>其它情况单位距离代价k</p><p>求(sx,sy) -&gt; (gx,gy) 的最小代价</p><h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h3><p>t 2e5 测试点</p><p>b,k [1,1e9]</p><p>sx,sy,gx,gy [0,1e9]</p><p>3s</p><p>1024mb</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h3><p>显然是个数学处理一下, 就做的题</p><p>两个点分开考虑</p><p>一个点计算它本身, 四个方向到x=bn or y=bn , 的点,再到四个角的点</p><p>点类型 (普通0,边点1,十字交点2)</p><p>(0-任何) 直接距离乘k</p><p>(边点 - 边/十字) = 在方向上同bn, 则x1, 否则直接距离乘k</p><p>(十字-十字) = 距离x1</p><p>写了二十多分钟</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc258/submissions/32973579" target="_blank" rel="noopener">https://atcoder.jp/contests/abc258/submissions/32973579</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 1000000007#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readll b;ll k;const int T_NORMAL = 0; // 普通const int T_SIDE = 1; // 边const int T_CROSS = 2; // 角int calctype(ll i,ll j){  return (int)(i%b == 0) + (int)(j%b == 0);}vector&lt;array&lt;ll,3&gt; &gt; calc(ll i,ll j){  // i , j , dis  vector&lt;ll&gt; ai = {i};  vector&lt;ll&gt; aj = {j};  if(i%b) {    ai.pb((i/b)*b);    ai.pb((i/b+1)*b);  }  if(j%b) {    aj.pb((j/b)*b);    aj.pb((j/b+1)*b);  }  vector&lt;array&lt;ll,3&gt; &gt; res;  for(auto ni:ai){    for(auto nj:aj){      if(ni != i &amp;&amp; nj != j){        res.pb({ni,nj, (abs(ni-i) + abs(nj-j) - max(abs(ni-i), abs(nj-j)))*k + max(abs(ni-i), abs(nj-j)) });      }else{        if(i % b != 0 &amp;&amp; j%b != 0){          res.pb({ni,nj, (abs(ni-i) + abs(nj-j))*k});        }else{          res.pb({ni,nj, (abs(ni-i) + abs(nj-j))});        }      }    }  }  return res;}void w(){  b = read();  k = read();  ll si = read();  ll sj = read();  ll gi = read();  ll gj = read();  auto ijds = calc(si,sj);  auto ijdg = calc(gi,gj);  ll ans = 0x3f3f3f3f3f3f3f3f;  for(auto [i0,j0,d0]:ijds){    int t0 = calctype(i0,j0);    for(auto [i1,j1,d1]:ijdg){      int t1 = calctype(i1,j1);      if(t0 == T_NORMAL || t1 == T_NORMAL){        ans = min(ans,d0+d1+ (abs(i1-i0) + abs(j1-j0))*k);      }else if(t0 == T_SIDE || t1 == T_SIDE){        if(i0 == i1 &amp;&amp; i0 % b == 0){          ans = min(ans,d0+d1+abs(j1-j0));        }else if(j0 == j1 &amp;&amp; j0 % b == 0){          ans = min(ans,d0+d1+abs(i1-i0));        }else{          ans = min(ans,d0+d1+(abs(i1-i0)+abs(j1-j0))*k);        }      }else{ // == CROSS        ans = min(ans,d0+d1+abs(i1-i0)+abs(j1-j0));      }    }  }  printf(&quot;%lld\n&quot;,ans);}int main(){  int t = read();  while(t--) w();  return 0;}</code></pre><h1 id="H-Ex"><a href="#H-Ex" class="headerlink" title="H/Ex"></a>H/Ex</h1><p><a href="https://atcoder.jp/contests/abc258/tasks/abc258_h" target="_blank" rel="noopener">https://atcoder.jp/contests/abc258/tasks/abc258_h</a></p><p>序列X满足</p><ol><li>所有元素正奇数</li><li>和为s</li><li>X前缀和的值不在集合A中, 集合A大小为N</li></ol><p>求满足的要求的序列X的个数</p><h2 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h2><p>n 1e5</p><p>ai [1,1e18]</p><p>s [1,1e18]</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h3><p>果然读错题, 读成了需要序列X长度也是N</p><p>实际上对序列长度无要求</p><hr><p>不考虑X而是直接考虑X的前缀和</p><p><code>dp[v] =</code> 构成v的方案数</p><p><code>dp[Aj] = 0</code></p><p><code>dp[0] = 1</code></p><p>递推关系</p><p><code>dp[v] = sum{dp[v-1]+dp[v-3]+ dp[v-5]+...}</code></p><p>令<code>f[i] = dp[i] + dp[i-2] + dp[i-4]</code></p><p>有<code>dp[v] = f[v-1]</code> <code>f[v] = dp[v] + f[v-2] = (v in A ? 0 :f[v-1]) + f[v-2]</code></p><p>所以可以直接算f 矩阵快速幂</p><p>然后问题是要处理掉v 在 A中的情况, 并且注意到v在A中是<code>dp[v] == 0</code> 并不意味<code>f[v-1] == 0</code></p><pre><code>(f[v-1] f[v-2]) (f[v] f[v-1])                (1/0    1   )                ( 1     0   )</code></pre><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc258/submissions/32981204" target="_blank" rel="noopener">https://atcoder.jp/contests/abc258/submissions/32981204</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 998244353#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readint n;ll s ;ll a[100010];// Wi = (f[i]  f[i-1])// (f[v] f[v-1]) = (f[v-1] f[v-2]) *//                                (1/0    1   )//                                ( 1     0   )vector&lt;vector&lt;ll&gt; &gt; mul(vector&lt;vector&lt;ll&gt; &gt;m0,vector&lt;vector&lt;ll&gt; &gt;m1){  vector&lt;vector&lt;ll&gt; &gt; r = vector&lt;vector&lt;ll&gt; &gt;(m0.size(), vector&lt;ll&gt;(m1[0].size(),0));  assert(m0[0].size() == m1.size());  rep(i,0,m0.size()){    rep(j,0,m1[0].size()){      rep(k,0,m0[0].size()){        (r[i][j] += m0[i][k] * m1[k][j] % MOD) %= MOD;      }    }  }  return r;}vector&lt;vector&lt;ll&gt; &gt; mypow(vector&lt;vector&lt;ll&gt; &gt;m0,ll pwr){  vector&lt;vector&lt;ll&gt; &gt; r = {    {1,0},    {0,1}  };  while(pwr){    if(pwr%2) r = mul(r,m0);    m0 = mul(m0,m0);    pwr/=2;  }  return r;}int main(){  n = read();  s = read();  rep(i,0,n) a[i] = read();  a[n] = s; // dp[s] = f[s-1] =&gt;  w[s][1]  n++;  vector&lt;vector&lt;ll&gt; &gt; w; // w[iw] = {f[iw], f[iw-1]}  ll iw = 1;  if(a[0] == 1) w = { {0,1} };  else w = { {1,1} };  rep(i,0,n){    ll ai = a[i];    if(iw == ai)continue;    if(iw == ai-1){      w = mul(w,{          {0,1},          {1,0}          });      iw = ai;    }else{      w = mul(          mul(w,mypow({              {1,1},              {1,0}              }, ai-iw-1)),{          {0,1},          {1,0}          });      iw = ai;    }    // printf(&quot;w[%lld] = {%lld %lld}\n&quot;,iw, w[0][0],w[0][1]);  }  printf(&quot;%lld\n&quot;,w[0][1]);  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>F</p><p>没啥难的</p><p>G</p><p>内置 bitset 优化一下效率就行了</p><p>Ex</p><p>也没啥难的</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://atcoder.jp/contests/abc258/editorial" target="_blank" rel="noopener">官方题解</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;F(暴力)G(bitset)H/Ex(dp,矩阵快速幂)&lt;/p&gt;
&lt;h1 id=&quot;F&quot;&gt;&lt;a href=&quot;#F&quot; class=&quot;headerlink&quot; title=&quot;F&quot;&gt;&lt;/a&gt;F&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="Atcoder" scheme="http://yexiaorain.github.io/Blog/categories/Atcoder/"/>
    
    
      <category term="暴力" scheme="http://yexiaorain.github.io/Blog/tags/%E6%9A%B4%E5%8A%9B/"/>
    
      <category term="bitset" scheme="http://yexiaorain.github.io/Blog/tags/bitset/"/>
    
      <category term="矩阵快速幂" scheme="http://yexiaorain.github.io/Blog/tags/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 1698</title>
    <link href="http://yexiaorain.github.io/Blog/2022-07-02-CF1698/"/>
    <id>http://yexiaorain.github.io/Blog/2022-07-02-CF1698/</id>
    <published>2022-07-02T14:24:00.000Z</published>
    <updated>2022-07-30T19:50:12.118Z</updated>
    
    <content type="html"><![CDATA[<p>F(数学,数组,相邻无序对)G(GF(2),meet in middle,不懂证明)</p><h1 id="F"><a href="#F" class="headerlink" title="F"></a>F</h1><p><a href="https://codeforces.com/contest/1698/problem/F" target="_blank" rel="noopener">https://codeforces.com/contest/1698/problem/F</a></p><p>给长度n的数组A和B</p><p>每次可以选择A数组中值相等两个数,把它们中间的区间颠倒顺序</p><p>求$n^2$次数内的方案得到B</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>n 500</p><p>1s</p><p>256MB</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>没有思路</p><p>只知道首个和末个 有重复的数字的一定位置不会变,且它们两侧的也不会变</p><p>但如何记录翻转并不知道</p><p>可行的话, 首先每个值个数要一样</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>数组不变量</p><p>首先a1和an是不会变的</p><p>然后是相邻元素构成无序对不变, 因为 区间 v…v颠倒,那么 中间和v连接的依然和v连接</p><p>必要显然</p><p>充分性, 我们具体构造</p><p>假设 前缀 a[..i] 和 b[..i] 相同, a[i] = x</p><p>a[i+1] = y</p><p>b[i+1] = z</p><p>如果存在 <code>a[i..] = [x,y,...,z,x,...]</code> 那么直接翻转 做1次</p><p>如果 <code>a[i...] = [x,y,...,x,z,...]</code>, 如果 <code>x,z</code> 右侧还有<code>x</code> 则翻转2次</p><p>否则 <code>x,z</code> 的<code>x</code>是最后出现的<code>x</code>, 所以, x至少2个</p><p>如果x恰好2个, 且是连着 <code>a[i..]= [x,y,x,z,...]</code>, <code>b[i..] = [x,z,....y,x,y,...]</code> , 这样转b</p><p>否则<code>a[i..]</code> 中 x相邻至少3对相邻</p><p>那么根据上面的,只有最后的那一个x的右侧不能通过,x本身交换 完成, 而a和b的操作是对称的</p><p>所以 <code>3对</code>中 最多<code>2对</code>无法交换,所以总存在一个相邻,可以0~2次 完成换到<code>a[i..] = [x,?,...]</code></p><p>即只要满足,无序对的性质</p><p>那么<code>a[0..i]</code> 一致了 就有办法让<code>b[0..i]</code> 一致</p><hr><p>直接暴力找 <code>O(n^2)</code></p><p>注意到的是算法实际的次数是不超过4n的</p><p>而需要的是小于$n^2$的次数,所以考察 <code>n=[1..4]</code>的合法的数组的操作次数时候</p><p>n=1 0次</p><p>n=2 0次</p><p>n=3 0次</p><p>n=4 0次/1次</p><p>所以也满足次数要求</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><a href="https://codeforces.com/contest/1698/submission/162605498" target="_blank" rel="noopener">https://codeforces.com/contest/1698/submission/162605498</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;#define MOD 1000000007#define rep(i,a,n) for (int i=a;i&lt;(int)n;i++)#define per(i,a,n) for (int i=n;i--&gt;(int)a;)int read(){int r;scanf(&quot;%d&quot;,&amp;r);return r;} // readint n;int a[510];int b[510];// 翻转区间void rev(int *arr,int i,int j){  rep(k,i,j+1){    int rk = j-(k-i);    if(rk &lt; k)break;    swap(arr[k],arr[rk]);  }}// 找arr[sti...]中 找 [x,y,...,z,x,...], 翻转成[x,z...]bool op(int *arr,int sti,int z,vector&lt;pair&lt;int,int&gt;&gt; &amp; ans){  int x = arr[sti];  rep(i,sti+1,n){    // [x,y........z,x]    // [sti............i]    if(arr[i] == x &amp;&amp; arr[i-1] == z){      rev(arr, sti+1,i-1);      ans.push_back({sti+1,i+1});      return true;    }  }  return false;}// 找arr[sti...]中 找 [x,y,...,x,z,...,x,...], 翻转成[x,z...]bool oprev(int *arr,int sti,int z,vector&lt;pair&lt;int,int&gt;&gt; &amp; ans){  int x = arr[sti];  rep(i,sti+1,n){    // [x,y........x,z,.....x]    // [sti..........i      j]    if(arr[i] == z &amp;&amp; arr[i-1] == x){      rep(j,i+1,n){        if(arr[j] == x){          rev(arr, sti+1,j-1);          ans.push_back({sti+1,j+1});          return op(arr,sti,z,ans);        }      }      return false;    }  }  return false;}void w(){  n = read();  rep(i,0,n) a[i] = read();  rep(i,0,n) b[i] = read();  if(a[0] != b[0]) {    printf(&quot;NO\n&quot;);    return ;  }  if(a[n-1] != b[n-1]){    printf(&quot;NO\n&quot;);    return ;  }  vector&lt;pair&lt;int,int&gt;&gt; pa;  rep(i,1,n){    int u = a[i-1];    int v = a[i];    if(u &gt; v) swap(u,v);    pa.push_back({u,v});  }  vector&lt;pair&lt;int,int&gt;&gt; pb;  rep(i,1,n){    int u = b[i-1];    int v = b[i];    if(u &gt; v) swap(u,v);    pb.push_back({u,v});  }  sort(pa.begin(),pa.end());  sort(pb.begin(),pb.end());  if(pa != pb){    printf(&quot;NO\n&quot;);    return ;  }  printf(&quot;YES\n&quot;);  // 一定可以  // -------------  vector&lt; pair&lt;int,int&gt; &gt;ans; // 正向  vector&lt; pair&lt;int,int&gt; &gt;revans; // 反向  rep(i,0,n){    if(a[i] != b[i]){      int x = a[i-1];      //      if(op(   a,i-1,b[i],ans))continue;      if(oprev(a,i-1,b[i],ans))continue;      if(op(   b,i-1,a[i],revans))continue;      if(oprev(b,i-1,a[i],revans))continue;      int w = -1; // 找既不等于 b[i] 也不等于a[i]的 x相邻的, 至少存在一个      rep(j,i+1,n){        if(a[j] == x){          if(a[j-1] != a[i] &amp;&amp; a[j-1] != b[i]){            w = a[j-1];          }else if(a[j+1] != a[i] &amp;&amp; a[j+1] != b[i]){            w = a[j+1];          }          assert(w!=-1);          break;        }      }      assert(w!=-1);      if(!op(a,i-1,w,ans)){        assert(oprev(a,i-1,w,ans));      }      if(!op(b,i-1,w,revans)){        assert(oprev(b,i-1,w,revans));      }    }  }  per(i,0,revans.size()) ans.push_back(revans[i]);  printf(&quot;%d\n&quot;,(int)ans.size());  for(auto [u,v]:ans){    printf(&quot;%d %d\n&quot;,u,v);  }}int main(){  int t = read();  while(t--) w();  return 0;}</code></pre><h1 id="G"><a href="#G" class="headerlink" title="G"></a>G</h1><p>S 是长度n的0/1串</p><p>让S与任意个S的任意正位移 做xor</p><p>求 结果中1的个数恰好2个,且字符串表示下字典序最大的串中, 这两个1的位置</p><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>n 35</p><p>2s</p><p>256MB</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h3><p>显然 第一次取S</p><p>然后把首个1以后的内容 的 首个1与S的首个1对齐 做xor, 直到后续剩余的只有1个1</p><p>这样的话,S的首个1和末个1各贡献一次, 位置就可以算了</p><p>为了简化运算,可以预处理掉S的前后缀0记录下来</p><hr><p>然而n有35, 虽然无法估计精确复杂度,但这样做上限是2的35次方会超时,写出来也果然tle 6 了</p><h3 id="官方"><a href="#官方" class="headerlink" title="官方"></a>官方</h3><p>多项式问题</p><p>首先 忽略S前后缀0, 这些零在最后的结果中会加回来</p><p>那么把S看作在GF(2)域中多项式P(x)</p><p>Galois Field, 只有0,1二元及+（异或运算）×（与运算）</p><p>那么要求的是$P(x)Q(x) = x^k+1$ 的最小k</p><p>P(x)的常数项是1, Q是任意的, 所以一定存在</p><p>证明, 显然 $x^k$ 随着k增大$x^k \mod P(x)$ 成周期,且始终不为0, 那么周期的就是一个$x^k \mod P(x) = 1$的解</p><p>所以$k \le 2^{35}$ 依然很大</p><p>要用的方法是meet in middle?</p><hr><p>emmmmm 就是直接除 然后meet in middle?</p><p>我没懂 这个prod 为何一定是 mod 为1, 以及GF(2)域上的相关性质</p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_back#define all(x) (x).begin(), (x).end()int n;char s0[100];ll mod;// (i*j)%mod in GF(2)ll mul(ll i, ll j) {  ll res = 0;  rep(x, 0, n-1) {    if (i &amp; (1LL &lt;&lt; x)) res ^= j;    j &lt;&lt;= 1;    if (j &amp; (1LL &lt;&lt; (n - 1))) j ^= mod; // 取mod in GF(2)  }  return res;}// (2**i)%mod in GF(2)ll pow2(ll pwr) {  ll res = 1; // result  ll b = 2; // base  while (pwr) { // pwr    if (pwr &amp; 1) res = mul(res, b);    b = mul(b, b);    pwr &gt;&gt;= 1;  }  return res;}// v的二进制最高位1在2的多少幂次, high1(3) = 1int high1(ll v){  int leadz = __builtin_clzll(v); // x 前缀0个数  return 63 - leadz;}int main() {  char *s = s0;  scanf(&quot;%s&quot;,s);  n = strlen(s);  vector&lt;int&gt; pos; // 只用来判断 &lt;= 2的1  rep(i,0,n){    if (s[i] == &#39;1&#39;) pos.push_back(i+1);  }  per(i,0,n) { // remove trailing zero    if(s[i] != &#39;0&#39;) break;    s[i] = 0;  }  rep(i,0,n) { // remove prefix zero    if(s[0] != &#39;0&#39;) break;    s++;  }  int offset = s - s0; // 前导0  n = strlen(s);  if (pos.size() == 0) { // all zero    printf(&quot;-1\n&quot;);    return 0;  }  if (pos.size() == 1) { // only 1 of 1    printf(&quot;%d %d\n&quot;,pos[0],pos[0]+1);    return 0;  }  if (pos.size() == 2) { // 恰好2个    printf(&quot;%d %d\n&quot;,pos[0],pos[1]);    return 0;  }  rep(i, 0, n) { // 正向和逆向结果一样的    if (s[i] == &#39;1&#39;) mod |= (1LL &lt;&lt; i); // s.trim().tobinary()  }  printf(&quot;s: %lld\n&quot;,mod);  int h = (n + 1) / 2; // 半长  ll val = mod;  ll prod = 1; // (2**h(x)-1)(2**h(x))**(pwr-1)  rep(x, 3LL, 1 &lt;&lt; h) { // GF(2)乘法还满足结合率    if (!(x &amp; 1)) continue; // x 末位是1    int pwr = 0; // val = x^pwr * ... 相当于 计算GF(2) 中 val的因子和幂次    while (true) {      ll curr = val;      ll other = 0;      rep(bit, 0, n) {        if (!(curr &amp; (1LL &lt;&lt; bit))) continue;        curr ^= x &lt;&lt; bit;        other ^= 1LL &lt;&lt; bit;      }      if (curr)  break;      // val = x * other in GF(2)      printf(&quot;%lld = %lld * %lld\n&quot;, val, x, other);      val = other;      pwr++;    }    if (pwr) { // x的pwr次方      printf(&quot;=&gt; %lld ** %d\n&quot;,x,pwr);      printf(&quot;high1[%lld] =  %d\n&quot;,x,high1(x));      // prod *= (10-1) * 10 * 10 ,        3**3      prod *= (1LL &lt;&lt; high1(x)) - 1;      rep(y, 1, pwr) prod *= 1LL &lt;&lt; high1(x);    }  }  // val 的 一次方  if (val &gt; 1) prod *= (1LL &lt;&lt; high1(val)) - 1;  // mod =&gt; GF(2) =&gt; 基的幂次 乘积 =&gt; (2的幂次)的幂次和2的(幂次-1) 的 积  ll ans = 1LL &lt;&lt; 60;  // printf(&quot;prod:%lld\n&quot;,prod);  assert(pow2(prod) == 1); // 2**prod ???????????????????????????????????????????  for (ll x = 1; x * x &lt;= prod; x++) { // 长度一定是prod的因子 ????????????????????????????????    if (prod % x ) continue;    if (pow2(x) == 1) ans = min(ans, x);    if (pow2(prod / x) == 1) ans = min(ans, prod / x);  }  printf(&quot;%d %lld\n&quot;,offset+1,offset+ans+1);}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>F</p><p>这个交换性质 厉害了,之前并不了解,也没有自己推出</p><p>相等的位置的交换,必定让相邻无序对是不变的,而且是充要条件</p><p>还是不变量的思考</p><p>G</p><p>GF(2) 真的没有系统学过</p><p>通过这个题看起来 乘法还 满足 结合率</p><p>加减也是对称的 A+B= C, A-B=C</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://codeforces.com/blog/entry/104310" target="_blank" rel="noopener">官方</a></p><p><a href="https://www.luogu.com.cn/paste/1z5pai9x" target="_blank" rel="noopener">洛谷 GF(2)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;F(数学,数组,相邻无序对)G(GF(2),meet in middle,不懂证明)&lt;/p&gt;
&lt;h1 id=&quot;F&quot;&gt;&lt;a href=&quot;#F&quot; class=&quot;headerlink&quot; title=&quot;F&quot;&gt;&lt;/a&gt;F&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://codefor
      
    
    </summary>
    
      <category term="Codeforces" scheme="http://yexiaorain.github.io/Blog/categories/Codeforces/"/>
    
    
      <category term="数学" scheme="http://yexiaorain.github.io/Blog/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="数组" scheme="http://yexiaorain.github.io/Blog/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="相邻无序对" scheme="http://yexiaorain.github.io/Blog/tags/%E7%9B%B8%E9%82%BB%E6%97%A0%E5%BA%8F%E5%AF%B9/"/>
    
      <category term="GF(2)" scheme="http://yexiaorain.github.io/Blog/tags/GF-2/"/>
    
      <category term="meet in middle" scheme="http://yexiaorain.github.io/Blog/tags/meet-in-middle/"/>
    
      <category term="不懂证明" scheme="http://yexiaorain.github.io/Blog/tags/%E4%B8%8D%E6%87%82%E8%AF%81%E6%98%8E/"/>
    
  </entry>
  
  <entry>
    <title>Atcoder arc143</title>
    <link href="http://yexiaorain.github.io/Blog/2022-06-27-ac_arc143/"/>
    <id>http://yexiaorain.github.io/Blog/2022-06-27-ac_arc143/</id>
    <published>2022-06-26T20:25:14.000Z</published>
    <updated>2022-07-30T19:50:12.114Z</updated>
    
    <content type="html"><![CDATA[<p>D(dfs,无向图无桥联通块,强连通分量)</p><p>哎 超时8min过了E,但这个D我还是不会</p><h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><p>评分2229</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://atcoder.jp/contests/arc143/tasks/arc143_d" target="_blank" rel="noopener">https://atcoder.jp/contests/arc143/tasks/arc143_d</a></p><p>左边1-n的点</p><p>右边1-n的点</p><p>左i-右i有边</p><p>给你m对数 (ai,bi), 你需要输出长度为m的0/1字符串</p><p>如果你要(左ai-右bi) 则第i个字符为0, 如果你要(左bi-右ai)则第i个字符是1</p><p>最终让图里的桥最少, 求一个字符串方案</p><h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h3><p>n 2e5</p><p>m 2e5</p><p>2s</p><p>1024mb</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h3><p>只想着贪心</p><p>首先如果一个边在任意环里那它就不是桥, 所以希望能贪心尽量让边进入环</p><p>统计给的m对数中, 每个值出现的次数</p><p>对于只出现一次的无药可救,先不管它</p><p>对于出现2次的,那就安排让它左右各连出一个</p><p>如果运算过程中某个点一侧被连了,另一侧没有连,还有关于这个点的数对,那么就去连另一测</p><p>已经两侧都连了的就不管</p><hr><p>但就写的来看似乎有问题, 还蛮多人过了这个题</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><blockquote><p>一句话 把它当成一个未定向的有向图， 然后在图上找环， 并定向即可</p></blockquote><p>首先考虑一个n个点, m边的无向图, 按照ai-bi的连接</p><p>如果有边在无向图中也是桥, 那么在题目问题中它只能是桥</p><p>对于无向图来说,移除了所有桥以后, 每个连通块可以单独独立处理</p><p>所以假设 拿到一个无向连通 无桥图</p><p>总有办法给所有边一个方向,让连通图变成强联通图</p><p>一个办法就是 直接做dfs树</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/arc143/submissions/32806181" target="_blank" rel="noopener">https://atcoder.jp/contests/arc143/submissions/32806181</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define pb push_backint read(){int r;scanf(&quot;%intd&quot;,&amp;r);return r;} // readint n;int m;char s[200010]; // answerpair&lt;int,int&gt; ab[200010];vector&lt;array&lt;int,3&gt;&gt; u2[200010]; // {v, ab idx, &#39;0&#39;,&#39;1&#39;}bool vis[200010];void dfs(int u){  vis[u] = true;  for(auto [v,i,o]:u2[u]){    if(s[i]) continue; // 边处理过    s[i] = (char)o;    if(!vis[v]) dfs(v);  }}int main(){  n = read();  m = read();  rep(i,0,m) ab[i].first = read();  rep(i,0,m){    int a = ab[i].first;    int b = ab[i].second = read();    u2[a].pb({b,i,(int)&#39;0&#39;});    u2[b].pb({a,i,(int)&#39;1&#39;});  }  rep(i,1,n+1){    if(vis[i])continue;    dfs(i);  }  rep(i,0,m){    if(!s[i]) s[i] = &#39;0&#39;;  }  printf(&quot;%s\n&quot;,s);  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>D</p><p>知道逻辑以后 10min 随便写了QAQ</p><p>我不知道应该怎么归类,信息提取,还是有向图无向图连通性质</p><p>我觉得有一点 算是 无向图的无桥联通块 能通过指定所有边 变成有向图的强连通分量这一点吧,但好像又是一个提炼性质</p><p>哎</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://atcoder.jp/contests/arc143/editorial/4210" target="_blank" rel="noopener">官方题解</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;D(dfs,无向图无桥联通块,强连通分量)&lt;/p&gt;
&lt;p&gt;哎 超时8min过了E,但这个D我还是不会&lt;/p&gt;
&lt;h1 id=&quot;D&quot;&gt;&lt;a href=&quot;#D&quot; class=&quot;headerlink&quot; title=&quot;D&quot;&gt;&lt;/a&gt;D&lt;/h1&gt;&lt;p&gt;评分2229&lt;/p&gt;
&lt;h2 i
      
    
    </summary>
    
      <category term="Atcoder" scheme="http://yexiaorain.github.io/Blog/categories/Atcoder/"/>
    
    
      <category term="dfs" scheme="http://yexiaorain.github.io/Blog/tags/dfs/"/>
    
      <category term="无向图无桥联通块" scheme="http://yexiaorain.github.io/Blog/tags/%E6%97%A0%E5%90%91%E5%9B%BE%E6%97%A0%E6%A1%A5%E8%81%94%E9%80%9A%E5%9D%97/"/>
    
      <category term="强连通分量" scheme="http://yexiaorain.github.io/Blog/tags/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 1696</title>
    <link href="http://yexiaorain.github.io/Blog/2022-06-26-CF1696/"/>
    <id>http://yexiaorain.github.io/Blog/2022-06-26-CF1696/</id>
    <published>2022-06-26T14:24:00.000Z</published>
    <updated>2022-07-30T19:50:12.114Z</updated>
    
    <content type="html"><![CDATA[<p>G(线性规划,对偶,dp,矩阵乘法,segtree)H(TODO)</p><h1 id="G"><a href="#G" class="headerlink" title="G"></a>G</h1><p><a href="https://codeforces.com/contest/1696/problem/G" target="_blank" rel="noopener">https://codeforces.com/contest/1696/problem/G</a></p><p>给一个长n数列</p><p>q个操作或询问</p><ol><li>操作修改 a[i] = v</li><li>询问[l,r] 区间上, 最小处理代价(不真实的修改区间)</li></ol><p>f(l,r) = 每次可以对 相邻元素,分别 (-xt,-yt) 或(-yt,-xt) 代价为t</p><p>问最小代价和让 a[l..r] 全部小于等于0</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>n 2e5</p><p>q 2e5</p><p>x,y [1,1e6]</p><p>ai, v [1,1e6]</p><p>6s</p><p>1024MB</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>因为对称,不妨设 ( x &lt; y)</p><p>开始没看到相邻以为任意,那么不就是维护区间和与区间最大值 = max(和/(x+y),最大值/y)</p><p>但是要相邻这样肯定不对了, 比如样例1, 不相邻可以3,相邻最少要3.5</p><hr><p>单次询问怎么做?</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><h3 id="线性规划对偶"><a href="#线性规划对偶" class="headerlink" title="线性规划对偶"></a>线性规划对偶</h3><p><a href="https://pic1.zhimg.com/80/v2-b780de4a3bd814944026ad22f51518f8_720w.jpg" target="_blank" rel="noopener">https://pic1.zhimg.com/80/v2-b780de4a3bd814944026ad22f51518f8_720w.jpg</a></p><p>$max \sum c_j x_j$</p><p>限制</p><p>$a_{ij} x_{j} \le b_i$</p><p>$x_j \ge 0$</p><p>$i=1\cdots m,j=1\cdots n$</p><p>它的对偶问题</p><p>$min \sum b_i y_i$</p><p>限制</p><p>$a_{ij} y_{i} \ge c_i$</p><p>$y_i \ge 0$</p><p>$i=1\cdots m,j=1\cdots n$</p><hr><p>我看了很多直觉的举例,反而没有理解,通过公式倒是理解了大流程, 下面youtube链接 感觉很清晰</p><p>小写字母表示列向量,大写字母表示矩阵</p><p>$max (c^Tx)$</p><p>$Ax \le b$</p><p>$x \ge 0$</p><p>对于任意$y \ge 0$满足</p><p>$c^Tx \le y^TAx$</p><p>有 $c^Tx \le y^TAx \le y^Tb$, 所以所有都满足,那么它的最大 = 右边的最小</p><p>所以对于所有$c^T \le y^TA$, $max(c^Tx) = min(y^Tb)$</p><p>$c^T \le y^TA$ 即是$Ay \ge c$</p><hr><p>更一般的转化</p><ol><li><p>min max 对换</p></li><li><p>列个数x 变成行个数y</p></li><li><p>右侧约束 和 表达式系数 兑换</p></li><li><p>偏序关系</p></li></ol><p>同偏序: max 变量(xi) 与 0关系 和 min 约束(不等式组xi) 左与右 关系</p><p>反偏序: min 变量(xi) 与 0关系 和 max 约束(不等式组xi) 左与右 关系</p><p>约束等于 对应 变量无约束</p><h2 id="回到题目"><a href="#回到题目" class="headerlink" title="回到题目"></a>回到题目</h2><p>线性规划 问题</p><p>原数组A</p><p>最小化  $\sum_{1\le i &lt; n} a_i+b_i $</p><p>限制</p><p>$Xa_1+Yb_1\ge A_1$</p><p>$Xa_i+Yb_i+Ya_{i-1}+Xb_{i-1}\ge A_i (2\le i &lt; n) $</p><p>$Ya_{n-1}+Xb_{n-1}\ge A_n $</p><p>$a_i,b_i\ge 0$</p><hr><p>那么对偶</p><p>最大化 $\sum_{1\le i \le n} A_iz_i $</p><p>限制</p><p>$xz_i + yz_{i+1} \le 1 (1 \le z &lt; n)$</p><p>$yz_i + xz_{i+1} \le 1 (1 \le z &lt; n)$</p><p>$z_i \ge 0$</p><p>很好的把上面要求的所有系数1变成了右侧的限制</p><hr><p>所以$z_i$ 可能取值$0,\frac{1}{y},\frac{1}{x+y}$</p><p>如果只有两个, 线性规划很明显 <a href="https://www.wolframalpha.com/input?i=2x%2B3y+%3C%3D+1%2C+2y%2B3x+%3C%3D+1" target="_blank" rel="noopener">https://www.wolframalpha.com/input?i=2x%2B3y+%3C%3D+1%2C+2y%2B3x+%3C%3D+1</a></p><p>去画3个的3d情况,你会发现,和2d一样虽然有些棱,但如果这个棱上最优,那么棱上的顶点也最优,但这些凸点的坐标都是这三个可能值中</p><hr><p>然后就可以dp了</p><p><code>dp[i][0/1/2]</code>, 即是算 $max \sum_{j \le i} A_jz_j$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>jiangly 的, 他整个G只花了15min??????</p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_back#define SEG_ROOT 1,0,n#define mid (l+r)/2#define SEG_L 2*p#define SEG_R 2*p+1#define SEG_L_CHILD SEG_L,l,mid#define SEG_R_CHILD SEG_R,mid,rll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readint n;int a[200010];template&lt;class Info,  class Merge = plus&lt;Info&gt; // 合并方法  &gt;  struct SegmentTree {    const int n;    const Merge merge;    vector&lt;Info&gt; info;    SegmentTree(int n) : n(n), merge(Merge()), info(4*n) {}    SegmentTree(vector&lt;Info&gt; init) : SegmentTree(init.size()) {      function&lt;void(int, int, int)&gt; build = [&amp;](int p, int l, int r) { // [l,r) 左闭右开        if (r - l == 1) { // 线段树叶子节点          info[p] = init[l];          return;        }        build(SEG_L_CHILD);        build(SEG_R_CHILD);        pull(p);      };      build(SEG_ROOT);    }    void pull(int p) {      info[p] = merge(info[SEG_L], info[SEG_R]);    }    void modify(int p, int l, int r, int x, const Info &amp;v) {      if (r - l == 1) {        info[p] = v;        return;      }      if (x &lt; mid) {        modify(SEG_L_CHILD, x, v);      } else {        modify(SEG_R_CHILD, x, v);      }      pull(p);    }    void modify(int p, const Info &amp;v) {      modify(SEG_ROOT, p, v);    }    Info rangeQuery(int p, int l, int r, int x, int y) {      if (l &gt;= y || r &lt;= x) return Info(); // 直接省去范围判断, 超过范围提前 返回可参与计算的空状态      if (l &gt;= x &amp;&amp; r &lt;= y) return info[p];      return merge(rangeQuery(SEG_L_CHILD, x, y), rangeQuery(SEG_R_CHILD, x, y));    }    Info rangeQuery(int l, int r) {      return rangeQuery(SEG_ROOT, l, r);    }  };int x, y;// 0: 0// 1: 1/(x+y)// 2: 1/y// 线段树每个节点struct Info {  double f[3][3];  Info(ll v = 0) {    rep(i,0,3){      rep(j,0,3){        if (i + j &gt; 2) {          f[i][j] = -1E18; // 不合法        } else { // 这里直接 值 * z_i(0,1/(x+y),1/y), 因为转移方程里始终要乘 值          f[i][j] = (j == 0 ? 0.0 : 1.0 * v / (j == 1 ? x + y : y));        }      }    }  }};// 实现合并方法Info operator+(const Info &amp;a, const Info &amp;b) {  Info c;  rep(i,0,3){    rep(j,0,3){      c.f[i][j] = -1E18; // 不合法      rep(k,0,3){        // max 矩阵乘法        c.f[i][j] = max(c.f[i][j], a.f[i][k] + b.f[k][j]);      }    }  }  return c;}int main() {  int n = read();  int q = read();  x = read();  y = read();  if (x &gt; y) swap(x, y); // 保证 x&lt;=y  vector&lt;int&gt; b(n);  rep(i,0,n) b[i] = read();  SegmentTree seg(vector&lt;Info&gt;(b.begin(), b.end())); // v =&gt; Info(v) =&gt; segtree(vector&lt;info()&gt;)  while(q--) {    int t = read();    if (t == 1) {      int k = read() - 1;      int v = read();      seg.modify(k, v);    } else {      int l = read() - 1;      int r = read();      auto info = seg.rangeQuery(l, r) + Info(); // + Info() 整合最大值,否则需要手动for 去取max      printf(&quot;%.15lf\n&quot;,info.f[0][0]);    }  }  return 0;}</code></pre><h1 id="H"><a href="#H" class="headerlink" title="H"></a>H</h1><p><a href="https://codeforces.com/contest/1696/problem/H" target="_blank" rel="noopener">https://codeforces.com/contest/1696/problem/H</a></p><p>给一个正整数k</p><p>大小为n,元素可重复的集合A</p><p>f(集合S) = S中恰好选出k个元素能得到的最大乘积</p><p>求 A所有元素个数不小于k的子集B,的f(B)的和</p><p>mod 1e9+7</p><h2 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h2><p>n 600</p><p>ai [-1e9,1e9</p><p>1.5s</p><p>512 MB</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h3><p>如果全非负, 则最大k个的乘积</p><p>如果全负</p><p>k为偶数, 则最小k个的乘积</p><p>k为奇数, 则最大k个的乘积</p><p>如果有负有非负</p><p>k为偶数, 则负 和 非负 分两组, 每组按照绝对值 从大到小,两两成对 构成新的乘积, 一对一对选</p><p>如果k 为奇数, 取一个最大非负, 剩下的 和偶数方案一样处理</p><p>所以肯定要对原来的集合拍个序</p><p>但贡献怎么统计没有思路</p><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>选k个指定它们最大? 计算会出现在多少个集合中??</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>G</p><p>低分题做多了, 太久没遇到线性规划了,很久以前学过, 但好像也是系数多限制多变量少的,</p><p>然后这个对偶学了一下, 希望下次能有用到的地方???</p><p>最后转化可以描述为矩阵max乘法,可以用segtree维护</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://codeforces.com/blog/entry/103479" target="_blank" rel="noopener">官方</a></p><p><a href="https://sites.math.washington.edu/~burke/crs/407/notes/section3.pdf" target="_blank" rel="noopener">https://sites.math.washington.edu/~burke/crs/407/notes/section3.pdf</a></p><p><a href="https://www.youtube.com/watch?v=yU8updOR87c" target="_blank" rel="noopener">https://www.youtube.com/watch?v=yU8updOR87c</a></p><p><a href="https://blog.csdn.net/qq_43539633/article/details/109150749" target="_blank" rel="noopener">https://blog.csdn.net/qq_43539633/article/details/109150749</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;G(线性规划,对偶,dp,矩阵乘法,segtree)H(TODO)&lt;/p&gt;
&lt;h1 id=&quot;G&quot;&gt;&lt;a href=&quot;#G&quot; class=&quot;headerlink&quot; title=&quot;G&quot;&gt;&lt;/a&gt;G&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://codeforces.com/c
      
    
    </summary>
    
      <category term="Codeforces" scheme="http://yexiaorain.github.io/Blog/categories/Codeforces/"/>
    
    
      <category term="dp" scheme="http://yexiaorain.github.io/Blog/tags/dp/"/>
    
      <category term="线性规划" scheme="http://yexiaorain.github.io/Blog/tags/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/"/>
    
      <category term="对偶" scheme="http://yexiaorain.github.io/Blog/tags/%E5%AF%B9%E5%81%B6/"/>
    
      <category term="矩阵乘法" scheme="http://yexiaorain.github.io/Blog/tags/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/"/>
    
      <category term="segtree" scheme="http://yexiaorain.github.io/Blog/tags/segtree/"/>
    
  </entry>
  
  <entry>
    <title>Atcoder abc257</title>
    <link href="http://yexiaorain.github.io/Blog/2022-06-25-ac_abc257/"/>
    <id>http://yexiaorain.github.io/Blog/2022-06-25-ac_abc257/</id>
    <published>2022-06-24T20:25:14.000Z</published>
    <updated>2022-07-30T19:50:12.114Z</updated>
    
    <content type="html"><![CDATA[<p>D(正确读题就能做)G(kmp+DP)Ex(TODO)</p><h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><p>天天卡D我服了,EF都过了就是卡D</p><p>题解这次出得好慢</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://atcoder.jp/contests/abc257/tasks/abc257_d" target="_blank" rel="noopener">https://atcoder.jp/contests/abc257/tasks/abc257_d</a></p><p>平面n个点</p><p>每个点一个倍率Pi</p><p>每个点可到达 PiS 曼哈顿距离以内的点</p><p>问最小的整数S让 可以选择某一点, 让其它点都可从此点跳跃到达,(不需要一次路径)</p><h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h3><p>n 200</p><p>坐标 x,y [-1e9,1e9]</p><p>p [1..1e9]</p><p>3s</p><p>1024mb</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h3><p>一眼 二分答案+tarjan+拓扑排序</p><p>关键这是abc的D题不应该,而且N也就200</p><p>不会这么难, 想不出啊,接近2k人比赛里过了,心态有点炸,还好跳了去做了EF,而且本来abc我也不算分了</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>不要读错题,</p><p>我读成选点 跳跃经过所有点</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>无</p><h1 id="G"><a href="#G" class="headerlink" title="G"></a>G</h1><p><a href="https://atcoder.jp/contests/abc257/tasks/abc257_g" target="_blank" rel="noopener">https://atcoder.jp/contests/abc257/tasks/abc257_g</a></p><p>两个只有小写字母的字符串S,T</p><p>让T 为 S的k个前缀的拼接</p><p>求最小的k 或报不可能</p><h2 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h2><p>|S| 5e5</p><p>|T| 5e5</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><h3 id="我的想法"><a href="#我的想法" class="headerlink" title="我的想法"></a>我的想法</h3><p>一眼像是kmp,但kmp写得真的少,</p><p>而且不确定kmp 怎么具体做,去计算t每个位置作为起始的最大长度</p><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>dp[i] = T[0..i] 和S匹配的答案</p><p>如果 T[i-p…i] == S[1..p], 那么有 dp[i] = min(dp[i-p]+1), p 可能有多种, 没有答案就INF</p><p>单调性</p><p>dp[i] &lt;= dp[i+1]</p><p>否则你把 dp[i+1]的方案中最后一个字符去掉,dp[i] 就能变小</p><p>因此你只需要关心最长的前缀匹配</p><hr><p>终究还是来到了kmp</p><p>经典的# 拼接</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p><a href="https://atcoder.jp/contests/abc257/submissions/32786655" target="_blank" rel="noopener">https://atcoder.jp/contests/abc257/submissions/32786655</a></p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 1000000007#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readclass KMP {  private :    vector&lt;int&gt; f; // 比它小的最长前缀的长度    char *s;    int sz;  public:    KMP(char *s,int sz):s(s),sz(sz){      f = vector&lt;int&gt;(sz,0);      int fa = 0;      rep(i,1,sz){        while (fa &amp;&amp; s[i] != s[fa]) fa = f[fa-1];        if (s[i] == s[fa]) fa++;        f[i] = fa;      }    }    vector&lt;int&gt; getPrefixLen(){      return f;    }    int posIn(char *t,int szt) {      int fa = 0;      rep(i,0,szt) {        while (fa &amp;&amp; t[i] != s[fa]) fa = f[fa-1];        if (t[i] == s[fa]) fa++;        if (fa == sz) return i-fa+1;      }      return -1;    }};char s[1000010];int ns;int nt;const int INF = 0x3f3f3f3f;int main(){  scanf(&quot;%s&quot;,s);  int ns = strlen(s);  s[ns] = &#39;#&#39;;  scanf(&quot;%s&quot;,s+ns+1);  int nt = strlen(s+ns+1);  int n = ns+1+nt;  vector&lt;int&gt; dp(nt+1,INF);  dp[0] = 0;  KMP kmp(s, n);  auto pl = kmp.getPrefixLen();  // rep(i,0,nt){  //   printf(&quot;%lld: %d\n&quot;,i,pl[i+ns+1]);  // }  rep(i,1,nt+1){    dp[i] = dp[i-pl[i+ns]]+1;    // printf(&quot;dp[%lld] = %d\n&quot;,i,dp[i]);  }  printf(&quot;%d\n&quot;, dp[nt] &gt;= INF?-1:dp[nt]);  return 0;}// k 个S前缀拼成 T// KMP?</code></pre><h1 id="Ex"><a href="#Ex" class="headerlink" title="Ex"></a>Ex</h1><p><a href="https://atcoder.jp/contests/abc257/tasks/abc257_h" target="_blank" rel="noopener">https://atcoder.jp/contests/abc257/tasks/abc257_h</a></p><p>n个6面dice,每个上面6个给定数字, 每个价格Ci</p><p>恰好买k个,</p><p>求期望sum(扔的数字)^2 - sum(价格) 最大</p><p>输出 mod 998244353</p><h2 id="范围-2"><a href="#范围-2" class="headerlink" title="范围"></a>范围</h2><p>n 1e3</p><p>k [1..N]</p><p>ci [1,1e5]</p><p>aij [1,1e5]</p><h2 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h3><p>先期望转化</p><p>E((?+xi)^2 - Ci) - E(?^2)</p><p>= E(?^2+2?xi+xi^2) - Ci - E(?^2)</p><p>= E(xi^2) - Ci + 2?E(xi)</p><p>看起来是?的线性函数, 不知道这个是否有局部性可以贪心, 或者<code>dp[前i][用了k] = {E(ans),E?}</code></p><h3 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h3><p>只有一个日文的 <a href="https://atcoder.jp/contests/abc257/editorial/4168" target="_blank" rel="noopener">https://atcoder.jp/contests/abc257/editorial/4168</a></p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>D</p><p>读错题好难受啊</p><p>G</p><p>然后我也更新了一下我的kmp板子多加了个外置函数</p><p>Ex</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://cp-algorithms.com/string/prefix-function.html" target="_blank" rel="noopener">KMP</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;D(正确读题就能做)G(kmp+DP)Ex(TODO)&lt;/p&gt;
&lt;h1 id=&quot;D&quot;&gt;&lt;a href=&quot;#D&quot; class=&quot;headerlink&quot; title=&quot;D&quot;&gt;&lt;/a&gt;D&lt;/h1&gt;&lt;p&gt;天天卡D我服了,EF都过了就是卡D&lt;/p&gt;
&lt;p&gt;题解这次出得好慢&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="Atcoder" scheme="http://yexiaorain.github.io/Blog/categories/Atcoder/"/>
    
    
      <category term="dp" scheme="http://yexiaorain.github.io/Blog/tags/dp/"/>
    
      <category term="kmp" scheme="http://yexiaorain.github.io/Blog/tags/kmp/"/>
    
  </entry>
  
  <entry>
    <title>Atcoder arc142</title>
    <link href="http://yexiaorain.github.io/Blog/2022-06-24-ac_arc142/"/>
    <id>http://yexiaorain.github.io/Blog/2022-06-24-ac_arc142/</id>
    <published>2022-06-23T20:25:14.000Z</published>
    <updated>2022-07-30T19:50:12.114Z</updated>
    
    <content type="html"><![CDATA[<p>D(树,dp)</p><h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><p>评分2900,远高于C的难度</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://atcoder.jp/contests/arc142/tasks/arc142_d" target="_blank" rel="noopener">https://atcoder.jp/contests/arc142/tasks/arc142_d</a></p><p>给你一个树,要上面放一些棋子</p><p>每个时间周期,所有棋子要向它相邻的任意一个点移动,确保移动时每条边最大负债1,移动后每个点最多棋子1个</p><p>且保证任意个时间周期的结果唯一</p><p>问所有合法放置方案数</p><h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h3><p>n 2e5</p><p>2s</p><p>1024mb</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h3><p>要唯一,考虑做树上dp</p><p><code>dp[from][to][tofa]</code> 每个点2x2x2=8 最多8个状态</p><p>from表示根原来有或没, to表示移动一次后有或没, tofa表示移动一次以后对父节点是否有贡献</p><p>但转移感觉只有手动推一推, 不知道自动怎么算</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>注意到是唯一的反复跳 <code>u-&gt;v-&gt;u-&gt;v</code></p><p>那么实际上树是由多个不相交的链组成的</p><p>如果分叉角度说</p><p>a-b a-c a-d</p><p>a总有一轮是1, 两轮都是0是不可能的(这样有多个摆放方案</p><p>那么移动一次后一是到b,c,d中的一个</p><p>而下一次会移动回来</p><p>说明a至多和两个位置跳来跳去剩下的就是和a不相关的链了</p><hr><p>那么<code>1110110</code>, 这样的看作两条链</p><p>问题就是如何划分链</p><p>potato167 的blog上画了很多方便理解的图</p><p>注意到每个独立的链都是 <code>111110</code> 的形式, 而不相交的相邻链是 1和0 相临的, 且独立的链最小长度为2</p><p>然后一条链的端点也不能和另一条链的中间点相邻, 但两条链的中点可以相邻</p><p>所以对于一个点来讲,它可以是头0,头1或者中间的1,</p><p>dp上 就考虑根的状态了</p><hr><p>0 端点 ( 另一个端点是这个端点的后代</p><p>1 端点 ( 另一个端点不是这个端点的后代</p><p>2 非端点, 且连接父节点</p><p>3 非端点, 且连接两个子节点</p><p>这里的状态划分也不再关心是端点是0还是1,因为你只需要保证端点之和端点相邻(相邻的端点相互决定),这样只用关心有多少自由端点的个数n即可, $2^n$</p><hr><p>手推4种状态</p><p>0: 1个子节点1/2, 剩余都是0</p><p>1: 所有子节点都是0</p><p>2: 1个子节点1/2, 剩余都是3</p><p>3: 2个子节点1/2, 剩余都是3</p><p>除了状态转移, 还需要统计自由度</p><p>中间的3 和 根的0 会让自由度+1</p><p>自由度+1, 相当于答案乘2, 所以直接统计答案比记录自由度更方便</p><hr><p>计算</p><p>0: </p><p>一种方案是</p><p><code>sum (dp[v][1]+dp[v][2]) * ((sum dp[..][0]) - dp[v][0])</code></p><p><code>sum (dp[v][1]+dp[v][2]) * (sum dp[..][0]) - sum (dp[v][1]+dp[v][2]) *  dp[v][0])</code></p><p><code>(sum1+sum2)*sum0 - sum( (v1+v2)(v0))</code></p><p>另一种按照循环增加的算法是</p><p><code>res = (res * dp[v][0]) + (dp[v][1] + dp[v][2])*(before all 0)</code></p><p>1: all0</p><p>2: 类似0的计算方法 采取循环子节点 的方法</p><p><code>res = (res * dp[v][3]) + (dp[v][1] + dp[v][2])*(before all 3)</code></p><p>3: 相当于双状态转移</p><p><code>res[2个满足子节点] = res[2] * dp3 + (dp1+dp2)*(before res[1])</code></p><p><code>res[1个满足子节点] = res[1] * dp3 + (dp1+dp2)*(before res[0] = before all 3)</code></p><p>最后记得3还要再乘2</p><p>当然注意到 1和2只有过程中的计算才是分开的, 父子之间处理是一起使用的, 还可以降低一个状态,虽然意义不大</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/arc142/submissions/32681890" target="_blank" rel="noopener">https://atcoder.jp/contests/arc142/submissions/32681890</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 998244353#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readvector&lt;int&gt; G[200010];int main() {  int n = read();  rep(i,1,n){    int u = read() - 1;    int v = read() - 1;    G[u].push_back(v);    G[v].push_back(u);  }  vector&lt;int&gt; fa(n,-1); // 父节点?  vector&lt;int&gt; order={0}; // 树上bfs 顺序, 反序就是树上dp  rep(i,0,n) {    int u = order[i];    for(auto v:G[u]){      if(v == fa[u]) continue;      fa[v] = u;      order.push_back(v);    }  }  vector&lt;vector&lt;ll&gt;&gt; dp(n,vector&lt;ll&gt;(4));  per(i,0,n){    int u = order[i];    ll all0 = 1;    ll all3 = 1;    ll pre1 = 0;    for(auto v:G[u]){      if(fa[v]!=u) continue;      ll s12 = (dp[v][1]+dp[v][2])%MOD;      // 0      dp[u][0] = (dp[u][0] * dp[v][0] % MOD + all0 * s12 % MOD)%MOD;      // 2      dp[u][2] = (dp[u][2] * dp[v][3] % MOD + all3 * s12 % MOD)%MOD;      // 3      dp[u][3] = (dp[u][3] * dp[v][3] % MOD + pre1 * s12 % MOD)%MOD;      pre1     = (pre1     * dp[v][3] % MOD + all3 * s12 % MOD)%MOD;      (all0 *= dp[v][0]) %= MOD;      (all3 *= dp[v][3]) %= MOD;    }    // 1    dp[u][1] = all0;    (dp[u][3] *= 2) %= MOD;  }  printf(&quot;%lld\n&quot;,(dp[0][0] * 2 % MOD + dp[0][3])%MOD);}</code></pre><p>如果再压缩1和2的状态</p><pre><code class="cpp">vector&lt;vector&lt;ll&gt;&gt; dp(n,vector&lt;ll&gt;(3)); // 0:0, 1:1&amp;2, 2:3per(i,0,n){  int u = order[i];  ll all0 = 1;  ll all3 = 1;  ll pre1 = 0;  for(auto v:G[u]){    if(fa[v]!=u) continue;    dp[u][0] = (dp[u][0] * dp[v][0] % MOD + all0 * dp[v][1] % MOD)%MOD; // 0    dp[u][1] = (dp[u][1] * dp[v][2] % MOD + all3 * dp[v][1] % MOD)%MOD; // 2    dp[u][2] = (dp[u][2] * dp[v][2] % MOD + pre1 * dp[v][1] % MOD)%MOD; // 3    pre1     = (pre1     * dp[v][2] % MOD + all3 * dp[v][1] % MOD)%MOD;    (all0 *= dp[v][0]) %= MOD;    (all3 *= dp[v][2]) %= MOD;  }  (dp[u][1] += all0) %= MOD; // 1 &amp; 2  (dp[u][2] *= 2) %= MOD;}printf(&quot;%lld\n&quot;,(dp[0][0] * 2 % MOD + dp[0][2])%MOD);</code></pre><h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><p>n 个巫师,</p><p>ai 能力</p><p>打败 bi 怪物</p><p>对任意巫师增加任意次1能力</p><p>(i,j) is good when (a[i] &gt;= bi and a[j] &gt;= bj) or (a[i] &gt;= b[j] and a[j] &gt;= b[i])</p><p>相当于直接打败或交叉打败</p><p>给你m 个 (x,y)</p><p>要最小增加能力, 让所有(x,y) 是good</p><h2 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h2><p>n 100</p><p>ai bi [1,100]</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>如果自己打败自己,那很好算,但是不一定是答案,但是答案上界至少是</p><p>考虑结果总有个每个巫师的大小顺序</p><p>如果<code>(a[i] - a[j])*(b[i]-b[j]) &gt;= 0</code> , 且存在限制 (x,y) = (i,j)</p><p>那么 必然<code>a[i] &gt;= b[i]</code> <code>a[j] &gt;= b[j]</code> , 如果</p><p>因为如果(i,j) good ,也就是 min(a[i],a[j]) &gt;= min(b[i],b[j]) , max(a[i],a[j]) &gt;= max(b[i],b[j]) </p><p>但是n是100 不可能去枚举顺序</p><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>首先, a[x],a[y] &gt;= min(a[x],a[y]) 这是必要的, 所以可以预处理掉这个</p><p>X 为 能力 小于 monter的 集合, 且在(x,y)中出现了的巫师</p><p>Y 是 其它的巫师</p><p>对于(x,y) 且 x属于X, y属于Y, 结果上期望 a[y] &gt;= b[x] 或 a[x] &gt;= b[x]</p><p>因为有预处理, 所以b[x] &gt; b[y], 因为如果 b[x] &lt;= b[y] 那么必然有 a[x] &gt;= min(b[x],b[y]) = b[x],  x不会属于X,</p><p>也就是X-Y的连接, 一定y中的b更小</p><p><code>b[x] &gt; a[x] &gt;= b[y]</code> 的顺序, <code>a[y] &gt;= b[y]</code></p><p>对于Y-Y的连接,不需要考虑,因为a只会增大,原来满足增加后还是满足</p><p>对于X-X的链接,不会存在,因为有了预处理, 这两个a大于min(b), 所以一定有一个属于Y</p><hr><p>回到X-Y</p><p><code>a[y] &gt;= b[x] &gt; a[x] &gt;= b[y]</code> 直接合法</p><p><code>b[x] &gt; (a[x],a[y]) &gt;= b[y]</code> 考虑上面是让<code>a[y] &gt;= b[x]</code> 还是 <code>a[x] &gt;= b[x]</code></p><hr><p>建图</p><p>点:</p><p>S源,T汇</p><p>X每个x一个点</p><p>Y每个y,100个点(y,i = 1..100)</p><p>边</p><p><code>S -&gt; x</code> 权重<code>b[x] - a[x]</code></p><p><code>(y,i) -&gt; T</code> 权重1</p><p><code>(y,i) -&gt; (y,i-1)</code> 权重无限大</p><p><code>x -&gt; (y,b[x] - a[y])</code> 权重无限大</p><hr><p>意义</p><p>先看假设只有一对</p><p><code>S-(bx-ax)-&gt;x-(无限)-&gt; (y, b[x]-a[y])-(1)-&gt; T</code>, 然后还有些<code>(y,i)-&gt;(y,i-1)</code>的边</p><p><code>S-&gt;X</code>这边限制了不会大于<code>bx-ax</code>, 右边限制了不会大于<code>bx-ay</code></p><p>最小割一定是 <code>S-&gt;x</code>和<code>(y,i)-&gt;T</code> 中的边,不会是那些无限的边</p><p>而如果<code>S-&gt;x</code> 不在最小割里,说明右侧对应的<code>(y,b[x]-a[y]) -&gt; T</code>, 以及更小的i的<code>(y,i)</code> 全部填满, 否则可至少可以再+1, 填满也就说明选择满足</p><hr><p>这个最小割的建图,我也是真不会啊(最大流,最小割还是会写)</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p><a href="https://atcoder.jp/contests/arc142/submissions/32759166" target="_blank" rel="noopener">https://atcoder.jp/contests/arc142/submissions/32759166</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // read#define N 100#define INF 0x3f3f3f3fint n,m;int a[N+10];int b[N+10];vector&lt;int&gt; p2[110]; // 双向关系int S = 0;int T = 1;// S,T,[2..101],[102...201][202..301][302..401]//int nodex(int x) {  assert(x &gt;=0 &amp;&amp; x&lt; 100);  return 2+x;}int nodey(int y,int value) {  assert(y &gt;=0 &amp;&amp; y&lt; 100);  assert(value &gt;=1 &amp;&amp; value &lt;= 100);  return 101 + y*100 + value;}class MinCut{  int sz ;  // TODO 优化成正反边下标  vector&lt;unordered_map&lt;int,ll&gt; &gt; G; // {idx,weight}  vector&lt;int&gt; d; // bfs 距离public:  MinCut(int n):sz(n){    G = vector&lt;unordered_map&lt;int,ll&gt; &gt;(sz);  }  void path(int u,int v,ll w){    assert(u != v);    G[u][v] += w;  }  int dfs(int u,int en, ll s){    if (u == en)return s;    for(auto [v,w]:G[u]){      if(w == 0) continue;      if(d[v] != d[u]+1) continue;      int r = dfs(v,en,min(s,w));      if(r){        G[u][v] -= r;        G[v][u] += r;        return r;      }    }    d[u] = 0; // 标记无效 替代vis    return 0;  }  bool bfs(int st,int en){    d = vector&lt;int&gt;(sz+10,-1);    vector&lt;int&gt; q = {st};    d[st] = 0;    rep(i,0,q.size()){      int u = q[i];      for(auto [v,w]: G[u]){ // u -&gt; v, weight =w        if(d[v] != -1) continue;        if(w == 0) continue;        d[v] = d[u] +1;        q.pb(v);      }    }    return d[en] &gt;= 0;  }  // 一次性计算  ll calc(int st,int en){    int ans = 0;    while (bfs(st, en)) ans += dfs(st, en, INF);    return ans;  }};int main(){  n = read();  S = 0;  T = 1;  rep(i,0,n){    a[i] = read();    b[i] = read();  }  m = read();  int ans = 0;  // 预处理 和 建边  rep(i,0,m){    int x = read() - 1;    int y = read() - 1;    int minv = min(b[x],b[y]);    ans += max(0,minv - a[x]);    a[x] = max(a[x],minv);    ans += max(0,minv - a[y]);    a[y] = max(a[y],minv);    p2[x].pb(y);    p2[y].pb(x);  }  MinCut mc(20000);  rep(i,0,n) {    if(a[i] &lt; b[i]){ // i in X      mc.path(S,nodex(i),b[i] - a[i]);      for(auto u:p2[i]){ // u in Y        if(a[u] &gt;= b[i]) continue;        mc.path(nodex(i),nodey(u,b[i]-a[u]),INF);      }    }else{ // i in Y      rep(j,1,101){        mc.path(nodey(i,j),T,1);        if(j &gt; 1){          mc.path(nodey(i,j),nodey(i,j-1),INF);        }      }    }  }  printf(&quot;%lld\n&quot;,ans + mc.calc(S,T) );  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>D</p><p>我突然觉得我的<code>dp[from][to][tofa]</code> 是不是也可能可以做?? 看起来是完全不同的思路</p><p>虽然想到反复横跳,但拆成链以及链的链接合法方式完全没想过</p><p>而且即使是拆成链,看了积分代码, 所做的树上dp也不相同, 能拆成这样四个也是很需要功力的</p><p>看potato167的代码学了一手非递归的树上dp, 通过先建立order,再逆序做</p><p>E</p><p>光是这个预处理就很厉害,解决了分类的问题, 能证明但完全没能自己挖掘出这个性质</p><p>然后这个建图我也是不会, 虽然学过最大流最小割,但是为啥这样想,没做过这种, 顺便整两个mincut板子</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://atcoder.jp/contests/arc142/editorial" target="_blank" rel="noopener">官方题解</a></p><p><a href="https://potato167.hatenablog.com/entry/2022/06/21/005732" target="_blank" rel="noopener">potato167 D</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;D(树,dp)&lt;/p&gt;
&lt;h1 id=&quot;D&quot;&gt;&lt;a href=&quot;#D&quot; class=&quot;headerlink&quot; title=&quot;D&quot;&gt;&lt;/a&gt;D&lt;/h1&gt;&lt;p&gt;评分2900,远高于C的难度&lt;/p&gt;
&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerl
      
    
    </summary>
    
      <category term="Atcoder" scheme="http://yexiaorain.github.io/Blog/categories/Atcoder/"/>
    
    
      <category term="dp" scheme="http://yexiaorain.github.io/Blog/tags/dp/"/>
    
      <category term="树" scheme="http://yexiaorain.github.io/Blog/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>June Lunchtime 2022 Division 1</title>
    <link href="http://yexiaorain.github.io/Blog/2022-06-22-LTIME109A/"/>
    <id>http://yexiaorain.github.io/Blog/2022-06-22-LTIME109A/</id>
    <published>2022-06-22T14:24:00.000Z</published>
    <updated>2022-07-30T19:50:12.114Z</updated>
    
    <content type="html"><![CDATA[<p>P5.MINXORSEG(XOR,fenwick)</p><h1 id="MINXORSEG"><a href="#MINXORSEG" class="headerlink" title="MINXORSEG"></a>MINXORSEG</h1><p>评分 3087, tourist 也没做出</p><p>给你长度n数组, q个询问,每次问区间[l,r]中任意两个数的异或的最小值</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>n 2e5</p><p>q 2e5</p><p>ai 2^30</p><p>3s</p><p>400MB</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>离线, 按查询的右端点排序</p><p>简单的扫描加入 是n方?</p><p>x=a[l]^a[r]</p><p>假设x最高位1在p位,那么高于p的bit,a[l]和a[r]一样</p><p>如果[l..r] 之间有同样的高于p的bit和它们一样的t,那么(l,r)这一对一定不是最小值,因为 (l,t) 或 (t,r) 比它小</p><p>如果区间有3个高w位一样,那么答案至少是高w位为0, 所以答案最小的只存两个高w一样,或者存在两个相等的数</p><p>这个观察很神奇,也就是说如果ai和aj高w位相同,那么要让它们可能是答案的必要条件是,它们中间没有高w位和它们相同的</p><p>换句话说, a[i]如果和它前面某个a[j]高w相同,贡献了最小xor,那么a[i]的w相同的前面最近的就是a[j]</p><p>所以直接记录每个数前面和它高0,1,2,3..位相同的最近的下标即可, 这可以简单的排序记录</p><hr><p>最后扫描+fenwick一下</p><p>其中把每对的左点为index,异或和为值,做后缀min fenwick 就可以了, 这样每次询问就是[l…  中的最小值</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://www.codechef.com/viewsolution/67421139" target="_blank" rel="noopener">https://www.codechef.com/viewsolution/67421139</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backconst ll INF = 0x3f3f3f3f3f3f;ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readll a[200010];int idxs[200010];struct fenwick_tree {  vector&lt;ll&gt; bit;  int n;  fenwick_tree(int n) : n(n) {    bit = vector&lt;ll&gt; (n + 1, INF); // 后缀min fenwick  }  void update(int u, ll v) {    for (u++; u &gt; 0; u -= u &amp; -u) bit[u] = min(bit[u], v);  }  int query(int u) {    ll r = INF;    for (u++; u &lt;= n; u += u &amp; -u) r = min(r, bit[u]);    return r;  }};int main() {  int n = read();  int q = read();  vector&lt;vector&lt;int&gt;&gt; lst(n);  vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; que(n);  rep(i,0,n) a[i] = read();  rep(b,0,30+1) { // 低位到高位    // 按高 30-p 位排序    iota(idxs,idxs+n,0);    sort(idxs,idxs+n,[=](int i,int j){return make_pair((a[i] &gt;&gt; b),i) &lt; make_pair((a[j] &gt;&gt; b),j); });    rep(i,1,n) {      if ((a[idxs[i]] &gt;&gt; b) == (a[idxs[i-1]] &gt;&gt; b)) { // 高位相同,建立可能对最小值贡献的关系        lst[idxs[i]].push_back(idxs[i-1]);      }    }  }  vector&lt;int&gt; ans(q);  rep(i,0,q) {    int l = read() - 1;    int r = read() - 1;    que[r].push_back({l, i});  }  fenwick_tree fen(n);  rep(i, 0, n) {    for (int v : lst[i]) fen.update(v, a[v] ^ a[i]);    for (auto [l, ind] : que[i]) ans[ind] = fen.query(l);  }  for(auto v:ans) printf(&quot;%d\n&quot;, v);}// n 2e5 个数// q询问,2e5// 查区间内 最小的两个值的 xor</code></pre><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote><p>MINXORSEG</p></blockquote><p>这个观察最小的可能贡献很厉害啊, 应该属于xor的一个神奇的知识点了?</p><p>另一个就是, 这种非统计的, 最大最小也是可以从”可能贡献”的角度去思考,这个我没有思路过,学到了</p><p>fenwick这个还有后缀写法,不需要做颠倒原数组的动作</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://discuss.codechef.com/search?q=tags%3Aeditorial%2BLTIME109" target="_blank" rel="noopener">官方</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;P5.MINXORSEG(XOR,fenwick)&lt;/p&gt;
&lt;h1 id=&quot;MINXORSEG&quot;&gt;&lt;a href=&quot;#MINXORSEG&quot; class=&quot;headerlink&quot; title=&quot;MINXORSEG&quot;&gt;&lt;/a&gt;MINXORSEG&lt;/h1&gt;&lt;p&gt;评分 3087, 
      
    
    </summary>
    
      <category term="CodeChef" scheme="http://yexiaorain.github.io/Blog/categories/CodeChef/"/>
    
    
      <category term="异或" scheme="http://yexiaorain.github.io/Blog/tags/%E5%BC%82%E6%88%96/"/>
    
      <category term="fenwick" scheme="http://yexiaorain.github.io/Blog/tags/fenwick/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 1700</title>
    <link href="http://yexiaorain.github.io/Blog/2022-06-21-CF1700/"/>
    <id>http://yexiaorain.github.io/Blog/2022-06-21-CF1700/</id>
    <published>2022-06-21T14:24:00.000Z</published>
    <updated>2022-07-30T19:50:12.114Z</updated>
    
    <content type="html"><![CDATA[<p>E(总体观察,数学),F(贪心)</p><h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><p><a href="https://codeforces.com/contest/1700/problem/E" target="_blank" rel="noopener">https://codeforces.com/contest/1700/problem/E</a></p><p>给你一个矩阵,每个数字都不相同</p><p>然后让你依次取1,2,3,4,… 取完所有</p><p>取的块需要和之前取过的至少一个4临</p><p>直接可取输出0</p><p>需要还是交换两个位置(可以不相邻)后可取,输出<code>1 方案数</code></p><p>还是都不行输出2</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>矩阵大小4e5</p><p>2s</p><p>256MB</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>0很好判断,vis染色+bfs</p><p>其实就是1的时候怎么算个数</p><p>不妨设按找上述方法最开始失败的是x</p><p>意味着, 小于x的连在一起了,</p><p>那么有两种方案</p><ol><li>交换x和小于x的外边界,这样小于等于x就连在一起了,</li><li>交换小于x的某一个和x的四临</li></ol><p>但是这两种如果一个一个检验是时间复杂度会炸掉的</p><hr><p>考虑可交换的,对于第一种没有什么思路</p><p>对于第二种,你可以考察每个依赖于它的是否仅依赖于它, 但也不一定</p><pre><code>1452.63?7.8.</code></pre><p>比如上面这样,7仅依赖于6,而6也可以移动</p><p>不知道怎么搞了</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>不要看一步一步,看总览性质</p><p>如果一个位置，它的四个邻居有比他小的，那么它就能连到小于它的数。矩阵为可遍历当且仅当所有点（除了1）的四个邻居都有比他小的。</p><p>这归纳法可证明</p><hr><p>所以判断可行,也不再需要vis+bfs, 而直接判断count(badpos)== 0</p><p>所以badpos 需要交换它或者它的邻居</p><p>两两不相同,显然badpos不相邻, 因为badpos需要小于4临, 说明4临都不是badpos</p><p>两两不同,说明交换以后的两个位置,一个比原来大,一个比原来小,</p><p>比原来大的位置4邻之前一定不是badpos, </p><p>比原来小的本身一定不是badpos</p><p>综上, badpos最多5个, 一个中心一个4临</p><p>5x5x4, 种</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>无</p><h1 id="F"><a href="#F" class="headerlink" title="F"></a>F</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://codeforces.com/contest/1700/problem/F" target="_blank" rel="noopener">https://codeforces.com/contest/1700/problem/F</a></p><p>2 * n 的01矩阵,两个</p><p>每次交换第一个中相邻位置的01,求最小次数得到第二个矩阵</p><h3 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h3><p>n 2e5</p><p>1s</p><p>256mb</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h3><p>写了个假的</p><p>两个变量记录未匹配的,然后进入则+,退出则-</p><p>发生 一正一负则消耗1抵消</p><p>竟然官方数据弱还过了system test</p><p>然后有错误样例</p><pre><code>0 1 01 0 00 1 00 0 1</code></pre><p>我的匹配会</p><pre><code>0 b 0a 0 00 a 00 0 b</code></pre><p>代价为4, 最小的是2</p><h3 id="官方"><a href="#官方" class="headerlink" title="官方"></a>官方</h3><p>直接可配消耗掉即可…….</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>无</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>E</p><p>这个总体观察没想到, 一直在想细节的步, 总体只想到vis+bfs 而不是这个充分性质</p><p>jiangly 也TLE了好像</p><p>F</p><p>贪心细节还是没想到啊</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://codeforces.com/blog/entry/103978" target="_blank" rel="noopener">官方</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;E(总体观察,数学),F(贪心)&lt;/p&gt;
&lt;h1 id=&quot;E&quot;&gt;&lt;a href=&quot;#E&quot; class=&quot;headerlink&quot; title=&quot;E&quot;&gt;&lt;/a&gt;E&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1700/probl
      
    
    </summary>
    
      <category term="Codeforces" scheme="http://yexiaorain.github.io/Blog/categories/Codeforces/"/>
    
    
      <category term="贪心" scheme="http://yexiaorain.github.io/Blog/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="数学" scheme="http://yexiaorain.github.io/Blog/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="总体观察" scheme="http://yexiaorain.github.io/Blog/tags/%E6%80%BB%E4%BD%93%E8%A7%82%E5%AF%9F/"/>
    
  </entry>
  
</feed>
