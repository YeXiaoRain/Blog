<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog</title>
  
  
  <link href="/Blog/atom.xml" rel="self"/>
  
  <link href="http://yexiaorain.github.io/Blog/"/>
  <updated>2022-08-08T00:54:42.979Z</updated>
  <id>http://yexiaorain.github.io/Blog/</id>
  
  <author>
    <name>Xiao Ye</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Atcoder abc222</title>
    <link href="http://yexiaorain.github.io/Blog/2022-08-08-ac_abc222/"/>
    <id>http://yexiaorain.github.io/Blog/2022-08-08-ac_abc222/</id>
    <published>2022-08-07T20:25:14.000Z</published>
    <updated>2022-08-08T00:54:42.979Z</updated>
    
    <content type="html"><![CDATA[<p>G(数学, 欧拉定理,phi,miller-robin,pollard-rho)H(题意转化,DP,FFT,生成函数,拉格朗日反演,P-recursive )</p><h1 id="G-222"><a href="#G-222" class="headerlink" title="G - 222"></a>G - 222</h1><p><a href="https://atcoder.jp/contests/abc222/tasks/abc222_g" target="_blank" rel="noopener">https://atcoder.jp/contests/abc222/tasks/abc222_g</a></p><p>在数列2,22,222,2222,22222,….中</p><p>N个X, 首个是 Xi的倍数的下标是?, 或者不存在</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>N 200</p><p>Xi [1,1e8]</p><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>一眼看上去很数学, 很像Project Euler的题</p><p>$2222222 = 2 * 1111111 = 2 * \frac{(10^7 - 1)}{9}$</p><p>其实就是问对于x</p><p>是否 2 * (10^7 - 1) = 9 k x</p><p>首先x的2的幂次为0/1</p><hr><p>好像有点绕</p><p>$kx = 1111111 = 10^0+10^1+10^2+\cdots$</p><p>右边虽然项数为合数时可以拆分, 例如$6 = 3 * 2$,  $111111 = 111 \cdot 1001 = 11 \cdot 10101$</p><p>但不知道是否能拆出所有</p><hr><p>另一个就是对于比较小的<code>11111</code>的部分,可以<code>pollard-rho</code>分解</p><hr><p>考虑长除法?</p><p>每次 除法取mod 乘10 加1</p><p>但1e8 不知道效率怎么样</p><hr><p><a href="http://yexiaorain.github.io/Blog/2020-12-03-pe129/">PE 129</a> 做过类似的, 但是问题是首个 让是它倍数的最小$111\cdots 111$长度超过百万的是哪个因子</p><p>而有一些可用的结论</p><p>除了上面$2,5$因子外$kx = 111\cdots 111$始终有解, 且$111\cdots 111$ 的长度不超过$n$ (因为模数随着长度变化成环)</p><p>因此 如果暴力的话, 期望值是在 $O(NAi)$ 的</p><hr><p>想了下打表 超过1e6的记录下来, 未超过的现场算, 但很多 超过1e6的</p><pre><code class="cpp">int two(int v){  int c = 0;  ll m = 0;  do{    m*=10;    m+=2;    c++;    m%=v;  }while(m!=0);  return c;}void calc(){  rep(i,1000000, 100000000+1){    if(i % 1000000 == 0) printf(&quot;progress %lld\n&quot;,i/1000000);    if(i % 4 == 0 || i % 5 == 0)continue;    int res = two(i);    if(res &gt; 1000000) printf(&quot;ans[%lld] = %d\n&quot;,i,res);  }}</code></pre><hr><p>另一个就是根据PE129的证明过程, 反正有$\phi(n)$ 或者$\phi(9n)$ 是一个解</p><p>那么可以找$\phi(n) , \phi(9n)$的因子尝试, 但这样是否能保证是最小的呢????? 根据倍数, 显然最小的是这个解的因子</p><p>$\phi(n) = n \cdot (1-1/p1) \cdot (1-1/p2) \cdots$</p><p>似乎可做?</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>题解说不需要这么多, 就欧拉定理+暴力找phi就够了</p><p>看来我用高级算法乱搞了太多</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc222/submissions/33867609" target="_blank" rel="noopener">https://atcoder.jp/contests/abc222/submissions/33867609</a></p><p>16ms 还不是最快的, 有人10ms</p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef __int128 lll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readll quick_p(ll b, ll p,ll mod){  ll r = 1;  while(p){    if(p%2)(r*=b)%=mod;    (b*=b)%=mod;    assert(r&gt;0);    assert(b&gt;0);    p/=2;  }  return r%mod;}bool is_prime_32(ll v){  if(v == 2)return true;  if(v &lt; 2)return false;  if(v%2 == 0)return false;  ll test_g[] = {2, 325, 9375, 28178, 450775, 9780504, 1795265022};  ll startp = v-1;  while(startp%2 == 0)startp&gt;&gt;=1;  rep(i,0,7){    ll p = startp;    ll base = test_g[i];    // don&#39;t break may cause 4033 bug    if(base % v == 0)continue;    bool find = false;    ll r = quick_p(base,p,v);    while(p != v-1){      if(r == v-1){        find = true;        break;      }      // -1 开始的序列, 或全1序列      if(r == 1){        if(p == startp){          find = true;          break;        }        return false;      }      p*=2;      (r*=r)%=v;    }    if(!find){      return false;    }  }  return true;}ll my_sqrt(ll v){  assert(v &gt; 1);  ll l = 1;  ll r = v; // care overflow  ll ret = 1;  while(l &lt; r){    ll m = (l+r)/2;    ll m2 = m*m;    if(m2 == v) return m;    if(m2 &lt; v) {      ret = m;      l = m + 1;    } else {      r = m - 1;    }  }  return ret;}ll randint(ll low,ll hi){  return low + (rand() % static_cast&lt;int&gt;(hi - low + 1));}ll Pollard_Rho(ll N) { // 返回一个&gt; 1的因数  assert(N &gt; 1);  if (N == 4) return 2;  ll ret = my_sqrt(N); // 质数平方 效率低 提前判断  if(ret * ret == N) return ret;  while(true) {    ll c = randint(1, N - 1); // 生成随机的c    auto f = [=](ll x) { return ((lll)x * x + c) % N; }; // ll 表示__int128，防溢出    ll t = 0, r = 0; // 初始两个相同    do{      t = f(t); // 1倍速度      r = f(f(r)); // 2倍速度      ll d = gcd(abs(t - r), N);      if (d &gt; 1 &amp;&amp; d &lt; N) return d;    }while (t != r);  }}// 分解x为质因数, sorted, {prime,power}vector&lt;pair&lt;ll,int&gt; &gt; fenjie(ll x) {  vector&lt;int&gt; res = {};  deque &lt;ll&gt; arr = {x};  while(arr.size()){    ll v = arr.front();    arr.pop_front();    if(v == 1) continue;    if(is_prime_32(v)) {      res.pb(v);      continue;    }    ll divisor = Pollard_Rho(v);    arr.push_back(divisor);    arr.push_back(v/divisor);  }  sort(res.begin(),res.end());  vector&lt;pair&lt;ll,int&gt; &gt; ret;  rep(i,0,res.size()){    if(i == 0|| res[i] != res[i-1]) ret.push_back({res[i], 1});    else ret.back().second++;  }  return ret;}ll phi(ll n){  auto primes = fenjie(n);  // printf(&quot;%lld =&quot;,n);  // for(auto [v,pwr]:primes) printf(&quot;[%lld %d]&quot;,v,pwr);  // printf(&quot;\n&quot;);  ll ret = n;  for(auto [v,pwr]:primes) ret = (ret/v)*(v-1);  return ret;}// -------------------------- lib -------------------------- int n ;void dfs(int idx, vector&lt;pair&lt;ll,int&gt;&gt; primes, ll mul, ll &amp; ans){  if(idx == (int)primes.size()){    // test pwr 10^p = k 9v + 1,  10^p % 9v == 1    if(quick_p(10,mul,9*n) == 1) ans = min(ans,mul);    return ;  }  rep(pwr,0,primes[idx].second+1){    if(mul &gt; ans) return;    dfs(idx+1,primes,mul,ans);    mul *= primes[idx].first;  }}void w(){  n = read();  if(n % 4 == 0 || n % 5 == 0){    printf(&quot;-1\n&quot;);    return ;  }  if(n % 2 == 0) n /= 2;  ll phin = n % 3 == 0 ? phi(9*n) : phi(n);  if(phin == 1){    printf(&quot;1\n&quot;);    return ;  }  auto primes = fenjie(phin);  ll ans = phin;  dfs(0, primes, 1, ans);  printf(&quot;%lld\n&quot;,ans);}int main(){  int t = read();  while(t--) w();  return 0;}</code></pre><h1 id="H-Beautiful-Binary-Tree"><a href="#H-Beautiful-Binary-Tree" class="headerlink" title="H - Beautiful Binary Tree"></a>H - Beautiful Binary Tree</h1><p><a href="https://atcoder.jp/contests/abc222/tasks/abc222_h" target="_blank" rel="noopener">https://atcoder.jp/contests/abc222/tasks/abc222_h</a></p><p>给定N, 问多少个满足条件的有根二叉树, 每个点上有数字 0 或 1, 叶子点上都是1</p><p>至多n-1次操作, 让根上值为N, 其它所有点的值为0</p><p>每次操作, 把一个点的值全部加到它的父节点或,父节点的父节点上</p><p>答案mod 998244353</p><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>N 1e7</p><p>3s</p><p>1024 mb</p><h2 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h2><p>首先 叶子上全是1, 且n-1次内全部移动完, 限制了最大的树的高度</p><p>而这里 二叉树 还可能有多个点只有一个子节点的</p><p>至于如何操作呢</p><p>那感觉上也是贪心从下向上,</p><p>而如果叶子向上看是 x-1-?的形式, 那么中间的一定会操作, 所以叠加上去, 0-(1+x)-?</p><p>而如果是 <code>x-0-?</code>, 那就直接跳过</p><p>这里要注意的是 可能有 长成这样的</p><pre><code> 0 01 0   1</code></pre><p>因此顺序应该是 从深度从大到小,而不是所有叶子做bfs</p><hr><p>再看如果给定图 做dfs的话,</p><p>dfs(i) 表示把低层的都收集到i的次数</p><p>那么 对于一个节点 u-v-k</p><p>v 原来是1, 那么次数 = dfs(v) + 1</p><p>如果v 原来是0, 那么 次数 = sum (dfs(k) + 1), k 是v的所有子节点</p><hr><p>换句话说, dfs过程中 一部分是在合并和, 还有一部分是在+1</p><p>所以本质上,能让所有的和 = N, 就要看所有+1的来源, 当然根上可以直接放1</p><p>又注意到上面写的 dfs转移方程式, 其实每次+1, 对应一个次移动</p><p>那么一共n-1次+1, 也就意味 根上一定是1</p><hr><p>然后感觉上, 可以考虑左右树拆分</p><p>左树贡献 i的话, 右侧贡献为 n-1 - i</p><p>两边独立, 似乎就可以fft/ntt 来搞了</p><hr><p>然后如何变成和主问题等价的子问题呢?</p><p>考虑其中一个子节点 让它对根贡献i, 记作$h(i)$</p><p>子节点为空, 则贡献i = 0,方案1</p><p>子节点为1, 则贡献为 i = 子树贡献(和原问题等价) + 1</p><p>子节点为0, 则考虑它的子节点, 因为它不能是叶子,它至少有一个子节点</p><p>那么1个的情况 i = 子树贡献() + 1, 方案数 x 2</p><p>那么2个的情况 i = 左子树贡献x + 1 + 右子树贡献y + 1, 方案数加和, </p><hr><p>有点问题是 这样下面贡献可能根是非1的, 因此<code>f(x)</code> 的意义改成产生的+1贡献, 根也是0的情况</p><hr><p>$f(x) = \sum_{i=0}^{x} h(i)\cdot h(x-i)$,</p><p>$h(0) = 1$ // 对应无节点</p><p>$h(x) = f(x-1) + 2 * f(x-1) + \sum_{i=0}^{x-2} f(i)\cdot f(x-2-i), x &gt; 0$</p><p>答案就是$f(n-1)$</p><p>这种自身相互依赖的用cdq二分 好像能做?吗?</p><hr><p><strong> 好像我的过程漏掉了总和, 只考虑操作步数……… 推了半天推了个锤子,白推了 </strong></p><h2 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a>官方题解</h2><p>满足条件的树的充要</p><ol><li>根和叶子都是1</li><li>所有1的和 = N</li><li>0不连续</li></ol><p>证明</p><p>首先所有1 要汇总到根, 所有不在根上的1, 至少操作1次, 而最多n-1次,因此 根有1,且所有其它1恰好被操作1次,而非1的地方不被操作</p><p>因此也不能有连续的0</p><p>问题变成统计上面的树的个数了</p><hr><p>定义,对于$i &gt; 0$</p><p>$a_i = i$个点是1,根也是1的满足要求的树的方案数</p><p>$b_i = i$个点是1,根是0的,满足剩余要求的树的方案</p><p>因为没有连续零,那么bi 要么有单个子树 $2 a_i$, 要么两个子树都不为空</p><p>所以 $b_i = 2a_i + \sum_{j=1}^{i-1} a_ja_{i-j}$</p><p>类似的,对于$a_i$</p><p>$a_1 = 1$</p><p>一个子节点时 $2(a_{i-1}+b_{i-1})$</p><p>所以 $a_i = 2(a_{i-1}+b_{i-1}) + \sum_{j=1}^{i-2} (a_j+b_j)(a_{i-1-j} + b_{i-1-j}), i &gt; 1$</p><hr><p><del>一点简化?(并不是) 是不是令$a_0 = 1,b_0 = 0$ 可以让上面变成完全的求和式子</del></p><hr><p>这里也说 分治类fft 可以做到 $N log^2 N$, 虽然没试过两个怎么做分治, 但会超时</p><h3 id="生成方程"><a href="#生成方程" class="headerlink" title="生成方程"></a>生成方程</h3><p>$a_0 = b_0 = 0$</p><p>分别把$a_i$和$b_i$作为系数做它们的生成方程$A(x),B(x)$</p><p>那么第一个表达式和$B=2A+A^2$等价</p><p>第二个和$A = x + 2x(A+B) + x(A+B)^2$</p><p>然后两个生成式带入一下</p><p>$A = x(1+A+B)^2 = x(1+3A+A^2)^2$</p><p>用 Newton’s algorithm 据说可以 $O(N log N)$, 也会超时</p><h3 id="Lagrange-inversion-theorem-拉格朗日反演"><a href="#Lagrange-inversion-theorem-拉格朗日反演" class="headerlink" title="Lagrange inversion theorem 拉格朗日反演?"></a>Lagrange inversion theorem 拉格朗日反演?</h3><p>解决的问题, 给定F(x)</p><p>找G(x) 使得 G(F(x)) = x</p><p><strong>这里有一点要用到,但是没有证明的是 $G(F(x)) = x$ 则 $F(G(x)) = x$</strong>, 只能说在$F(x)$的值域内$F(G(F(x)) = F(x)$即$F(G(x)) = x$可以证明, 但在值域外不知道如何证明…</p><p>如果 F,G满足, 且它们0次项系数均为0, 1次项系数均非0</p><p>那么有$\lbrack x^n \rbrack G(x) = \frac{1}{n} \lbrack x^{n-1} \rbrack \left(\frac{x}{F(x)}\right)^n.$</p><p>即是G的n次项 = $(\frac{x}{F(x)})^n$ 的$n-1$次项的$\frac{1}{n}$</p><p>证明</p><hr><p>辅助lemma: 对于任何0次系数为0,存在非0次系数不为0的$F(x)$, 有对于整数$k$</p><p>$\lbrack x^{-1} \rbrack F’(x) F(x)^k = \lbrack k = -1\rbrack$, 即是$k=-1$时$-1$次系数为$1$,否则$-1$次系数为$0$</p><p>证明lemma:</p><p>对于$k\neq -1$, 显然求导法则$F’(x) F(x)^k = \frac{\left ( F(x)^{k+1} \right)’}{k+1}$</p><p>对于$k = -1$, $F(x) = \sum_{i&gt;0} a_i x^i$</p><p>$\frac{F’(x)}{F(x)} = \frac{a_1+2a_2x+3a_3x^2+\cdots}{x(a_1+a_2x+a_3x^2+\cdots}= x^{-1} \frac{1 + 2\frac{a_2}{a_1}x + \cdots}{1 + \frac{a_2}{a_1}x + \cdots}$</p><p>也就是右侧这个分式除完以后是$1+k_1x+k_2x^2+\cdots$的样子, 因此 -1 次方的系数是 1, lemma 证毕.</p><hr><p>因此$G(F(x)) = x$, 的$G$ 满足条件</p><p>$G’(F)\cdot F’ = 1$ ( 同时求导</p><p>展开$\sum_i i(\lbrack x^i\rbrack G(x) ) F^{i-1} F’ = 1$, (基本的求导法则 $(ax^i)’ = iax^{i-1}$, 注意到前两项都是系数而非生成函数</p><p>$\sum_{i} i (\lbrack x^i \rbrack G (x)) F^{i-1-n} F’ = F^{-n}.$ ( 同乘上$F^{-n}$</p><p>$\lbrack x^{-1}\rbrack \left(\sum_{i} i (\lbrack x^i \rbrack G (x)) F^{i-1-n} F’\right) = \lbrack x^{-1}\rbrack \left(F^{-n}\right).$ (提取$-1$次项目的系数</p><p>因为左侧$i (\lbrack x^i \rbrack G (x)) $ 整个都是系数,以及上面的lemma, 左侧只有$i=n$时 生成系数的内容才为$1$,其它则是$0$</p><p>$n[x^n]G = [x^{-1}]F^{-n}$</p><p>变形一下,就有了最初要证明的$\lbrack x^n \rbrack G(x) = \frac{1}{n} \lbrack x^{n-1} \rbrack \left(\frac{x}{F(x)}\right)^n.$</p><hr><p>这玩意 百科上说建立了函数方程和幂级数之间的联系</p><h3 id="使用示例-卡特兰数Catalan-number"><a href="#使用示例-卡特兰数Catalan-number" class="headerlink" title="使用示例: 卡特兰数Catalan number"></a>使用示例: 卡特兰数Catalan number</h3><p>$c_0 = 1$</p><p>$c_{n+1} = \sum_{i=0}^n c_{i} \cdot c_{n-i}$</p><p>令$C$为以卡特兰数 1,1,2,5,14为系数的生成方程</p><p>令$F(x) = C(x) - 1$, 保证0次项系数为0, 1次系数非0</p><p>那么$F(x) = x(F(x)+1)^2$ , 根据卡特兰数本身推导的定义的到的</p><p>令$G(x) = \frac{x}{(x+1)^2}$</p><p>那么有$G(F(x)) = \frac{F(x)}{(F(x)+1)^2} = x$</p><p>那么$c_n$ 就有了</p><p>因此</p><p>$<br>\begin{aligned}<br>[x^n]F(x) &amp;= \frac{1}{n} \lbrack x^{n-1} \rbrack \left(\frac{x}{G(x)}\right)^n \\<br>&amp;= \frac{1}{n} \lbrack x^{n-1} \rbrack (x + 1)^{2n} \\<br>&amp;= \frac{1}{n} \binom{2n}{n-1} = \frac{1}{n+1} \binom{2n}{n},<br>\end{aligned}$</p><h3 id="回到原问题"><a href="#回到原问题" class="headerlink" title="回到原问题"></a>回到原问题</h3><p>$A(x) = x(1+3A(x)+A(x)^2)^2$</p><p>令$G(x) = \frac{x}{(1+3x+x^2)^2}$</p><p>感觉到一点点套路了, 就是如果本身A(x) 的等式里是 $A(x) = x W(A)$的形式,直接$G(x) = \frac{x}{W(x)}$ 就行了,因为这样就有 $G(A) = \frac{A}{W(A)} = \frac{xA}{xW(A)} = \frac{xA}{A} = x$</p><p>同时$A(G(x)) = x$, 可以验证$x = A(G) = G(1+3A(G)+A(G)^2)^2 = \frac{x}{(1+3x+x^2)^2}(1+3x+x^2)^2$</p><p>$\lbrack x^n \rbrack A(x) = \frac{1}{n}\lbrack x^{n-1}\rbrack \left(\frac{x}{G(x)}\right)^{2n}= \frac{1}{n}\lbrack x^{n-1}\rbrack (1+3x+x^2)^{2n}$</p><hr><p>现在只要找到$(1+3x+x^2)^{2N} $的$N-1$次的系数,再除以$N$就是要的答案了</p><p>$\left((1+3x+x^2)^{2N}\right)’ = 2N(1+3x+x^2)^{2N-1}(1+3x+x^2)’$</p><p>$(1+3x+x^2)\left((1+3x+x^2)^{2N}\right)’ = 2N(1+3x+x^2)^{2N}(1+3x+x^2)’$</p><p>把这个用生成方程表示$\sum u_k x^k = (1+3x+x^2)^{2N}$</p><p>$(1+3x+x^2)\left(\sum u_k x^k\right)’ = 2N(1+3x+x^2)’ (\sum u_k x^k)$</p><p>$(1+3x+x^2)(\sum ku_k x^{k-1}) = 2N(3+2x)(\sum u_k x^k)$</p><p>考虑两边$x^{k-1}$次项系数</p><p>$ku_k + 3(k-1)u_{k-1} + (k-2)u_{k-2} = 2N(3u_{k-1}+2u_{k-2})$</p><p>$u_k = \frac{(6N-3k+3)u_{k-1} + (4N - k + 2)u_{k-2}}{k}$</p><p>这样可以O(N) 递推, ??? 这样会触发很多乘法逆元的出现吗? 还是用分数做中间过程?</p><hr><p>不做递推的直接求</p><p>$\begin{aligned}<br>u_k &amp;= \lbrack x^k \rbrack (1+3x+x^2)^{2N} \\<br>&amp;= \lbrack x^k \rbrack ( (1+3x)+x^2)^{2N} \\<br>&amp;=\lbrack x^k \rbrack \sum_{0 \leq j \leq 2N} \binom{2N}{j}x^{2j} (1+3x)^{2N-j} \\<br>&amp;=\sum_{0 \leq j \leq 2N} \binom{2N}{j}\lbrack x^{k-2j} \rbrack (1+3x)^{2N-j} \\<br>&amp;=\sum_{0 \leq j \leq 2N} \binom{2N}{j} \binom{2N-j}{k-2j} 3^{k-2j},<br>\end{aligned}$</p><p>至此可以$O(N)$, 算出</p><hr><p>再次注意,要算的是$N-1$次项系数再除以$N$</p><h3 id="继续优化-P-recursive"><a href="#继续优化-P-recursive" class="headerlink" title="继续优化 P-recursive"></a>继续优化 P-recursive</h3><p>TODO, orz</p><p>据说能做到$O(\sqrt{N} log N)$</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>基于 最后那个非递推求的</p><p>maspy 的只有46ms</p><p><a href="https://atcoder.jp/contests/abc222/submissions/33870319" target="_blank" rel="noopener">https://atcoder.jp/contests/abc222/submissions/33870319</a></p><p>300+ms</p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 998244353#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readint n;int qpow(ll v,int pwr){  ll r = 1;  while(pwr){    if(pwr%2) (r*=v)%=MOD;    (v*=v)%=MOD;    pwr/=2;  }  return r;}int fac[20000010] = {1};int ifac[20000010];ll binom(ll n,ll m){  if(n &lt; 0 || m &lt; 0 || m &gt; n) return 0;  return fac[n]*(ll)ifac[m]%MOD*(ll)ifac[n-m]%MOD;}int main(){  int n = read();  rep(i,1,2*n+1) fac[i] = fac[i-1]*(ll)i % MOD;  ifac[2*n] = qpow(fac[2*n],MOD-2);  per(i,0,2*n) ifac[i] = ifac[i+1] * (ll)(i+1) % MOD;  ll ans = 0;  ll p3 = qpow(3,n-1);  ll inv3_sq = qpow(3*3, MOD-2);  // sum_{i=[0..2n]}binom(2n,i)binom(2n-i,n-1-2i) 3^{n-1-2i}  rep(i,0,2*n+1) {    if(n-1-2*i &lt; 0) break;    (ans += binom(2*n,i)*binom(2*n-i,n-1-2*i)%MOD*p3) %= MOD;    (p3 *= inv3_sq)%=MOD;  }  printf(&quot;%lld\n&quot;,ans*qpow(n,MOD-2) % MOD); // 1/n  return 0;}</code></pre><h3 id="使用了atcoder-modint"><a href="#使用了atcoder-modint" class="headerlink" title="使用了atcoder modint"></a>使用了atcoder modint</h3><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;#include &lt;atcoder/modint&gt;using mint = atcoder::modint998244353;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readint n;mint fac[20000010] = {1};mint ifac[20000010];mint binom(ll n,ll m){  if(n &lt; 0 || m &lt; 0 || m &gt; n) return 0;  return fac[n] * ifac[m] * ifac[n-m];}int main(){  int n = read();  rep(i,1,2*n+1) fac[i] = fac[i-1] * i ;  ifac[2*n] = fac[2*n].inv();  per(i,0,2*n) ifac[i] = ifac[i+1] * (i+1);  mint ans = 0;  mint p3 = mint(3).pow(n-1);  mint inv3_sq = mint(3*3).inv();  // sum_{i=[0..2n]}binom(2n,i)binom(2n-i,n-1-2i) 3^{n-1-2i}  rep(i,0,2*n+1) {    if(n-1-2*i &lt; 0) break;    ans += binom(2*n,i)*binom(2*n-i,n-1-2*i)*p3;    p3 *= inv3_sq;  }  printf(&quot;%d\n&quot;,(ans/n).val()); // 1/n  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>G</p><p>欧拉公式, $gcd(a,n) = 1$时$a^{\phi(n)} \equiv 1 \pmod n$</p><p>后面乱搞也行, 枚举算$\phi$也行</p><p>H</p><p>题意转化</p><p>DP</p><p>FFT</p><p>生成方程</p><p>拉格朗日反演</p><p>可以又学了一堆新知识点</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://atcoder.jp/contests/abc222/editorial" target="_blank" rel="noopener">官方题解</a></p><p><a href="https://en.wikipedia.org/wiki/Repunit" target="_blank" rel="noopener">wikipedia repunits</a></p><p><a href="http://yexiaorain.github.io/Blog/2020-12-03-pe129/">Project Euler 129 repunits</a></p><p><a href="http://yexiaorain.github.io/Blog/2021-06-12-project-euler216/">Project Euler 216 miller robin 质数判别</a></p><p><a href="http://yexiaorain.github.io/Blog/2022-06-03-pollard-rho/">pollard-rho质数拆分</a></p><p><a href="https://baike.baidu.com/item/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E5%8F%8D%E6%BC%94/20844121" target="_blank" rel="noopener">拉格朗日反演</a></p><p><a href="https://chaoli.club/index.php/6072" target="_blank" rel="noopener">超理论坛 拉格朗日反演</a></p><p><a href="https://www.luogu.com.cn/blog/tiw-air-oao/post-ke-pu-xiang-la-ge-lang-ri-fan-yan-di-ji-zhong-xing-shi" target="_blank" rel="noopener">洛谷 拉格朗日反演</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;G(数学, 欧拉定理,phi,miller-robin,pollard-rho)H(题意转化,DP,FFT,生成函数,拉格朗日反演,P-recursive )&lt;/p&gt;
&lt;h1 id=&quot;G-222&quot;&gt;&lt;a href=&quot;#G-222&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="Atcoder" scheme="http://yexiaorain.github.io/Blog/categories/Atcoder/"/>
    
    
      <category term="DP" scheme="http://yexiaorain.github.io/Blog/tags/DP/"/>
    
      <category term="数学" scheme="http://yexiaorain.github.io/Blog/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="欧拉定理" scheme="http://yexiaorain.github.io/Blog/tags/%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86/"/>
    
      <category term="phi" scheme="http://yexiaorain.github.io/Blog/tags/phi/"/>
    
      <category term="miller-robin" scheme="http://yexiaorain.github.io/Blog/tags/miller-robin/"/>
    
      <category term="pollard-rho" scheme="http://yexiaorain.github.io/Blog/tags/pollard-rho/"/>
    
      <category term="题意转化" scheme="http://yexiaorain.github.io/Blog/tags/%E9%A2%98%E6%84%8F%E8%BD%AC%E5%8C%96/"/>
    
      <category term="FFT" scheme="http://yexiaorain.github.io/Blog/tags/FFT/"/>
    
      <category term="生成函数" scheme="http://yexiaorain.github.io/Blog/tags/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"/>
    
      <category term="拉格朗日反演" scheme="http://yexiaorain.github.io/Blog/tags/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E5%8F%8D%E6%BC%94/"/>
    
      <category term="P-recursive" scheme="http://yexiaorain.github.io/Blog/tags/P-recursive/"/>
    
  </entry>
  
  <entry>
    <title>Atcoder abc221</title>
    <link href="http://yexiaorain.github.io/Blog/2022-08-07-ac_abc221/"/>
    <id>http://yexiaorain.github.io/Blog/2022-08-07-ac_abc221/</id>
    <published>2022-08-06T20:25:14.000Z</published>
    <updated>2022-08-08T00:54:42.979Z</updated>
    
    <content type="html"><![CDATA[<p>F(树的直径)G(坐标转化,笛卡尔系)H(差分转化,前缀和,滑窗和,动态规划)</p><h1 id="F-Diameter-set"><a href="#F-Diameter-set" class="headerlink" title="F - Diameter set"></a>F - Diameter set</h1><p><a href="https://atcoder.jp/contests/abc221/tasks/abc221_f" target="_blank" rel="noopener">https://atcoder.jp/contests/abc221/tasks/abc221_f</a></p><p>N 点树, 找染色法, 染&gt;=2个点为红色,让红色点两两之间距离为直径</p><p>方案数 mod 998244353</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>N 2e5</p><p>2s</p><p>1024mb</p><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>首先直径 是经典算法, 随机点u,找最远点v, 再以v找最远点 便是直径</p><p>如果选v</p><p>那么可以把v看作根, 相当于做树上dp</p><p>因为有深度和直径都知道, 那么对于到叶子距离2倍小于直径的分叉至多选一个,</p><p>而2倍大于直径的分叉(不可能都有直径,否则这样能得到更大的长度)</p><p>如果直径是偶数, 那么从v到1/2直径点u再到最远点, 这样的点u只有一个,并且这个u可以看成重心</p><p>因此可以从重心去找 直径/2 的距离做树上统计 即可</p><p>问题来到了奇数长度的直径, 如果直径是奇数, 选了v到最远点的方案 就是最远点的个数</p><hr><p>任意两个直径 必有交点, 否则 两个直径上 p1..p2 有一个简单路径 取 p1 — 最远, p2 — 最远, p1-p2, 大于等于 直径/2向上取整 + 1</p><p>这样的话</p><p>任取一条来看,</p><p>v …. x - y…..t</p><p>假设,x和y是中间距离的两个点</p><p>那么不可能有不经过y的v..x…t1, 否则 t..x..t1 更长</p><p>换句话说</p><p>一定所有直径有x-y</p><p>类似的证明</p><p>已经证明了有公共点,</p><p>那么假设是y右侧的最近的某个p</p><p>同样v ….p…更长的一半, 将会比直径长</p><p>x对称同理</p><hr><p>所以奇数情况,就是, x 去找距离的方案 乘上 y 去找距离的方案</p><hr><p>似乎就推出来了?</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc221/submissions/33847992" target="_blank" rel="noopener">https://atcoder.jp/contests/abc221/submissions/33847992</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 998244353#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readvector&lt;int&gt; p2[200010];// {distance, node}pair&lt;int,int&gt; dfs(int u,int fa,int d = 0){  pair&lt;int,int&gt; r = {d ,u};  for(auto v:p2[u]) if(v != fa) r = max(r, dfs(v,u,d +1));  return r;}int D = 0;bool dfsxy(int u,int fa,int findv,int &amp;x,int &amp;y,int d = 0){  bool ok = u == findv;  for(auto v:p2[u]) if(v!=fa) ok = ok || dfsxy(v,u,findv,x,y,d+1);  if(ok &amp;&amp; d == D/2) x = u;  if(ok &amp;&amp; d == D/2 + 1) y = u;  return ok;}int dfscnt(int u,int fa,int d){  int r = d==0;  for(auto v:p2[u])if(v!=fa) r += dfscnt(v,u,d-1);  return r;}int main(){  int n = read();  rep(i,1,n){    int u = read();    int v = read();    p2[u].pb(v);    p2[v].pb(u);  }  auto [_,u] = dfs(1,0);  auto [d,v] = dfs(u,0);  D = d;  int x,y; // x: d/2, y: d/2+1  dfsxy(u,0,v,x,y);  if(d % 2){ // 奇数长度    ll cx = dfscnt(x,y,D/2);    ll cy = dfscnt(y,x,D/2);    printf(&quot;%lld\n&quot;,cx*cy % MOD);  }else{ // 偶数长度    ll s = 1;    ll r = 1;    for(auto p:p2[x]){      ll c = dfscnt(p,x,D/2-1);      (r*=(c+1))%=MOD;      s += c;    }    printf(&quot;%lld\n&quot;,(r+MOD-s)%MOD);  }  return 0;}</code></pre><h1 id="G-Jumping-sequence"><a href="#G-Jumping-sequence" class="headerlink" title="G - Jumping sequence"></a>G - Jumping sequence</h1><p><a href="https://atcoder.jp/contests/abc221/tasks/abc221_g" target="_blank" rel="noopener">https://atcoder.jp/contests/abc221/tasks/abc221_g</a></p><p>能否从(0,0) 恰好N次,跳到(A,B)</p><p>第i次可以向, x正/x负/y正/y负(4选1),跳恰好Di</p><p>如果可以,给一个方案</p><h2 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h2><p>N 2000</p><p>A,B [-3.6e6,3.6e6]</p><p>Di 1800</p><p>5s</p><p>1024</p><h2 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h2><p>顺序其实没有关系,因为是向量加和</p><p>那一个角度转化就是</p><p>分成4组,</p><p>其中两组的差 = X</p><p>另外两组的差 = Y</p><hr><p>另一个就是</p><p>先分两组 组A-组B = X+Y</p><p>然后找到组A中部分 = Y的 移出来</p><p>但这个只是 充分条件不是必要条件</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>逆时针转45度坐标轴 长度再乘上 根号2</p><p>终点 原坐标系(a,b) -&gt; 新坐标系 (a-b,a+b)</p><p>操作 全变成了(+-di,+-di)的形式</p><p>什么好处呢, 两个轴单独考虑了</p><hr><p>对于一个轴, 要找</p><p>S = sum (1/-1) * di</p><p>的方案</p><p>可以同时加 所有di的和</p><p>S + sum di = sum (2/0) <em> di = 2 </em> (选一些di)</p><p>就是简单的01 背包,需要bitset搞一下 空间</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc221/submissions/33849395" target="_blank" rel="noopener">https://atcoder.jp/contests/abc221/submissions/33849395</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readbitset&lt;3600001&gt; dp[2001]; // bitset 压空间, dp[前i个][值] = 是否可达int d[2000];// 旋转矩阵: 逆时针 45度 * 根号2// (x y) ( 1  1) =&gt; (x-y, x+y)//       (-1  1)//                                     x y   y   x// L: (-1 0) =&gt; (-1 -1)  =&gt;  +1)/2 =&gt; (0,0)  0 + 0 =  0// D: (0 -1) =&gt; ( 1 -1)  =&gt;  +1)/2 =&gt; (1,0)  0 + 1 =  1// U: (0  1) =&gt; (-1  1)  =&gt;  +1)/2 =&gt; (0,1) 10 + 0 = 10// R: (1  0) =&gt; ( 1  1)  =&gt;  +1)/2 =&gt; (1,1) 10 + 1 = 11const char c[] = { &#39;L&#39;,&#39;D&#39;,&#39;U&#39;,&#39;R&#39;};char ans[2010];bool w(){  int n = read();  int x = read();  int y = read();  int m[2] = {x-y,x+y};  int s = 0;  rep(i,0, n) {    d[i] = read(); // [1,1800]    s += d[i];  }  rep(i,0,2) if(abs(m[i]) &gt; s) return false; // 过远  rep(i,0,2) if((m[i] + s) % 2 != 0) return false; // (m[i] + s )/2 = 选部分di  rep(i,0,2) m[i] = (m[i] + s) / 2;  dp[0][0] = true;  rep(i,0, 2000) dp[i + 1] = dp[i] | (dp[i] &lt;&lt; d[i]); // 哇  rep(j,0,2) if(!dp[n][m[j]]) return false; // 有值无法构成  per(i,0,n){ // 倒着找哪些用了哪些没用    int bit = 0;    rep(j,0,2) if (!dp[i][m[j]]) { // 表示可达, 直接贪心选取, 两个中必有一个可行,一个不可行另一个一定可行      m[j] -= d[i];      bit += (1 &lt;&lt; j);    }    ans[i] = c[bit];  }  return true;}int main() {  if(!w()) printf(&quot;No\n&quot;);  else {    printf(&quot;Yes\n&quot;);    printf(&quot;%s\n&quot;,ans);  }  return 0;}</code></pre><h1 id="H-Count-Multiset"><a href="#H-Count-Multiset" class="headerlink" title="H - Count Multiset"></a>H - Count Multiset</h1><p><a href="https://atcoder.jp/contests/abc221/tasks/abc221_h" target="_blank" rel="noopener">https://atcoder.jp/contests/abc221/tasks/abc221_h</a></p><p>输入正整数 N, M</p><p>找可重集合,k=1…N个正整数, 和=N, 同一个重复数量不超过M, 这样可重集合的个数</p><p>mod 998244353</p><p>对于k=1..N 分别输出答案</p><h2 id="范围-2"><a href="#范围-2" class="headerlink" title="范围"></a>范围</h2><p>M &lt;= N &lt;= 5000</p><p>2 s</p><p>1024 mb</p><h2 id="我的思路-2"><a href="#我的思路-2" class="headerlink" title="我的思路"></a>我的思路</h2><p>5000 很想平方</p><p>但是直接之想到3维dp</p><p><code>dp[v][x][c] =</code> 和 = v, 最大值不超过v, 一共用了c个数 的方案数</p><p>转移</p><p><code>dp[v][x][c] = sum dp[v-kx][x-1][c-k], k=0..m</code></p><p>这样$N^3$的状态, 转移还要枚举k(可以跳点双指针变成O1均摊), 虽然滚动可以吃掉一维解决空间,还是无法解决时间</p><p>但是从加和的角度可以看成二维卷积 一个稀疏的<code>[k][1] * 0..m</code></p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>显然 等于 非严格递增序列的方案数(其实上面dp就是按照这个来的</p><p>令B为其差分数组,其中B1=A1, Bi = Ai-A[i-1]</p><p>sum Ai = N</p><p>sum Bi * (k-1+i) = N</p><p>考虑翻转顺序</p><p>sum i Bi = N</p><p>然后限制是最多M个Ai, 也就是连续0的个数 &lt;= M-1 &lt; M</p><p>这里的好处就是把M限制变成了连续0的限制,不影响总和,而非0的内容是任意的数量,没有限制</p><p><code>f[i][j] =</code> B中前i个数和为j 且最后一个数不为0的方案数</p><p>$f_{i,j}=\sum\limits_{k=\max(0,i-m)}^{i-1}\sum\limits_{l = ik &lt; j} f_{k,j-l}$</p><p>初始状态<code>f[0][0] = 1, f[0][&gt;0] = 0</code></p><hr><p>滑窗和/前缀和优化一下就n^2了</p><p>注意到颠倒了i以后正好我们要的就是首个不为0,变成末尾不为零</p><p>因此<code>f[i][n]</code> 就是要求的k=i的答案</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc221/submissions/33848661" target="_blank" rel="noopener">https://atcoder.jp/contests/abc221/submissions/33848661</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 998244353#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readconst int N = 5000;ll f[N+10][N+10]; // f[i][j] = 前i个(第i个不为0), sum(i*Bi) = j 方案数ll sum[N+10][N+10]; // sum[i][j] = sum f[i-m+1..i][j], 对i维度的滑窗和(也可以前缀和)int main() {  int n = read();  int m = read();  f[0][0] = sum[0][0] = 1;  rep(i,1,n+1) rep(j,0,n+1) {    // f[i][j] = sum f[i-m ~ i-1][j - i * bi] ,  k = bi * i, O(log)    for(int k = i; k &lt;= j; k+=i) (f[i][j] += sum[i-1][j-k]) %= MOD;    sum[i][j] = (sum[i-1][j] + f[i][j] - (i-m&gt;=0?f[i-m][j]:0)) % MOD; // 长度m的滑窗  }  rep(i,1,n+1) printf(&quot;%lld\n&quot;, (f[i][n] + MOD) % MOD);  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>F</p><p>没啥难的</p><p>先知道基本的直径算法, 也是可以自己推的</p><p>G</p><p>分离相关性</p><p>坐标轴转化</p><p>据说有黑科技 能55ms Linear Time Algorithms for Knapsack Problems with Bounded Weights</p><p><a href="https://www.sciencedirect.com/science/article/abs/pii/S0196677499910349" target="_blank" rel="noopener">https://www.sciencedirect.com/science/article/abs/pii/S0196677499910349</a></p><p>H</p><p>差分转化!!!</p><p>这里的好处就是把M限制变成了连续0的限制,不影响总和,而非0的内容是任意的数量,没有个数限制</p><p>只有对于首个非零和连续0的个数的限制了</p><p>然后是bitset的熟练应用了, 甚至位运算做01背包转移</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://atcoder.jp/contests/abc221/editorial" target="_blank" rel="noopener">官方题解</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;F(树的直径)G(坐标转化,笛卡尔系)H(差分转化,前缀和,滑窗和,动态规划)&lt;/p&gt;
&lt;h1 id=&quot;F-Diameter-set&quot;&gt;&lt;a href=&quot;#F-Diameter-set&quot; class=&quot;headerlink&quot; title=&quot;F - Diameter set&quot;
      
    
    </summary>
    
      <category term="Atcoder" scheme="http://yexiaorain.github.io/Blog/categories/Atcoder/"/>
    
    
      <category term="动态规划" scheme="http://yexiaorain.github.io/Blog/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="树" scheme="http://yexiaorain.github.io/Blog/tags/%E6%A0%91/"/>
    
      <category term="前缀和" scheme="http://yexiaorain.github.io/Blog/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
      <category term="直径" scheme="http://yexiaorain.github.io/Blog/tags/%E7%9B%B4%E5%BE%84/"/>
    
      <category term="树的直径" scheme="http://yexiaorain.github.io/Blog/tags/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/"/>
    
      <category term="坐标转化" scheme="http://yexiaorain.github.io/Blog/tags/%E5%9D%90%E6%A0%87%E8%BD%AC%E5%8C%96/"/>
    
      <category term="笛卡尔系" scheme="http://yexiaorain.github.io/Blog/tags/%E7%AC%9B%E5%8D%A1%E5%B0%94%E7%B3%BB/"/>
    
      <category term="差分转化" scheme="http://yexiaorain.github.io/Blog/tags/%E5%B7%AE%E5%88%86%E8%BD%AC%E5%8C%96/"/>
    
      <category term="滑窗和" scheme="http://yexiaorain.github.io/Blog/tags/%E6%BB%91%E7%AA%97%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>Atcoder abc220</title>
    <link href="http://yexiaorain.github.io/Blog/2022-08-06-ac_abc220/"/>
    <id>http://yexiaorain.github.io/Blog/2022-08-06-ac_abc220/</id>
    <published>2022-08-05T20:25:14.000Z</published>
    <updated>2022-08-08T00:54:42.979Z</updated>
    
    <content type="html"><![CDATA[<p>G(计算几何,排序,自定义排序)H(FWHT,FWT,meet-in-middle,bitmask)</p><h1 id="G-Isosceles-Trapezium"><a href="#G-Isosceles-Trapezium" class="headerlink" title="G - Isosceles Trapezium"></a>G - Isosceles Trapezium</h1><p>二维平面, N个点,坐标Xi,Yi, 权重Ci</p><p>选4个点, 形成 等腰梯形, 问选的4个点最大权重和</p><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>N 1000</p><p>Xi,Yi [-1e9,1e9]</p><p>Ci [1,1e9]</p><p>无重点</p><p>3s</p><p>1024</p><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>有点计算几何</p><p>N的样子,像是N^2的做法</p><p>如果是暴力找三个点, 确定平行边,那么剩下一个点就自然确定了, 这样的话是 <code>N^3 log(N)</code></p><hr><p>换个想法, 按对称轴来找</p><p>如果是垂于对称轴的一点,则找对称轴最远的两个点</p><p>这样 N^2 的对称轴, 其中相等的里面 按照垂点相同的最大的,找不同的两组就行了??</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc220/submissions/33799130" target="_blank" rel="noopener">https://atcoder.jp/contests/abc220/submissions/33799130</a></p><pre><code class="cpp">    #include &lt;bits/stdc++.h&gt;    using namespace std;    typedef long long ll;    #define MOD 1000000007    #define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)    #define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)    #define pb push_back    ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // read    ll gcd(ll a,ll b){      a = abs(a);      b = abs(b);      while(b!= 0) tie(a,b) = make_pair(b,a%b);      return a;    }    const ll INF = 0x3f3f3f3f3f3f3f3f;    array&lt;ll,3&gt; xyv[1010];    map&lt;tuple&lt;ll,ll,ll&gt;, vector&lt;pair&lt;int,int&gt; &gt; &gt; cx;    void addp(int i,int j){      auto [x0,y0,v0] = xyv[i];      auto [x1,y1,v1] = xyv[j];      // 对称轴, 标准化      ll ky = 2*(y1-y0);      ll kx = -2*(x1-x0);      ll k  = (x1-x0)*(x1+x0) + (y1-y0)*(y1+y0);      ll g = gcd(k,gcd(ky,kx));      ky /= g;      kx /= g;      k  /= g;      if(ky &lt; 0){        ky = -ky;        kx = -kx;        k  = -k;      }else if(ky == 0 &amp;&amp; kx &lt; 0){        kx = -kx;        k  = -k;      }      cx[{ky,kx,k}].push_back({i,j});    }    int main(){      int n = read();      rep(i,0,n){        int x = read();        int y = read();        int v = read();        xyv[i] = {x,y,v};      }      rep(i,0,n) rep(j,i+1,n) addp(i,j);      ll ans = -1;      for(auto [_,vec]:cx){        auto center = [=](const pair&lt;int,int&gt;&amp;ij){            auto [i0,j0] = ij;            auto [x0,y0,v0] = xyv[i0];            auto [x1,y1,v1] = xyv[j0];            return make_pair(x0+x1,y0+y1);        };        sort(vec.begin(),vec.end(), [=](const auto &amp;ij0,const auto &amp;ij1){            return center(ij0) &lt; center(ij1);        });        ll lastmax = -INF;        ll cur = -INF;        rep(i,0,vec.size()){          if(i == 0 || center(vec[i]) != center(vec[i-1])){            lastmax = max(lastmax,cur);            cur = 0;          }          auto [i0,j0] = vec[i];          cur = max(cur, xyv[i0][2] + xyv[j0][2]);          if(lastmax != -INF){            ans = max(ans, lastmax + cur);          }        }      }      printf(&quot;%lld\n&quot;,ans);      return 0;    }    // y = -(x1-x0)/(y1-y0) (x - (x0+x1)/2) + (y0+y1)/2    // 2(y1-y0) y = -2(x1-x0) x + (x1-x0)(x1+x0) + (y0+y1)(y1-y0)</code></pre><h1 id="H-Security-Camera"><a href="#H-Security-Camera" class="headerlink" title="H - Security Camera"></a>H - Security Camera</h1><p>N 点, M 边</p><p>选定一些点, 让边(至少一个点上有被选定的)的数量是偶数个</p><p>求合法方案数</p><h2 id="限制-1"><a href="#限制-1" class="headerlink" title="限制"></a>限制</h2><p>N 40</p><p>无重边,自环</p><p>2s</p><p>1024mb</p><h2 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h2><p>感觉题面就是个朴素的图论</p><p>40 呢, 对应边就是780</p><p>估计是个边平方~ 3次方 左右的算法, 或者点的5次方?</p><hr><p>思路正向就是考虑局部可行方案加上插头状态</p><p>逆向就是 所有减去存在未选择的 做容斥</p><p>点数量40, 2^40 = 1099511627776</p><hr><p>如果, 是一个一个安装的, 那么考虑对于个数的影响</p><p>增量是 相邻未安装的和</p><p>而对于这个连接出的点,相邻未安装的奇偶性发生颠倒</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>2^20 = 1048576</p><p>折半</p><p>把拆成两个点集合S,T</p><p><code>L1[S,s] =</code> 点集S的子集s 被选了, 覆盖的边数的奇偶性</p><p><code>L2[S,T,s] =</code> 点集T中, 连向S\s的数量是奇数的点集? (因为偶数的话,首先不被s选,其次不论在T中是否被选不影响奇偶性</p><p><code>R[T,t] =</code> 点集T的子集t被选了,覆盖的两端属于T的边的奇偶性</p><p>因为对于每个选中状态, 可以枚举剩下所有点, 所以 可以$O(|S|2^{|S|})$ 暴力算完</p><p>那么对于答案有贡献的</p><p>$L_1[s] \oplus  ((\text{popcount} (L_2[s]  \&amp;  t) ) \&amp;1) \oplus R[t] = 0$</p><p>意义 s得到的奇数偶,t内部奇偶,和t向S\s的奇偶 = 最终奇偶</p><hr><p>中间这玩意怪怪的,虽然很长意义也就是<code>L2[s] &amp; t</code> 的1的个数的奇偶性</p><p>像个办法把右侧合并一下</p><p>$F[S,T,s] = \sum_{t \subset T} ((\text{popcount} (L_2[s]  \&amp;  t) ) \&amp; 1) \oplus R[t] $</p><p>注意到 求和部分,奇数贡献1, 偶数贡献0, 所以这里是对于给定s,在T的子集中, 让上述表达式贡献1的个数</p><p>那么贡献0的个数就是 $2^{|T|} - F[S,T,s]$</p><p>如果能求出来, 那么对于每个$s$, 有$L1[s]$ 的奇偶性, 直接加上对应贡献即可</p><hr><p>问题变成是如何求出<code>F[S,T,s]</code></p><p>这里记$t’ = L2[s]$, 这样一个s唯一对应一个<code>t&#39;</code>, 但<code>t&#39;</code>可能有多个<code>s</code> 映射过来</p><p>记作$G[T,t’] = \sum_{t \subset T} ((\text{popcount} (t’ \&amp;  t) ) \&amp;1) \oplus R[t] $</p><p>这样有个好处是,不再关心<code>S</code>和<code>s</code>, 只用管<code>T</code>中的即可</p><hr><p>注意到 $FWHT$的变换公式是</p><p>$fwht[a]_ i = \sum_{(\text{popcount}(i \&amp; j) \bmod 2 = 0}a_j - \sum_{(\text{popcount}(i\&amp; j) \bmod 2  = 1}a_j$</p><p>对于给定 i</p><p>一个具体的j</p><p>左侧为0时, 原式子贡献是 R[j], 而fwht贡献是 a[j]</p><p>左侧为1时, 原式子贡献是 R[j]^1, 而fwht贡献是 -a[j]</p><p>如果让a[j] = R[j], 那么</p><p>左侧为0时, 原式子贡献是 0 , 而fwht贡献是 0</p><p>左侧为0时, 原式子贡献是 1 , 而fwht贡献是 1</p><p>左侧为1时, 原式子贡献是 0^1, 而fwht贡献是 -0</p><p>左侧为1时, 原式子贡献是 1^1, 而fwht贡献是 -1</p><p>左侧为0和为1各占一半, 总贡献会少掉$2^{|T|-1}$</p><p>加上即可?</p><h2 id="另一个做法"><a href="#另一个做法" class="headerlink" title="另一个做法"></a>另一个做法</h2><p>所有边变成”有向”, 小点连出到大点</p><p><code>f[i][j][k] =</code> 前i个点, 未覆盖的边的两端都在前i的边数为j(奇1/偶0), 一些未来不选的会影响未覆盖边的奇偶性的点的方案数</p><p><code>i+1</code>选 <code>f[i][j][k]</code> 贡献 <code>f[i+1][j][k高(i+2)位]</code></p><p><code>i+1</code>不选 <code>f[i][j][k]</code> 贡献 <code>f[i+1][j^(i+1是否在k中)][(k高(i+2)位) ^ (i+1 连出的边) ]</code></p><hr><p>很神奇的是, 这样每个点对于每个上个状态最多分支出两个状态</p><p>那么前一半最多<code>2^20</code>个状态</p><p>而状态低<code>i</code>位都是<code>0</code>, 所以后面的一半也是最多<code>2^20</code>个状态</p><p>所以复杂度也是</p><p><code>n 2^{n/2}</code></p><p>从一定程度上也有meet-in-middle 的感觉,而没有了fwt的需要</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc220/submissions/33847519" target="_blank" rel="noopener">https://atcoder.jp/contests/abc220/submissions/33847519</a></p><p>1.7s 快超时了, 为什么有人6ms 啊</p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readll g[50]; // g[小点] = 大点的bit mask// f[前i个点][两端均在前i个中的未覆盖的边的奇偶][mask中的点每不选一个奇偶性变化1]=方案数unordered_map&lt;ll,ll&gt;f[50][2];int main() {  int n = read(); // 点  int m = read(); // 边  rep(i,0,m){    int x = read() - 1;    int y = read() - 1;    if(x &gt; y) swap(x,y);    g[x] |= 1ll&lt;&lt;y; // 全是小 -&gt; 大  }  f[0][0][0]=1; // 选 点0，所有点因为不选 未覆盖 的边都为0，为偶数。  f[0][0][g[0]]++; // 不选 点0，0指向的点因为不选 未覆盖 的边+1.  rep(i,0,n-1) rep(j,0,2) { // 枚举当前的未覆盖的边数的奇偶。    for(auto [mask,cnt]:f[i][j]) { // 枚举上一层的所有状态，进行推磨式转移。      ll bit = (mask &gt;&gt; (i+1)) &amp; 1;// 确定 不选点i+1 未覆盖的边的 奇偶变化。      //选 点i+1，所有点(i+1之后的点) 因为不选而未覆盖的边数的就不变。且j的状态不变。      f[i+1][j][mask^(bit&lt;&lt;(i+1))]+=cnt;      //不选 点i+1，j的状态 根据当前j 和 因为i不选要未覆盖的边数的就确定      //并且改变之后的点因为不选而未覆盖的边的奇偶      f[i+1][j^bit][mask^(bit&lt;&lt;(i+1))^g[i+1]] += cnt;    }  }  ll ans=0;  for(auto [_,cnt]:f[n-1][m&amp;1]) ans += cnt; // m&amp;1 未覆盖的奇偶和总边一样,则覆盖了的为偶数  printf(&quot;%lld&quot;,ans);  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>G</p><p>没啥难的</p><p>简单的计算几何,排序,自定义排序</p><p>H</p><p>一个是40的一半是20, 2^20 是可以范围内的</p><p>另一个是拆的时候,可以按点拆分,一半是有点就包含,另一半是需要两端都属于集合</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://atcoder.jp/contests/abc220/editorial" target="_blank" rel="noopener">官方题解</a></p><p><a href="https://www.cnblogs.com/gcfer/p/15344079.html" target="_blank" rel="noopener">csdn 逆天峰 H</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;G(计算几何,排序,自定义排序)H(FWHT,FWT,meet-in-middle,bitmask)&lt;/p&gt;
&lt;h1 id=&quot;G-Isosceles-Trapezium&quot;&gt;&lt;a href=&quot;#G-Isosceles-Trapezium&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
      <category term="Atcoder" scheme="http://yexiaorain.github.io/Blog/categories/Atcoder/"/>
    
    
      <category term="计算几何" scheme="http://yexiaorain.github.io/Blog/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
    
      <category term="排序" scheme="http://yexiaorain.github.io/Blog/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="bitmask" scheme="http://yexiaorain.github.io/Blog/tags/bitmask/"/>
    
      <category term="FWT" scheme="http://yexiaorain.github.io/Blog/tags/FWT/"/>
    
      <category term="FWHT" scheme="http://yexiaorain.github.io/Blog/tags/FWHT/"/>
    
      <category term="自定义排序" scheme="http://yexiaorain.github.io/Blog/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F/"/>
    
      <category term="meet-in-middle" scheme="http://yexiaorain.github.io/Blog/tags/meet-in-middle/"/>
    
  </entry>
  
  <entry>
    <title>Atcoder abc219</title>
    <link href="http://yexiaorain.github.io/Blog/2022-08-05-ac_abc219/"/>
    <id>http://yexiaorain.github.io/Blog/2022-08-05-ac_abc219/</id>
    <published>2022-08-04T20:25:14.000Z</published>
    <updated>2022-08-08T00:54:42.979Z</updated>
    
    <content type="html"><![CDATA[<p>F(排序,分组)G(根号分类,分类)H(区间dp,问题转化)</p><h1 id="F-Cleaning-Robot"><a href="#F-Cleaning-Robot" class="headerlink" title="F - Cleaning Robot"></a>F - Cleaning Robot</h1><p><a href="https://atcoder.jp/contests/abc219/tasks/abc219_f" target="_blank" rel="noopener">https://atcoder.jp/contests/abc219/tasks/abc219_f</a></p><p>给序列 从点(0,0) 出发,上下左右走n个点,</p><p>重复序列k次, 问经过次数&gt;=1的点有几个</p><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>n 2e5</p><p>k 1e12</p><p>2s</p><p>1024mb</p><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>可以看成 一个图形, 每次平移固定向量, k次,问覆盖的图形面积</p><p>似乎脑补可得: 每次计算增量, 如果增量不变, 则往后都是这个增量</p><hr><p>但不知道如何判断 达到了最小增量</p><p>如果是这个形状, s -&gt; e</p><pre><code>xxxxxesxx</code></pre><p>那么下一次增量是5, 下下次增量也是5, 但是 这不是最小增量, 最小是3</p><hr><p>所以可能要变成去计算每个点首次不产生贡献的时刻, 而不产生贡献,也就是沿着 e -&gt; s 的向量方向如果存在点</p><p>所以考虑对点归类, 能够通过向量 e -&gt; s 到达的 归类</p><p>然后比较时刻和所有点的首次不产生贡献的时间即可</p><p>不产生时刻 = 同类别最近的方向向量 / 向量</p><p>好像就过了</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc219/submissions/33772772" target="_blank" rel="noopener">https://atcoder.jp/contests/abc219/submissions/33772772</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readchar s[200010];int ch[256];int di[] = {-1,1,0,0};int dj[] = {0,0,-1,1};vector&lt;pair&lt;pair&lt;ll,ll&gt;,ll&gt; &gt; pos;int main(){  ch[(int)&#39;L&#39;] = 0;  ch[(int)&#39;R&#39;] = 1;  ch[(int)&#39;U&#39;] = 2;  ch[(int)&#39;D&#39;] = 3;  scanf(&quot;%s&quot;,s);  int n = strlen(s);  ll k = read();  ll dx = 0;  ll dy = 0;  vector&lt;pair&lt;ll,ll&gt; &gt; vis = {{dx,dy}};  rep(i,0,n){    dx += di[ch[(int)s[i]]];    dy += dj[ch[(int)s[i]]];    vis.push_back({dx, dy});  }  if(dx &lt; 0){ // 保证在 (-pi/2,pi/2]    dx = -dx;    dy = -dy;  }else if(dx == 0 &amp;&amp; dy &lt; 0){ // &lt;- bug dx == 0    dy = -dy;  }  sort(vis.begin(),vis.end());  rep(i,0,vis.size()) if(i == 0 || vis[i] != vis[i-1]){    auto [x,y] = vis[i];    ll t = 0;    if(dx != 0){ // dx &gt;= 0      t = x/dx;      x -= t * dx;      y -= t * dy;      if(x &lt; 0){        t --;        x += dx;        y += dy;      }    }else if(dy != 0){ // dx == 0, dy &gt;= 0      t = y/dy;      y -= t * dy;      if(y &lt; 0){        t --;        y += dy;      }    }    pos.push_back({ { x , y } , t}); // 没空格 hexo 炸了  }  sort(pos.begin(),pos.end());  ll ans = 0;  if(dx == 0 &amp;&amp; dy == 0){    ans = pos.size();  }else{    rep(i,0,pos.size()){      if(i == 0 || pos[i].first != pos[i-1].first){        ans += k;      }else{        ans += min(k, pos[i].second - pos[i-1].second);      }    }  }  printf(&quot;%lld\n&quot;,ans);  return 0;}</code></pre><h1 id="G-Propagation"><a href="#G-Propagation" class="headerlink" title="G - Propagation"></a>G - Propagation</h1><p><a href="https://atcoder.jp/contests/abc219/tasks/abc219_g" target="_blank" rel="noopener">https://atcoder.jp/contests/abc219/tasks/abc219_g</a></p><p>n个点,m跳边的图, 点i上写的i</p><p>q次操作</p><p>每次让点xi 上的值扩散给它的所有相邻节点</p><p>输出最终每个点上的值</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>n 2e5</p><p>m 2e5</p><p>q 2e5</p><p>无重边 自环</p><p>2s</p><p>1024mb</p><h2 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h2><p>直接模拟? 如果出现2层菊花形状 每次一个外层染进来,中心扩散, 那么可能就是QN的量级</p><p>那么思路方向一个如何批量 或者 lazy的表示</p><p>另一个就是有没有可能倒着做</p><hr><p>如果把做为修改中心的, 作为点, 按时间顺序和依赖关系 可以建立树(森林), 但不太知道怎么去建</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>分度处理</p><p>对于度小于 $\sqrt{m}$, 直接修改周围的点, 而对于 $\ge \sqrt{m}$的度的点, 在点上标识</p><p>对于查询, 可以查询所有, 相当于边访问2次</p><p>而每次 处理前, 需要遍历一次周围度大于等于$\sqrt{m}$ 的</p><p>复杂度分析</p><p>修改就不用说了显然</p><p>而就每次获取最新状态时, 因为要遍历相邻的所有度$\sqrt{m}$</p><p>那么假设有$w$个, 那么即使边来自它们之间 $\frac{w \sqrt{m}}{2} leq m$, 即$w \leq {2\sqrt{m}}$, 说明也是$O(\sqrt{m})$ 级别的访问</p><p>中间复杂度$O(q\sqrt{m})$, 最后查询复杂度$O(n\sqrt{m})$</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc219/submissions/33773300" target="_blank" rel="noopener">https://atcoder.jp/contests/abc219/submissions/33773300</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readvector&lt;int&gt;p2[200010];vector&lt;int&gt;pl[200010]; // linked largebool large[200010]; // is largepair&lt;int,int&gt; distr[200010]; // [u] = {value, time}int a[200010]; // valueint t[200010]; // timeint getV(int u){  int val = a[u];  int ti = t[u];  for(auto v:pl[u]) if(distr[v].second &gt; ti) tie(val,ti) = distr[v];  return val;}int main(){  int n = read();  ll m = read();  int q = read();  rep(i,0,m){    int u = read();    int v = read();    p2[u].pb(v);    p2[v].pb(u);  }  iota(a+1,a+n+1,1);  rep(i,1,n+1) large[i] = (ll)p2[i].size() * (ll)p2[i].size() &gt; m;  rep(u,1,n+1){    for(auto v:p2[u]){      if(large[v]) pl[u].push_back(v);    }  }  rep(ti,1,q+1){    int u = read();    int val = getV(u);    a[u] = val;    t[u] = ti;    if(large[u]){      distr[u] = {val, ti};    }else{      for(auto v:p2[u]){        a[v] = val;        t[v] = ti;      }    }  }  rep(i,1,n+1) printf(&quot;%d &quot;,getV(i));  return 0;}</code></pre><h1 id="H-Candles"><a href="#H-Candles" class="headerlink" title="H - Candles"></a>H - Candles</h1><p><a href="https://atcoder.jp/contests/abc219/tasks/abc219_h" target="_blank" rel="noopener">https://atcoder.jp/contests/abc219/tasks/abc219_h</a></p><p>N 个蜡烛, 第i个在Xi, 长度Ai</p><p>每分钟, 点燃的蜡烛长度-1, 直到 = 0, 而没点燃的不变化</p><p>初始在0,每分钟可以移动+1/-1, 如果当前位置有任何蜡烛,可以扑灭(不耗时)</p><p>求所有蜡烛长度剩余和的最大值</p><h2 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h2><p>N 300</p><p>xi [-1e9,1e9]</p><p>Ai [1,1e9]</p><h2 id="我的思路-2"><a href="#我的思路-2" class="headerlink" title="我的思路"></a>我的思路</h2><p>第一感觉是, 向左走 然后一直向右, 或者向右然后一直向左, 找这个折反点</p><p>问题是,会不会出现 左右左的情况?</p><p>例如-1上有10个, 2上有10个, -4 上1个, 都足够的长</p><p>那么 0 -&gt; -1 -&gt; 2 -&gt; -4 的损失是21 <em> 1 + 11 </em> 3 + 1 * 6, 是最小的</p><hr><p>这样证否了贪心折返</p><p>注意到N很小</p><p>甚至能接受 n^3, 考虑dp</p><p><code>dp[i..j][0]</code> = <code>[i,j]</code> 区间内全部熄灭(烧完), 停在i 的 {最大长度, 时间} </p><p>问题是, 这种状态设计下, 最大长度和时间是有一致性吗?</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>也是说, 仅从访问来看</p><p>如果已经访问过的区间是<code>[X_i,X_j]</code> 那么下一次 一定是<code>[X_{i-1},X_j]</code> 或<code>[X_i,X_{j+1}]</code></p><hr><p>修改一下问题</p><ol><li>蜡烛可以负数长度</li><li>你可以在起始时移除一些蜡烛</li></ol><p>显然新答案不会比原答案更大,而如果有一个答案的方案你照着走,然后把是会是负数的在一开始就移除,那么也可以达到这个原答案的最大值</p><hr><p>那么</p><ol><li>初始 分 = 0</li><li>计数 C 去 [0,N] 之间的一个值, 相当于剩余的蜡烛个数,但是不知道具体是哪C个蜡烛</li><li>Hi等于对应蜡烛的高度</li><li>每次移动坐标变化1, 分数 -= C</li><li>对于走到一个未访问过的点, 且C &gt; 0, 可以选择 C-=1, 分 += Hi</li></ol><p>求最大分</p><p>显然最优解和答案是一样的</p><p>// 咦 我怎么看到上凸函数的影子</p><hr><p>然后就可以dp了</p><p><code>dp[i][j][flag][k] =</code> 已获的最大分数, $[X_i,X_j]$ 已经访问,$flag = 0$ 在$X_i$,$flag = 1$ 在$X_j$, $k$ 是剩余的要去熄灭的蜡烛个数</p><p>那么转移方程, 走到$X_i$</p><p><code>dp[i][j][0][k] = max(dp[i+1][j][0/1][k] - 距离 * k, dp[i+1][j][0/1][k+1] - 距离 * (k+1) + H[i])</code></p><p>转移方程, 走到$X_j$</p><p><code>dp[i][j][1][k] = max(dp[i][j-1][0/1][k] - 距离 * k, dp[i][j-1][0/1][k+1] - 距离 * (k+1) + H[i])</code></p><p>最后答案就是<code>dp[0][n-1][0/1][0]</code></p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc219/submissions/33780170" target="_blank" rel="noopener">https://atcoder.jp/contests/abc219/submissions/33780170</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readconst int N = 300;ll dp[N+10][N+10][2][N+10];pair&lt;int,int&gt; ph[N+10]; // pos height 起点 {0,0}const ll INF = 0x3f3f3f3f3f3f3f3f;void setMax(ll &amp;v0,ll v1){ if(v1 &gt; v0) v0 = v1; }int main(){  int n = read();  rep(i,1,n+1){    auto p = read();    auto h = read();    ph[i] = {p,h};  }  sort(ph,ph+n+1);  int ci = -1; // center i 起始点  rep(i,0,n+1){    if(ph[i] == make_pair(0,0)){      ci = i;      break;    }  }  rep(i,0,n+1) rep(j,0,n+1) rep(f,0,2) rep(c,0,n+1) dp[i][j][f][c] = -INF;  rep(f,0,2) rep(c,0,n+1) dp[ci][ci][f][c] = 0;  per(i,0,ci+1) rep(j,ci,n+1) {    //dp[i][j][0][k]=max(dp[i+1][j][0/1][k]-距离*k,dp[i+1][j][0/1][k+1]-距离*(k+1)+H[i])`    //dp[i][j][1][k]=max(dp[i][j-1][0/1][k]-距离*k,dp[i][j-1][0/1][k+1]-距离*(k+1)+H[i])`    if(i == j) continue;    rep(c,0,n+1) rep(f,0,2) {      if(i &lt; ci) {        auto [x,h] = ph[i];        const ll pos[] = {i+1, j};        ll &amp;res = dp[i][j][0][c];        setMax(res, dp[pos[0]][pos[1]][f][c] - (ph[pos[f]].first - x) * c);        if(c &lt; n) setMax(res, dp[pos[0]][pos[1]][f][c+1] - (ph[pos[f]].first - x) * (c+1) + h);      }      if(j &gt; ci){        auto [x,h] = ph[j];        const ll pos[] = {i, j-1};        ll &amp;res = dp[i][j][1][c];        setMax(res, dp[pos[0]][pos[1]][f][c] - (x - ph[pos[f]].first) * c);        if(c &lt; n) setMax(res, dp[pos[0]][pos[1]][f][c+1] - (x - ph[pos[f]].first) * (c+1) + h);      }    }  }  printf(&quot;%lld\n&quot;, max(dp[0][n][0][0], dp[0][n][1][0]));  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>F</p><p>一眼题</p><p>G</p><p>分类处理, 根号分治</p><p>做了不少分类的,又忘了分类</p><p>H</p><p>一个是题目转化去掉限制的技巧不会啊, 如果直接是转化后的题面, 那我还是会区间DP的, 但这个转化感觉遇到多了学一学转化</p><p>其实就是这里每分钟下降 燃烧着的个数, 会因为=0而难以维护, 通过支持负数 和可预先移除来让每分钟下降易于维护, 同时保持新的最大答案 = 原答案</p><p>n^3和dp的感知还是没有问题, 虽然在没有前面转化的情况下用处不大</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://atcoder.jp/contests/abc219/editorial" target="_blank" rel="noopener">官方题解</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;F(排序,分组)G(根号分类,分类)H(区间dp,问题转化)&lt;/p&gt;
&lt;h1 id=&quot;F-Cleaning-Robot&quot;&gt;&lt;a href=&quot;#F-Cleaning-Robot&quot; class=&quot;headerlink&quot; title=&quot;F - Cleaning Robot&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="Atcoder" scheme="http://yexiaorain.github.io/Blog/categories/Atcoder/"/>
    
    
      <category term="排序" scheme="http://yexiaorain.github.io/Blog/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="区间dp" scheme="http://yexiaorain.github.io/Blog/tags/%E5%8C%BA%E9%97%B4dp/"/>
    
      <category term="分组" scheme="http://yexiaorain.github.io/Blog/tags/%E5%88%86%E7%BB%84/"/>
    
      <category term="根号分类" scheme="http://yexiaorain.github.io/Blog/tags/%E6%A0%B9%E5%8F%B7%E5%88%86%E7%B1%BB/"/>
    
      <category term="分类" scheme="http://yexiaorain.github.io/Blog/tags/%E5%88%86%E7%B1%BB/"/>
    
      <category term="问题转化" scheme="http://yexiaorain.github.io/Blog/tags/%E9%97%AE%E9%A2%98%E8%BD%AC%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Atcoder abc218</title>
    <link href="http://yexiaorain.github.io/Blog/2022-08-04-ac_abc218/"/>
    <id>http://yexiaorain.github.io/Blog/2022-08-04-ac_abc218/</id>
    <published>2022-08-03T20:25:14.000Z</published>
    <updated>2022-08-08T00:54:42.979Z</updated>
    
    <content type="html"><![CDATA[<p>G(dp,树,multiset)H(王钦石二分,Alien Trick)</p><h1 id="G-Game-on-Tree-2"><a href="#G-Game-on-Tree-2" class="headerlink" title="G - Game on Tree 2"></a>G - Game on Tree 2</h1><p><a href="https://atcoder.jp/contests/abc218/tasks/abc218_g" target="_blank" rel="noopener">https://atcoder.jp/contests/abc218/tasks/abc218_g</a></p><p>n点, 树, 点i上有数字Ai</p><p>初始 棋子在点1, 交替玩, 每次移动到未访问过的相邻点, 直到无法移动为止</p><p>先手 希望最大化访问过的中位数, 后手希望最小化中位数</p><p>如果他们都最优方案, 求这个中位数</p><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>N 1e5</p><p>Ai [2,1e9]</p><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>既然是树, 相当于1作为根, 走到叶节点结束, 路径上的中位数就是结果</p><p>换句话说, 每个叶节点 可以存储结果</p><p>如果能够算出每个从根到叶的结果, 那么简单的根据深度树上dp就完了(根 同的2倍深度 选最大, 根%2不同深度选最小)</p><p>想到的是相当于从中间剖开,那么dfs维护一个大根堆,一个小根堆,让它们元素个数差最多是1即可</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc218/submissions/33755229" target="_blank" rel="noopener">https://atcoder.jp/contests/abc218/submissions/33755229</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readint A[100010];vector&lt;int&gt; e[100010];template&lt;typename T&gt; using maxSet = multiset&lt;T, greater&lt;T&gt;&gt;;template&lt;typename T&gt; using minSet = multiset&lt;T&gt;;int mid[100010];template&lt;typename T&gt;void balance(maxSet&lt;T&gt; &amp;small,minSet&lt;T&gt; &amp;large){  while(large.size() &gt; small.size()){    small.insert(*large.begin());    large.erase(large.begin());  }  while(small.size() &gt;= large.size() + 2){    large.insert(*small.begin());    small.erase(small.begin());  }}template&lt;typename T&gt;int dfs(int u,int f,maxSet&lt;T&gt; &amp;small,minSet&lt;T&gt; &amp;large, int dep){  // 插入  if(small.size() == 0 || *small.begin() &gt;= A[u]){    small.insert(A[u]);  }else{    large.insert(A[u]);  }  balance(small,large);  int res = 0;  if(u != 1 &amp;&amp; e[u].size() == 1){ // leaf    res = (small.size() == large.size()) ? (*small.begin() + *large.begin())/2 : *small.begin();  }else{    vector&lt;int&gt; vals;    for(auto v:e[u]) if(v != f) vals.push_back(dfs(v,u,small,large,dep^1));    res = (dep==0)? *max_element(vals.begin(),vals.end()) : *min_element(vals.begin(),vals.end());  }  // 删除  auto sptr = small.find(A[u]);  if(sptr != small.end()){    small.erase(sptr);  }else{    auto lptr = large.find(A[u]);    assert(lptr != large.end());    large.erase(lptr);  }  balance(small,large);  return res;}int main(){  int n = read();  rep(i,1,n+1) A[i] = read();  rep(i,1,n){    int u = read();    int v = read();    e[u].pb(v);    e[v].pb(u);  }  maxSet&lt;int&gt; small ; // 前一半  minSet&lt;int&gt; large ;  printf(&quot;%d\n&quot;,dfs(1,1,small,large,0));  return 0;}</code></pre><h1 id="H-Red-and-Blue-Lamps"><a href="#H-Red-and-Blue-Lamps" class="headerlink" title="H - Red and Blue Lamps"></a>H - Red and Blue Lamps</h1><p><a href="https://atcoder.jp/contests/abc218/tasks/abc218_h" target="_blank" rel="noopener">https://atcoder.jp/contests/abc218/tasks/abc218_h</a></p><p>N个灯, 你需要让R个红色,N-R个蓝色</p><p>如果 i 和 i+1 不同色 则有Ai的贡献</p><p>求最大的贡献</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>N 2e5</p><p>R [1,N-1]</p><p>Ai [1,1e9]</p><p>2s</p><p>1024mb</p><h2 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h2><p>显然有个n^2的dp</p><p><code>dp[i][j][c] =</code> 前i个有j个红色,第i个颜色为c,的最大贡献</p><p><code>dp[i][j][red] = max(dp[i-1][j-1][red] , dp[i-1][j-1][blue] + A[i])</code></p><p><code>dp[i][j][blue] = max(dp[i-1][j][red] +A[i], dp[i-1][j][blue])</code></p><p>但肯定超时</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>如果红色比蓝色多, 则交换颜色数量</p><p>那么尽量多的两两不同,显然红色不相邻</p><p>那么把 A[i]+A[i+1] 看作整体</p><p>构造B[i] = A[i]+A[i+1] 数组</p><p>变成在B中选r个不相邻的元素使得总价值最大, 类似的<code>dp[i][j][0/1] =</code>前i个,选了j个,第i个是否选的最大值</p><p><code>dp[i][j][1] = dp[i-1][j-1][0] + B[i]</code></p><p><code>dp[i][j][0] = max(dp[i-1][j][1],dp[i-1][j][0])</code></p><p>复杂度依然不能接受</p><hr><p>但是有简单的性质: 可以王钦石二分</p><h2 id="王钦石二分"><a href="#王钦石二分" class="headerlink" title="王钦石二分"></a>王钦石二分</h2><ol><li>当可选的越多(虽然题目要你求具体的), 那么总收益越大(单增)</li><li>当选的越多, 增量非严格递减凹函数(上凸)</li><li>不限制个数,容器得到最优方案</li></ol><p>反过来, 如果我们指定一个最大收益, 那么可以快速算出需要可选的最少数量</p><p>如果变成二维图,是凹(上凸)函数,</p><p>方法是二分斜率, 对斜率找和凹函数的切点(切线)</p><p>而显然切线在y轴截距最大, <code>f(x) = g(x) - k x</code>, 原函数<code>g(x)</code>, 截距函数<code>f(x)</code></p><p>问题变成 给k, 找最大f(x), 而 g(x) - k x 从另一个角度看, 就是每个值-k 以后选x, 对于x没有限制时, 容易求的话,那就容易得到f(x) 和 x</p><p>求的话因为干掉了一个记录当前有多少个的限制, 从而可以简单dp</p><hr><p>然后…. 我被卡double /long double 了</p><p>现实是,本身斜率就是 每次增量, 答案不会有小数,而切点对切线斜率也是单调影响, 所以,全整数就行了</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc218/submissions/33768310" target="_blank" rel="noopener">https://atcoder.jp/contests/abc218/submissions/33768310</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readint n;ll a[200010];pair&lt;ll,int&gt; f(ll v){ // f(斜率) =&gt; {最大截距, 横坐标(选的个数)}  auto dp = vector(n,vector(2,pair&lt;ll,int&gt;{0,0})); // dp[i][选/不选] = {最大截距,个数}  rep(i,1,n){    auto [y0, c0] = dp[i-1][0];    dp[i][1] = {y0 + (a[i-1] - v), c0 + 1}; // 当前选, 则上一个不选    dp[i][0] = max(dp[i-1][0],dp[i-1][1]); // 当前不选, 则上一个可选可不选  }  return max(dp[n-1][0],dp[n-1][1]);}int main(){  n = read();  int x = read();  x = min(x, n-x);  rep(i,0,n-1) a[i] = read(); // [0..n-2]  rep(i,0,n-1) a[i] += a[i+1]; // [0..n-2], 看成多了末尾多了一个0, 对最大值无影响  ll L = 0, R = 3&#39;000&#39;000&#39;000; // 斜率  while(L + 1 &lt; R) { // 二分, 这里可能 有多个点 让同一个斜率最大, 保证 f(R).pos &lt; x &lt;= f(L).pos 即可    ll mid = (L + R) / 2;    auto [_, pos] = f(mid);    if(pos &lt; x) R = mid;    else L = mid;  }  auto [y,_] = f(L);  ll ans = (ll)(y + x * L);  printf(&quot;%lld\n&quot;, ans);}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>G</p><p>没啥难的</p><p>H</p><p>感觉有的时候还是有点 PE的味道,偏数学一点</p><p>这里涉及 王钦石二分, 也是凸(凹)函数和二分相关的知识</p><p>然后这里double还不行,得long double</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://atcoder.jp/contests/abc218/editorial" target="_blank" rel="noopener">官方题解</a></p><p><a href="https://zhuanlan.zhihu.com/p/340514421" target="_blank" rel="noopener">王钦石二分</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;G(dp,树,multiset)H(王钦石二分,Alien Trick)&lt;/p&gt;
&lt;h1 id=&quot;G-Game-on-Tree-2&quot;&gt;&lt;a href=&quot;#G-Game-on-Tree-2&quot; class=&quot;headerlink&quot; title=&quot;G - Game on Tree
      
    
    </summary>
    
      <category term="Atcoder" scheme="http://yexiaorain.github.io/Blog/categories/Atcoder/"/>
    
    
      <category term="dp" scheme="http://yexiaorain.github.io/Blog/tags/dp/"/>
    
      <category term="二分" scheme="http://yexiaorain.github.io/Blog/tags/%E4%BA%8C%E5%88%86/"/>
    
      <category term="树" scheme="http://yexiaorain.github.io/Blog/tags/%E6%A0%91/"/>
    
      <category term="multiset" scheme="http://yexiaorain.github.io/Blog/tags/multiset/"/>
    
      <category term="王钦石二分" scheme="http://yexiaorain.github.io/Blog/tags/%E7%8E%8B%E9%92%A6%E7%9F%B3%E4%BA%8C%E5%88%86/"/>
    
      <category term="Alien Trick" scheme="http://yexiaorain.github.io/Blog/tags/Alien-Trick/"/>
    
      <category term="凹函数" scheme="http://yexiaorain.github.io/Blog/tags/%E5%87%B9%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>Atcoder abc217</title>
    <link href="http://yexiaorain.github.io/Blog/2022-08-03-ac_abc217/"/>
    <id>http://yexiaorain.github.io/Blog/2022-08-03-ac_abc217/</id>
    <published>2022-08-02T20:25:14.000Z</published>
    <updated>2022-08-08T00:54:42.979Z</updated>
    
    <content type="html"><![CDATA[<p>G(dp)H(凸函数)</p><h1 id="G-Groups"><a href="#G-Groups" class="headerlink" title="G - Groups"></a>G - Groups</h1><p><a href="https://atcoder.jp/contests/abc217/tasks/abc217_g" target="_blank" rel="noopener">https://atcoder.jp/contests/abc217/tasks/abc217_g</a></p><p>有数字1..N</p><p>把它们分成k组(每组至少一个数)</p><p>要求, 每组中没有两个数 mod M 是相等的</p><p>问对于k=1…n 分别有多少方案</p><p>答案 模 998244353</p><p>方案: 如果两方案不同,至少有一个(x,y) 在一个中同组,另一个是不同组</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>n 5000</p><p>2 &lt;= m &lt;= n</p><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>显然 (n - 1) / m + 1 个 mod m = 1 的</p><p>我们也容易计算mod m = r 的有多少个</p><p>然后 计算这个方案数无非是两个方向, 正向算和逆向算</p><p>正向算, 则需要对每个方案唯一标识, 那么考虑用每组中( (value - 1 )mod m, value) 最小的作为组标识</p><p>似乎相互依赖很多, 不知道怎么算</p><p>反向算, 则就是同 mod的放在同一个位置了</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>我感觉自己已经傻掉了, 看到n 5000 竟然没有想一下n方的算法</p><p><code>dp[i][j]</code> 表示前i个数,分成了j组方案</p><p>如果没有同余限制</p><p><code>dp[i][j] = dp[i-1][j-1](单独放在j) + j * dp[i-1][j] (前面i-1已经放了j)</code> 个</p><p>注意到同余的限制</p><p>那么j的放法就是 和它不同余的位置</p><p>已经有 ((i-1) / m)个和它同余了</p><p><code>dp[i][j] = dp[i-1][j-1](单独放在j) + (j-(i-1)/m)保证非负 * dp[i-1][j] (前面i-1已经放了j)</code> 个</p><hr><p>就没了</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc217/submissions/33750183" target="_blank" rel="noopener">https://atcoder.jp/contests/abc217/submissions/33750183</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;#include &lt;atcoder/modint&gt;using mint = atcoder::modint998244353;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;(int)n;i++)int read(){int r;scanf(&quot;%d&quot;,&amp;r);return r;} // readint main() {  int n = read();  int m = read();  vector&lt;vector&lt;mint&gt;&gt; dp(n + 1, vector&lt;mint&gt; (n + 1));  dp[0][0] = 1;  rep(i,1,n+1){    rep(j,1,i+1) { // j-(i-1)/m &gt;= 0      dp[i][j] = dp[i-1][j-1];      if(j-(i-1)/m &gt;= 0) dp[i][j] += dp[i-1][j] * (j-(i-1)/m);    }  }  rep(i,1,n+1) printf(&quot;%d\n&quot;,dp[n][i].val());  return 0;}</code></pre><h1 id="H-Snuketoon"><a href="#H-Snuketoon" class="headerlink" title="H - Snuketoon"></a>H - Snuketoon</h1><p><a href="https://atcoder.jp/contests/abc217/tasks/abc217_h" target="_blank" rel="noopener">https://atcoder.jp/contests/abc217/tasks/abc217_h</a></p><p>初始在点0, 每秒可以-1,0,+1</p><p>N次事件: 在ti时刻, 若在Xi左侧且Di = 0,受到和Xi距离的伤害, 若在Xi右侧, 且Di = 1,受到和Xi距离的伤害</p><p>想要受到伤害最小化, 求最小值</p><h2 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h2><p>N 2e5</p><p>ti [1,1e9]</p><p>di 0/1</p><p>Xi [-1e9,1e9]</p><h2 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h2><p>看起来像dp</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>$dp_{i,x} = $ 在Ti分钟 恰好在x 所需要受到的最小伤害, 为了方便认为T0 = 0</p><p>那么</p><p><code>dp[0][0] = 0</code></p><p><code>dp[0][!=0] = INF</code></p><p>若Di = 0, <code>dp[i][x] = min(dp[i-1][y]) + max(0,Xi - x)</code>, 且<code>|y-x| &lt;= T[i] - T[i-1]</code></p><p>若Di = 1, <code>dp[i][x] = min(dp[i-1][y]) + max(0,x - Xi)</code>, 且<code>|y-x| &lt;= T[i] - T[i-1]</code></p><p>很明显直接算会TLE</p><hr><p>对于一个具体的i, 在二维平面上画点$(x,dp_{i,x})$, 其中横坐标范围是$[-T_i,T_i]$, 然后用线段连起来, 发现是个凸函数(下凸)</p><p>证明: 若对于i-1是下凸函数, 注意到<code>min(dp[i-1][y])</code> 依然是凸函数, 而<code>max</code>部分也是凸函数,所以对于<code>i</code> 也是凸函数</p><hr><p>因此问题变成维护那些拐点</p><p>每次min的操作,相当于把最小值的区间 向两侧 平移<code>T[i]-T[i-1]</code></p><p>注意到 最初是[0,0], 其实就是把区间最左和最有移动到<code>-Ti</code>和正<code>Ti</code></p><p>然后每次+max, 相当于一段不变, 一段 斜率+1, 还可能产生新的节点</p><p>如何维护呢?</p><p>注意到每次 min的过程核心等于向两侧平移, 如果以 和<code>-Ti</code>,<code>Ti</code>的距离来看, 甚至是没有变化</p><p>每次 +max, 是区间内斜率增加1, 那不妨直接记录 斜率1的起始点,斜率2的起始点, 斜率3的起始点( 可能会有重合, 这些点和左侧的距离, 和右侧的距离</p><hr><p> -3 -2 -1 0 1 2 3 这样的斜率区间</p><p> 如果加上 0 1 的</p><p> 最终会变成  -3 -2 -1 0 1 2 3 4 这样的, 虽然可能有起点重合(斜率区间长度为0</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc217/submissions/33754555" target="_blank" rel="noopener">https://atcoder.jp/contests/abc217/submissions/33754555</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readpriority_queue&lt;ll&gt; ql; //大根堆,左侧, 记录斜率-1的起点,-2的起点,-3的起点,...到 -Ti的距离priority_queue&lt;ll&gt; qr; //大根堆,右侧, 记录斜率 1的起点, 2的起点, 3的起点,...到  Ti的距离int main() {  int n = read();  ll ans = 0;  rep(i, 1, n+1) {    ll t = read();    ll d = read();    ll x = read();    // 让下凸的最小值一直是0    if (d == 0) {      if (x &gt; t) { // 超出范围直接全部都加上        ans += x - t;        x = t;      }      if (qr.empty() || qr.top() &lt;= t-x) { // 不影响右侧的        ql.push(x + t);// 原来-1变-2, -2变-3,... , 新的-1的起点      } else { // ... -3 -2 -1  0 ... 0 1 2 3 ... 影响右侧的,        int pos = t - qr.top(); // 最小值的位置 右侧1斜率的起点        qr.pop();        ans += x - pos; // 让下凸的最小值 = 0        ql.push(pos-(-t)); // 成为左侧新的 -1 斜率的起点        qr.push(t - x); // 插入新的 斜率变化分割(距离右侧Ti      }    } else { // d = 1      if (x &lt; -t) { // 超出范围直接全部都加上        ans += -t - x;        x = -t;      }      if (ql.empty() || x - (-t) &gt;= ql.top()) { // 不影响左侧        qr.push(t - x); // 右侧最大点      } else {        int pos = ql.top() - t; // 最小值的位置, 左侧-1斜率的起点        ql.pop();        ans += pos-x;        qr.push(t-pos);        ql.push(x-(-t));      }    }  }  printf(&quot;%lld\n&quot;, ans);  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>G</p><p>干啊, n方dp都想不到了,我</p><p>据说有数学的 N log N 的方法</p><p>H</p><p>知识点就是凸函数, 但是变化点较少时, 只需要维护这些点即可</p><p>然后维护的时候, 想办法保持尽可能多的不变量, 让变化记录是常数级别</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://atcoder.jp/contests/abc217/editorial" target="_blank" rel="noopener">官方题解</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;G(dp)H(凸函数)&lt;/p&gt;
&lt;h1 id=&quot;G-Groups&quot;&gt;&lt;a href=&quot;#G-Groups&quot; class=&quot;headerlink&quot; title=&quot;G - Groups&quot;&gt;&lt;/a&gt;G - Groups&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://atcode
      
    
    </summary>
    
      <category term="Atcoder" scheme="http://yexiaorain.github.io/Blog/categories/Atcoder/"/>
    
    
      <category term="dp" scheme="http://yexiaorain.github.io/Blog/tags/dp/"/>
    
      <category term="凸函数" scheme="http://yexiaorain.github.io/Blog/tags/%E5%87%B8%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>POJ 3169</title>
    <link href="http://yexiaorain.github.io/Blog/2022-08-02-poj3169/"/>
    <id>http://yexiaorain.github.io/Blog/2022-08-02-poj3169/</id>
    <published>2022-08-01T20:25:14.000Z</published>
    <updated>2022-08-08T00:54:42.979Z</updated>
    
    <content type="html"><![CDATA[<p>cow game, 差分约束</p><h1 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h1><p><a href="http://poj.org/problem?id=3169" target="_blank" rel="noopener">http://poj.org/problem?id=3169</a></p><p>数轴上放N个点(按照i的顺序坐标非严格单调递增</p><p>10000 个大于限制, 点i和点j距离不超过 di (1e6)</p><p>10000 个小于限制, 点i和点j距离不小于 di (1e6)</p><p>1s</p><p>64MB</p><p>求点1 和 点N的最大距离</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>传说中日本众所周知的的cow game</p><p>也就是 全部小于号, (大于号同乘-1)</p><p>注意到上面要保证i的顺序( 所以 大-小 &lt;= Di 或者 大减小 &gt;= Di</p><p>然后说 差分约束本质上还是 最短路 只是需要建图</p><p>b-a &lt;= d</p><p>转化成 a + d &gt;= b, 所以 a -&gt; b如果有边长d的话, 那么b的距离最小就是 a+d 还可能更小</p><p>b-a &gt;= d的话</p><p>转化成 b-d &gt;= a, 也就是 b -&gt; a 如果有边长 (-d), 那么a的距离最小是 b-d, 还可能更小</p><p>总而言之转化成</p><p>点0 + ? &gt;= 点1 的形式, 然后从点0 发一条长? 的边</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="过不了编译版本"><a href="#过不了编译版本" class="headerlink" title="过不了编译版本"></a>过不了编译版本</h3><p>这poj g++版本太老了</p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (int i=a;i&lt;n;i++)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readconst int INF = 0x3f3f3f3f; // 1e9vector&lt;array&lt;int,3&gt; &gt; e; // 有向边 [u,v,weight/length]int main(){  int N = read();  int ML = read();  int MD = read();  // 建图  rep(i,1,N) e.push_back({i+1, i, 0}); // 从i+1-&gt;i权值为0的边 保证顺序i的距离不大于i+1  rep(i,0,ML){ //&#39;喜欢&#39;关系约束 &lt;= DL    int a = read();    int b = read(); // 保证 b&gt;a    int d = read(); // |距离| &lt;= DL[i]    /* b-a&lt;=d, 即 a+d&gt;=b 从a到b权值为d的边 */    e.push_back({a,b,d});  }  rep(i,0,MD){ //&#39;不喜欢&#39;关系约束 &gt;= DD    int a = read();    int b = read(); // 保证 b&gt;a    int d = read(); // |距离| &gt;= DD[i]    /* BD - AD &gt;= DD 即 BD - DD &gt;= AD,  从BD到AD权值-DD的边*/    e.push_back({b,a,-d});  }  // Bellman_Ford  vector&lt;int&gt;dist(N+1,INF);// 最短距离  dist[1] = 0;  //循环N-1次 对所有边进行松弛操作  rep(i,0,N-1) for(auto [u,v,w]: e) if(dist[u] != INF) dist[v] = min(dist[v], dist[u] + w);  //再遍历一次所有边（第N次循环）如果本次有更新，则存在负环  bool ngloop = false;  for(auto [u,v,w]: e) if(dist[u] != INF &amp;&amp; dist[u] + w &lt; dist[v] ) ngloop = true;  int ans = dist[N];  if (ngloop) ans = -1;  else if(ans == INF) ans = -2;  printf(&quot;%d\n&quot;, ans);  return 0;}</code></pre><h3 id="AC-版本"><a href="#AC-版本" class="headerlink" title="AC 版本"></a>AC 版本</h3><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define mt make_tuplell read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readconst int INF = 0x3f3f3f3f; // 1e9// 没有tuplestruct edge{  int u;  int v;  int w;  // 结构体直接赋值也没有  edge(int _u,int _v,int _w){    u = _u;    v = _v;    w = _w;  }};vector&lt;edge&gt; e; // 有向边 [u,v,weight/length]int main(){  int N = read();  int ML = read();  int MD = read();  // 建图  rep(i,1,N) e.push_back(edge(i+1, i, 0)); // 从i+1-&gt;i权值为0的边 保证顺序i的距离不大于i+1  rep(i,0,ML){ //&#39;喜欢&#39;关系约束 &lt;= DL    int a = read();    int b = read(); // 保证 b&gt;a    int d = read(); // |距离| &lt;= DL[i]    /* b-a&lt;=d, 即 a+d&gt;=b 从a到b权值为d的边 */    e.push_back(edge(a,b,d));  }  rep(i,0,MD){ //&#39;不喜欢&#39;关系约束 &gt;= DD    int a = read();    int b = read(); // 保证 b&gt;a    int d = read(); // |距离| &gt;= DD[i]    /* BD - AD &gt;= DD 即 BD - DD &gt;= AD,  从BD到AD权值-DD的边*/    e.push_back(edge(b,a,-d));  }  // Bellman_Ford  vector&lt;int&gt;dist(N+1,INF);// 最短距离  dist[1] = 0;  //循环N-1次 对所有边进行松弛操作  rep(t,0,N-1) rep(i,0,e.size()){    edge &amp;uvw = e[i]; // 不支持auto    int u = uvw.u;    int v = uvw.v;    int w = uvw.w;    if(dist[u] != INF) dist[v] = min(dist[v], dist[u] + w);  }  //再遍历一次所有边（第N次循环）如果本次有更新，则存在负环  bool ngloop = false;  rep(i,0,e.size()){    edge &amp;uvw = e[i]; // 不支持auto    int u = uvw.u;    int v = uvw.v;    int w = uvw.w;    if(dist[u] != INF &amp;&amp; dist[u] + w &lt; dist[v] ) ngloop = true;  }  int ans = dist[N];  if (ngloop) ans = -1;  else if(ans == INF) ans = -2;  printf(&quot;%d\n&quot;, ans);  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>就是如何对差分变成图</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;cow game, 差分约束&lt;/p&gt;
&lt;h1 id=&quot;Layout&quot;&gt;&lt;a href=&quot;#Layout&quot; class=&quot;headerlink&quot; title=&quot;Layout&quot;&gt;&lt;/a&gt;Layout&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://poj.org/problem?
      
    
    </summary>
    
      <category term="poj" scheme="http://yexiaorain.github.io/Blog/categories/poj/"/>
    
    
      <category term="差分约束" scheme="http://yexiaorain.github.io/Blog/tags/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/"/>
    
  </entry>
  
  <entry>
    <title>Atcoder abc216</title>
    <link href="http://yexiaorain.github.io/Blog/2022-08-01-ac_abc216/"/>
    <id>http://yexiaorain.github.io/Blog/2022-08-01-ac_abc216/</id>
    <published>2022-07-31T20:25:14.000Z</published>
    <updated>2022-08-08T00:54:42.979Z</updated>
    
    <content type="html"><![CDATA[<p>G(贪心,差分约束,最短路)H(LGV引理,状压dp)</p><h1 id="G-01Sequence"><a href="#G-01Sequence" class="headerlink" title="G - 01Sequence"></a>G - 01Sequence</h1><p><a href="https://atcoder.jp/contests/abc216/tasks/abc216_g" target="_blank" rel="noopener">https://atcoder.jp/contests/abc216/tasks/abc216_g</a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc216/submissions/33727628" target="_blank" rel="noopener">https://atcoder.jp/contests/abc216/submissions/33727628</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;(int)n;i++)int read(){int r;scanf(&quot;%d&quot;,&amp;r);return r;} // readconst int N=200000;int a[N+10]; // a[空白个数] = 到右侧点, 之间全是1int r[N+10]; // 读入int y[N+10]; // 左侧0个数vector&lt;int&gt; l2i[N+10]; // 左端点到第i个区间int main() {  int n = read();  int m = read();  rep(i,1,m+1){    int l = read();    r[i] = read();    y[i] = (r[i]-l+1) - read(); // 左侧0个数 [[....yi],1,1,1,1,1,1]    l2i[l].push_back(i);  }  int cnt = 0; // 遍历过程中 (&lt;l) 0 的个数  rep(pos,1,n+1){ // 下标    for(auto i:l2i[pos]) a[y[i]+cnt] = max(a[y[i]+cnt],r[i]);// [pos.....r[i]]    printf(&quot;%d &quot;, a[cnt] &gt;= pos); // 这一段全是1, 1尽量向右,贪心塞0    cnt += (a[cnt] &lt; pos); // 计数+1  }  return 0;}</code></pre><h1 id="H-Random-Robots"><a href="#H-Random-Robots" class="headerlink" title="H - Random Robots"></a>H - Random Robots</h1><p>数轴上k个机器人, 初始位置分别在xi</p><p>每次 每个机器人独立选择 移动(正向+1)或不动 1/2 概率</p><p>问经过N次,过程中没有任何两个robot 同时在同位置的概率</p><p>mod 998244353</p><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>k [2,10]</p><p>n 1000</p><p>xi [0,1000], 严格单增提供</p><p>2s</p><p>1024mb</p><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>一般来说 概率 = 次/总次数 可以互相转化</p><p>不相遇 可以 和相遇的容斥互相转化</p><p>k 10 的话可能和k的bitmask有关系</p><p>如果进行一次</p><p>而碰撞比不碰撞似乎好算一些</p><p>而且一般是相邻碰撞</p><p>pi 和pi+1 在t次时刻碰撞</p><p>意味着 t-1 次时距离1, t时 1/4 概率</p><p>0~t-1 时刻每次 1/4 +1, 1/4 -1, 1/2 不变</p><p>设原来距离 为d</p><p>那么 -1 次数 减去 +1 次数 = d-1, 且中间不能有负数情况</p><p>变成后缀个数统计问题</p><p>似乎可以强行算出t时刻 的概率, 实在组合排列不行, <code>dp[时刻1000][距离2000]</code> 来算也可以</p><hr><p>那么无碰撞 = 所有 - 碰撞</p><p>所以想办法容斥掉碰撞</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>用一下LGV引理相关的思路: 相交的路径 总有转化方法,成对的出现互为相反数的贡献,从而有相交的内容贡献和为0</p><p>每一个路径组方案贡献1 乘上-1的最终位置的逆序列数量次方, 其实就像当于LGV中所有边权为1 的特殊情况</p><p>$\sum_{Q} (-1)^{\sigma(Q)}\cdot(\frac{1}{2})^{NK}\cdot\prod_{i=1}^K {\rm C}(N,Q_i-x_i)$</p><p>也就是 方案 * (-1) 的幂次权, 再除以总方案数</p><p>Qi 为初始第i个机器人最终的下标</p><p>$\sigma(Q)$ 为逆序对个数</p><p>那么对于一条具体的有交的路径, 找其编号最小交点, 其中最小的起始位置,做后置路径交换(和LGV一样), 那么将得到一个新的路径组,有同样的交点,最小交点的最小起始位置依然相同, 但逆序对数变化为1, 所以总贡献为0</p><hr><p><code>f[S][j] =</code> 选起点集合在S中, 最终节点最大值 &lt;= j 的 带权 方案数和</p><p><code>ans = f[{1,...,k}][x[k] + n]</code></p><p>考虑状态转移</p><p>最终最大节点 &lt; j, <code>f[S][j] += f[S][j-1]</code></p><p>最终最大节点 = j, <code>f[S][j] += lgv中的行列式值 展开最后一列</code></p><p>所以有</p><p>$f(S, j) = f(S, j-1) + \sum_{i=1}^{|S|} (-1)^{|S|+i} e(x_{s_i}, j) f(S\setminus{s_i}, j-1).$</p><p>$f(S, j) = f(S, j-1) + \sum_{i=1}^{|S|} (-1)^{|S|+i} \binom{n}{j-x_{s_i}} f(S\setminus{s_i}, j-1).$</p><p>状态$2^k(n + x_k - x_1)$, 转移倍数$k$</p><p>总时间复杂度 $2^kk(n + x_k - x_1)$</p><hr><p>注意到j仅依赖于j-1, 所以可以滚动数组降低空间</p><p>而S依赖于的都是S子集, 所以保证顺序即可</p><p>$for(j) \\ f(S) = f(S) + \sum_{i=1}^{|S|} (-1)^{|S|+i} \binom{n}{j-x_{s_i}} f(S\setminus{s_i}).$</p><p>注意到这里的i不是X数组的i而是X选出的x按照顺序组成的S中的i, 且是1-index</p><p>也可以表示成$d(S,i) = S$中比$i$大的的个数</p><p>$for(j) \\ f(S) = f(S) + \sum_{i=1}^{|S|} (-1)^{d(S,i)} \binom{n}{j-x_{s_i}} f(S\setminus{s_i}).$</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc216/submissions/33737388" target="_blank" rel="noopener">https://atcoder.jp/contests/abc216/submissions/33737388</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;#include &lt;atcoder/modint&gt;using mint = atcoder::modint998244353;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readint x[2010]; // 初始位置mint f[2010] = {1}; // f[i] = binom(n,i)int p[(1&lt;&lt;10)+10]; // p[mask] = (-1)^(mask中1的个数)mint dp[(1&lt;&lt;10)+10] = {1}; // 第二维滚动 f(S,pos) = f(S, pos-1) + \sum_{i=1}^{|S|} (-1)^{count(S,&gt; i)} \binom{n}{pos-x_{s_i}} f(S\setminus\{s_i\}, pos-1).$int main() {  int k=read();  int n=read();  rep(i,0,k) x[i]=read();  rep(i,1,n+1) f[i]=f[i-1]*(n-i+1)/i; // binom(n,i-1) -&gt; binom(n,i)  rep(mask,0,1&lt;&lt;k) p[mask] = p[mask&gt;&gt;1] * (mask&amp;1?-1:1);  rep(pos,x[0],x[k-1]+n+1){ // 第二维滚动    per(mask,0,1&lt;&lt;k) { // 第一维 bitmask 注意顺序      rep(i,0,k) if(mask&amp;(1&lt;&lt;i)) { // 变成递推贡献, 要增加的bit位        if(x[i]&lt;=pos &amp;&amp; pos&lt;=x[i]+n) { // 保证 binom 不为0          // f(S) += f(S\i) * binom(n, pos - x[S_i]) * (-1)^count(S,&gt;i)          dp[mask] += dp[mask^(1&lt;&lt;i)] * f[pos-x[i]] * p[mask&gt;&gt;(i+1)];        }      }    }  }  printf(&quot;%d\n&quot;,(dp[(1&lt;&lt;k)-1] / ((mint)2).pow(k*n)).val()); // 频次/总次数 = 概率  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>G</p><p>贪心完全不会</p><p>题解说有个cow game</p><p>有一些 dj-di &lt;= wij 的限制</p><p>寻找最大的 dT-dS, 可以变成最短路问题</p><p><a href="http://poj.org/problem?id=3169" target="_blank" rel="noopener">http://poj.org/problem?id=3169</a></p><p>H</p><p>学了一下LGV引理, 和其思路细节</p><p>路径不相交问题首选逆序对容斥，那么可以套用 LGV 引理</p><p>相关练习: <a href="https://www.luogu.com.cn/problem/P7736" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P7736</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://atcoder.jp/contests/abc216/editorial" target="_blank" rel="noopener">官方题解</a></p><p><a href="https://yexiaorain.github.io/Blog/2022-07-22-LGVlemma/">LGV引理</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;G(贪心,差分约束,最短路)H(LGV引理,状压dp)&lt;/p&gt;
&lt;h1 id=&quot;G-01Sequence&quot;&gt;&lt;a href=&quot;#G-01Sequence&quot; class=&quot;headerlink&quot; title=&quot;G - 01Sequence&quot;&gt;&lt;/a&gt;G - 01Sequenc
      
    
    </summary>
    
      <category term="Atcoder" scheme="http://yexiaorain.github.io/Blog/categories/Atcoder/"/>
    
    
      <category term="贪心" scheme="http://yexiaorain.github.io/Blog/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="差分约束" scheme="http://yexiaorain.github.io/Blog/tags/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/"/>
    
      <category term="最短路" scheme="http://yexiaorain.github.io/Blog/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
      <category term="LGV引理" scheme="http://yexiaorain.github.io/Blog/tags/LGV%E5%BC%95%E7%90%86/"/>
    
      <category term="状压dp" scheme="http://yexiaorain.github.io/Blog/tags/%E7%8A%B6%E5%8E%8Bdp/"/>
    
  </entry>
  
  <entry>
    <title>Atcoder abc215</title>
    <link href="http://yexiaorain.github.io/Blog/2022-07-31-ac_abc215/"/>
    <id>http://yexiaorain.github.io/Blog/2022-07-31-ac_abc215/</id>
    <published>2022-07-30T20:25:14.000Z</published>
    <updated>2022-08-08T00:54:42.979Z</updated>
    
    <content type="html"><![CDATA[<p>G(概率论,组合数,期望,贡献统计)H(二分图,霍尔定理,SOSDP,子集反演)</p><h1 id="G-Colorful-Candies-2"><a href="#G-Colorful-Candies-2" class="headerlink" title="G - Colorful Candies 2"></a>G - Colorful Candies 2</h1><p>N 个 有色糖果,第i个颜色c[i]</p><p>从中选K个有 binom(N,K)种方案</p><p>等概率选一种方案</p><p>价值=所选的颜色的不同的数量</p><p>对于每个 k= 1…N 求期望价值</p><p>mod 998244353</p><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>N 5e4</p><p>c[i]  [1,1e9]</p><p>4s</p><p>1024mb</p><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>首先只关心不同值,显然c[i]可以离散化到[1..N]</p><p>答案 = sum{价值} / binom(N,K)</p><p>不同颜色互不影响</p><p>所以 选了j种颜色, 一共k个, 如果能算方案出来 f(j), 那么答案 = sum j * f(j)</p><p>指定的 c[…] 中选的话</p><p>似乎可以卷积</p><p>去表示每个颜色 选t个的方案数, 然后卷积意义是前 j 种颜色(可能有的不选) 选k个的方案数</p><p>好像无法获得选了几个颜色</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>反过来, 也就是每个颜色出现一次的概率 的贡献和</p><p>P(出现一次) = 1-P(一次都不出现)</p><p>binom(n-x,k) / binom(n,k) , 也就是x 是这个颜色的个数</p><p>其中 n-x &lt; k 的话, 必定出现p = 1</p><p>(binom(n,k) - binom(n-x,k))/binom(n,k) , 也就是x 是这个颜色的个数</p><p>可以减少计算</p><p>注意到 可以统计个数为x的有多少个, 这样最多 $\sqrt(N)$个统计</p><p>因此对于k来讲,是$O(\sqrt{N})$的</p><p>总的便是$O(N^{\frac{3}{2}})$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc215/submissions/33712411" target="_blank" rel="noopener">https://atcoder.jp/contests/abc215/submissions/33712411</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;#include &lt;atcoder/all&gt;using mint = atcoder::modint998244353;using namespace std;typedef long long ll;const int MOD = 998244353;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readint c[50010];mint fac[50010] = {1};mint invv[50010] = {0,1};mint invfac[50010] = {1};mint binom(int n,int m){  if(m &gt; n) return 0;  return fac[n] * invfac[m] * invfac[n-m];}int main(){  int n = read();  rep(i,0,n) c[i] = read();  rep(i,1,n+1) fac[i] = fac[i-1] * i;  invv[1] = 1;  rep(i,2,n+1) invv[i] = (MOD - MOD/i) * invv[MOD%i];  rep(i,1,n+1) invfac[i] = invfac[i-1] * invv[i];  sort(c,c+n);  vector&lt;int&gt; sz = {1};  rep(i,1,n){    if(c[i] != c[i-1]){      sz.push_back(1);    }else{      sz.back()++;    }  }  sort(sz.begin(),sz.end());  vector&lt;pair&lt;int,int&gt;&gt; sc; // size count  int cnt = 0;  rep(i,0,sz.size()){    cnt++;    if(i+1 == (int)sz.size() || sz[i] != sz[i+1]){      sc.push_back({sz[i],cnt});      cnt = 0;    }  }  rep(k,1,n+1){    mint bnk = binom(n,k);    mint ans = bnk * sz.size() ;    for(auto [s,t]:sc) {      if(n-s &lt; k) break; // n-s &lt; k 的话, 必定出现p = 1      ans -= binom(n-s,k) * t; // * 次数    }    ans /= bnk;    printf(&quot;%d\n&quot;,ans.val());  }  return 0;}</code></pre><h1 id="G-Cabbage-Master"><a href="#G-Cabbage-Master" class="headerlink" title="G - Cabbage Master"></a>G - Cabbage Master</h1><p>N种菜,每种 A[i] 个</p><p>M个需求, 每个需求B[i] 个, 但是限制<code>c[i][j] = 0/1</code> 表示第i个需求 是否允许得到 第j种菜</p><p>如果 能满足所有需求则 成功</p><p>现在要尽量少的删除一些菜的个数, 让它无法成功</p><p>并且求, 删除同样数量的方案数  mod 998244353</p><h2 id="限制-1"><a href="#限制-1" class="headerlink" title="限制"></a>限制</h2><p>n 20</p><p>m 1e4</p><p>a[i] 1e5</p><p>b[i] 1e5</p><p>3s</p><p>1024mb</p><h2 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h2><p>一眼感觉网络流, 但是看着这n这么少</p><p>又觉得说 会不会是 maskdp</p><p>2^20 = 1048576, 大概1e6</p><hr><p>网络流思路</p><p>就是 S -&gt; Ini 流量 A[i]</p><p>Ini -&gt; Outj 流量无限 如果<code>c[i][j] == 1</code></p><p>Outj -&gt; T 流量B[i]</p><p>那么目标是让最小割(最大流) &lt;= sum B[i] 即可</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>二分图</p><p>左侧N个颜色, 右侧M个需求</p><p>注意到 这里成功对应的是 匹配 = sum 右侧</p><p>所以是枚举右侧的的点集,看对应左侧的点集是否大于等于右侧</p><p>左侧L, 右侧R</p><p>要能完美匹配 $\forall S \subset R $</p><p>左侧对应集合并的和 $\ge S$对应需求的和</p><p>即 min (左侧对应集合并的和 - S对应需求的和) &gt;= 0</p><hr><p>n=20, 考虑枚举左侧的并,来找右侧的max</p><p>但似乎通过枚举子集可能有m 2^n 复杂度</p><p>但实际上我们要的是</p><p>min {f(L0) - g(L0)} &gt;= 0, 其中f 算的集合里左侧的和, g 算的映射到左侧包含于集合的右侧的值的和 (既然B[i] 都是正的,那就是所有的加起来让g达到最大</p><p>g中计算 子集和可以sosdp 高维前缀和</p><p>那么删除数量X = min( f(L0) - g(L0)) + 1</p><hr><p>然后问题变成如何计算方案数</p><p>ans = 0 , 不操作1种</p><p>对于ans &gt; 0</p><p>设 左侧移除的X的值 来自的点集合恰好为S</p><p>当存在 S1 满足 S 是 S1 的子集, 且 f(L0) - g(S1) + 1 == X, 这时 S移除X的方案数h(S) 会有贡献</p><p>binom(S的个数,X) = sum h(T), T 是S的子集</p><p>这就是 子集反演问题</p><p>$h(S) = \sum (-1)^{|S|-|T|} binom(T的个数,X)$, T是S的子集</p><p>又是求子集的函数和, 那么这里把和原集合有关的移动一下</p><p>$(-1)^{|S|} {h(S)} = \sum (-1)^{|T|} \binom{f(T)}{X}$, T是S的子集</p><p>同样FWT, SOSDP可以处理</p><h2 id="霍尔-Hall-定理"><a href="#霍尔-Hall-定理" class="headerlink" title="霍尔(Hall)定理"></a>霍尔(Hall)定理</h2><p>二分图 左侧n点 右侧 m 点, n&lt;= m</p><p>二分图的最大匹配个数=|n| 的充要条件, 左侧点n的任意大小(=k)的子集连到右图的点的个数都满足&gt;=k</p><p>必要性, 因为最大匹配=|n|,所以存在一个方案, 任意左侧子集(=k)的方案对应右侧的点都是k, 所以连接的一定 &gt;= k</p><p>充分性, 归纳法, 显然 n = 1时 成立</p><p>如果n时成立</p><p>对于n+1个点</p><p>假设存在k(&lt;=n)个左侧点对应可达右侧刚好是k个, 那么存在一组匹配</p><p>注意到左侧 n+1对应 右侧&gt;=n+1, 那么从左右分别去掉上面的k个</p><p>那么左侧n+1-k, 右侧 &gt;=n+1-k, 归纳有方案</p><hr><p>如果上述不存在, 则所有k(&lt;=n)个左侧 对应的是 &gt;= k+1个右侧</p><p>那么 任意取一个匹配, 那么剩下的n个左点对应的右点 &gt;= k 个, 所以归纳成立</p><h2 id="子集反演"><a href="#子集反演" class="headerlink" title="子集反演"></a>子集反演</h2><p>$g(S) = \sum f(T)$, T是S的子集合</p><p>$f(S) = \sum (-1)^{|S| - |T|} g(T)$ , T是S的子集合</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc215/submissions/33719233" target="_blank" rel="noopener">https://atcoder.jp/contests/abc215/submissions/33719233</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;#include &lt;atcoder/all&gt;using mint = atcoder::modint998244353;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readconst ll INF = 0x3f3f3f3f; // &gt; 1e9const int N = 20;const int MASK = ( 1 &lt;&lt; N ) ;const int M = N * 100000;mint fac[M+10] = {1}; // 阶乘mint ifac[M+10] ={1}; // 阶乘的逆向int f[MASK+10]; // f[1 &lt;&lt; i] = A[i], f[mask] = sum Aint g[MASK+10]; // g[左侧mask] = sum B , 通过sosdp 变成子集和mint h[MASK+10]; // h(S=bitmask) S中移除 X 个的方案数,(每个恰好一个)int cnt[MASK+10]; // mask 中1的个数int cont[MASK+10]; // cont[mask] = 多少个父集合 是满足 最小代价为X的 在mask中移除让Hall定理触发不满足int B[M+10]; // 读入int adj[M+10]; // adj[右侧] = 左侧的bitmaskmint binom( int n, int m ) { return n &lt; m ? 0 : fac[n] * ifac[m] * ifac[n - m]; }int main() {  rep(i,1,M+1) fac[i] = fac[i - 1]*i;  ifac[M] = fac[M].inv();  per(i,0,M) ifac[i] = ifac[i + 1]*(i + 1);  int n = read();  int m = read();  rep(i,0,n)f[1 &lt;&lt; i]=read();//f[1 &lt;&lt; i]=A[i]  rep(j,0,m)B[j]=read();  rep(i,0,n)rep(j,0,m) if(read())adj[j]|=1 &lt;&lt; i; // 转换成mask  rep(j,0,m)g[adj[j]] += B[j]; // g[对应左侧mask] += B[j]  rep(mask,1,1 &lt;&lt; n) cnt[mask] = cnt[mask &gt;&gt; 1] + ( mask &amp; 1 ); // 计算1个数  rep(mask,1,1 &lt;&lt; n) f[mask] = f[mask&amp;(-mask)] + f[mask&amp;(mask-1)]; // 去掉最后一个1 和最后一个1的mask之和  rep(pwr,0,n) rep(mask,1,1 &lt;&lt; n) if(mask &amp; (1 &lt;&lt; pwr)) g[mask] += g[mask ^ (1 &lt;&lt; pwr)]; // sosdp 高维前缀和  rep(mask,0,1 &lt;&lt; n) if(!g[mask]) g[mask] = -INF; // 右侧没有集合对应左侧集合是mask的子集合  int X = INF; // 答案第一部分 删除个数  rep(mask,1,1 &lt;&lt; n) X = min(X,f[mask]-g[mask]+1 ); // Hall定理, min(左子集值和 - 右侧来源子集和)  if(max(X,0) == 0) { // 本来就不合法    printf( &quot;0 1\n&quot; );    return 0;  }  // h&#39;(S) = (-1)^|S| h(S) = sum (-1)^|T| binom(f[t], X) SOSDP  rep(mask,1,1 &lt;&lt; n) h[mask] = binom(f[mask], X) * (cnt[mask] &amp; 1 ? -1 : 1);  rep(pwr,0,n) rep(mask,0,1 &lt;&lt; n) if(mask &amp; (1 &lt;&lt; pwr)) h[mask] += h[mask ^ (1 &lt;&lt; pwr)];  rep(mask,0,1 &lt;&lt; n) h[mask] = h[mask] * ((cnt[mask] &amp; 1)?-1:1);  // SOSDP 父集合反演(本质上还是 子集反演, 你只是把每个mask 看成mask的取反即可, 最外层是pwr顺序, mask每次之间没有链式依赖,都是两两依赖, 所以mask不需要换顺序  rep(mask,1,1 &lt;&lt; n) if( f[mask] - g[mask] + 1 == X ) cont[mask] = 1;  rep(pwr,0,n) rep(mask,0,1 &lt;&lt; n) if(mask &amp; (1 &lt;&lt; pwr)) cont[mask ^ (1 &lt;&lt; pwr)] += cont[mask]; // 统计父集合可行的次数  mint ans = 0;  rep(mask,0,1 &lt;&lt; n) if(cont[mask]) ans += h[mask];  printf(&quot;%d %d\n&quot;,X, ans.val());  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>G</p><p>其实还算基础知识点, 如何批量算模拟元,批量阶乘和阶乘模逆元,如何基于它们快速bionom</p><p>然后就是概率统计变形状和相同次数统计变成$\sqrt{N}$</p><p>评分 2267 也差不多</p><p>H</p><p>二分图,霍尔(Hall)定理</p><p>二分图一定程度上, 就不在意初始设计的方向了,  因为是匹配, 内部是没有关系的</p><p>霍尔定理对于这种大于1流量的也适用(因为从本质上看 左/右侧最多k个, 无非是k个点, 有无穷大边, 无非是这些拆开后的左右侧按照原来的关系两两有边, 而这个思路是不是特殊题型还能反过来思考)</p><p>这种”任意”的条件，可以考虑是在哪个部分将它破坏的</p><p>还涉及到 子集反演(以及用子集反演完成父集合反演)</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://atcoder.jp/contests/abc215/editorial" target="_blank" rel="noopener">官方题解</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;G(概率论,组合数,期望,贡献统计)H(二分图,霍尔定理,SOSDP,子集反演)&lt;/p&gt;
&lt;h1 id=&quot;G-Colorful-Candies-2&quot;&gt;&lt;a href=&quot;#G-Colorful-Candies-2&quot; class=&quot;headerlink&quot; title=&quot;G - 
      
    
    </summary>
    
      <category term="Atcoder" scheme="http://yexiaorain.github.io/Blog/categories/Atcoder/"/>
    
    
      <category term="图" scheme="http://yexiaorain.github.io/Blog/tags/%E5%9B%BE/"/>
    
      <category term="dp" scheme="http://yexiaorain.github.io/Blog/tags/dp/"/>
    
      <category term="scc" scheme="http://yexiaorain.github.io/Blog/tags/scc/"/>
    
      <category term="网络流" scheme="http://yexiaorain.github.io/Blog/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
      <category term="二分图" scheme="http://yexiaorain.github.io/Blog/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    
      <category term="排列" scheme="http://yexiaorain.github.io/Blog/tags/%E6%8E%92%E5%88%97/"/>
    
      <category term="容斥" scheme="http://yexiaorain.github.io/Blog/tags/%E5%AE%B9%E6%96%A5/"/>
    
      <category term="环" scheme="http://yexiaorain.github.io/Blog/tags/%E7%8E%AF/"/>
    
      <category term="费用流" scheme="http://yexiaorain.github.io/Blog/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/"/>
    
      <category term="霍尔定理" scheme="http://yexiaorain.github.io/Blog/tags/%E9%9C%8D%E5%B0%94%E5%AE%9A%E7%90%86/"/>
    
      <category term="SOSDP" scheme="http://yexiaorain.github.io/Blog/tags/SOSDP/"/>
    
      <category term="子集反演" scheme="http://yexiaorain.github.io/Blog/tags/%E5%AD%90%E9%9B%86%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
  <entry>
    <title>Atcoder abc214</title>
    <link href="http://yexiaorain.github.io/Blog/2022-07-30-ac_abc214/"/>
    <id>http://yexiaorain.github.io/Blog/2022-07-30-ac_abc214/</id>
    <published>2022-07-29T20:25:14.000Z</published>
    <updated>2022-08-08T00:54:42.979Z</updated>
    
    <content type="html"><![CDATA[<p>G(排列,图,容斥,dp,环)H(scc,网络流,费用流)</p><h1 id="G-Three-Permutations"><a href="#G-Three-Permutations" class="headerlink" title="G - Three Permutations"></a>G - Three Permutations</h1><p><a href="https://atcoder.jp/contests/abc214/tasks/abc214_g" target="_blank" rel="noopener">https://atcoder.jp/contests/abc214/tasks/abc214_g</a></p><p>给[1..N]的排列p和q</p><p>求多少个排列r 满足 r[i] != p[i] , r[i] != q[i], i = [0..N]</p><p>mod 1e9+7</p><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>n 3000</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h3><p>如果只是给一个排列p</p><p>要找另一个排列r让每个位置对应不等(r[i] != p[i])</p><p>一个想法是, 把它直接按照p[i]的1到n重新排序</p><p>问题变成了 找r[i] != i的排列方案数</p><p>考虑长度n的和n-1之间变化</p><p>如果i放的n,而n放的i ,那么 去掉i和n, 方案数 为f(n-2)</p><p>n 有 n-1中交替放的方案, (n-1) f(n-2)</p><p>如果i放的n,而n放的不是i, 那么,交换i和n放的, 前n-1也合法, f(n-1)</p><p>f(n-1) 每个方案每个位置和n换, 贡献(n-1)f(n-1)</p><p>f(n) = (n-1)(f(n-1) + f(n-2))</p><p>f(1) = 0</p><p>f(2) = 1</p><p>f(3) = 2(1+0) = 2</p><hr><p>那么对于两个序列</p><p>首先一样的思路按照p 来排序</p><p>那么变成 r[i] != q[i], r[i] != i</p><p>但因为q[i]的限制并不能 像上面那样转移</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>如果对于每个位置,计算ri=pi或ri=qi的排列方案数,可以考虑容斥</p><p>假设 i1,i2,…ik, 对应的下标满足, ri=pi 或 ri=qi, 那么要计算所有r[i1],r[i2]..r[ik]的值方案</p><p>对于每个 i in i[1..k],在图中,我们增加一个(pi,qi)的边, 只需计算每条边分配给其一个端点的总数，以便没有两条不同的边共享一个分配给它的顶点。(意思就是边即是i, 而给边分配的点,即是r[i]的值, 不能共享点,意味着值不重复</p><p>(注意到 如果(pi,qi)链接的话, 只可能是 链 或 环,不可能出现分叉</p><p>对于每个联通分量考虑(除去孤立点和自环)</p><p>因为环之间两两不相关, 所以每一组i的选择答案 = 不同环的方案的乘积</p><p>我们对于一个K个点的环内, 选了k条边, 的方案数</p><p>当所有边被选(所有的i都有相等关系), 那么有2种方案</p><p>不是全部都选, 考虑把环剖成链讨论首尾是否选择</p><hr><p><code>dp[i][j][s0=0/1/2][si=0/1/2]</code> 表示前i条边,选择了j条, 且第一条是s0 状态,第i条是si状态的方案数</p><p>0: 未选择</p><p>1: 该边分配了左点</p><p>2: 该边分配了右点</p><p>状态转移</p><p>不选 <code>dp[i][j][s0][0] = sum dp[i-1][j][s0][0..2]</code></p><p>向左 <code>dp[i][j][s0][1] = sum dp[i-1][j-1][s0][0..1]</code></p><p>向右 <code>dp[i][j][s0][2] = sum dp[i-1][j-1][s0][0..2]</code></p><p>这样最后长n的环选了k条链的总方案数 就是<code>sum dp[n][k][s0][s1], 且 (s0 != 1 || s1 != 2)</code></p><p>记为<code>circle[n][k]</code></p><hr><p>如果gi 表示 指定了i个不合法的选择, 剩余的n-i个任意选(可以合法也可以不合法,但始终满足是排列)</p><p>那么 $ans = \sum_{i=0}^n (-1)^i(n-i)! g_i$</p><hr><p>而gi也可以通过上面环的结果, 去做dp</p><p><code>f[i][k] =</code> 前i个环指定了k个边 的方案数</p><p><code>f[i][k] = sum{f[i-1][k-t] * circle[sz[i]][t]}</code> 前i个环指定了k个边 的方案数</p><hr><p>于是把所有环剖成链连续放在数组上</p><p><code>g[i][j][s0][s1]</code> = 前i边,指定分配了j条, i所在环的起始是s0,结束是s1的方案数, 这里也是把s0也与i做相关意义了</p><p>转移类似, 分别是跨环转移 和 环内转移</p><hr><p>感觉这题还可以改控制最大环长, 但增大总长度, 变成矩阵乘法</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc214/submissions/33643608" target="_blank" rel="noopener">https://atcoder.jp/contests/abc214/submissions/33643608</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;#include &lt;atcoder/all&gt;using namespace std;using mint = atcoder::modint1000000007;#define rep(i,a,n) for (int i=a;i&lt;(int)n;i++)int read(){int r;scanf(&quot;%d&quot;,&amp;r);return r;} // readconst int N = 3000;int p[N+10];int q[N+10];int e[N+10]; // 单向边int vis2[N+10]; // 每个环的结束位置 = 1, 例如环为 2 3 5, 那么 [2]=1,[2+3=5]=1,[5+5=10]=1, 自环结束位置=2// 0 不分配, 1 分配左点, 2分配右点mint g[N+10][N+10][3][3]; // [i][j][s0][si] 每个环剖成链以后,长度i的链 分配了j条, 当前环 首个点state 0, 最后一个点stateimint fac[N+10]; // n!int main() {  int n=read();  fac[0]=1;  rep(i,1,n+1) fac[i]=fac[i-1]*i;  rep(i,0,n) p[i] = read();  rep(i,0,n) e[p[i]] = q[i] = read(); // 建立边 p,q =&gt; e  { // e =&gt; vis2    vector&lt;bool&gt; vis(n+1,false); // 点是否被访问    int m = 0;    rep(i,1,n+1) if(!vis[i]){      if(e[i]==i) { // 自环        vis2[++m]=2;        continue;      }      for(int j=i;!vis[j];j=e[j]) {        vis[j]=1;        m++;      }      vis2[m]=1;    }  }  g[0][0][0][0] = 1; // 初始状态  vis2[0] = 1;       // 初始状态  rep(i,0,n+1) rep(j,0,i+1){ // 剖成链, 前i个边, 指定j个不合法, 第i个点所在环首个点s0,第i个点s1状态    if(vis2[i]) { // 环结束位置      g[i][j][1][2] = 0; // 环首为向左环尾向右      if(vis2[i]==2) g[i][j][1][1]=0; // 自环, 不选是一种, 选左和选右相同, 去掉一个      rep(k,0,3) rep(l,0,3) { // i+1 是新的环        auto v = g[i][j][k][l];        g[i+1][j  ][0][0] += v; // 新环 本身与i 无关, 应该是1,这里相当于全部乘上前面的倍数        g[i+1][j+1][1][1] += v;        g[i+1][j+1][2][2] += v;      }    } else { // 环内      rep(k,0,3) rep(l,0,3){        auto v = g[i][j][k][l];        g[i+1][j  ][k][0] += v;        g[i+1][j+1][k][1] += ((l == 2) ? 0 : v); // 不能下一个向左 这一个向右        g[i+1][j+1][k][2] += v;      }    }  }  mint res = 0;  rep(i,0,n+1) {    mint cnt = 0; // 方案数    rep(j,0,3) rep(k,0,3) cnt += g[n][i][j][k];    res += fac[n-i]*cnt*(i%2?-1:1); // 容斥  }  printf(&quot;%d&quot;,res.val());  return 0;}</code></pre><h1 id="H-Collecting"><a href="#H-Collecting" class="headerlink" title="H - Collecting"></a>H - Collecting</h1><p><a href="https://atcoder.jp/contests/abc214/tasks/abc214_h" target="_blank" rel="noopener">https://atcoder.jp/contests/abc214/tasks/abc214_h</a></p><p>有向图 N点, M边</p><p>xi个东西在点i上</p><p>k个人一个一个遍历graph</p><p>1开始, 遍历有限长度, 找最大可被收集的东西个数</p><h2 id="限制-1"><a href="#限制-1" class="headerlink" title="限制"></a>限制</h2><p>n2e5, m 2e5</p><p>k 10</p><p>xi [1..1e9]</p><p>4s</p><p>1024mb</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h3><p>显然 可以scc缩点, 然后问题变成 一个有向无环图</p><p>找k(&lt;=10)条路径, 被经过的点的和最大</p><p>这没啥想法了</p><p>例如</p><p>a-&gt;b-&gt;c</p><p>a-&gt;b-&gt;d</p><p>a-&gt;e-&gt;d</p><p>a-&gt;e-&gt;f</p><p>一次选择的贪心 是否对全局也是最好的?</p><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>果然也是先scc变成DAG</p><p>然后这里是最小费用流问题</p><ol><li>DAG每个点拆成out,in, 增加源S和汇T</li><li>DAG中每个u, 增加 in[u] -&gt; out[u], 流量1, 费用-val<a href="首次经过点">u</a>, 以及无限(K)流量费用0</li><li>DAG中(u,v)变成 out[u] -&gt; in[v] , 流量无限(K), 费用0</li><li>S -&gt; in[1] 容量k, 费用0 ( 这里可以简化成去掉S, 1 作为S, 通过 in[1] -&gt; out[1] 总容量k 来保证最大流 = K</li><li>out[u] -&gt; T 容量无限(k), 费用0</li></ol><p>求min cost max flow , 答案乘上 -1</p><p>我看atcoder的库是可以限制最大流的求 mincost</p><hr><p>然后这样做的话 代价有些是负的</p><p>办法是</p><ol><li>DAG中每个u, in[u] -&gt; out[u], 流量1费用0, 流量无限(费用val[u])</li><li>DAG中(u,v), out[u] -&gt; in[v], 无限流量, 费用sum X[u+1..v-1]</li><li>out[u] -&gt; T, 无限流量, 代价sum X[u+1..N]</li></ol><p>ans = s-&gt;t 流=K 的最小代价 - K * sum X</p><hr><p>原理</p><p>本质上希望每个流的代价增加 sum X</p><p>那么整体形式就是 从 in[u0] -&gt; out[u0] -&gt; in[v1] -&gt; out[v1] -&gt; T</p><p>希望  每次到out[u] 的时候, 费用和的增量是 前缀和X[0..u], 这样每个 out[u] -&gt; T, 只需要是X[0..n] - X[0..u] 即可</p><p>那么自然 out[u]-&gt; in[v] -&gt; out[v]</p><p>这一整段增加为 X[0..v] - X[0..u] // 保证拓扑序 来让它非负? atcoder的scc返回保证了逆向拓扑序!!</p><p>那么, 这里设计 in[v] -&gt; out[v] 增加X[v]</p><p>所以 out[u] -&gt; in[v] 增加 X[0..v] - X[0..u] - X[v]</p><hr><p>它这个没有拓扑似乎也保证不了 cost非负?</p><p>保证的是没有负环!?</p><p>注意因为没有S所以 链增加的是 X[0..n] - X[0..start]</p><h3 id="费用流-mcmf"><a href="#费用流-mcmf" class="headerlink" title="费用流 mcmf"></a>费用流 mcmf</h3><p>费用流, 每个边有流量限制和每单位费用</p><p>最大流最小费 = 最短路</p><p>最大流最大费 = 最长路</p><p>满足正向单位费用的相反数 = 逆向单位费用</p><p>最小费用以流量的单价作为边权值跑最短路，注意因为不会有负环（否则费用是负无限大）所以用SPFA就可以了</p><p>如果增广路中出现了负环，那么在上一次选择中一定有一条更短的路径。(如果开始就有负环呢？ 那么它说明你图建错了</p><p>最小费用流, 就是在做最大流的时候, 把dfs改成 spfa, 而距离= 路径上单位cost代价之和</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p><a href="https://atcoder.jp/contests/abc214/submissions/33655383" target="_blank" rel="noopener">https://atcoder.jp/contests/abc214/submissions/33655383</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;#include &lt;atcoder/scc&gt;#include &lt;atcoder/mincostflow&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readint main() {  int N = read();  int M = read();  int K = read();  vector&lt;int&gt; A(M), B(M);  atcoder::scc_graph graph(N); // 0-index 点  rep(i,0,M){    A[i] = read() - 1; // 0-index    B[i] = read() - 1;    graph.add_edge(A[i], B[i]);  }  const vector&lt;vector&lt;int&gt;&gt; scc = graph.scc(); // 连通块 atcoder的scc返回还保证了逆拓扑序  const int V = scc.size(); // DAG节点个数  vector&lt;int&gt; belongs(N); // [节点] = 所在块  rep(i,0,V) for(int u : scc[i]) belongs[u] = i;  vector&lt;ll&gt; X(V); // 新图每个点上的值  rep(i,0,N) X[belongs[i]] += read();  vector&lt;ll&gt; accum(V + 1, 0); // 前缀和  rep(i,0,V) accum[i + 1] = accum[i] + X[i];  atcoder::mcf_graph&lt;int, ll&gt; network(2 * V + 1); // in[1]变成 S, T = 2*V  int S = 2*belongs[0];  int T = 2*V;  rep(i,0,V) {    network.add_edge(2 * i, 2 * i + 1, 1, 0); // in[i] -&gt; out[i], 容量1, 费用 -X[i] + X[i]    network.add_edge(2 * i, 2 * i + 1, K, X[i]); // in[i] -&gt; out[i], 容量K(无穷), 费用 0 + X[i]    network.add_edge(2 * i + 1, 2 * V, K, accum[V] - accum[i + 1]); // out[i] -&gt; T 费用 0 + All - X[0..i]  }  rep(i,0,M) {    int u = belongs[A[i]];    int v = belongs[B[i]];    if (u != v) network.add_edge(2 * u + 1, 2 * v, K, accum[v] - accum[u + 1]); // out[u] -&gt; in[v] , 容量k, 费用 0 + X[0..v] - X[0..u]  }  auto [maxflow, mincost] = network.flow(S,T,K/* 限流 */);  printf(&quot;%lld\n&quot;,(accum[V] - accum[belongs[0]]) * K - mincost);}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>G</p><p>容斥还是不熟 感觉这个式子需要记忆 $ans = \sum_{i=0}^n (-1)^i c_i$</p><p>然后这个排列会构成多个环感觉很常用虽然知道, 但是这里通过边表示i, 分配点表示取值还是没有想到, 感觉也是一种转化思路</p><p>然后环拆成链+两头也是很经典的方法了</p><p>实现上把 环变成链 再在数组上连续性, 去做dp的方法, 比多重再算g更神奇</p><p>另外这里递推贡献更新时没有保证正确性, 有的在处理时才修复正确性 比如<code>[1][2]</code> 和自环</p><p>H</p><p>网络流完全不会, 学了一手费用流, 看起来就是正常最大流 变了spfa和 路径cost和</p><p>atcoder 内置的scc 和mincostflow</p><pre><code class="cpp">#include &lt;atcoder/scc&gt;#include &lt;atcoder/mincostflow&gt;</code></pre><p>然后这个神奇的让 所有费用变正的 前缀和变化法 , 感觉其它地方似乎也能用</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://atcoder.jp/contests/abc214/editorial" target="_blank" rel="noopener">官方题解</a></p><p><a href="https://oi-wiki.org/graph/flow/min-cost/" target="_blank" rel="noopener">oi wiki 费用流</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;G(排列,图,容斥,dp,环)H(scc,网络流,费用流)&lt;/p&gt;
&lt;h1 id=&quot;G-Three-Permutations&quot;&gt;&lt;a href=&quot;#G-Three-Permutations&quot; class=&quot;headerlink&quot; title=&quot;G - Three Permu
      
    
    </summary>
    
      <category term="Atcoder" scheme="http://yexiaorain.github.io/Blog/categories/Atcoder/"/>
    
    
      <category term="图" scheme="http://yexiaorain.github.io/Blog/tags/%E5%9B%BE/"/>
    
      <category term="dp" scheme="http://yexiaorain.github.io/Blog/tags/dp/"/>
    
      <category term="scc" scheme="http://yexiaorain.github.io/Blog/tags/scc/"/>
    
      <category term="网络流" scheme="http://yexiaorain.github.io/Blog/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
      <category term="排列" scheme="http://yexiaorain.github.io/Blog/tags/%E6%8E%92%E5%88%97/"/>
    
      <category term="容斥" scheme="http://yexiaorain.github.io/Blog/tags/%E5%AE%B9%E6%96%A5/"/>
    
      <category term="环" scheme="http://yexiaorain.github.io/Blog/tags/%E7%8E%AF/"/>
    
      <category term="费用流" scheme="http://yexiaorain.github.io/Blog/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>Atcoder abc261</title>
    <link href="http://yexiaorain.github.io/Blog/2022-07-29-ac_abc261/"/>
    <id>http://yexiaorain.github.io/Blog/2022-07-29-ac_abc261/</id>
    <published>2022-07-28T20:25:14.000Z</published>
    <updated>2022-08-08T00:54:42.979Z</updated>
    
    <content type="html"><![CDATA[<p>G(dp, 字符串),H/Ex(图,dp,拓扑排序,dij,拆点)</p><h1 id="G-Replace"><a href="#G-Replace" class="headerlink" title="G - Replace"></a>G - Replace</h1><p>字符串S,T包含小写英文</p><p>可以执行k种 操作, 任意次 任意顺序</p><p>第i种 操作: 1代价, 把一个字符Ci 换成 字符串Ai</p><p>问S变成T 的最小代价 或不可能</p><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>|S|&lt;=|T| &lt;= 50</p><p>k &lt;= 50</p><p>|Ai| &lt;= 50</p><p>2s</p><p>1024mb</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h3><p>既然是字符(离散)换成字符串</p><p>那么岂不是 <code>dp[i][j]</code> 表示 S前i 个换成 T前j个</p><p><code>dp[i][j]</code> = <code>dp[i-1][j-k]</code>, <code>s[i] -&gt; T[j-k+1..j]</code> 可行</p><p>那么问题是如何判断可行</p><p>换句话说, 如果我们能算出 <code>T[j-k+1..j]</code> 能否逆向变成<code>s[i]</code> 也是办法</p><p>但是感觉这个会分叉很多</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p><code>dp[i][j][c]</code> = 最小代价<code>T[i..j] =&gt; 字符 c</code></p><p><code>f[i][j][k][l]</code> = 最小代价<code>T[i..j]</code> =&gt; 字符串 <code>A[k][1..l]</code> (这个很关键, 是把字符中前缀设置成状态)</p><pre><code>for i = N -&gt; 1:  for j = i -&gt; N:    计算 f[i][j][k][l], f[i][j][c], f[i][j][k][1]</code></pre><hr><p>计算<code>f[i][j][k][l]</code> 时 (<code>T[i..j] =&gt; A[k][1..l]</code>)</p><p>注意到替换时顺序不会变相当于</p><p>时 (<code>T[i.m][m+1.j] =&gt; A[k][1..l-1] A[k][l]</code>)</p><p>$f[i][j][k][l] = min(f[i][m][k][l-1] + dp[m+1][j][A[k][l]])$</p><hr><p>计算<code>dp[i][j][c] / f[i][j][k][1]</code></p><ol><li>本身就是c字符, i==j, Ti = c, 0</li><li>一步到位 <code>T[i..j] = A[k], C[k] = c</code></li><li>先转换到某个<code>A[k]</code> 再转一步, <code>min(f[i][j][k][|A[k]|]+1),C[k] = c</code></li></ol><p><code>f[i][j][k][1]</code> 从<code>dp[i][j][A[k][1]]</code> 中读即可</p><hr><p>这大概是O(n^4)的状态</p><p><code>O(n^5)</code> 的转移复杂度</p><hr><p>这其中还有一个问题是, 对于A和C都是单个字符的, 你会出现<code>T[i...j] -&gt; c0 -&gt; c1 -&gt; c2</code></p><p>你需要求最短路dij/spfa松弛 即可</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc261/submissions/33608140" target="_blank" rel="noopener">https://atcoder.jp/contests/abc261/submissions/33608140</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;(int)n;i++)#define per(i,a,n) for (int i=n;i--&gt;(int)a;)int read(){int r;scanf(&quot;%d&quot;,&amp;r);return r;} // readconst int INF = 0x3f3f3f3f; // 无穷大const int maxc = &#39;z&#39; - &#39;a&#39;; // 最大字符对应数字vector&lt;int&gt; t;int f[60][60][60][60]; // [l..r] =&gt; a[k][0...i] (prefix(a[k][i]))int dp[60][60][30]; // [l..r] =&gt; char cint c[60] = {maxc + 1}; // 不存在的字符vector&lt;int&gt; a[60]; // c[i] -&gt; a[i];vector&lt;pair&lt;int,int&gt; &gt; c2c; // 单字符映射char tmp[60];int lcStr2VecInt(vector&lt;int&gt; &amp; res){ // lower case string to vector&lt;int&gt;  scanf(&quot;%s&quot;, tmp);  int sz = strlen(tmp);  res.resize(sz);  rep(i,0,sz) res[i] = tmp[i] - &#39;a&#39;; // s 放在 c[0],a[0]  return sz;}void setMin(int &amp;v0,int v1){v0 = min(v0,v1);}int main(){  int ns = lcStr2VecInt(a[0]); // s 放在 c[0],a[0]  int nt = lcStr2VecInt(t); // t  int K = read() + 1; // 包含s  rep(i,1,K){    scanf(&quot;%s&quot;, tmp);    c[i] = tmp[0] - &#39;a&#39;;    if(lcStr2VecInt(a[i]) == 1) c2c.push_back({c[i], a[i][0]});  }  rep(l,0,nt) {    rep(r,l,nt) { // 全部设置为无穷大      rep(k,0,K) rep(i,0,50) f[l][r][k][i] = INF;      rep(c,0,maxc+1) dp[l][r][c] = INF;    }    dp[l][l][t[l]] = 0; // 本身就是字符  }  // --- init ---  per(l,0,nt) rep(r,l,nt){ // T[l..r], 各种顺序都行 保证依赖关系先被运算    rep(k,0,K){      int sz = a[k].size();      rep(i,1,sz){ // T[l..j][j+1..r] = &gt; a[k][0..i-1],a[k][i]        int &amp;v = f[l][r][k][i];        rep(j,l,r) setMin(v, f[l][j][k][i-1] + dp[j+1][r][a[k][i]]);        if(i == sz - 1) setMin(dp[l][r][c[k]], v + 1); // T[i..j] =&gt; a[k] =&gt; c[k]      }    }    // dp[l][r][c]=min(dp[l][r][k][|a[k]|]) + 1 = min(len &gt; 1(上面算了), len = 1) + 1, len = |a[k]|    rep(c,0,maxc+1) for(auto [c0, c1]: c2c) setMin(dp[l][r][c0], dp[l][r][c1] + 1); // 26 次 松弛    rep(k,0,K) setMin(f[l][r][k][0], dp[l][r][a[k][0]]); // 更新 f 中首字母  }  int &amp; ans = f[0][nt-1][0][ns-1];  printf(&quot;%d\n&quot;, ans == INF? -1: ans);  return 0;}</code></pre><h1 id="H-Ex-Game-on-Graph"><a href="#H-Ex-Game-on-Graph" class="headerlink" title="H/Ex - Game on Graph"></a>H/Ex - Game on Graph</h1><p>N点, M边</p><p>有向边 [ui,vi,weight i], 无重边 无自环</p><p>初始,点v上有个棋子</p><p>T和A交替游戏</p><ul><li>如果棋子所在点 没有向外路径 则结束游戏</li><li>如果有路径,任选一个走路径</li></ul><p>T 让weight和尽量小, A让和尽量大</p><p>T(结束游戏优先级 &gt; 和尽量小)</p><p>A(让游戏无限循环优先级 &gt; 和尽量大)</p><h2 id="限制-1"><a href="#限制-1" class="headerlink" title="限制"></a>限制</h2><p>N 2e5</p><p>M 2e5</p><p>Wi [0,1e9]</p><p>2s</p><p>1024mb</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h3><p>并不是有环就一定无限, 例如 <code>a-&gt;b-&gt;c-&gt;d-&gt;a</code></p><p>a连了个有限的, c也连了个更短的有限的</p><p>那么虽然你可以走到b,让对手走到c,这样在走到有限的 会比a直接去到有限的更短</p><p>考虑从叶子反过来, 判断是否有限,感觉bfs或者spfa/dij的感觉</p><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>图上环状dp</p><p><code>dp[x][0]</code> 从x出发 尽量小</p><p><code>dp[x][1]</code> 从x出发 尽量大</p><p><code>dp[x][0] = min (f[y][1] + weight[x][y])</code>, 相当于 反向图的最短路</p><p><code>dp[x][1] = max (f[y][0] + weight[x][y])</code>, 需要所有<code>f[y][0]</code> 被计算后才有意义</p><hr><p>然后就反图+拓扑+dij 就没了???</p><p>我感觉这个条件必要, 但总觉得没有证明到充分</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc261/submissions/33603896" target="_blank" rel="noopener">https://atcoder.jp/contests/abc261/submissions/33603896</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readll dp[2][200010];ll mx[200010]; // 只记录1的, 因为0的直接记录在pq和dp中, 而1的在子节点未完全计算时pq和dp都不会记录int deg[200010]; // 正向图出度, 反向图入度vector&lt;pair&lt;int,int&gt; &gt; g[200010]; // 反向图 v = {u, weight}template &lt;typename T&gt; using minPQ = priority_queue&lt;T,vector&lt;T&gt;, greater&lt;T&gt;&gt;; // 小根堆int main(){  int n = read();  int m = read();  int v = read();// 起点  rep(i,0,2) fill(dp[i],dp[i]+n+1,-1); // 未访问  rep(i,0,m) {    int u = read();    int v = read();    int w = read();    g[v].push_back({u, w});    deg[u] ++;  }  minPQ&lt;array&lt;ll,3&gt;&gt; q; // 小根堆, dij 每次找最小的未达点变为可达 {距离, 0/1, 点}  rep(i,1,n+1) if(deg[i] == 0) rep(j,0,2) q.push({0, j, i}); // dp[0/1][i] 反向入度为0 的节点  while(q.size()) {    auto [d, i, u] = q.top(); q.pop();    if(dp[i][u] != -1) continue; // 计算过    dp[i][u] = d; // 更新值    if(!i) { // dp[0][u] -&gt; dp[1][v]      for(auto [v, w] : g[u]) { // 更新反向边 并更新 deg[v] --        mx[v] = max(mx[v], d + w); // 更新值但是 不一定进入pq dp[x][1] = max (f[y][0] + weight[x][y])        if(--deg[v] == 0) q.push({mx[v], 1, v}); // dp[1][v] 只能所有计算都计算后才有意义      }    } else for(auto [v, w] : g[u]) q.push({d + w, 0, v}); // dp[1][u] -&gt; dp[0][v] dij  }  if(dp[0][v] == -1) printf(&quot;INFINITY\n&quot;);  else printf(&quot;%lld\n&quot;, dp[0][v]);  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>G</p><p>大小只有50的情况, <strong>对字符串中的前缀设计状态</strong>, 从而有dp的状态</p><p>第二就是 小的情况 多次松弛简单也效率满足, 不需要上dij</p><p>H/Ex</p><p>我感觉这个条件必要, 但总觉得没有证明到充分???</p><p>可能关键在于,虽然点上有 0/1两个状态,但实际上这两个状态不相关, 所以其实每个点可以拆点</p><p>这样就变成了路径的逆向dp了, 有环一定不行, 所以关键在这个拆点 -&gt; 变成dij</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://atcoder.jp/contests/abc261/editorial" target="_blank" rel="noopener">官方题解</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;G(dp, 字符串),H/Ex(图,dp,拓扑排序,dij,拆点)&lt;/p&gt;
&lt;h1 id=&quot;G-Replace&quot;&gt;&lt;a href=&quot;#G-Replace&quot; class=&quot;headerlink&quot; title=&quot;G - Replace&quot;&gt;&lt;/a&gt;G - Replace&lt;/h1&gt;
      
    
    </summary>
    
      <category term="Atcoder" scheme="http://yexiaorain.github.io/Blog/categories/Atcoder/"/>
    
    
      <category term="图" scheme="http://yexiaorain.github.io/Blog/tags/%E5%9B%BE/"/>
    
      <category term="dp" scheme="http://yexiaorain.github.io/Blog/tags/dp/"/>
    
      <category term="拓扑排序" scheme="http://yexiaorain.github.io/Blog/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    
      <category term="字符串" scheme="http://yexiaorain.github.io/Blog/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="dij" scheme="http://yexiaorain.github.io/Blog/tags/dij/"/>
    
      <category term="拆点" scheme="http://yexiaorain.github.io/Blog/tags/%E6%8B%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>Atcoder abc213</title>
    <link href="http://yexiaorain.github.io/Blog/2022-07-28-ac_abc213/"/>
    <id>http://yexiaorain.github.io/Blog/2022-07-28-ac_abc213/</id>
    <published>2022-07-27T20:25:14.000Z</published>
    <updated>2022-08-08T00:54:42.979Z</updated>
    
    <content type="html"><![CDATA[<p>F(SA,后缀数组,单调栈)G(bitmask, 集合论, 图, dp, 子集遍历),H/Ex(dp, 卷积, fft, NTT, 分治NTT)</p><h1 id="F-Common-Prefixes"><a href="#F-Common-Prefixes" class="headerlink" title="F - Common Prefixes"></a>F - Common Prefixes</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://atcoder.jp/contests/abc213/tasks/abc213_f" target="_blank" rel="noopener">https://atcoder.jp/contests/abc213/tasks/abc213_f</a></p><p>给长n字符串S</p><p>求其每个位置开始的后缀字符串, 和所有其它后缀字符串的 公共前缀和</p><h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h3><p>n 1e6</p><p>3s</p><p>1024mb</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="官方"><a href="#官方" class="headerlink" title="官方"></a>官方</h3><p>知识点 <a href="http://yexiaorain.github.io/Blog/2022-07-27-sa/">后缀数组 SA</a></p><p>那么对于 后缀i</p><p>它在SA中的位置是 rank[i]</p><p>有高度数组表示 rank[i] 和 rank[i-1]的最长公共前缀</p><p>那么就是 min(height[0..i]]) + min(height[1..i]) +… + min(height[i..i]) + (n-i) + min(height[i+1..i+1]) + .. + min(height[i+1..n])</p><p>直接枚举依然不行</p><p>考虑 可以单调栈维护计算其中一半</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc213/submissions/33587517" target="_blank" rel="noopener">https://atcoder.jp/contests/abc213/submissions/33587517</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 1000000007#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_back#define mp make_pairll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readconst int N = 1000000;char s[N+10]; // readint rk[N+10]; // rankint rk0[N+10]; // 临时int h[N+10]; // heightint sa[N+10]; // SAll pre[N+10]; // 前缀和ll suf[N+10]; // 后缀和int main(){  int n = read();  scanf(&quot;%s&quot;, s);  // sa &amp; rank  iota(sa,sa+n,0);  sort(sa,sa+n,[=](int i,int j){return s[i] &lt; s[j];});  rk[sa[0]] = 0;  rep(i,1,n) rk[sa[i]] = rk[sa[i-1]] + (s[sa[i]] != s[sa[i-1]]);  rep(pwr,0,22){    int w = 1&lt;&lt;pwr;    if(w &gt; n) break;    rep(i,0,n) rk0[i] = rk[i];    auto f = [=](int i){return i &lt; n?rk0[i]:-1;};    sort(sa,sa+n,[=](int i,int j){ return mp(f(i),f(i+w)) &lt; mp(f(j),f(j+w));});    rk[sa[0]] = 0;    rep(i,1,n) rk[sa[i]] = rk[sa[i-1]] + (mp(f(sa[i]),f(sa[i]+w)) != mp(f(sa[i-1]),f(sa[i-1]+w)));  }  // height  int hei = 0;  rep(i,0,n){    if(!rk[i]) continue;    if(hei) hei--;    while(s[i + hei] == s[sa[rk[i]-1] + hei]) hei++;    h[rk[i]] = hei;  }  // 单调栈  {    vector&lt;int&gt; stk = {};    rep(i,1,n) {      while(stk.size() &amp;&amp; h[i] &lt; h[stk.back()]) stk.pop_back();      // h[i] * length + stk[]      int last = stk.size() ? stk.back() : 0;      pre[i] = pre[last] + h[i] * (i - last);      stk.push_back(i);    }  }  {    vector&lt;int&gt; stk = {};    per(i,1,n) {      while(stk.size() &amp;&amp; h[i] &lt; h[stk.back()]) stk.pop_back();      // h[i] * length + stk[]      int last = stk.size() ? stk.back() : n;      suf[i] = suf[last] + h[i] * (last - i);      stk.push_back(i);    }  }  rep(i,0,n) printf(&quot;%lld\n&quot;,(n-i) + pre[rk[i]] + suf[rk[i]+1]);  return 0;}</code></pre><h1 id="G-Connectivity-2"><a href="#G-Connectivity-2" class="headerlink" title="G - Connectivity 2"></a>G - Connectivity 2</h1><p><a href="https://atcoder.jp/contests/abc213/tasks/abc213_g" target="_blank" rel="noopener">https://atcoder.jp/contests/abc213/tasks/abc213_g</a></p><p>无向图</p><p>n 点, m 边</p><p>考虑移除任意条边得到新图G, 有 2^M 种新图G</p><p>对于每个点, 计算在所有新图中, 和1属于同一连通块的个数</p><p>mod 9098244353</p><h2 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h2><p>n 17</p><p>无重边,无自环</p><p>3s</p><p>1024mb</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>显然, n&lt;=17 是个bitmask的题</p><p>2^17 = 131072</p><p>定义mask 为点1所在的联通块, 那么其实状态只有2^16 了</p><p>c[mask] = 包含mask的联通块个数</p><p>cnt[mask] = 边的两个端点都属于mask 的数量</p><p>对于剩下m - cnt[Mask] 条边</p><ul><li>如果端点均不在mask中, 则是否选边对mask没有影响,</li><li>如果端点一个在一个不在不在mask中, 则不可选,否则mask会变化</li></ul><p>导出子图(induced subgraph)是指，由该图顶点的一个子集和该图中两端均在该子集的所有边的集合组成的图。</p><hr><p>dp[S] = S构成连通块时, 内部的选的边端点均属于S的方案数</p><p>$dp[S] = 2^{cnt(S)} - \sum_{1\in T, T\subset S} dp[T] \cdot 2^{cnt(S-T)}$</p><p>所有方案 - 非所有点连通的方案(即是一个包含1的非所有点连通块,以及不包含1的连通块内的点的剩余边随便连)</p><hr><p>那么$ans(x) = \sum_{1\in S,x\in S} dp[S] \cdot 2^{cnt(全集 - S)}$</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc213/submissions/33590273" target="_blank" rel="noopener">https://atcoder.jp/contests/abc213/submissions/33590273</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 998244353#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // read// 2^17 =      65&#39;536// 2^17 =     131&#39;072// 3^16 =  43&#39;046&#39;721// 3^17 = 129&#39;140&#39;163const int N = 1&lt;&lt;17;int f[N+10];int c[N+10]; // 边两端 都属于mask 的数量ll p2[150]={1}; // 2**power , 17 * (17-1)/2 = 136ll ans[20];int main(){  rep(i,1,140) p2[i]=2*p2[i-1]%MOD;  int n = read();  int m = read();  // O(m 2^n)  rep(i,0,m){    int u = read() - 1; // 0-index    int v = read() - 1;    rep(mask,0,p2[n]) if((mask &amp; p2[u]) &amp;&amp; (mask &amp; p2[v])) c[mask]++; // 直接统计mask数量  }  rep(S0,0,p2[n-1]){    int S = 2*S0+1; // S一定要选0    f[S] = p2[c[S]]; // f[S] = 2^c[S] - sum{1\in T,T\subset S} f[T] 2^c[S-T]    for(int T0=S0&amp;(S0-1);S0/* 只有点0 没有真子集*/;T0=(T0-1)&amp;S0){// 真子集遍历 记住复杂度是O(3^n)      int T = 2*T0 + 1; // T一定选0      (f[S] -= f[T] * p2[c[S-T]] % MOD) %= MOD;      if(!T0)break;    }    // S包含0,i ; 时间复杂度 O(n 2^n)    rep(i,1,n) if(S &amp; p2[i]) (ans[i] += f[S]*p2[c[p2[n]-1-S]] % MOD) %= MOD;  }  rep(i,1,n) printf(&quot;%lld\n&quot;, (ans[i]+MOD) % MOD);}</code></pre><h1 id="H-Ex-Stroll"><a href="#H-Ex-Stroll" class="headerlink" title="H/Ex - Stroll"></a>H/Ex - Stroll</h1><p><a href="https://atcoder.jp/contests/abc213/tasks/abc213_h" target="_blank" rel="noopener">https://atcoder.jp/contests/abc213/tasks/abc213_h</a></p><p>N个点</p><p>M 个点对, 连接ui,vi, <code>p[i][d]</code>条路 长度d的路, (d [1,T])</p><p>找从点1开始,点1结束,长度等于T的路径方案数</p><h2 id="范围-2"><a href="#范围-2" class="headerlink" title="范围"></a>范围</h2><p>n 10</p><p>m min(10,n(n-1)/2)</p><p>t 4e4</p><p><code>p[1..m][1..T]</code> \in [0,998244353]</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h3><p>一眼递推</p><p><code>f[u][d] =</code>到u步数为T的方案数</p><p>那么每次找未贡献的最小的<code>d</code></p><p><code>f[v][d+step] += p[边[u &lt;-&gt; v]][step] * f[u][d]</code></p><p>但这样$NT$个状态, 每个状态会更新$MT$个点</p><p>看起来有$O(MNT^2)$</p><h3 id="官方-1"><a href="#官方-1" class="headerlink" title="官方"></a>官方</h3><p><code>dp[u][i]=</code> 1 出发, 长度i, 走到u 方案数</p><p>考虑最后一次转移 从v到u, 走t步</p><p>$dp[u][i] = \sum_{(u,v)\in E} \sum_{t=1}^i dp[v][i-t] * p[e_{u,v}][t]$</p><p>直接NTT依然不行</p><p>因为它们相互依赖</p><p>于是来到了分治NTT</p><hr><p>cdq 分治 + NTT/fft 框架</p><pre><code class="cpp">solve(l..r):  solve(l..mid)  // 计算(l..mid) 对(mid+1..r) 的贡献 , 这一部分将是dp[l..mid] 卷积 g[1..(r-l+1)], fft/ntt nlogn  solve(mid+1..r)</code></pre><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc213/submissions/me" target="_blank" rel="noopener">https://atcoder.jp/contests/abc213/submissions/me</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;#include &lt;atcoder/all&gt;using namespace std;using mint=atcoder::modint998244353;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readll n;ll p[20][40010]; // 系数矩阵mint dp[20][40010];vector&lt;pair&lt;int,int&gt;&gt; e[20];// cdq 分治 [l..r],// 每次分治 [l..mid], 计算[l..mid] 对 [mid+1..r]的贡献, 分治[mid+1..r]// 所以卷积代价 convolution([l..mid] x g[1..(r-l+1)]), ntt n log n, 总 =&gt; logn// 意味着每次分治solve(l..r)结束后,(l..r)的内部的贡献计算完了,(r+1...)的贡献完全没有统计void solve(ll l,ll r) {  if(l==r) return;  ll mid=(l+r)/2;  solve(l, mid);  rep(u,1,n+1) for(auto [v,eid]:e[u]) { // 枚举所有点和边    vector &lt;mint&gt; A = {};    vector &lt;mint&gt; B = {0};    // A[l..mid] , T[1..(r-l+1)], dp[i+1] = dp[i-j] * p[j] = A[i-j-l] * B[j] = C[i-l]    rep(i,l,mid+1) A.pb(dp[u][i]);    rep(i,1,(r-l+1)+1) B.pb(p[eid][i]);    auto C = atcoder::convolution(A,B); // 内部小的暴力 大的 fft    rep(i,mid+1,r+1) dp[v][i]+=C[i-l].val();  }  solve(mid+1,r);}int main() {  n = read();  ll m = read();  ll t = read();  rep(i,0,m) {    ll u = read();    ll v = read();    e[u].pb({v,i});    e[v].pb({u,i});    rep(j,1,t+1) p[i][j] = read();  }  dp[1][0] = 1;  solve(0,t);  printf(&quot;%d\n&quot;,dp[1][t].val());  return 0;}// dp[u][i] = sum{(u,v)\in E} sum{t=1..i} dp[v][i-t] * p[e_{u,v}][t]$</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>F</p><p>知识点 后缀数组 与高度数组</p><p>G</p><p>感觉有点集合论转移的思路,没有类似的练习</p><p>然后就是如何做分类和贡献统计, 这里是按照和1连通的作为一个分类的依据</p><p>分别记录内部方案数, 和 外部方案倍数, 外部倍数相对好算, 而内部方案数 需要dp推导</p><p>所有子集遍历的复杂度是$3^n$ 不是$4^n$</p><p>H</p><p>除了dp还可以数学直接表示到目标点, 从而引申出求和 有卷积</p><p>这里新知识点是分治NTT</p><p>atcoder 提供 atcoder::modint998244353, 以及卷积 atcoder::convolution</p><hr><p>关于Ubuntu 使用, 最简单就是, 克隆下来做个软链接</p><pre><code class="bash">git clone git@github.com:atcoder/ac-library.gitcd /usr/local/include/ # 切换到目录sudo ln -s 克隆路径/atcoder</code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://atcoder.jp/contests/abc213/editorial" target="_blank" rel="noopener">官方题解</a></p><p><a href="https://atcoder.jp/contests/abc213/editorial/2410" target="_blank" rel="noopener">https://atcoder.jp/contests/abc213/editorial/2410</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;F(SA,后缀数组,单调栈)G(bitmask, 集合论, 图, dp, 子集遍历),H/Ex(dp, 卷积, fft, NTT, 分治NTT)&lt;/p&gt;
&lt;h1 id=&quot;F-Common-Prefixes&quot;&gt;&lt;a href=&quot;#F-Common-Prefixes&quot; clas
      
    
    </summary>
    
      <category term="Atcoder" scheme="http://yexiaorain.github.io/Blog/categories/Atcoder/"/>
    
    
      <category term="图" scheme="http://yexiaorain.github.io/Blog/tags/%E5%9B%BE/"/>
    
      <category term="fft" scheme="http://yexiaorain.github.io/Blog/tags/fft/"/>
    
      <category term="dp" scheme="http://yexiaorain.github.io/Blog/tags/dp/"/>
    
      <category term="后缀数组" scheme="http://yexiaorain.github.io/Blog/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"/>
    
      <category term="单调栈" scheme="http://yexiaorain.github.io/Blog/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
      <category term="bitmask" scheme="http://yexiaorain.github.io/Blog/tags/bitmask/"/>
    
      <category term="NTT" scheme="http://yexiaorain.github.io/Blog/tags/NTT/"/>
    
      <category term="SA" scheme="http://yexiaorain.github.io/Blog/tags/SA/"/>
    
      <category term="集合论" scheme="http://yexiaorain.github.io/Blog/tags/%E9%9B%86%E5%90%88%E8%AE%BA/"/>
    
      <category term="子集遍历" scheme="http://yexiaorain.github.io/Blog/tags/%E5%AD%90%E9%9B%86%E9%81%8D%E5%8E%86/"/>
    
      <category term="卷积" scheme="http://yexiaorain.github.io/Blog/tags/%E5%8D%B7%E7%A7%AF/"/>
    
      <category term="分治NTT" scheme="http://yexiaorain.github.io/Blog/tags/%E5%88%86%E6%B2%BBNTT/"/>
    
  </entry>
  
  <entry>
    <title>后缀数组 SA</title>
    <link href="http://yexiaorain.github.io/Blog/2022-07-27-sa/"/>
    <id>http://yexiaorain.github.io/Blog/2022-07-27-sa/</id>
    <published>2022-07-27T02:37:14.000Z</published>
    <updated>2022-08-08T00:54:42.979Z</updated>
    
    <content type="html"><![CDATA[<h1 id="相关内容"><a href="#相关内容" class="headerlink" title="相关内容"></a>相关内容</h1><p>后缀自动机</p><h1 id="最终产物"><a href="#最终产物" class="headerlink" title="最终产物"></a>最终产物</h1><p>一个数组sa 记录下标, 按照后缀字典序排序</p><p>以及需要的话一个记录rank的数组(和sa相反)</p><p><img src="https://oi-wiki.org/string/images/sa1.png" alt="后缀数组"></p><p>h[i] 表示排名为i的和排名为i-1的最长公共前缀长度</p><h1 id="SA"><a href="#SA" class="headerlink" title="SA"></a>SA</h1><p>就是字符串所有后缀, 按照字典序排序</p><p>就是先按照每个位置开始长度为1排序, 变成数值顺序</p><p>再按照长度2的前缀顺序排, 但是此时 不需要原字符串,而直接用算出的数值顺序拼接</p><p>再按照长度4的前缀顺序排, 同上 相当于两个 长度2 的拼接</p><pre><code>for step =&gt; 2 * step:  rank = sort(pair&lt; rank[i],rank[i+step] &gt;)</code></pre><h2 id="例如代码"><a href="#例如代码" class="headerlink" title="例如代码"></a>例如代码</h2><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 1000000007#define rep(i,a,n) for (ll i=a;i&lt;n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backconst int N = 1000000;bool eq(vector&lt;int&gt;&amp; rk, int x,int y,int w){  return rk[x] == rk[y] &amp;&amp; rk[x+w] == rk[y+w];}// 0-index + 基数排序void calcsa(char *s,int n, vector&lt;int&gt; &amp;sa,vector&lt;int&gt; &amp;rk){  const int SIZE = max(512, n+1); // 字符集大小  vector&lt;int&gt;cnt(SIZE, 0); // char 2 count  rk.resize(2*n); // rank: 相等的前缀rank相等, 结束符rank = 0, 所以rank从1开始  sa.resize(n); // 后缀 index  rep(i,0,n) ++cnt[rk[i] = s[i]]; // 计数统计  rep(i,1,SIZE) cnt[i] += cnt[i - 1]; // 计数统计前缀  per(i,0,n) sa[--cnt[rk[i]]] = i; // 当前排序  { // n == 1    auto oldrk = rk;    int p = 0;    rep(i,0,n) {      if (i == 0 || oldrk[sa[i]] != oldrk[sa[i-1]]) p++;      rk[sa[i]] = p;    }  }  // rk = sort({rk[i],rk[i+w]}  for(int w = 1; w &lt; n; w *= 2) {    // 从低位到高位排序, 先排低位 rank[i+w], 再排 rank[i+0]    for(auto d:{w, 0}){      cnt = vector(SIZE,0);      rep(i,0,n) ++cnt[rk[i + d]]; // 所有 i+d 开始的计数统计      rep(i,1,SIZE) cnt[i] += cnt[i - 1];// 前缀和(基数排序      auto idx = sa;      per(i,0,n) sa[--cnt[rk[idx[i] + d]]] = idx[i]; // 保序    }    auto oldrk = rk;    int p = 0;    rep(i,0,n) {      if (i == 0 || oldrk[sa[i]] != oldrk[sa[i-1]] || oldrk[sa[i]+w] != oldrk[sa[i - 1] + w]) p++;      rk[sa[i]] = p;    }  }  rk.resize(n+1);}int main() {  char s[N+10] = &quot;aabaaaab&quot;;  int n = strlen(s) ;  printf(&quot;%d\n&quot;,n);  printf(&quot;%s\n&quot;,s);  vector&lt;int&gt; sa;  vector&lt;int&gt; rank;  calcsa(s, n, sa, rank);  rep(i,0,n) printf(&quot;%d &quot;, sa[i]);  return 0;}</code></pre><h2 id="height-数组"><a href="#height-数组" class="headerlink" title="height 数组"></a>height 数组</h2><p>而h数组, 首次相等的则 = 1</p><p>h[i] = lcp(sa[i],sa[i-1])</p><p>性质</p><p>h[rk[i]] &gt;= h[rk[i-1]] - 1</p><p>设后缀i-1 = “aAB”, a字符,A是h[i-1]对应字符串剩余部分,B是后缀的剩余部分</p><p>那么后缀i = “AB”</p><p>因为后缀i-1 = “aAB” 其实存在 “aAC”, “C &lt; B”, 且”C,B”公共前缀为空字符串</p><p>那么也就说明”AC”也存在</p><p>“AC”, “AB” 之间 如果还有其他的字符串,只能是”AD”形式 “C &lt; D &lt; B”, 那么长度至少为”|A|”, 得证</p><p>所以 可以按照i的顺序暴力算</p><pre><code class="cpp">int k = 0;rep(i,0,n) {  if (rk[i] == 0) continue;  if (k) --k;  while (s[i + k] == s[sa[rk[i] - 1] + k]) ++k;  h[rk[i]] = k;}</code></pre><h2 id="vector-sort-pair版本"><a href="#vector-sort-pair版本" class="headerlink" title="vector + sort + pair版本"></a>vector + sort + pair版本</h2><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 1000000007#define rep(i,a,n) for (ll i=a;i&lt;n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_back// 0-index + vector + sort// sa 下标按照顺序排列// rank 下标对应顺序index// h sa 中相邻后缀 最长公共前缀 h[0] = 0;template&lt;class T&gt;void calc_sa_rank(vector&lt;T&gt;&amp; arr, vector&lt;int&gt; &amp;sa,vector&lt;int&gt; &amp;rank, vector&lt;int&gt;&amp;h){  int n = arr.size();  rank = vector&lt;int&gt;(n,0);  sa = vector&lt;int&gt;(n,0);  iota(sa.begin(),sa.end(), 0);  sort(sa.begin(),sa.end(), [=](int i,int j){return arr[i] &lt; arr[j];});  rep(i,1,n) rank[sa[i]] = rank[sa[i-1]] + !(arr[sa[i]] == arr[sa[i-1]]);  for(int w = 1; w &lt; n; w *= 2) {    auto rank0 = rank;    auto rk = [=](int i){return i &lt; n ? rank0[i] : -1;};    sort(sa.begin(),sa.end(), [=](int i,int j){        return rk(i) != rk(j) ? rk(i) &lt; rk(j) : rk(i+w) &lt; rk(j+w);    });    rank[sa[0]] = 0;    rep(i,1,n) rank[sa[i]] = rank[sa[i-1]] + !(rk(sa[i]) == rk(sa[i-1]) &amp;&amp; rk(sa[i]+w) == rk(sa[i-1]+w));  }  // height  h = vector&lt;int&gt;(n,0);  int k = 0;  rep(i,0,n) {    if (rank[i] == 0) continue;    if (k) --k;    while (arr[i + k] == arr[sa[rank[i] - 1] + k]) ++k;    h[rank[i]] = k;  }}int main() {  char s[100] = &quot;aabaaaab&quot;;  int n = strlen(s) ;  printf(&quot;s:%s\n&quot;,s);  vector&lt;char&gt; arr ;  rep(i,0,n) arr.pb(s[i]);  vector&lt;int&gt; sa;  vector&lt;int&gt; rank;  vector&lt;int&gt; h;  calc_sa_rank(arr, sa, rank, h);  printf(&quot;sa:\n&quot;);  rep(i,0,n) printf(&quot;%d %s\n&quot;, sa[i], s + sa[i]);  printf(&quot;\nrk:\n&quot;);  rep(i,0,n) printf(&quot;%d %s\n&quot;, rank[i], s + i);  printf(&quot;\nhei:&quot;);  rep(i,0,n) printf(&quot;%d &quot;, h[i]);  printf(&quot;\n&quot;);  return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;相关内容&quot;&gt;&lt;a href=&quot;#相关内容&quot; class=&quot;headerlink&quot; title=&quot;相关内容&quot;&gt;&lt;/a&gt;相关内容&lt;/h1&gt;&lt;p&gt;后缀自动机&lt;/p&gt;
&lt;h1 id=&quot;最终产物&quot;&gt;&lt;a href=&quot;#最终产物&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
      <category term="algorithm" scheme="http://yexiaorain.github.io/Blog/categories/algorithm/"/>
    
    
      <category term="SAM" scheme="http://yexiaorain.github.io/Blog/tags/SAM/"/>
    
      <category term="SA" scheme="http://yexiaorain.github.io/Blog/tags/SA/"/>
    
  </entry>
  
  <entry>
    <title>从FFT 到 FWHT 快速沃尔什-阿达玛转换(Walsh Hadamard transform)</title>
    <link href="http://yexiaorain.github.io/Blog/2022-07-26-FWT/"/>
    <id>http://yexiaorain.github.io/Blog/2022-07-26-FWT/</id>
    <published>2022-07-26T14:24:00.000Z</published>
    <updated>2022-08-08T00:54:42.979Z</updated>
    
    <content type="html"><![CDATA[<h1 id="FWHT"><a href="#FWHT" class="headerlink" title="FWHT"></a>FWHT</h1><p>快速沃尔什-阿达玛转换(Fast Walsh-Hadamard transform), 一种广义傅立叶变换(FWHT)</p><h2 id="解决什么问题"><a href="#解决什么问题" class="headerlink" title="解决什么问题"></a>解决什么问题</h2><p>FWHT 是用于解决对下标进行位运算卷积问题的方法</p><p>$c_{i} = \sum_{i=j \bigoplus k}a_{j} b_{k}$</p><p>并且没有fft中会涉及到double</p><hr><p>前置知识 FFT(DFT)</p><p>DFT:</p><p>${\displaystyle {\begin{bmatrix}f_{0}\\f_{1}\\\vdots \\f_{n-1}\end{bmatrix}}={\begin{bmatrix}1&amp;1&amp;1&amp;\cdots &amp;1\\1&amp;\alpha &amp;\alpha ^{2}&amp;\cdots &amp;\alpha ^{n-1}\\1&amp;\alpha ^{2}&amp;\alpha ^{4}&amp;\cdots &amp;\alpha ^{2(n-1)}\\\vdots &amp;\vdots &amp;\vdots &amp;&amp;\vdots \\1&amp;\alpha ^{n-1}&amp;\alpha ^{2(n-1)}&amp;\cdots &amp;\alpha ^{(n-1)(n-1)}\\\end{bmatrix}}{\begin{bmatrix}v_{0}\\v_{1}\\\vdots \\v_{n-1}\end{bmatrix}}.}$</p><h2 id="回顾离散傅立叶与卷积"><a href="#回顾离散傅立叶与卷积" class="headerlink" title="回顾离散傅立叶与卷积"></a>回顾离散傅立叶与卷积</h2><p>核心等式</p><p>$\operatorname{FFT}(a * b) = \operatorname{FFT}(a) \cdot \operatorname{FFT}(b)$</p><p>快速变换, $x$原向量,$N$大小, $idx$ 下标</p><p>$idx \le \frac{N}{2}$</p><p>$f(x,N,idx) = f(even(x),\frac{N}{2},idx) + w^k \cdot f(odd(x),\frac{N}{2},idx)$</p><p>$f(x,N,idx+\frac{N}{2}) = f(even(x),\frac{N}{2},idx) - w^k \cdot f(odd(x),\frac{N}{2},idx)$</p><h2 id="Or-版本-FORT-Fast-or-transform"><a href="#Or-版本-FORT-Fast-or-transform" class="headerlink" title="Or 版本 FORT(Fast or transform)"></a>Or 版本 FORT(Fast or transform)</h2><h3 id="Or卷积-与-ForT"><a href="#Or卷积-与-ForT" class="headerlink" title="Or卷积 与 ForT"></a>Or卷积 与 ForT</h3><p>$c_{i} = \sum_{i = j | k}a_{j} b_{k}$, 这里$|$ 是按位或不是整除</p><p>令$fort[C]_ i = \sum_{i = j|i} A_j$</p><p>$\begin{aligned}<br>fort[a]_ i \cdot fort[b]_ i &amp;= (\sum_{j|i=i} a_j) \cdot (\sum_{k|i=i} b_k) \\<br>&amp;= \sum_{j|i=i} \sum_{k|i=i} a_jb_k \\<br>&amp;= \sum_{(j|k)|i = i} a_jb_k \\<br>&amp;= fort[c]_ i<br>\end{aligned}$</p><p>这证明了 $\operatorname{ForT}(\left(\sum_{i=j | k}a_{j} b_{k}\right)) = \operatorname{ForT}(a) \cdot \operatorname{ForT}(b)$</p><h3 id="快速变换"><a href="#快速变换" class="headerlink" title="快速变换"></a>快速变换</h3><p>下面问题就是如何fast, 如何让快速计算fort和它的逆变换ifort</p><p>快速变换, $x$原向量,$N$大小, $idx$ 下标</p><p>$idx &lt; \frac{N}{2}$</p><p>$f(x,N,idx) = f(x, \frac{N}{2},idx)$</p><p>$f(x,N,idx+\frac{N}{2}) = f(x[0\cdots \frac{N}{2}-1]),\frac{N}{2},idx) + f(x[\frac{N}{2}\cdots N-1],\frac{N}{2},idx)$</p><p>因为本身$fort$的第$i$位就是所有$i$的二进制子集位置的和</p><p>那么对于$idx$ 它的子集一定也是在前半数组中</p><p>那么对于$idx + \frac{N}{2}$ 它的 其实就是最高位多了一个bit, 除了这个bit, 剩余部分和$idx$一样, 所以前半后半都按照$idx$来计算求和即可</p><p>至此完成fast</p><pre><code class="cpp">void ForT(modint *f) {  for (int k = 1; k &lt; n; k *=2){    for (int i = 0; i &lt; n; i += 2*k){      for (int j = 0; j &lt; k; j++){        // f[i+j] = f[i+j];        f[i+j+k] += f[i+j];      }    }  }}</code></pre><h3 id="逆变换"><a href="#逆变换" class="headerlink" title="逆变换"></a>逆变换</h3><p>可以直接参考fast的过程, 每个位置表示它所有bit子集的和, 那么按照反过来, 可以先减去未包含最低的其它子集和bit的值,未包含了低2位bit的其她子集和,…</p><p>显然对于的向量的$v$首个值有 $fort(v)_ 0 = v_0$</p><p>所以 $a_0 = fort(a)_ 0$</p><p>因为 $fort(a)_ 1 = fort(a_0) + fort(a_1)$</p><p>所以 $a_1 = fort(a_1) = fort(a)_ 1 - fort(a_0)$</p><p>同理$idx &lt; \frac{N}{2}$</p><p>$f(x,N,idx) = f(x, \frac{N}{2},idx)$</p><p>$f(x,N,idx+\frac{N}{2}) = f(x[0\cdots \frac{N}{2}-1]),\frac{N}{2},idx) - f(x[\frac{N}{2}\cdots N-1],\frac{N}{2},idx)$</p><pre><code class="cpp">void IForT(modint *f) {  for (int k = 1; k &lt; n; k *=2){    for (int i = 0; i &lt; n; i += 2*k){      for (int j = 0; j &lt; k; j++){        f[i+j+k] -= f[i+j];      }    }  }}</code></pre><hr><p>合并</p><pre><code class="cpp">// Or卷积void ForT(vector&lt;modint&gt; &amp;f,int flag = 1/* 1:正变换,-1:逆变换 */) {  int n = f.size();  for (int k = 1; k &lt; n; k *=2){    for (int i = 0; i &lt; n; i += 2*k){      for (int j = 0; j &lt; k; j++){        f[i+j+k] += flag * f[i+j];      }    }  }}</code></pre><h2 id="And-卷积-Fast-and-transform"><a href="#And-卷积-Fast-and-transform" class="headerlink" title="And 卷积(Fast and transform)"></a>And 卷积(Fast and transform)</h2><p>$c_{i} = \sum_{i = j \&amp; k}a_{j} b_{k}$</p><p>和Or的部分同理</p><ol><li>定义变换$fandt(a)_ i = \sum_{i|j = j} a_j$</li><li>证明 $fandt(a) \odot fandt(b) = fandt(\left(\sum_{i = j \&amp; k}a_{j} b_{k}\right))$</li><li>利用分块关系,实现fast</li></ol><p>最终代码</p><pre><code class="cpp">void FandT(vector&lt;modint&gt; &amp;f, int flag = 1/* 1:正变换,-1:逆变换 */) {  int n = f.size();  for (int k = 1; k &lt; n; k *=2){    for (int i = 0; i &lt; n; i += 2*k){      for (int j = 0; j &lt; k; j++){        f[i+j] += f[i+j+k] * flag;      }    }  }}</code></pre><h2 id="Xor卷积-与-FWHT-Fast-Walsh-Hadamard-transform"><a href="#Xor卷积-与-FWHT-Fast-Walsh-Hadamard-transform" class="headerlink" title="Xor卷积 与 FWHT(Fast Walsh-Hadamard transform)"></a>Xor卷积 与 FWHT(Fast Walsh-Hadamard transform)</h2><p>$\operatorname{FWHT}(\left(\sum_{i=j \bigoplus k}a_{j} b_{k}\right)) = \operatorname{FWHT}(a) \cdot \operatorname{FWHT}(b)$</p><h3 id="定义FWHT"><a href="#定义FWHT" class="headerlink" title="定义FWHT"></a>定义FWHT</h3><p>其实和上面一样,依然是三步,定义转换,证明等式,实现fast</p><p>定义符号 $x\otimes y=\text{popcount}(x \&amp; y) \bmod 2$, 即 $x$位与$y$后的二进制表示的$1$的个数再$\bmod 2$</p><p>有性质$(i \otimes j) \oplus (i \otimes k) = i \otimes (j \oplus k)$</p><p>证明: 对于给定的一位, 如果i中0, 则都贡献0, 如果i中是1, $j,k$对应的是1 则贡献是0 则不贡献, 得证</p><p>定义: $fwht[a]_ i = \sum_{i\otimes j = 0}a_j - \sum_{i\otimes j = 1}a_j$</p><p>那么有:</p><p>$fwht[a]_ i \cdot fwht[b]_ i$</p><p>$\begin{aligned}<br>&amp;= (\sum_{i\otimes j = 0} a_j - \sum_{i\otimes j = 1} a_j)\cdot (\sum_{i\otimes k = 0} b_k - \sum_{i\otimes k = 1} b_k) \\<br>&amp;=\left((\sum_{i\otimes j=0}a_j)(\sum_{i\otimes k=0}b_k)+(\sum_{i\otimes j=1}a_j)(\sum_{i\otimes k=1}b_k) \right)-\left((\sum_{i\otimes j=0}a_j)(\sum_{i\otimes k=1}b_k)-(\sum_{i\otimes j=1}a_j)(\sum_{i\otimes kj=0}b_k)\right)\\<br>&amp;=\sum_{i\otimes(j \oplus k)=0}a_jb_k-\sum_{i\otimes(j\oplus k)=1}a_jb_k \\<br>&amp;=\sum_{i\otimes l = 0}\sum_{l = j \oplus k}a_jb_k-\sum_{i\otimes l = 1}\sum_{l = j\oplus k}a_jb_k \\<br>&amp;= fwht[\left(\sum_{i=j \bigoplus k}a_{j} b_{k}\right)]_ i<br>\end{aligned}$</p><h3 id="Walsh-matrix-and-Hadamard-transform"><a href="#Walsh-matrix-and-Hadamard-transform" class="headerlink" title="Walsh matrix and Hadamard transform"></a>Walsh matrix and Hadamard transform</h3><p>可以看看Walsh矩阵的样子</p><p>${\displaystyle H_{m}={\frac {1}{\sqrt {2}}}{\begin{pmatrix}H_{m-1}&amp;H_{m-1}\\H_{m-1}&amp;-H_{m-1}\end{pmatrix}}}$</p><p>${\begin{aligned}H_{0}&amp;=+{\begin{pmatrix}1\end{pmatrix}}\\H_{1}&amp;={\frac {1}{\sqrt {2}}}\left({\begin{array}{rr}1&amp;1\\1&amp;-1\end{array}}\right)\\H_{2}&amp;={\frac {1}{2}}\left({\begin{array}{rrrr}1&amp;1&amp;1&amp;1\\1&amp;-1&amp;1&amp;-1\\1&amp;1&amp;-1&amp;-1\\1&amp;-1&amp;-1&amp;1\end{array}}\right)\\H_{3}&amp;={\frac {1}{2^{3/2}}}\left({\begin{array}{rrrrrrrr}1&amp;1&amp;1&amp;1&amp;1&amp;1&amp;1&amp;1\\1&amp;-1&amp;1&amp;-1&amp;1&amp;-1&amp;1&amp;-1\\1&amp;1&amp;-1&amp;-1&amp;1&amp;1&amp;-1&amp;-1\\1&amp;-1&amp;-1&amp;1&amp;1&amp;-1&amp;-1&amp;1\\1&amp;1&amp;1&amp;1&amp;-1&amp;-1&amp;-1&amp;-1\\1&amp;-1&amp;1&amp;-1&amp;-1&amp;1&amp;-1&amp;1\\1&amp;1&amp;-1&amp;-1&amp;-1&amp;-1&amp;1&amp;1\\1&amp;-1&amp;-1&amp;1&amp;-1&amp;1&amp;1&amp;-1\end{array}}\right)\\(H_{n})_{i,j}&amp;={\frac {1}{2^{n/2}}}(-1)^{i\cdot j}\end{aligned}}$</p><p>对于 $(1,0,1,0,0,1,1,0)$</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/aa/1010_0110_Walsh_spectrum_%28single_row%29.svg/300px-1010_0110_Walsh_spectrum_%28single_row%29.svg.png" alt="The product of a Boolean function and a Walsh matrix"></p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/58/1010_0110_Walsh_spectrum_%28fast_WHT%29.svg/300px-1010_0110_Walsh_spectrum_%28fast_WHT%29.svg.png" alt="Fast Walsh–Hadamard transform, a faster way to calculate the Walsh spectrum"></p><h3 id="快速变换-1"><a href="#快速变换-1" class="headerlink" title="快速变换"></a>快速变换</h3><p>其实看到了矩阵之间的递推关系 这个表达式就很显然了</p><p>$idx &lt; \frac{N}{2}$</p><p>$f(x,N,idx) = f(x[0,\frac{N}{2}), \frac{N}{2},idx) + f(x[\frac{N}{2},N), \frac{N}{2}, idx)$</p><p>$f(x,N,idx+\frac{N}{2}) = f(x[0,\frac{N}{2}), \frac{N}{2},idx) - f(x[\frac{N}{2},N), \frac{N}{2}, idx)$</p><pre><code class="cpp">void FWHT(vector&lt;modint&gt; &amp;f, int flag = 1 /* 1: 正变换, 1/2: 逆变换*/) {  int n = f.size();  for (int k = 1; k &lt; n; k *=2){    for (int i = 0; i &lt; n; i += 2*k){      for (int j = 0; j &lt; k; j++){        auto U = f[i+j];        auto T = f[i+j+k];        f[i+j]   = U + T;        f[i+j+k] = U - T;        f[i+j] *= flag;        f[i+j+k] *= flag;      }    }  }}</code></pre><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;#include &quot;./modint.cpp&quot;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backusing MODINT::modint;namespace FWT{  void ForT(vector&lt;modint&gt; &amp;f,int flag = 1/* 1:正变换,-1:逆变换 */) {    int n = f.size();    for (int k = 1; k &lt; n; k *=2){      for (int i = 0; i &lt; n; i += 2*k){        for (int j = 0; j &lt; k; j++){          f[i+j+k] += f[i+j] * flag;        }      }    }  }  void IForT(vector&lt;modint&gt; &amp;f) {ForT(f, -1);}  vector&lt;modint&gt; or_convolution(vector&lt;modint&gt; &amp;v0, vector&lt;modint&gt; &amp;v1){    const int sz = v0.size();    ForT(v0);    ForT(v1);    vector&lt;modint&gt; v2(sz,0);    rep(i,0,sz) v2[i] = v0[i] * v1[i];    IForT(v2);    return v2;  }  void FandT(vector&lt;modint&gt; &amp;f, int flag = 1/* 1:正变换,-1:逆变换 */) {    int n = f.size();    for (int k = 1; k &lt; n; k *=2){      for (int i = 0; i &lt; n; i += 2*k){        for (int j = 0; j &lt; k; j++){          f[i+j] += f[i+j+k] * flag;        }      }    }  }  void IFandT(vector&lt;modint&gt; &amp;f) {FandT(f, -1);}  vector&lt;modint&gt; and_convolution(vector&lt;modint&gt; &amp;v0, vector&lt;modint&gt; &amp;v1){    const int sz = v0.size();    FandT(v0);    FandT(v1);    vector&lt;modint&gt; v2(sz,0);    rep(i,0,sz) v2[i] = v0[i] * v1[i];    IFandT(v2);    return v2;  }  modint inv2 = modint(2).inv();  void FWHT(vector&lt;modint&gt; &amp;f, modint flag = 1 /* 1: 正变换, 1/2: 逆变换*/) {    int n = f.size();    for (int k = 1; k &lt; n; k *=2){      for (int i = 0; i &lt; n; i += 2*k){        for (int j = 0; j &lt; k; j++){          auto U = f[i+j];          auto T = f[i+j+k];          f[i+j]   = U + T;          f[i+j+k] = U - T;          f[i+j] *= flag;          f[i+j+k] *= flag;        }      }    }  }  void IFWHT(vector&lt;modint&gt; &amp;f) {FWHT(f, inv2);}  void FxorT(vector&lt;modint&gt; &amp;f,int flag = 1) {FWHT(f, flag);}  void IFxorT(vector&lt;modint&gt; &amp;f) {IFWHT(f);}  vector&lt;modint&gt; xor_convolution(vector&lt;modint&gt; &amp;v0, vector&lt;modint&gt; &amp;v1){    const int sz = v0.size();    FxorT(v0);    FxorT(v1);    vector&lt;modint&gt; v2(sz,0);    rep(i,0,sz) v2[i] = v0[i] * v1[i];    IFxorT(v2);    return v2;  }};void print(vector&lt;modint&gt; &amp;arr){  for(auto &amp;v:arr) printf(&quot;%d &quot;, v.val());  printf(&quot;\n&quot;);}int main(){  // 长度2的幂次  const vector&lt;modint&gt; A0 = {1,2,3,0};  const vector&lt;modint&gt; B0 = {4,5,6,0};  // --- or ---  {    auto A = A0;    auto B = B0;    auto C = FWT::or_convolution(A,B);    print(C);  }  // --- and ---  {    auto A = A0;    auto B = B0;    auto C = FWT::and_convolution(A,B);    print(C);  }  // --- xor ---  {    auto A = A0;    auto B = B0;    auto C = FWT::xor_convolution(A,B);    print(C);  }  return 0;}</code></pre><h2 id="洛谷P4717"><a href="#洛谷P4717" class="headerlink" title="洛谷P4717"></a>洛谷P4717</h2><p><a href="https://www.luogu.com.cn/record/81332363" target="_blank" rel="noopener">https://www.luogu.com.cn/record/81332363</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;n;i++)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // read// ----------- modint -----------namespace MODINT{  const int _mod = 998244353;  class modint{    private:      ll _v;    public:      modint() :_v(0) {  }      modint(ll _a) {        _v = (_a &lt; 0)? _mod - ((-_a) % _mod) : (_a % _mod);      }      int val()const { return _v; }      modint operator+()const { return *this; }      modint operator-()const { return { _mod - _v }; }      modint operator+(const modint&amp; rhs) const { return modint(*this) += rhs; }      modint operator-(const modint&amp; rhs) const { return modint(*this) -= rhs; }      modint operator*(const modint&amp; rhs) const { return modint(*this) *= rhs; }      modint operator/(const modint&amp; rhs) const { return modint(*this) /= rhs; }      bool operator==(const modint&amp; rhs)const { return _v == rhs._v; }      bool operator!=(const modint&amp; rhs)const { return _v != rhs._v; }      bool operator&gt; (const modint&amp; rhs)const { return _v &gt;  rhs._v; }      bool operator&gt;=(const modint&amp; rhs)const { return _v &gt;= rhs._v; }      bool operator&lt;=(const modint&amp; rhs)const { return _v &lt;= rhs._v; }      bool operator&lt; (const modint&amp; rhs)const { return _v &lt;  rhs._v; }      modint&amp; operator+=(const modint&amp; rhs) {        (_v += rhs._v) %= _mod;        return *this;      }      modint&amp; operator-=(const modint&amp; rhs) {        (_v += _mod - rhs._v) %= _mod;        return *this;      }      modint&amp; operator*=(const modint&amp; rhs) {        _v = _v * rhs.val() % _mod;        return *this;      }      modint&amp; operator/=(const modint&amp; rhs) { // 费马小定理        _v = _v * rhs.inv().val() % _mod ;        return *this;      }      modint pow(ll pwr) const {        ll res(1);        ll _b(_v);        while (pwr) {          if (pwr &amp; 1) (res *= _b) %= _mod;          (_b *= _b) %= _mod;          pwr /= 2;        }        return res;      }      modint inv() const {        assert(_v != 0);        return pow(_mod - 2);      }  };};// ----------- modint -----------// ----------- fwt -----------using MODINT::modint;namespace FWT{  void ForT(vector&lt;modint&gt; &amp;f,int flag = 1/* 1:正变换,-1:逆变换 */) {    int n = f.size();    for (int k = 1; k &lt; n; k *=2){      for (int i = 0; i &lt; n; i += 2*k){        for (int j = 0; j &lt; k; j++){          f[i+j+k] += f[i+j] * flag;        }      }    }  }  void IForT(vector&lt;modint&gt; &amp;f) {ForT(f, -1);}  vector&lt;modint&gt; or_convolution(vector&lt;modint&gt; &amp;v0, vector&lt;modint&gt; &amp;v1){    const int sz = v0.size();    ForT(v0);    ForT(v1);    vector&lt;modint&gt; v2(sz,0);    rep(i,0,sz) v2[i] = v0[i] * v1[i];    IForT(v2);    return v2;  }  void FandT(vector&lt;modint&gt; &amp;f, int flag = 1/* 1:正变换,-1:逆变换 */) {    int n = f.size();    for (int k = 1; k &lt; n; k *=2){      for (int i = 0; i &lt; n; i += 2*k){        for (int j = 0; j &lt; k; j++){          f[i+j] += f[i+j+k] * flag;        }      }    }  }  void IFandT(vector&lt;modint&gt; &amp;f) {FandT(f, -1);}  vector&lt;modint&gt; and_convolution(vector&lt;modint&gt; &amp;v0, vector&lt;modint&gt; &amp;v1){    const int sz = v0.size();    FandT(v0);    FandT(v1);    vector&lt;modint&gt; v2(sz,0);    rep(i,0,sz) v2[i] = v0[i] * v1[i];    IFandT(v2);    return v2;  }  modint inv2 = modint(2).inv();  void FWHT(vector&lt;modint&gt; &amp;f, modint flag = 1 /* 1: 正变换, 1/2: 逆变换*/) {    int n = f.size();    for (int k = 1; k &lt; n; k *=2){      for (int i = 0; i &lt; n; i += 2*k){        for (int j = 0; j &lt; k; j++){          auto U = f[i+j];          auto T = f[i+j+k];          f[i+j]   = U + T;          f[i+j+k] = U - T;          f[i+j] *= flag;          f[i+j+k] *= flag;        }      }    }  }  void IFWHT(vector&lt;modint&gt; &amp;f) {FWHT(f, inv2);}  void FxorT(vector&lt;modint&gt; &amp;f,int flag = 1) {FWHT(f, flag);}  void IFxorT(vector&lt;modint&gt; &amp;f) {IFWHT(f);}  vector&lt;modint&gt; xor_convolution(vector&lt;modint&gt; &amp;v0, vector&lt;modint&gt; &amp;v1){    const int sz = v0.size();    FxorT(v0);    FxorT(v1);    vector&lt;modint&gt; v2(sz,0);    rep(i,0,sz) v2[i] = v0[i] * v1[i];    IFxorT(v2);    return v2;  }};// ----------- fwt -----------void print(vector&lt;modint&gt; &amp;arr){  for(auto &amp;v:arr) printf(&quot;%d &quot;, v.val());  printf(&quot;\n&quot;);}int main(){  const int n = read();  const int SIZE = 1&lt;&lt;n;  // 长度2的幂次  auto A0 = vector&lt;modint&gt;(SIZE,0);  auto B0 = vector&lt;modint&gt;(SIZE,0);  rep(i,0,SIZE) A0[i] = read();  rep(i,0,SIZE) B0[i] = read();  // --- or ---  {    auto A = A0;    auto B = B0;    auto C = FWT::or_convolution(A,B);    print(C);  }  // --- and ---  {    auto A = A0;    auto B = B0;    auto C = FWT::and_convolution(A,B);    print(C);  }  // --- xor ---  {    auto A = A0;    auto B = B0;    auto C = FWT::xor_convolution(A,B);    print(C);  }  return 0;}</code></pre><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="http://yexiaorain.github.io/Blog/2019-01-02-fftmul/">我的FFT笔记</a></p><p><a href="https://en.wikipedia.org/wiki/Fast_Walsh%E2%80%93Hadamard_transform" target="_blank" rel="noopener">wikipedia Fast Walsh-Hadamard transform</a></p><p><a href="https://en.wikipedia.org/wiki/Hadamard_transform" target="_blank" rel="noopener">Hadamard transform</a></p><p><a href="https://en.wikipedia.org/wiki/Walsh_matrix" target="_blank" rel="noopener">Walsh matrix</a></p><p><a href="https://codeforces.com/blog/entry/71899" target="_blank" rel="noopener">Codeforces FWHT inner working</a></p><p><a href="https://blog.csdn.net/a_forever_dream/article/details/105110089" target="_blank" rel="noopener">CSDN 快速沃尔什变换（FWT）详详详解</a></p><p><a href="https://www.luogu.com.cn/problem/solution/P4717" target="_blank" rel="noopener">luogu 模板练习</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;FWHT&quot;&gt;&lt;a href=&quot;#FWHT&quot; class=&quot;headerlink&quot; title=&quot;FWHT&quot;&gt;&lt;/a&gt;FWHT&lt;/h1&gt;&lt;p&gt;快速沃尔什-阿达玛转换(Fast Walsh-Hadamard transform), 一种广义傅立叶变换(FWHT)&lt;/p
      
    
    </summary>
    
      <category term="Codeforces" scheme="http://yexiaorain.github.io/Blog/categories/Codeforces/"/>
    
    
      <category term="fft" scheme="http://yexiaorain.github.io/Blog/tags/fft/"/>
    
      <category term="FWHT" scheme="http://yexiaorain.github.io/Blog/tags/FWHT/"/>
    
  </entry>
  
  <entry>
    <title>Atcoder abc212</title>
    <link href="http://yexiaorain.github.io/Blog/2022-07-25-ac_abc212/"/>
    <id>http://yexiaorain.github.io/Blog/2022-07-25-ac_abc212/</id>
    <published>2022-07-24T20:25:14.000Z</published>
    <updated>2022-08-08T00:54:42.979Z</updated>
    
    <content type="html"><![CDATA[<p>G(数学,数论,原根)H/Ex(沃尔什-阿达玛转换,FWT/FWHT)</p><h1 id="G-Power-Pair"><a href="#G-Power-Pair" class="headerlink" title="G - Power Pair"></a>G - Power Pair</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://atcoder.jp/contests/abc212/tasks/abc212_g" target="_blank" rel="noopener">https://atcoder.jp/contests/abc212/tasks/abc212_g</a></p><p>给定 质数$p$ </p><p>问 $x,y\in[0,p-1]$  中有多少对$(x,y)$满足</p><p>存在$n$, 使得$x^n = y \pmod p$</p><h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h3><p>p $10^{12}$</p><p>2s</p><p>1024mb</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h3><p>显然x=0 只有y = 0, y=0也只有x=0</p><p>然后如果x是原根 那么 方案数$p-1$</p><p>如果$r|(p-1)$ 那么 $x^r \pmod p$的方案数为$\frac{p-1}{r}$</p><p>或者$x$的最小幂次$t$让$x^t = 1 \pmod p$, 则答案为$t$</p><p>但是即使这样, 如果每个去枚举依然是$O(p log(p))$</p><p>反过来考虑说有没有办法求$x^t = 1$ 的方案数,</p><p>如果能快速计算出,那么 方案数减去它的t因子对应的方案数 就恰好是 = t的方案数</p><p>而$t$的取值只会是 $p-1$的因数</p><p>$t = 1$ $x = 1$</p><p>$t = 2$ $x = 1,-1$</p><p>$t = 4$</p><p>$t = 7$</p><p>$t = 8$</p><hr><p>t = 2k时, $x^{2k} - 1 = 0 \pmod p$</p><p>$(x^k+1)(x^k-1) = 0 \pmod p$, 相当于$x^k = 1 \pmod p, x^k = -1 \pmod p $的解的并</p><p>并不会</p><h3 id="官方"><a href="#官方" class="headerlink" title="官方"></a>官方</h3><p>原根的想法没问题, 然后就变成了我们指定原根</p><p>$x^i = j$, $(i,j)$ 是一一对应, 且取$[1,p-1]$范围内的所有值</p><p>这样的话</p><p>要求 $x^i$ 的最小让 幂次等于1的t</p><p>注意到 和我思路一样的 $x^i$当$i | (p-1)$时, 方案数 $=\frac{p-1}{i}$</p><p>而这里$i$可能不是$p-1$的因子, 而易证明 方案数为 $\frac{p-1}{gcd(p-1,i)}$</p><p>这里问题变成了, 统计不同 $gcd(p-1,i) = k$ 的数量即可</p><hr><p>$g | (p-1)$</p><p>$\sum_{g|(p-1)} count(g 倍数 且非(p-1)因子) $</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc212/submissions/33524525" target="_blank" rel="noopener">https://atcoder.jp/contests/abc212/submissions/33524525</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 998244353#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // read// 转质数和幂次vector&lt;pair&lt;ll,int&gt; &gt; v2ppwr(ll v){  vector&lt;pair&lt;ll,int&gt; &gt; res = {};  rep(t,2,v+1){    if(t*t &gt; v) break;    int c = 0;    while(v % t == 0){      v /= t;      c ++;    }    if(c) res.pb({t,c});  }  if(v != 1) res.pb({v, 1});  return res;}// gcd = xll dfs(ll idx, ll y, vector&lt;ll&gt; primes, const vector&lt;pair&lt;ll,int&gt; &gt; &amp; ppwr1){  if(idx == (int)ppwr1.size()) {    ll rc = y; // 容斥    for(auto p:primes) rc = rc / p * (p-1);    return y % MOD * (rc % MOD) % MOD;  }  auto [p,mi] = ppwr1[idx];  ll mul = 1; // p ** pwr  primes.push_back(p);  ll res = 0;  rep(pwr,0,mi+1){    if(pwr == mi) primes.pop_back();    (res += dfs(idx+1, y / mul, primes, ppwr1)) %= MOD;    mul *= p;  }  return res;}int main(){  ll p = read();  auto ppwr = v2ppwr(p-1);  printf(&quot;%lld\n&quot;, (1 /* (0,0) */ + dfs(0, p-1, {}, ppwr)) % MOD);  return 0;}</code></pre><h1 id="H-Ex-Nim-Counting"><a href="#H-Ex-Nim-Counting" class="headerlink" title="H/Ex - Nim Counting"></a>H/Ex - Nim Counting</h1><p><a href="https://atcoder.jp/contests/abc212/tasks/abc212_h" target="_blank" rel="noopener">https://atcoder.jp/contests/abc212/tasks/abc212_h</a></p><p>给正整数 长度k的 数组A, 值两两不同</p><p>T和A轮流游戏, T先</p><p>选一个 &gt;= 1 的石堆, 移除任意正整数个</p><p>谁取了最后一个胜利</p><hr><p>问题是</p><p>对于长度[1,N] 每个元素属于A中的一个的 初始状态, 有多少种状态是 T 胜利</p><p>模 998244353</p><h2 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h2><p>n 2e5</p><p>k 65536</p><p>$a_i$ [1, 65536]</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h3><p>首先nim游戏作为博弈的常见基础, 很明显 就是 xor 和 != 0 时 T胜利</p><p>那么无非是求 所有 !=0 的方案数, 或者 是 == 0 的方案数, 去总方案减去 ==0的方案数</p><p>那么对于一个选择来说因为Ai两两不同, 偶数次被选的Ai 不影响xor,奇数次被选的Ai影响一次</p><p>问题变成了说</p><p>选x个Ai,让它们 xor = 0, 那么</p><p>对于长度x 贡献是 x!</p><p>对长度x+2 贡献是 ?? 还是x, 但是剩余两个是一样的, 这两个一样的如果属于x个值内注意不要重复统计,不属于x个数内,则穿插即可</p><h3 id="官方-1"><a href="#官方-1" class="headerlink" title="官方"></a>官方</h3><p>对于给定的数组长度M</p><p>$C=(C_0,C_1,…C_{2^{16}-1})$ 表示 下标的值 是否存在, 相当于选择了一次</p><p>定义xor的卷积 $Z_k = \sum_{i\oplus j=k} X_i Y_j$</p><p>那么$C$的M次卷积的结果$R$中的$R_0$, 就是期望值</p><hr><p>快速沃尔什-阿达玛转换(Fast Walsh Hadamard transform), 一种广义傅立叶变换</p><p>FWT/FWHT 是用于解决对下标进行位运算卷积问题的方法, 见下面我的博客链接</p><p>$C_{i} = \sum_{i=j \bigoplus k}A_{j} B_{k}$</p><hr><p>因为 xor 的卷积满足结合率, 所以可以考虑快速幂来算</p><p>注意到$C * C = ifwt(fwt(C)\odot fwt(C))$</p><p>而$C * C * C= ifwt(fwt(C * C) \odot fwt(C))$</p><p>$= ifwt(fwt(ifwt(fwt(C)\odot fwt(C))) \odot fwt(C))$</p><p>$= ifwt(fwt(C)\odot fwt(C) \odot fwt(C))$</p><p>即是 $C^n = ifwt(\left( fwt(C)_ i^n\right))$</p><p>所以 $C$的$n$次+/xor/or/and卷积等于 正变换每个位置的$n$次方后的逆变换, <strong>这个在dft(fft)/ntt/fwt 同理</strong></p><hr><p>令 $I = C^0 = (1,0,0,0,0,0,\cdots)$</p><p>答案 $R = C + C * C + \cdots + C^n$</p><p>$R * C = C^2 + C^3 + \cdots + C^{n+1}$</p><p>$R * (C-I) = C^{n+1} - C$</p><p>$fwt(R) \odot fwt(C-I) = fwt(C^{n+1} - C)$</p><p>$fwt(R) = fwt(C^{n+1} - C) \oslash fwt(C-I)$</p><p>$R = ifwt(fwt(C^{n+1} - C) \oslash fwt(C-I))$</p><p>注意到$fwt$ 实际是线性变换, 所以也有$fwt(a+b) = fwt(a) + fwt(b),fwt(a-b) = fwt(a) - fwt(b),$</p><p>$R = ifwt( (fwt(C^{n+1}) - fwt(C)) \oslash (fwt(C)-fwt(I)))$</p><p>注意到 $fwt(I) = (1,1,1,1,1,\cdots)$</p><p>$R = ifwt(\left(\frac{fwt(C)_ i^{n+1} - fwt(C)_ i}{fwt(C)_ i - 1}\right))$</p><hr><p>至此就很好写了</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc212/submissions/33545657" target="_blank" rel="noopener">https://atcoder.jp/contests/abc212/submissions/33545657</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // read// -------------- modint ---------------namespace MODINT{  const int _mod = 998244353;  class modint{    private:      ll _v;    public:      modint() :_v(0) {  }      modint(ll _a) {        _v = (_a &lt; 0)? _mod - ((-_a) % _mod) : (_a % _mod);      }      int val()const { return _v; }      modint operator+()const { return *this; }      modint operator-()const { return { _mod - _v }; }      modint operator+(const modint&amp; rhs) const { return modint(*this) += rhs; }      modint operator-(const modint&amp; rhs) const { return modint(*this) -= rhs; }      modint operator*(const modint&amp; rhs) const { return modint(*this) *= rhs; }      modint operator/(const modint&amp; rhs) const { return modint(*this) /= rhs; }      bool operator==(const modint&amp; rhs)const { return _v == rhs._v; }      bool operator!=(const modint&amp; rhs)const { return _v != rhs._v; }      bool operator&gt; (const modint&amp; rhs)const { return _v &gt;  rhs._v; }      bool operator&gt;=(const modint&amp; rhs)const { return _v &gt;= rhs._v; }      bool operator&lt;=(const modint&amp; rhs)const { return _v &lt;= rhs._v; }      bool operator&lt; (const modint&amp; rhs)const { return _v &lt;  rhs._v; }      modint&amp; operator+=(const modint&amp; rhs) {        (_v += rhs._v) %= _mod;        return *this;      }      modint&amp; operator-=(const modint&amp; rhs) {        (_v += _mod - rhs._v) %= _mod;        return *this;      }      modint&amp; operator*=(const modint&amp; rhs) {        _v = _v * rhs.val() % _mod;        return *this;      }      modint&amp; operator/=(const modint&amp; rhs) { // 费马小定理        _v = _v * rhs.inv().val() % _mod ;        return *this;      }      modint pow(ll pwr) const {        ll res(1);        ll _b(_v);        while (pwr) {          if (pwr &amp; 1) (res *= _b) %= _mod;          (_b *= _b) %= _mod;          pwr /= 2;        }        return res;      }      modint inv() const {        assert(_v != 0);        return pow(_mod - 2);      }  };};// -------------- modint ---------------// ---------- fwt ----------using MODINT::modint;namespace FWT{  void ForT(vector&lt;modint&gt; &amp;f,int flag = 1/* 1:正变换,-1:逆变换 */) {    int n = f.size();    for (int k = 1; k &lt; n; k *=2){      for (int i = 0; i &lt; n; i += 2*k){        for (int j = 0; j &lt; k; j++){          f[i+j+k] += f[i+j] * flag;        }      }    }  }  void IForT(vector&lt;modint&gt; &amp;f) {ForT(f, -1);}  vector&lt;modint&gt; or_convolution(vector&lt;modint&gt; &amp;v0, vector&lt;modint&gt; &amp;v1){    const int sz = v0.size();    ForT(v0);    ForT(v1);    vector&lt;modint&gt; v2(sz,0);    rep(i,0,sz) v2[i] = v0[i] * v1[i];    IForT(v2);    return v2;  }  void FandT(vector&lt;modint&gt; &amp;f, int flag = 1/* 1:正变换,-1:逆变换 */) {    int n = f.size();    for (int k = 1; k &lt; n; k *=2){      for (int i = 0; i &lt; n; i += 2*k){        for (int j = 0; j &lt; k; j++){          f[i+j] += f[i+j+k] * flag;        }      }    }  }  void IFandT(vector&lt;modint&gt; &amp;f) {FandT(f, -1);}  vector&lt;modint&gt; and_convolution(vector&lt;modint&gt; &amp;v0, vector&lt;modint&gt; &amp;v1){    const int sz = v0.size();    FandT(v0);    FandT(v1);    vector&lt;modint&gt; v2(sz,0);    rep(i,0,sz) v2[i] = v0[i] * v1[i];    IFandT(v2);    return v2;  }  modint inv2 = modint(2).inv();  void FWHT(vector&lt;modint&gt; &amp;f, modint flag = 1 /* 1: 正变换, 1/2: 逆变换*/) {    int n = f.size();    for (int k = 1; k &lt; n; k *=2){      for (int i = 0; i &lt; n; i += 2*k){        for (int j = 0; j &lt; k; j++){          auto U = f[i+j];          auto T = f[i+j+k];          f[i+j]   = U + T;          f[i+j+k] = U - T;          f[i+j] *= flag;          f[i+j+k] *= flag;        }      }    }  }  void IFWHT(vector&lt;modint&gt; &amp;f) {FWHT(f, inv2);}  void FxorT(vector&lt;modint&gt; &amp;f,int flag = 1) {FWHT(f, flag);}  void IFxorT(vector&lt;modint&gt; &amp;f) {IFWHT(f);}  vector&lt;modint&gt; xor_convolution(vector&lt;modint&gt; &amp;v0, vector&lt;modint&gt; &amp;v1){    const int sz = v0.size();    FxorT(v0);    FxorT(v1);    vector&lt;modint&gt; v2(sz,0);    rep(i,0,sz) v2[i] = v0[i] * v1[i];    IFxorT(v2);    return v2;  }};// ---------- fwt ----------const int SIZE = 1 &lt;&lt; 16; // 16;vector&lt;modint&gt; C(SIZE,0);int main(){  int n = read();  int k = read();  rep(i,0,k) { C[read()] = 1; }  auto ans = k == 1? n : ((modint(k).pow(n+1)- 1)/(k-1) - 1); // 总方案数  FWT::FWHT(C);  rep(i,0,SIZE) C[i] = (C[i] == 1) ? n : ((C[i].pow(n+1) - C[i])/(C[i] - 1)); // 等比数列求和  FWT::IFWHT(C);  printf(&quot;%d\n&quot;,(ans-C[0]).val());  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>G</p><p>没观察到选了一个原根以后 整个范围 都有幂次和值的一一映射</p><p>H(Ex)</p><p>首先这个C和这个卷积 就很神奇, 完全没有向这个方向的思路</p><p>学了一手FWT/FWHT</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://atcoder.jp/contests/abc212/editorial" target="_blank" rel="noopener">官方题解</a></p><p><a href="http://yexiaorain.github.io/Blog/2022-07-26-FWT/">FWHT/FWT</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;G(数学,数论,原根)H/Ex(沃尔什-阿达玛转换,FWT/FWHT)&lt;/p&gt;
&lt;h1 id=&quot;G-Power-Pair&quot;&gt;&lt;a href=&quot;#G-Power-Pair&quot; class=&quot;headerlink&quot; title=&quot;G - Power Pair&quot;&gt;&lt;/a&gt;G - P
      
    
    </summary>
    
      <category term="Atcoder" scheme="http://yexiaorain.github.io/Blog/categories/Atcoder/"/>
    
    
      <category term="数学" scheme="http://yexiaorain.github.io/Blog/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="数论" scheme="http://yexiaorain.github.io/Blog/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="原根" scheme="http://yexiaorain.github.io/Blog/tags/%E5%8E%9F%E6%A0%B9/"/>
    
      <category term="沃尔什-阿达玛转换" scheme="http://yexiaorain.github.io/Blog/tags/%E6%B2%83%E5%B0%94%E4%BB%80-%E9%98%BF%E8%BE%BE%E7%8E%9B%E8%BD%AC%E6%8D%A2/"/>
    
      <category term="FWT" scheme="http://yexiaorain.github.io/Blog/tags/FWT/"/>
    
      <category term="FWHT" scheme="http://yexiaorain.github.io/Blog/tags/FWHT/"/>
    
  </entry>
  
  <entry>
    <title>从FFT 到 NTT(快速数论变换)</title>
    <link href="http://yexiaorain.github.io/Blog/2022-07-24-NTT/"/>
    <id>http://yexiaorain.github.io/Blog/2022-07-24-NTT/</id>
    <published>2022-07-24T14:24:00.000Z</published>
    <updated>2022-08-08T00:54:42.979Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NTT"><a href="#NTT" class="headerlink" title="NTT"></a>NTT</h1><p>竟然Div2能出现NTT 虽然是在最后一题, 还是得学一学</p><h2 id="解决什么问题"><a href="#解决什么问题" class="headerlink" title="解决什么问题"></a>解决什么问题</h2><p>是多项式乘法带模数的情况计算卷积</p><p>并且没有fft中会涉及到double,</p><p>NTT 也就是关于任意 环(数学术语) 上的离散傅立叶变化(DFT), 有限域的情况下,通常成为数论变换</p><h2 id="离散傅立叶变换"><a href="#离散傅立叶变换" class="headerlink" title="离散傅立叶变换"></a>离散傅立叶变换</h2><p>回顾离散傅立叶变换, 就是</p><p>原函数(原向量) $\to$ DFT(离散傅立叶) $\to$ 点乘 $\to$ IDFT(逆傅立叶) $\to$ 结果函数(结果向量)</p><p>DFT:</p><p>$\hat{x}[k]=\sum_{n=0}^{N-1} e^{-i\frac{2\pi}{N}nk}x[n] \qquad k = 0,1,\ldots,N-1.$</p><p>IDFT:</p><p>$x\left[n\right]={1 \over N}\sum_{k=0}^{N-1} e^{ i\frac{2\pi}{N}nk}\hat{x}[k] \qquad n = 0,1,\ldots,N-1.$</p><p>有时系数可以是两个$\frac{1}{\sqrt{N}}$</p><p>矩阵表示的DFT, 是一个线性算子</p><p>${\displaystyle {\begin{bmatrix}f_{0}\\f_{1}\\\vdots \\f_{n-1}\end{bmatrix}}={\begin{bmatrix}1&amp;1&amp;1&amp;\cdots &amp;1\\1&amp;\alpha &amp;\alpha ^{2}&amp;\cdots &amp;\alpha ^{n-1}\\1&amp;\alpha ^{2}&amp;\alpha ^{4}&amp;\cdots &amp;\alpha ^{2(n-1)}\\\vdots &amp;\vdots &amp;\vdots &amp;&amp;\vdots \\1&amp;\alpha ^{n-1}&amp;\alpha ^{2(n-1)}&amp;\cdots &amp;\alpha ^{(n-1)(n-1)}\\\end{bmatrix}}{\begin{bmatrix}v_{0}\\v_{1}\\\vdots \\v_{n-1}\end{bmatrix}}.}$</p><h2 id="阶"><a href="#阶" class="headerlink" title="阶"></a>阶</h2><p>若 $gcd(a,p) = 1, p &gt; 1$</p><p>最小的$n &gt; 0$ 使得 $a^n \equiv 1 \pmod{p}$, 则$\delta_p(a) = n$ 称作$a$模$p$的阶</p><p>显然, 对于$i\in [0,\delta_p(a))$, $a^i \pmod p$ 两两不同</p><h2 id="原根"><a href="#原根" class="headerlink" title="原根"></a>原根</h2><p>$p &gt; 0, a$ 是整数, $\delta_p(a) = \varphi(a), gcd(p,a) = 1$, 则$a$为$p$的一个原根</p><p>其中$\varphi(n)$ 为欧拉函数, 表示$1$到$n$中与$n$互质的数的个数</p><p>若$gcd(a,p) = 1, p &gt; 0$ 则$a$为$p$的一个原根的充要条件 ${a^1,a^2,a^3,\cdots,a^{\varphi(p)}}$ 是p的简化剩余系</p><p>必要: $a$是$p$的原根, 根据阶中结论模n两两不同</p><p>充分: 因为是简化剩余系, 所以两两不同, 所以说明 $ &lt; \varphi(p)$ 的都不为1, 也说明$\delta_p(a) = \varphi(a)$</p><p>完全剩余系: n的完全剩余系, 在模n的剩余类中各取一个元素，则这n个数就构成了模n的一个完全剩余系。例如{0,1,2,3,…,n-1} 是n的一个完全剩余系</p><p>简化剩余系: 完全剩余系中 与n互质 构成的</p><h2 id="回到NTT"><a href="#回到NTT" class="headerlink" title="回到NTT"></a>回到NTT</h2><p>$p$为素数,$a$为$p$的一个原根, 有$\varphi(p) = p-1$</p><p>$n = 2^k, n | (p-1), k &gt; 0$</p><p>令 $g_n = a^{\frac{p-1}{n}}$</p><p>$g_n^n = (a^{\frac{p-1}{n}})^n = a^{p-1} = 1 \pmod p$</p><p>$g_n^{\frac{n}{2}} = a^{\frac{p-1}{2}} = -1 \pmod p$</p><p>$g_{tn}^{tk} = a^{\frac{tk(p-1)}{tn}}=a^{\frac{k(p-1)}{n}}=g_n^k$</p><p>这里想用 $g_n^k$ 来替代$w_n^k$ </p><p>(然后就直接可以替换了??? 不严格的语言证明是, 可以看成w为未知数, 那么$a * b = c$ 不过是变成了c = IFFT(FFT(a) FFT(b)) = a * b</p><p>也就是 最终的只和$w$的$n$和$\frac{n}{2}$有关,否则 会有复平面的偏移</p><p>所以$w_n^k = e^{- i \frac{2 \pi}{N} nk}$ 也好</p><p>所以$w_n^k = g_n^k \pmod p$ 也好, 只要满足了$n$和$\frac{n}{2}$次方的性质即可</p><hr><p>注意的是 $g_n^k \neq 1 \pmod p , k &lt; \varphi_p(g)$</p><p>例如</p><p>$p=998244353=7 \times 17 \times 2^{23}+1$</p><p>有$g_{2^{23}} = 3^{\frac{p-1}{2^{23}}}$</p><hr><p>据说$g$都挺小, 可以枚举$g$</p><hr><p>然后INTT, 和IFFT对应, IFFT 相当于乘上了$e^{i \frac{2 \pi}{N} nk} = \frac{1}{w_n^k}$</p><p>所以这里就是$g$的逆元,</p><h2 id="代码-模板"><a href="#代码-模板" class="headerlink" title="代码, 模板"></a>代码, 模板</h2><p><a href="https://github.com/CroMarmot/OICode/blob/master/functions/ntt998244353.cpp" target="_blank" rel="noopener">https://github.com/CroMarmot/OICode/blob/master/functions/ntt998244353.cpp</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (int i=a;i&lt;n;i++)const int MOD = 998244353; // 7*17*2^23 + 1const int MAXPWR = 22; // 随着MOD改变, 2的幂次, 对应复平面单位向量的N = 2 &amp;&amp; MAXPWR;const int g = 3;// 原根 随着MOD改变const int invg = 332748118;// 原根模逆元 随着MOD 和 g 改变// bit 翻转int rev(int x, int len) {  int ans = 0;  while(len -- ){    ans &lt;&lt;= 1;    ans |= x &amp; 1;    x &gt;&gt;= 1;  }  return ans;}inline int getlog2(int n){ return 31 - __builtin_clz(n);}ll mypow(ll a, ll k) { //快速幂，a**k  ll res = 1;  while (k) {    if (k &amp; 1) (res *= a) %= MOD;    (a *= a) %= MOD;    k &gt;&gt;= 1;  }  return res;}void NTT(vector&lt;ll&gt; &amp;A, int flag = 1 /* 1: NTT, -1: INTT*/ ) {  int n = A.size();  if(n == 1) return ;  // assert((n &amp; (n-1)) == 0); // 2 的幂次  int lgn = getlog2(n);  // assert(lgn &lt;= MAXPWR);  rep(i, 0, n) { // 同FFT    int j = rev(i, lgn);    if (j &gt; i) swap(A[i], A[j]);  }  rep(pwr,0,lgn){    int m = 1 &lt;&lt; pwr;    // assert((MOD - 1) % (m&lt;&lt;1) == 0);    ll gn = mypow(flag == 1 ? g : invg, (MOD - 1) / (m &lt;&lt; 1)); // 单位原根g_n    for (int k = 0; k &lt; n; k += (m&lt;&lt;1)) {      ll gi = 1;      rep(j,0,m) {        auto U = A[k + j];        auto T = gi * A[k + j + m] % MOD;        A[k + j] = (U + T) % MOD;        A[k + j + m] = (U - T + MOD) % MOD;        (gi *= gn) %= MOD;      }    }  }  if(flag == -1){ // 内置 / N    const ll INVSIZE = mypow(n, MOD-2);    rep(i,0,n) (A[i] *= INVSIZE) %= MOD;  }}void INTT(vector&lt;ll&gt; &amp;A){ NTT(A,-1);}int main(){  // 123*456 = 56088  const int SIZE = 8; // 一定要是2的幂次  auto a = vector&lt;ll&gt;{3,2,1,0,0,0,0,0};  auto b = vector&lt;ll&gt;{6,5,4,0,0,0,0,0};  // 计算  NTT(a);  NTT(b);  auto c = vector&lt;ll&gt;(SIZE,0);  rep(i,0,SIZE) c[i] = a[i] * b[i];  INTT(c);  // 输出  rep(i,0,SIZE) printf(&quot;(%lld)&quot;, c[i]);  printf(&quot;\n&quot;);  rep(i,0,SIZE-1) {// 进位    c[i+1] += c[i] / 10;    c[i] -= (c[i] / 10) * 10;  }  rep(i,0,SIZE) printf(&quot;(%lld)&quot;, c[i]);  printf(&quot;\n&quot;);  return 0;}</code></pre><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="http://yexiaorain.github.io/Blog/2019-01-02-fftmul/">我的FFT笔记</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;NTT&quot;&gt;&lt;a href=&quot;#NTT&quot; class=&quot;headerlink&quot; title=&quot;NTT&quot;&gt;&lt;/a&gt;NTT&lt;/h1&gt;&lt;p&gt;竟然Div2能出现NTT 虽然是在最后一题, 还是得学一学&lt;/p&gt;
&lt;h2 id=&quot;解决什么问题&quot;&gt;&lt;a href=&quot;#解决什么问题
      
    
    </summary>
    
      <category term="Codeforces" scheme="http://yexiaorain.github.io/Blog/categories/Codeforces/"/>
    
    
      <category term="fft" scheme="http://yexiaorain.github.io/Blog/tags/fft/"/>
    
      <category term="ntt" scheme="http://yexiaorain.github.io/Blog/tags/ntt/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 1709</title>
    <link href="http://yexiaorain.github.io/Blog/2022-07-23-CF1709/"/>
    <id>http://yexiaorain.github.io/Blog/2022-07-23-CF1709/</id>
    <published>2022-07-23T14:24:00.000Z</published>
    <updated>2022-08-08T00:54:42.979Z</updated>
    
    <content type="html"><![CDATA[<p>E(树,xor,贪心,树上启发式合并)F(dp,NTT,前缀和)</p><h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><p><a href="https://codeforces.com/contest/1709/problem/E" target="_blank" rel="noopener">https://codeforces.com/contest/1709/problem/E</a></p><p>给你个一个树, 每个点上有值, 修改尽量少的点为任意值</p><p>让任何简单路径的 xor都不为零</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>n 2e5</p><p>ai [1,2^30]</p><p>3s</p><p>256MB</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h3><p>显然啊, 类似树上差分的思想,  a…b xor = 0</p><p>意味着 a…root ^ root …b = 0</p><p>所以直接变成 计算每个数到根的xor</p><p>然后问题变成, 任意两个相同值之间的连线, 需要至少选一个点</p><p>或者说, 需要xor树最终两两不等 </p><p>不知道往后怎么搞</p><hr><p>一个思路是dp</p><p>但是 遇到同值点不是 祖先关系,而是分叉的关系 ,也不知打怎么记录</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>虽然的确有前缀意义,但其实 我想的总思路没问题, 但是细节有问题</p><p>并不是简单路径 = 到根的 路径 xor</p><p>因为它们的lca 被算了两次 </p><p>所以其实是 path[u]^path[v] = a[lca[u,v]]</p><hr><p>那么 对于一个点x  = lca(u,v) , 且 u..v 的xor = 0</p><p>那么 (x,y) 上至少有一点需要改变</p><p>然后 我们对所有的有这种情况的x 按深度从深到浅考虑</p><p>找深度最深的x, 那么修改 x的方案不会比修改 u…v 的更差</p><p>因为是最深的, 所以其它满足的链 如果经过它的子树 则必定经过它,因为它需要修改, 所以而至少一个, 而对于其它经过它的链来说是至多一个</p><hr><p>dfs(u){<br> 对于u的所有子树 dfs(v)</p><p> 每个点获取 从根到它的子节点 能得到的 xor 集合</p><p> 一旦有来自两个子树 中有值 xor == u 那么u就必然被选<br> 而被选的u对于它的父节点的返回是 空集合<br> 未被选的u对于它的父节点的返回是它所有子集合可达值 xor 它自身<br>}</p><hr><p>怎么看都是n^2 啊 , 为啥 O(nlog^2 n)</p><p>因为虽然dfs一次就可以把所有点到根的xor 算完</p><p>但是每次做 set 的合并时, 一个点就是会在它的 父节点 中被运算</p><p>那每个点被参与比较的次数可以达到 链的长度 不就是 n^2 吗</p><hr><p>然后神奇的是 这个启发式合并的复杂度不是n方</p><h3 id="启发式合并-DSU-on-Tree"><a href="#启发式合并-DSU-on-Tree" class="headerlink" title="启发式合并(DSU on Tree)"></a>启发式合并(DSU on Tree)</h3><p><a href="https://oi-wiki.org/graph/dsu-on-tree/#_3" target="_blank" rel="noopener">oi-wiki 树上启发式合并</a></p><p>重儿子, 儿子节点子节点个数最多的</p><p>重边, 当前点连向其中一个重儿子的边</p><p>轻边 非重边</p><hr><p>根到任意点 轻边不超过log n 条</p><p>反证法, 如果大于log n 条,</p><p>则最深的轻边的根至少还额外连了一个点大小为1的子树</p><p>第二深的轻边的根至少还额外连了一个点大小为3的子树</p><p>第三深的轻边的根至少还额外连了一个点大小为7的子树</p><p>…</p><p>第m深的轻边的根至少还额外连了一个点大小为2^m-1的子树</p><p>显然 m &gt; log n , 则 2^m - 1 &gt; n - 1 &gt;= n</p><p>性质得证</p><hr><p>那么每个节点 只有在它的某个祖先u的视角, 它是u的轻边的那一部分时, 才会作为被遍历的</p><p>所以每个节点的被遍历次数 = 它到根的 轻边数</p><p>所以 O(n log n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://codeforces.com/contest/1709/submission/165472602" target="_blank" rel="noopener">https://codeforces.com/contest/1709/submission/165472602</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readconst int N = 200000;int ans=0;int a[N+10]; // readint p[N+10]; // 当前每个节点对应st节点下标 pos[u]vector&lt;int&gt; e[N+10]; // edgeset&lt;int&gt; st[N+10]; // st[顶点] = {链到根的xor集合}void dfs(int u,int f, int x) {  int &amp;iu = p[u]; // 真的u  int bu = x^a[u]; // 从根下来的xor 链  st[iu].insert(bu);  bool delu = false; // delete u  for(auto v:e[u]) if(v != f){    dfs(v,u,bu);    int &amp;iv = p[v];    // 把小的向大的合并, 结果存在st[iu] 中    if(st[iu].size() &lt; st[iv].size()) swap(iu, iv);    for(auto val:st[iv]){      if(delu) break;      if(st[iu].count(val ^ a[u])) delu = true;    }    if(!delu) for(auto val:st[iv]) st[iu].insert(val);    st[iv] = {};  }  if(delu){    st[iu] = {};    ans++;  }}int main() {  int n = read();  rep(i,1,n+1) {    a[i] = read();    p[i] = i;  }  rep(i,1,n){    int u = read();    int v = read();    e[u].pb(v);    e[v].pb(u);  }  dfs(1,0,0);  printf(&quot;%d\n&quot;,ans);}</code></pre><h1 id="F"><a href="#F" class="headerlink" title="F"></a>F</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://codeforces.com/contest/1709/problem/F" target="_blank" rel="noopener">https://codeforces.com/contest/1709/problem/F</a></p><p>读入 n, k ,f</p><p>包含长度等于n的字符串 的可重集合 beautiful 定义为</p><p>对于长度 [1,n] 之间任意字符串s, c[s] &gt;= 集合中以s为前缀的字符串个数</p><p>任务 对于[1,n] 的所有字符串s, 你需要计算有多少 中映射c[s] 的选择方式</p><p>max(beautiful的集合的元素个数 )= f</p><p>其中 0 &lt;= c[s] &lt;= k</p><h3 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h3><p>n 15</p><p>k,f 2e5</p><p>6s</p><p>512ms</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h3><p>显然关于前缀</p><p>如果 s0 是 s1的前缀</p><p>那么显然 s0 出现的次数 &gt;= s1 出现的次数</p><p>那么 如果 c[s0] &lt;= c[s1] , c[s1] 就没什么作用</p><p>反过来, 如果 c[s0] &gt;= sum c[s0的所有下一级后缀], 那么c[s0] 也不是紧限制</p><p>因此 真正有效的内容是</p><p>c[s1] &lt;= c[s0] ,c[s0] &lt;= sum c[s0的所有下一级后缀], </p><hr><p>而这样约束以后, 方案数 就 = c[0] + c[1], 因为每个都表示<strong>能达到</strong>的最大个数</p><p>问题来了, 这样如何 算原始的c呢</p><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>转化一下题目</p><p>高度n的满二叉树</p><p>你需要对每个父子之间做最大流量限制,[0,k] 之间整数</p><p>让根源, 所有叶子汇, 的最大流恰好 = f</p><p>求方案数 % 998244353</p><hr><p>对于给定k</p><p>a(n,f) = 高度n, 最大恰好f的方案数</p><p>考虑状态转移</p><p>那么也就是 左边的n-1高度 最大流为v的时候,右边为f-v</p><p>但是这个 左边的最大流 可能是被根到左边这个边限制的, 也可能是本身n-1,v 的方案</p><p>定义 b(n,f) 等于 高度n 且根上多一个[0,k] 的限制的最大流 = k,方案数</p><p>如果是下面子树最大f, 那么对于根上可以选择 f~k, 所以有(k-f+1)a(n,f) 种</p><p>如果是下面子树最大 &gt; f, 那么对于根上仅可选择f, 所以有 $\sum_{i=f+1}^{2k} a(n,i) 种</p><p>综上$b(n,f) = (k-f+1)a(n,f) + \sum_{i=f+1}^{2k} a(n,i)$ , 前缀和每个状态 均摊O(1) 可算</p><p>那么对于a就是最开始的转移</p><p>$a(n,f) = \sum_{i=0}^f b(n-1,i)\cdot b(n-1,f-i)$, 卷积, 需要FFT或者NTT就可以搞</p><hr><p>那么答案 = $a(n,f)$, 也说明 $f &gt; 2k$ 无解</p><hr><p>最后边界处理, $b(n,f) = 0, f &gt; k$</p><hr><p>关于实现, 似乎直接NTT c++17会被卡, 可能要c++20</p><p>因为这里 相当于 是$a[n] = b[n-1]^2$, 所以平方可以少算一次NTT</p><p>然后 注意计算前把 末尾0删了, 不然可能长度倍增</p><p>以及我本地测 带了<code>-fsanitize</code>的编译, c++17/20 都4.5s, 而不带的都是1s</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p><a href="https://codeforces.com/contest/1709/submission/165613575" target="_blank" rel="noopener">https://codeforces.com/contest/1709/submission/165613575</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // read// ------------------------------- NTT --------------------------------namespace NTT998{  const int MOD = 998244353; // 7*17*2^23 + 1  const int MAXPWR = 22; // 随着MOD改变, 2的幂次, 对应复平面单位向量的N = 2 &amp;&amp; MAXPWR;  const int g = 3;// 原根 随着MOD改变  const int invg = 332748118;// 原根模逆元 随着MOD 和 g 改变  // bit 翻转  int rev(int x, int len) {    int ans = 0;    while(len -- ){      ans &lt;&lt;= 1;      ans |= x &amp; 1;      x &gt;&gt;= 1;    }    return ans;  }  inline int getlog2(int n){ return 31 - __builtin_clz(n);}  ll mypow(ll a, ll k) { //快速幂，a**k    ll res = 1;    while (k) {      if (k &amp; 1) (res *= a) %= MOD;      (a *= a) %= MOD;      k &gt;&gt;= 1;    }    return res;  }  void NTT(vector&lt;ll&gt; &amp;A, int flag = 1 /* 1: NTT, -1: INTT*/ ) {    int n = A.size();    if(n == 1) return ;    // assert((n &amp; (n-1)) == 0); // 2 的幂次    int lgn = getlog2(n);    // assert(lgn &lt;= MAXPWR);    rep(i, 0, n) { // 同FFT      int j = rev(i, lgn);      if (j &gt; i) swap(A[i], A[j]);    }    rep(pwr,0,lgn){      int m = 1 &lt;&lt; pwr;      // assert((MOD - 1) % (m&lt;&lt;1) == 0);      ll gn = mypow(flag == 1 ? g : invg, (MOD - 1) / (m &lt;&lt; 1)); // 单位原根g_n      for (int k = 0; k &lt; n; k += (m&lt;&lt;1)) {        ll gi = 1;        rep(j,0,m) {          auto U = A[k + j];          auto T = gi * A[k + j + m] % MOD;          A[k + j] = (U + T) % MOD;          A[k + j + m] = (U - T + MOD) % MOD;          (gi *= gn) %= MOD;        }      }    }    if(flag == -1){ // 内置 / N      const ll INVSIZE = mypow(n, MOD-2);      rep(i,0,n) (A[i] *= INVSIZE) %= MOD;    }  }  void INTT(vector&lt;ll&gt; &amp;A){ NTT(A,-1);}  // 平方 少一次 NTT  vector&lt;ll&gt; poly_sq(vector&lt;ll&gt; &amp;v0) {    int sz = v0.size() * 2;    if(sz == 0)return {};    sz = 1 &lt;&lt; (getlog2(sz) + !!(sz &amp; (sz-1))); // 非2的幂次    v0.resize(sz,0);    NTT(v0);    vector&lt;ll&gt; a2(sz,0);    rep(i,0,sz) a2[i] = v0[i] * v0[i] % MOD;    INTT(a2);    return a2;  }}// ------------------------------- NTT --------------------------------int n;vector&lt;ll&gt; a;vector&lt;ll&gt; b; // 滚动int main(){  const int MOD = NTT998::MOD;  int n = read(); // 15  int k = read(); // 2e5  int f = read(); // 2e5  if(f &gt; 2 * k){    printf(&quot;0\n&quot;);    return 0;  }  b = vector&lt;ll&gt;(k+1,1);  rep(i,1,n+1){    // a    a = NTT998::poly_sq(b); // 非平方也会TLE    if(a.size() &lt;= 2*k+1) a.resize(2*k+1,0);    vector&lt;ll&gt; prea(2*k+2, 0); // prefix sum of a    rep(j,0,2*k+1) prea[j+1] = (prea[j] + a[j]) % MOD;    b = vector&lt;ll&gt;(k+1,0);    rep(j,0,k+1) b[j] = (k-j+1) * a[j] % MOD + (prea[2*k+1] - prea[j+1]);    while(!b.empty() &amp;&amp; b.back() == 0) b.pop_back(); // 重要, 否则多出来的0 会导致 长度倍增 TLE  }  printf(&quot;%lld\n&quot;, a[f]);  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>E</p><p>一个是细节想错, lca多算一次 没想到</p><p>另一个是 考虑最深的lca的根 ,而不是考虑端点</p><p>这两点都是能想到没想到</p><p>然后关键的来了, 就是启发式合并的知识点, 这下学会了又</p><p>F</p><p>一个是变成树的 “流计算”, 很神奇 我好想 竖着觉得是树 ,横着就没发现了,</p><p>一个是学一下NTT, 以及NTT中的平方</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://codeforces.com/blog/entry/105164" target="_blank" rel="noopener">官方</a></p><p><a href="http://yexiaorain.github.io/Blog/2022-07-24-NTT/">NTT</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;E(树,xor,贪心,树上启发式合并)F(dp,NTT,前缀和)&lt;/p&gt;
&lt;h1 id=&quot;E&quot;&gt;&lt;a href=&quot;#E&quot; class=&quot;headerlink&quot; title=&quot;E&quot;&gt;&lt;/a&gt;E&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://codeforces.com/co
      
    
    </summary>
    
      <category term="Codeforces" scheme="http://yexiaorain.github.io/Blog/categories/Codeforces/"/>
    
    
      <category term="dp" scheme="http://yexiaorain.github.io/Blog/tags/dp/"/>
    
      <category term="贪心" scheme="http://yexiaorain.github.io/Blog/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="树" scheme="http://yexiaorain.github.io/Blog/tags/%E6%A0%91/"/>
    
      <category term="前缀和" scheme="http://yexiaorain.github.io/Blog/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
      <category term="xor" scheme="http://yexiaorain.github.io/Blog/tags/xor/"/>
    
      <category term="树上启发式合并" scheme="http://yexiaorain.github.io/Blog/tags/%E6%A0%91%E4%B8%8A%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/"/>
    
      <category term="NTT" scheme="http://yexiaorain.github.io/Blog/tags/NTT/"/>
    
  </entry>
  
  <entry>
    <title>LGV 引理</title>
    <link href="http://yexiaorain.github.io/Blog/2022-07-22-LGVlemma/"/>
    <id>http://yexiaorain.github.io/Blog/2022-07-22-LGVlemma/</id>
    <published>2022-07-22T14:24:00.000Z</published>
    <updated>2022-08-08T00:54:42.979Z</updated>
    
    <content type="html"><![CDATA[<p>Lindström–Gessel–Viennot lemma</p><p><a href="https://oi-wiki.org/graph/lgv/" target="_blank" rel="noopener">https://oi-wiki.org/graph/lgv/</a></p><p>前置知识, 图论基础,矩阵,行列式,高斯消元</p><p>适用于DAG上(有向无环图)</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>$P$ 路径</p><p>$\omega(P) = $ 路径$P$上边权之积</p><p>点$u,v$</p><p>$e(u,v) = \sum_{P:u\to v} \omega(P)$每一条 $u$到 $v$ 的路径$S$,的$\omega(P)$之和</p><p>大小为n的 起点集合A,终点集合B, (点集内也可能有边, 满足DAG, 以及还有一些不是起点也不是终点的其它中间的点</p><p>$S$ 一组不相交的路径组(路径集合,包含所有起点终点): 任意两个路径$S_i,S_j$没有公共顶点</p><p>$\sigma(S)$ 表示一个具体的路径集合$S$中,$A$按照顺序($S_i$的起点是$A_i$)时, $B$的下标序列</p><p>$N(\sigma) = \sigma$的逆序对个数</p><p>系数矩阵</p><p>$M = \begin{bmatrix}e(A_1,B_1)&amp;e(A_1,B_2)&amp;\cdots&amp;e(A_1,B_n)\\<br>e(A_2,B_1)&amp;e(A_2,B_2)&amp;\cdots&amp;e(A_2,B_n)\\<br>\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\<br>e(A_n,B_1)&amp;e(A_n,B_2)&amp;\cdots&amp;e(A_n,B_n)\end{bmatrix}<br>$</p><h2 id="引理"><a href="#引理" class="headerlink" title="引理"></a>引理</h2><p>其中$S$是不相交路径组</p><p>$\det(M)=\sum\limits_{S:A\rightarrow B}(-1)^{N(\sigma(S))}\prod\limits_{i=1}^n \omega(S_i)$</p><p>M的行列式的值是所有不相交路径的边权乘积的带符号数量和</p><hr><p>证明:</p><p>由行列式定义</p><p>$\begin{aligned}<br>\det(M)&amp;=\sum_{\sigma}(-1)^{N(\sigma)}\prod_{i=1}^ne(A_i,B_{\sigma_i})\\<br>&amp;=\sum_{\sigma}(-1)^{N(\sigma)}\prod_{i=1}^n\left(\sum_{P:A_i\rightarrow B_{\sigma_i}}\omega(P)\right)\\<br>&amp;=\sum_\sigma(-1)^{N(\sigma)}\sum_{\sigma=\sigma(S)}\prod_{i=1}^n \omega(S_i)\\<br>&amp;=\sum_{S:A\rightarrow B} (-1)^{N(\sigma(S))} \prod_{i=1}^n \omega(S_i)<br>\end{aligned}$</p><p>第一步是行列式展开</p><p>第二步是,e等价替换</p><p>第三步是,神奇的分配率, $(\omega(A_1\to B_{\sigma_1}方案0) + \omega(A_1\to B_{\sigma_1}方案1) + \cdots) \cdot (\omega(A_2\to B_{\sigma_2}方案0) + \omega(A_2\to B_{\sigma_2}方案1) + \cdots) \cdot (\cdots)$</p><p>这个使用分配率乘开了就是 方案之间的$\omega$之乘积, 再求和</p><p>再换句话说,原来内部的求和的是针对指定的起始点$A_i$结束点$B_{\sigma_i}$, 而拆开以后,把一个路径组看作单位,对路径组中第$i$条路径($A_i$)开头的进行统计</p><p>第四步就是, 把上面按照一个行列式的$\sigma$作为贡献的单位来计算,变成一个具体的$S$来计算,也是求和分配</p><hr><p>注意到上面仅证明了行列式能转换, 也保证了路径之间起点和终点互异, 但是<strong>没有证明是不相交路径</strong></p><p>但注意到对于所有(起点终点两两不同)的路径组,这个表达式也成立</p><p>对路径集合划分,$U$为不相交路径组,$V$为相交路径组</p><p>$\begin{aligned}<br>&amp;\sum_{S:A\rightarrow B} (-1)^{N(\sigma(S))} \prod_{i=1}^n \omega(S_i)\\<br>=&amp;\sum_{U:A\rightarrow B} (-1)^{N(\sigma(U))} \prod_{i=1}^n \omega(U_i)+\sum_{V:A\rightarrow B} (-1)^{N(\sigma(V))} \prod_{i=1}^n \omega(V_i)<br>\end{aligned}$</p><p>要证明右侧$\sum_{V:A\rightarrow B} (-1)^{N(\sigma(V))} \prod_{i=1}^n \omega(V_i) = 0$ 即可</p><p>对于$V$中一个具体的路径组$S$,取最小的相交路径的二元组$(i,j)$</p><p>有路径$S_i: A_i \to u \to B_{\sigma(S)_ i}$, $S_j: A_j \to u \to B_{\sigma(S)_ j}$, 其中$u$是路径上首次相交的点(注意到是DAG,所以两条路径中都是首次</p><p>修改得到路径$S_i: A_i \to u \to B_{\sigma(S)_ j}$, $S_j: A_j \to u \to B_{\sigma(S)_ i}$</p><p>这样得到$S’$</p><p>首先乘积的部分一致$\prod_{i=1}^n \omega(S_i) = \prod_{i=1}^n \omega(S’_ i)$, 而逆序对变化为$1 = |N(\sigma(S)) - N(\sigma(S’))|$, 所以 $S$与$S’$的贡献互为相反数, 总贡献和为$0$</p><p>并且根据这个交换产生规则,$S$唯一映射到$S’$,$S’$也唯一映射到$S$, 且$S \neq S’$ ??????? ( 感觉有点没对, 这样构造并不能保证交换后 最小二元组还是$(i,j)$, 因为被交换的路径和$i$ 有交,变成$(i,k)$</p><p>但是整体思路还是可以用的, 就是找标识去构建对称,总贡献为0.</p><p>这里需要改变的是, 把S中所有相交路径的交点中取编号最小的u, 在u处相交的取最小的二元组$(i,j)$ 并交换u以后的部分, 这样 交换以后能保证, 所有交点不变, 所以u依然最小,而在u处相交的也不变,依然是$(i,j)$, 这才有一一对应的关系</p><p>综上, 所有V中的两两成对,贡献和为$0$, 因此$V$的总贡献为$0$</p><p>证毕</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这又是行列式知识, 每个乘积的正负号 = (-1)的逆序对次方 乘对应位置的积</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Lindström–Gessel–Viennot lemma&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://oi-wiki.org/graph/lgv/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://oi-wiki.org/graph/l
      
    
    </summary>
    
      <category term="算法" scheme="http://yexiaorain.github.io/Blog/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="lgv lemma" scheme="http://yexiaorain.github.io/Blog/tags/lgv-lemma/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 1707</title>
    <link href="http://yexiaorain.github.io/Blog/2022-07-18-CF1707/"/>
    <id>http://yexiaorain.github.io/Blog/2022-07-18-CF1707/</id>
    <published>2022-07-18T14:24:00.000Z</published>
    <updated>2022-08-08T00:54:42.979Z</updated>
    
    <content type="html"><![CDATA[<p>C(最小生成树,LCA,树上差分)D(组合数,树上DP,DP,前缀和)E(数学,倍增)</p><h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><p><a href="https://codeforces.com/contest/1707/problem/C" target="_blank" rel="noopener">https://codeforces.com/contest/1707/problem/C</a></p><p>给你个n点,m边的连通图,边两两不等</p><p>有个错误的dfs算法, 每次找未选择的点中最短边进行dfs</p><p>问,从哪些点开始dfs,能得到正确的最小生成树</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>n 1e5</p><p>m [n-1,2e5]</p><p>2s</p><p>256MB</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>首先边两两不等,说明正确的最小生成树唯一</p><p>第二以一个点作为根, 按正确的最小生成树建树, 那么树边以外的其它边都是回边,没有跨边,则这个点做dfs合法</p><p>但这样每次枚举就是 O(n^2), TLE</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>先找到最小生成树</p><p>如果有连接 u v的非树边</p><p>那么 通过树边的简单路径 u—–v 通过树边的中间的点, 不可能, 且沿着树边扩展的点也不可能</p><hr><p>变成了树上染色问题</p><p>然后剩下就LCA,树上差分了</p><hr><p>LCA + 树上差分 思想就是</p><p>初始是对不可能的+1</p><p>然后因为批量+1 复杂度大</p><p>变成了记录每个数和它父节点的差(根节点表示自身的值), 就是树上差分了</p><p>那么对于 u,v 是非祖先关系, c[根]+=1,c[u]-=1,c[v]-=1</p><p>u和v是祖先关系, 假设u是v的祖先</p><p>c[u向v的子节点]+=1, c[v]-=1</p><p>最后还原差分成真实树即可, 判断 &gt; 0?</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://codeforces.com/contest/1707/submission/164711832" target="_blank" rel="noopener">https://codeforces.com/contest/1707/submission/164711832</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backconst int POWER = 20;const int N = 100000;const int M = 200000;ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readint n;int m;vector&lt;int&gt;p2[N+10]; // MSTpair&lt;int,int&gt; e[M+10]; // 边bool treee[M+10]; // tree edgeint f[N+10]; // 并查集int find(int v) {return f[v]==v?v:(f[v] = find(f[v]));}void link(int u,int v){ f[find(v)] = find(u);}ll x[N+10]; // 差分 和最终值int fa[N+10][POWER]; // 树上倍增int d[N+10]; // 深度// 一级父节点 和 深度void build(int u,int p = 1,int dep = 1){  fa[u][0] = p;  d[u] = dep;  for(auto v:p2[u]) if(v != p) build(v,u,dep+1);}// 还原差分void dfs(int u, int p = 1, int s = 0){  x[u] += s;  for(auto v:p2[u]) if(v != p) dfs(v,u,x[u]);}// 最近公共祖先int lca(int u,int v){  if(d[u] &lt; d[v])swap(u,v); // d[u] &gt; d[v]  per(i,0,POWER) if(d[u] - d[v] &gt;= (1 &lt;&lt; i)) u = fa[u][i];  if(u == v) return u;  per(i,0,POWER) {    if(fa[u][i] != fa[v][i]){      u = fa[u][i];      v = fa[v][i];    }  }  return fa[u][0];}// u 向上走d步int fa_d(int u,int d){  per(i,0,POWER) if(d &gt;= (1 &lt;&lt; i)) {    d -= (1&lt;&lt;i);    u = fa[u][i];  }  return u;}int main(){  // read  n = read();  m = read();  rep(i,0,m){    int u = read();    int v = read();    e[i] = {u,v};  }  // MST  iota(f+1,f+n+1,1);  rep(i,0,m){    auto [u,v] = e[i];    if(find(u) != find(v)) {      treee[i] = true;      link(u,v);      p2[u].pb(v);      p2[v].pb(u);    }  }  // 建立倍增  build(1); // 深度 和 1级父节点  rep(pwr,1,POWER) rep(i,1,n+1) fa[i][pwr] = fa[fa[i][pwr-1]][pwr-1];  // 树上差分  rep(i,0,m) if(!treee[i]){    auto [u,v] = e[i];    if(d[u] &gt; d[v]) swap(u,v); // d[u] &lt; d[v];    int r = lca(u,v);    if(u == r){      int w = fa_d(v, d[v] - d[u] - 1);      x[w]++;      x[v]--;    } else {      x[1]++;      x[u]--;      x[v]--;    }  }  // 差分还原成值  dfs(1);  // 输出答案  rep(i,1,n+1) printf(&quot;%d&quot;, (int)(x[i] == 0));  return 0;}</code></pre><h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><p><a href="https://codeforces.com/contest/1707/problem/D" target="_blank" rel="noopener">https://codeforces.com/contest/1707/problem/D</a></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>n 点 根为1树</p><p>初始 U = 1..n 点集合</p><p>一次操作, 取点集T, T 是U的部分虚树(T是U的真子集, 且T中任意两点的LCA也属于T), 令U=T</p><p>求 恰好k次操作后 集合只有根节点的操作路径有多少种</p><p>方案数 mod p </p><p>要求 k=1,2,…,n-1 所有的结果</p><h3 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h3><p>n 2000</p><p>p [1e8+7 ~ 1e9+9] 是 质数</p><p>2s</p><p>256mb</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h3><p>可能可以倒过来</p><p>初始只有根,每次增加至少一个点, 增加后要满足LCA的在集合中的关系, 一共k次</p><p>考虑一个叶子节点, 它可以任意时候被加入</p><p>一个非叶子只有一个分支的节点, 它也是任意时刻被加入</p><p>一个非叶子,多分支节点那么它加入的时机 需要 早于或等于 它的第二个被加入的子树</p><p>换句话说, 假设点i为多叉点,在t时刻被加入,那么 1..t-1 中至多只能存在点i 的其中一个子树中的点</p><p>f(t..k, all子树)</p><ul><li><p>f(1..k, 子树1, 至少一个在[1..t-1]) * f(t..k, all子树-子树1) + </p></li><li><p>f(1..k, 子树2, 至少一个在[1..t-1]) * f(t..k, all子树-子树2) + </p></li><li><p>…</p></li></ul><p>但似乎 注意到一个子树放在区间至于区间长度有关, 这样至少后面一半状态上是nk的</p><p>前面一节, 可以变成f(1..k,子树1) - f(t..k, 子树1) 这样剩下的至少一个不属于(t..k)</p><p>f(根u, 长度l) = for t = 1..l</p><p>转移还要n, 这样n^3, 而且还有k, 一眼TLE</p><p>考虑到本来状态就是 f(根u, 长度l) 也就是对于不同k可以复用, 那么问题来到了如何把转移优化到 log或者常数级别, 或者均摊常数级别</p><p>f(u,l) = f(v0, k - t + 1) * f(v1)</p><p>如果干掉这个t就好了</p><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>如果每次点数不严格下降结果为f,原答案为ans</p><p>有 $f_i=\sum_{j=0}^i\binom{i}{j}ans_j$, 因为j步意味着j+1个不同的集合, 要用这j+1个不同的集合按原顺序,可重复的产生i+1个集合, 那么其实就是选择每个开始的位置</p><p>既然是带系数前缀和,那也可以从 f反向推ans, 所以问题怎么球不严格下降的结果</p><hr><p>然后又是来到和我讨论类似的对删除时间的讨论</p><p>当一个节点u有分叉时</p><p>那么它的删除时间就会受到 子树的限制</p><ol><li><p>子树里所有节点 早于等于 u</p></li><li><p>u的某个子树以外的子树都删完了 早于等于 u, 早于剩下的子树最后一个节点</p></li></ol><p>状态 <code>dp[u][t]</code> , u以及它的子树,恰好第i次操作后删除完的方案数</p><hr><p>转移 $dp_{u,t}$</p><p>$C_u$ 是 $u$ 的子节点集合</p><p>前缀 $S_{u,t} = \sum_{i\le t} dp_{u,i}$</p><p>$u$子集前缀关于$t$的乘积 $M_{u,t} = \prod_{v \in C_u} S_{v,t}$</p><ol><li>$u$在$t$时刻删, 则 剩下的都在$[1,t]$时刻删</li></ol><p>$M_{u,t}$</p><ol start="2"><li>$u$在$t_0 &lt; t$ 时刻删, 因为要恰好, 则至少有个在$t$时刻删, 其它在$[1,t_0]$时刻删</li></ol><p>$ \sum_{v\in C_u} (dp_{v,t} \cdot \prod_{w \in C_u, w \neq v}^N S_{w,t_0})$</p><p>$ = \sum_{v\in C_u} (dp_{v,t} \cdot \frac{\prod_{w\in C_u} S_{w,t_0}}{S_{v,t_0}})$</p><p>$ = \sum_{v\in C_u} dp_{v,t} \cdot \frac{M_{u,t_0}}{S_{v,t_0}}$</p><p>对于所有$t_0 \in [1..t-1]$ 加和</p><p>$ = \sum_{t_0 = 1}^{t-1} (\sum_{v\in C_u} dp_{v,t} \cdot \frac{M_{u,t_0}}{S_{v,t_0}})$</p><p>$ = \sum_{v\in C_u} (dp_{v,t} \cdot (\sum_{t_0 = 1}^{t-1} \cdot \frac{M_{u,t_0}}{S_{v,t_0}}))$</p><hr><p>综上</p><p>$ dp_{u,t} = M_{u,t} + \sum_{v\in C_u} (dp_{v,t} \cdot (\sum_{t_0 = 1}^{t-1} \cdot \frac{M_{u,t_0}}{S_{v,t_0}}))$</p><p>每个$S_{u,t}$, 均摊只需要O(1), $S$总状态$O(n^2)$, 所以时间复杂度$O(n^2)$</p><p>然后每个$M_{u,t}$ 均摊需要$O(|C_u|)$, 对于所有$u$的$|C_u|$和为 节点数,所以时间复杂度也是$O(n^2)$</p><p>再看 $\sum_{t_0 = 1}^{t-1} \cdot \frac{M_{u,t_0}}{S_{v,t_0}}$</p><p>注意和$u,v,t$ 有关,但v只能是u的子节点集, 所以状态数为$O(|C_u|n)$, 总状态数依然是$O(n^2)$, 同样通过t的前缀和, 均摊$O(1)$, 所以总时间复杂度也是$O(n^2k)$</p><p>最后$dp_{u,t}$, 状态显然$O(n^2)$, 时间复杂度$O(|C_u|)$, 所以总时间复杂度$O(n^2)$;</p><p>可做……….</p><hr><p>咦,看起来和我的很像啊, 是不是我的那个t也可以干掉</p><p>可能不一定,别人通过恰好来简化了转移方便了前缀和实现</p><hr><p>最后的最后, 通过$ans_i = f_i - \sum_{j=0}^{i-1} \binom{i}{j} ans_j $反推即可</p><hr><p>实际写起来有几点坑,</p><ol><li><p>时间卡得紧, 不要频繁的用费马小定理 计算inv, TLE11</p></li><li><p>Wa31 第31个点 会出现S是MOD的倍数…..</p></li></ol><p>然后Wa31需要小学数学, 因为本身是乘法, 变成除法只是为了简化运算, 所以本身不会有除0, 但 变化后 加上mod 就可能除以0</p><p>注意到这里其实就是M和S之间,所以统计一下M中少乘一个零的结果, 当S=0时取那个结果即可</p><p>然后 因为量级很大, 不能去 大量做mod除法, 所以一个办法是记录 分子分母, 另一个办法是</p><p>M/S也变成前缀+后缀的形式来算, 当然前缀+后缀形式会常数更小</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>分数+除法 857ms 158MB</p><p><a href="https://codeforces.com/contest/1707/submission/164894672" target="_blank" rel="noopener">https://codeforces.com/contest/1707/submission/164894672</a></p><p>前后缀 + longlong 733ms 81MB</p><p><a href="https://codeforces.com/contest/1707/submission/164900140" target="_blank" rel="noopener">https://codeforces.com/contest/1707/submission/164900140</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backint MOD = -1;ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readll mpow(ll v,ll mi){ll r = 1;while(mi){if(mi%2)(r*=v)%=MOD;(v*=v)%=MOD;mi&gt;&gt;=1;};return r;} // quick power with MODint n;vector&lt;int&gt; e[2010];void dfs(int u,int fa){  vector&lt;int&gt; arr = {};  for(auto v: e[u]) if(v != fa) arr.pb(v);  e[u] = arr;  for(auto v: e[u]) dfs(v, u);}struct ModInt{  int v;  ModInt(ll val = 0) :v(val) { }};ll real(const ModInt &amp; v0){  return (v0.v + MOD) % MOD;}ModInt operator+(const ModInt &amp; v0, const ModInt &amp;v1){  return (v0.v + v1.v) % MOD;}ModInt operator-(const ModInt &amp; v0, const ModInt &amp;v1){  return (v0.v - v1.v) % MOD;}ModInt operator*(const ModInt &amp; v0, const ModInt &amp;v1){  return ((ll)v0.v * (ll)v1.v) % MOD;}ModInt dp[2010][2010];vector&lt;ModInt&gt; preMu[2010]; // 每次只会具体 u 可以复用vector&lt;ModInt&gt; sufMu[2010];ModInt S[2010][2010];ModInt W[2010][2010];ModInt fac[2010] = {1};ModInt invv[2010] = {1};ModInt invfac[2010] = {1};ModInt C(int n,int m) { return fac[n] * invfac[m] * invfac[n-m]; }ModInt ans[2010];int main(){  n = read();  MOD = read();  rep(i,1,n){    int u = read();    int v = read();    e[u].pb(v);    e[v].pb(u);  }  // 30 ms  rep(i,1,n+1) fac[i] = fac[i-1] * i;  invv[1] = 1;  rep(i,2,n+1) invv[i] = (MOD-MOD/i) * invv[MOD % i];  rep(i,1,n+1) invfac[i] = invfac[i-1] * invv[i];  dfs(1, 1);  // 61ms  // bfs on tree  vector&lt;int&gt; vorder = {1};  rep(i, 0, vorder.size()) {    int u = vorder[i];    for(auto v: e[u]) vorder.pb(v);  }  reverse(vorder.begin(), vorder.end());  for(auto u: vorder) {    rep(t,1,n) {      ModInt &amp;dput = dp[u][t] = 1; // 叶子      if(!e[u].empty()) {        // 优化成 前后缀        preMu[t] = vector&lt;ModInt&gt; (e[u].size() + 1, 1);        sufMu[t] = vector&lt;ModInt&gt; (e[u].size() + 1, 1);        rep(i,0,e[u].size()){          auto v = e[u][i];          preMu[t][i+1] = preMu[t][i] * S[v][t];        }        per(i,0,e[u].size()){          auto v = e[u][i];          sufMu[t][i] = sufMu[t][i+1] * S[v][t];        }        dput = preMu[t][e[u].size()];        if(t &gt; 1) rep(i,0,e[u].size()) {          auto v = e[u][i];          ModInt &amp;Wvt = W[v][t-1] = ((t-1 &gt; 1) ? W[v][t-2] : 0) + (preMu[t-1][i] * sufMu[t-1][i+1]);          dput = dput + dp[v][t] * Wvt;        }      }      S[u][t] = ((t &gt; 1) ? S[u][t-1] : 0) + dput;    }  }  rep(t,1,n) ans[t] = preMu[t][e[1].size()];  rep(t,1,n) rep(t0,1,t) ans[t] = ans[t] - ans[t0] * C(t,t0) ;  rep(t,1,n) printf(&quot;%lld &quot;, real(ans[t]));  return 0;}</code></pre><h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><p><a href="https://codeforces.com/contest/1707/problem/E" target="_blank" rel="noopener">https://codeforces.com/contest/1707/problem/E</a></p><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>长度n数组 a</p><p>$ai \in [1,n]$</p><p>f((l,r)) = (min(a[l..r]) , max(a[l..r])), 传入区间范围, 返回最小值和最大值</p><p>每次调用 (l,r) = f((l,r))</p><p>q个询问</p><p>每次问如果初始 li,ri, 需要反复调用 多少次 让l和r 最终变成(1,n) 或不可能</p><h3 id="范围-2"><a href="#范围-2" class="headerlink" title="范围"></a>范围</h3><p>q 1e5</p><p>n 1e5</p><h2 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路-2"><a href="#我的思路-2" class="headerlink" title="我的思路"></a>我的思路</h3><p>显然对于给定l,r 输出的f是一定的</p><p>所以对于所有的输入, 全部成环</p><p>那么f( (1,n) ) 一定要等于 (1,n), 否则 只有直接传入1,n 才会满足</p><p>想倒着找, 但是显然有最坏情况, 2 3 4 5 6, 这样一共有$O(n^2)$种不同输入和结果</p><h3 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h3><p>如果 区间A 包含于区间B</p><p>那么 f(A) 包含于 f(B)</p><p>证明, min(B) &lt;= min(A) &lt;= max(A) &lt;= max(B)</p><p>并且高阶f也有这个包含关系</p><hr><p>因此如果 [l,r] = ([l,r0] 并 [l0,r]), 其中 (l0 &lt;= r0) </p><p>那么 f(l,r) 包含 (f(l,r0) 并 f(l0,r)), </p><p>注意到 f(l,r0) 包含 f(l0,r0), f(l0,r) 也包含 f(l0,r0)</p><p>所以 f(l,r0) 和 f(l0,r) 本身就重叠, 所以 f(l,r0) 并 f(l0,r) = 连续的区间</p><p>那么 f(l,r) 的最小值 至少包含于 f(l,r0) 和 f(l0,r) 的其中一个, 最大值也是, 所以最小值最大值都存在,且连续, 包含于 f(l,r)</p><p>综上 f(l,r0) 并 f(l0,r) = f(l,r)</p><p>同样高阶也满足</p><p>例如2阶段, f(f(l,r)) = f(f(l,r0)) 并 f(f(l0,r)) , 思路同上, 包含于关系, 最小 最大值, 连续 推出相等</p><hr><p>注意到 一旦能到整个长度,那么一定 f(1,n) = (1,n)</p><p>如果链很长, 根据状态数 可能达到n^2</p><p>那么 办法就是倍增, 倍增到&gt; n^2 如果还不行那就真不行了</p><p>可以的话就二分倍增的倍数</p><p>为了效率, 用倍增记录每个位置开始的长度的 多少轮跳跃的结果</p><hr><p>然后实现上几点注意, 别二分, 每次二分会导致 长度不是幂次 依然需要log, 多层log过不了</p><p>找结果依然是倍增的找</p><p>然后就是cpu缓存和tlb机制, 注意循环顺序访问顺序和数组定义顺序</p><p>这导致常数影响非常明显, tle的代码和600+ms过的代码 就是把顺序换了换</p><hr><p>然后我看有人 长度开的2^18 也过了!!!, 不知道数学上是否有办法证明或者找反例</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><p><a href="https://codeforces.com/contest/1707/submission/164951002" target="_blank" rel="noopener">https://codeforces.com/contest/1707/submission/164951002</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readconst int N = 100000;const int PLEN = 19; // power length math.log(100000) / math.log(2) 16.609640474436812const int POP = 35; // power operation math.log(4999950000) / math.log(2) 32.219266521851075ll n;int L[POP][PLEN][N+10]; // 次数不用记录零次int R[POP][PLEN][N+10];int LG2[N+10]; // 0 和 1 都对应0次方, 需要减的 1&lt;&lt;LG2[r-l]的偏移量int a[N+10];inline pii f(int l,int r,int p1){  if(l == r) return {    L[p1][0][l],    R[p1][0][r]  };  int sz = LG2[r-l];  return {    min(L[p1][sz+1][l],L[p1][sz+1][r-(1&lt;&lt;sz)]),    max(R[p1][sz+1][l],R[p1][sz+1][r-(1&lt;&lt;sz)])  };}inline int query(int l,int r){  if(l == 1 &amp;&amp; r == n) return 0;  if(l == r) return -1;  // 不要二分, 二分是 log(n^2) = 2 log(n) * log(n)  // 直接binary 倍增做, log(r-l+1)*O(1) &lt; log(n)  ll ret = 0;  per(i, 0, POP){    // printf(&quot;%d = %d\n&quot;,r-l,p0);    int l0, r0;    tie(l0, r0) = f(l, r, i);    if(l0 != 1 || r0 != n){      // checklrk(l, r, 1ll &lt;&lt; i, l0, r0);      l = l0;      r = r0;      ret += (1ll &lt;&lt; i);      if(l == r) return -1;    }  }  tie(l,r) = f(l, r, 0);  return (l == 1 &amp;&amp; r == n) ? (ret + 1) : -1;}int main(){  n = read();  rep(i,2,N) LG2[i] = LG2[i/2] + 1;  int q = read();  rep(i,1,n+1) L[0][0][i] = R[0][0][i] = a[i] = read();  {    const int p1 = 0;    rep(p0,1,PLEN) rep(i,1,n+1) {      L[p1][p0][i] = min(L[p1][p0-1][i],L[p1][p0-1][min(n,i+(1ll &lt;&lt; max(0ll, p0-2)))]);      R[p1][p0][i] = max(R[p1][p0-1][i],R[p1][p0-1][min(n,i+(1ll &lt;&lt; max(0ll, p0-2)))]);      // check(i,p0,p1);    }  }  rep(p1, 1, POP) rep(p0, 0, PLEN) rep(i,1,n+1){    tie(        L[p1][p0][i] ,        R[p1][p0][i]       ) = f(         L[p1 - 1][p0][i],         R[p1 - 1][p0][i],         p1 - 1         );  }  while(q--){    int l = read();    int r = read();    printf(&quot;%d\n&quot;, query(l,r));  }  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>C</p><p>有想到, 环的最大边的 两点以外的点不可能,但是有反例, 就是没有把最小生成树 和 这个合在一起考虑</p><p>后面LCA和树上差分倒是没啥问题掌握了</p><p>D</p><p>感觉真有可能能做出来, 多习惯在dp时 分别恰好,和 小于等于 ,以及 前缀和方程与逆方程之间的联系</p><p>被小学数学教育了$a \neq \frac{a\cdot b}{b}$</p><p>然后就是 大量的inv还是不要, 一个办法就是 分数表示, 一个办法是想办法消除掉除法</p><p>E</p><p>数学推出性质以后 就是倍增倍增倍增了</p><p>实现上也有一些坑</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://codeforces.com/blog/entry/104930" target="_blank" rel="noopener">官方</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;C(最小生成树,LCA,树上差分)D(组合数,树上DP,DP,前缀和)E(数学,倍增)&lt;/p&gt;
&lt;h1 id=&quot;C&quot;&gt;&lt;a href=&quot;#C&quot; class=&quot;headerlink&quot; title=&quot;C&quot;&gt;&lt;/a&gt;C&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://codefo
      
    
    </summary>
    
      <category term="Codeforces" scheme="http://yexiaorain.github.io/Blog/categories/Codeforces/"/>
    
    
      <category term="LCA" scheme="http://yexiaorain.github.io/Blog/tags/LCA/"/>
    
      <category term="DP" scheme="http://yexiaorain.github.io/Blog/tags/DP/"/>
    
      <category term="前缀和" scheme="http://yexiaorain.github.io/Blog/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
      <category term="组合数" scheme="http://yexiaorain.github.io/Blog/tags/%E7%BB%84%E5%90%88%E6%95%B0/"/>
    
      <category term="树上差分" scheme="http://yexiaorain.github.io/Blog/tags/%E6%A0%91%E4%B8%8A%E5%B7%AE%E5%88%86/"/>
    
      <category term="数学" scheme="http://yexiaorain.github.io/Blog/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="倍增" scheme="http://yexiaorain.github.io/Blog/tags/%E5%80%8D%E5%A2%9E/"/>
    
      <category term="最小生成树" scheme="http://yexiaorain.github.io/Blog/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
      <category term="树上DP" scheme="http://yexiaorain.github.io/Blog/tags/%E6%A0%91%E4%B8%8ADP/"/>
    
  </entry>
  
  <entry>
    <title>Atcoder arc144</title>
    <link href="http://yexiaorain.github.io/Blog/2022-07-17-ac_arc144/"/>
    <id>http://yexiaorain.github.io/Blog/2022-07-17-ac_arc144/</id>
    <published>2022-07-16T20:25:14.000Z</published>
    <updated>2022-08-08T00:54:42.979Z</updated>
    
    <content type="html"><![CDATA[<p>D(数学,组合数),E(有向图,并查集,gcd,所有环,树回边)</p><h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://atcoder.jp/contests/arc144/tasks/arc144_d" target="_blank" rel="noopener">https://atcoder.jp/contests/arc144/tasks/arc144_d</a></p><p>有多少个映射f满足</p><p>定义域[0..2^n-1]</p><p>值域[0..k]</p><p>且值域内任意值x,y满足</p><p>f(x) + f(y) = f(x &amp; y) + f(x | y)</p><h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h3><p>n 3e5</p><p>k 1e18</p><p>2s</p><p>1024mb</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h3><p>f(…0) + f(1) = f(…1) + f(0)</p><p>f(…0.) + f(10) = f(…1.) + f(0)</p><p>因此 自由元素 f(0) f(1) f(2) f(4) …</p><p>把 f(0..2^{n-1}-1)看作整体, 那么 f(2^{n-1}..2^{n}-1) 可以看作它的平移</p><p>显然有</p><p><code>dp[i][min][max] = sum{dp[i-1][min][min..max]} + sum{dp[i-1][min..max][max]} - dp[i-1][min][max]</code></p><p>然而这 $O(nk^2)$ 显然时间空间都接受不了</p><p>不知道怎么化简</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>跟着上面思路 如果 f(0) = 0 , 那么 f(x) = 按二进制拆开x的 sum f(bit)</p><p>相当于 f(1) + f(2) + f(4) + f(8) … &lt;= k 插板组合数</p><p>如果f(0) != 0, 令 f(0) = V</p><p>那么令 g(x) = f(x) - V</p><p>那么g(x) 也满足条件,  -V &lt;= g(x) &lt;= K - V</p><p>0 &lt;= sum g(任意2幂)  + V &lt;= k</p><p>sum 正g(2幂) + V &lt;= k</p><p>sum 负g(2幂) + V &gt;= 0</p><hr><p>然后就是</p><p>枚举<code>f(0)</code> 的值V</p><p>枚举正数个数i, i个正的和 $\le k-V$, 因为小于等于 所以不妨把<code>k-V-和+1</code> 看作一个新的正数,相当于 i+1个正数 和 = k-V+1, 那就是k-V空隙插i个板子</p><p>枚举负数个数j,同理</p><p>$\sum_{V=0}^k \sum_{i=0}^n \sum_{j=0}^{n-i} \binom{n}{i} \binom{n-i}{j} \binom{k-V}{i} \binom{V}{j}$</p><p>$\sum_{i=0}^n \sum_{j=0}^{n-i} \binom{n}{i} \binom{n-i}{j} (\sum_{V=0}^k  \binom{k-V}{i} \binom{V}{j})$</p><p>$\sum_{i=0}^n \sum_{j=0}^{n-i} \binom{n}{i} \binom{n-i}{j} (\sum_{V=j}^{k-i}  \binom{k-V}{i} \binom{V}{j})$</p><p>右侧括号里,可以想成$k+1$个球, 选出$i+j+1$个球的组合方案数</p><p>我们去枚举被选的第$i+1$个球的位置$p$, $p \in [i+1,k+1-j]$</p><p>那么左侧有$p-1$个, 需要选出$i$个, 右侧有$k + 1 - p$个需要选出$j$个</p><p>令$V = k + 1 - p$即和现在表达式一致了</p><p>所以</p><p>$\sum_{i=0}^n \sum_{j=0}^{n-i} \binom{n}{i} \binom{n-i}{j} \binom{k+1}{i+j+1}$</p><p>$\sum_{i=0}^n \sum_{j=0}^{n-i} \binom{i+j}{i} \binom{n}{i+j} \binom{k+1}{i+j+1}$</p><p>$\sum_{i+j \le n} \binom{i+j}{i} \binom{n}{i+j} \binom{k+1}{i+j+1}$</p><p>二项式和</p><p>$\sum_{s = 0}^n 2^s \binom{n}{s} \binom{k+1}{s+1}$</p><p>就可以做了</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/arc144/submissions/33279666" target="_blank" rel="noopener">https://atcoder.jp/contests/arc144/submissions/33279666</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 998244353#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readll mul(ll a,ll b){  a %= MOD;  b %= MOD;  return a * b % MOD;}ll add(ll a,ll b){  a %= MOD;  b %= MOD;  return (a + b) % MOD;}ll normal(ll a){  return (a%MOD + MOD)%MOD;}ll mypow(ll v,ll pwr){  v%=MOD;  ll r = 1;  while(pwr){    if(pwr%2) (r*=v)%=MOD;    (v*=v)%=MOD;    pwr/=2;  }  return r;}ll fac[300010] = {1};ll binom(ll n,ll m){  if(m &gt; n) return 0;  return fac[n] * mypow(fac[m],MOD-2) % MOD * mypow(fac[n-m],MOD-2) % MOD;}int main(){  rep(i,1,300005) fac[i] = mul(fac[i-1],i);  int n = read();  ll k = read();  ll ans = 0;  ll binomk1s1 = 1; // k 很大  rep(s,0,n+1){    if(s &gt; k) break;    binomk1s1 = mul(binomk1s1,mul(k+1-s,mypow(s+1,MOD-2)));    ans = add(ans,mul(mul(mypow(2,s),binom(n,s)),binomk1s1) );  }  printf(&quot;%lld\n&quot;, normal(ans));  return 0;}</code></pre><h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>N点,M边有向图</p><p>有向边 都是从小节点指向大节点的(无自环,无重边)</p><p>输入一个初始W[1..N],其中如果是Wi=-1,就可以取任何值,否则按给定的来</p><p>点i 权重 Wi</p><p>求最大从1到N的所有路径的权重和的gcd</p><p>如果gcd可能无限大则输出-1</p><p>不需要输出W的方案</p><h3 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h3><p>N 3e5</p><p>M 3e5</p><p>至少存在一条路径</p><p>初始Wi [1…10e12]</p><p>2s</p><p>1024MB</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h3><p>首先 如果存在一条完全给定的 <code>1-&gt;N</code>的权重和则有限大,否则可能无限大(<code>A-&gt;B, B-&gt;C-&gt;D, B-&gt;D</code>, 其中<code>B</code>任意,而后面指定两条路径不等, 那么gcd也是有限大)</p><p>对于有限大, 因为有向边全是从小指向大, 所以不成环只有拓扑关系</p><p>在没有具体值的情况, 并不能对求和的表达式计算gcd</p><p>所以考虑有没有可能反过来</p><p>反过来指定gcd, 1个问题是并没有二分性质, 每条边的可能性是考虑mod gcd,也是gcd个, 量级也不会太小</p><p>对于直接有指定W路径的相对好一些, 其中gcd一定是它的约数,这样情况会少一些,但是Ai和M都很大,即使给定的路径W和也可以达到3e17</p><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>首先干掉 1不能到达, 和 不能到达N的点(无效的点), 防止无效的点影响找环的结果</p><p>如果k是答案,那么也就是所有路径 和 %k == 0</p><p>那么假设 到点u, <code>(1 -&gt; u)%k = p[u]</code> 是唯一的</p><p>那么所有直接相邻的 <code>vi-&gt;u</code>, 有 <code>p[vi] + w[u] = p[u] (mod k)</code></p><p>说明<code>p[vi]</code> 全部一样</p><p>这样, 就并查集了!</p><p>然后<code>p[n] = 0</code>, 所以可以加0号点 <code>W[0] = 0</code>, 路径<code>0-&gt;1</code></p><hr><p>有直接相邻<code>u-&gt;v</code>,且<code>w[v]</code>给定,</p><p>说明 两个并查集里的 的<code>union[u] + 3 = union[v]</code></p><hr><p>变成了 一些点, 和一些有权有向边</p><p>找所有环, 求gcd, 并不能找所有环,但是gcd性质上, 所有环gcd = 所有(树+回边) gcd</p><p>所以就可以搞了</p><p>环即可能由0产生, 也会有形如<code>A-&gt;B-&gt;C-&gt;D, A-&gt;D</code>, 这样产生</p><hr><p>无环 就任意都可以, -1</p><hr><p>然后有向图找环 我真不会写</p><p>学了一下apiad巨佬的代码, 发现是所有边建立正向和负向, 保证任何简单复杂路径 = 端点简单路径和即 全部像是无向图的有向图, 这样任何一个点可以作为根</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/arc144/submissions/33329393" target="_blank" rel="noopener">https://atcoder.jp/contests/arc144/submissions/33329393</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (int i=a;i&lt;(int)n;i++)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readll gcd(ll a,ll b){return b == 0?a:gcd(b,a%b);}const int N = 300000;int n,m;vector&lt;int&gt; u2v[N+10]; // 正向边vector&lt;int&gt; v2u[N+10]; // 反向边ll w[N+10];int invalid[N+10]; // 1 无效, 0 有效, -1 未访问int fa[N+10]; // 并查集// 并查集int getfa(int v){ return v == fa[v]?v:(fa[v] = getfa(fa[v]));}void link(int u,int v){ fa[getfa(u)] = getfa(v);}// 计算不可达bool dfs1n(int u){  int &amp;r = invalid[u];  if(r != -1) return r;  if(u == n) return r = 0;  r = 1;  for(auto v:u2v[u]) if(!dfs1n(v)) r = 0;  return r;}// 移除不合法vector&lt;int&gt; rminvalid(const vector&lt;int&gt; &amp;arr){  vector&lt;int&gt; ret = {};  for(auto u: arr) if(!invalid[u]) ret.pb(u);  return ret;}vector&lt;pair&lt;int,ll&gt; &gt; p2[N+10];int vis[N+10];ll dis[N+10]; // 和根的距离, root distancevoid dfs(int idx,ll d,ll &amp; ans) {  if(vis[idx]) {    // (环长 = 多树边 + 1回边), (重边), 多回边的环 gcd = 拆分的多个单回边环的gcd的gcd    ans = gcd(ans, abs(d - dis[idx]) );    return ;  }  vis[idx] = true;  dis[idx] = d;  for(auto [v,s]:p2[idx]) dfs(v, d + s, ans);}int main(){  n = read();  m = read();  iota(fa,fa+n+1,0); // fa[i] = i  fill(invalid+1,invalid+n+1,-1); // invalid[i] = -1  rep(i,1,m+1) { // u -&gt; v    int u = read();    int v = read();    u2v[u].push_back(v);    v2u[v].push_back(u);  }  rep(i,1,n+1) w[i] = read();  // 筛无效点  dfs1n(1);  rep(u,1,n+1) if(!invalid[u]) u2v[u] = rminvalid(u2v[u]);  rep(v,1,n+1) if(!invalid[v]) v2u[v] = rminvalid(v2u[v]);  // n -&gt; 1  u2v[n].pb(1);  v2u[1].pb(n);  // 找所有点的源点, 计算并查集  rep(v,1,n+1) if(!invalid[v]) rep(i,1,v2u[v].size()) link(v2u[v][i-1], v2u[v][i]);  // 根据给定w 建立新的图  rep(v,1,n+1) if(!invalid[v] &amp;&amp; w[v] != -1){    int tov = getfa(v); // 并查集中的点    int fromv = getfa(v2u[v][0]); // assert(v2u[tov].size()); 因为都可达所以每个点一定有前置点    // 全部双向边 辅助在有向图中找所有环的gcd    p2[fromv].pb({tov, w[v]}); // 正向    p2[tov].pb({fromv, -w[v]}); // 负向  }  // 找环  ll ans = 0;  rep(i,1,n+1) if(!invalid[i] &amp;&amp; !vis[i]) dfs(i,0,ans);  printf(&quot;%lld\n&quot;,ans == 0? -1: abs(ans));  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>D</p><p>这个对f(0) = 0特殊讨论 ,在 讨论f(0) 不为零的转化, 就是 一个特殊边界讨论 + 向特殊转移的问题</p><p>然后什么神奇的范德蒙恒等式(这里并不是, 但有一点思路相近的感觉</p><p>$\binom{n+m}{k} = \sum_{i=0}^k \binom{m}{i} \binom{n}{k-i}$</p><p>其实就是考虑$(1+x)^{m+n}$的$x^k$系数和 $(1+x)^m\cdot (1+x)^n$的$x^k$的系数</p><p>总之还有一些组合数的技巧,不是光有了初始表达式就可以的</p><p>E</p><p>讨论满足目标条件的 相邻转移</p><p>然后这个有向找所有环的gcd 也是学了一手, 改成正负双向</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://atcoder.jp/contests/arc144/editorial" target="_blank" rel="noopener">官方题解</a></p><p><a href="https://www.bilibili.com/video/BV1aB4y1a74j" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1aB4y1a74j</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;D(数学,组合数),E(有向图,并查集,gcd,所有环,树回边)&lt;/p&gt;
&lt;h1 id=&quot;D&quot;&gt;&lt;a href=&quot;#D&quot; class=&quot;headerlink&quot; title=&quot;D&quot;&gt;&lt;/a&gt;D&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;head
      
    
    </summary>
    
      <category term="Atcoder" scheme="http://yexiaorain.github.io/Blog/categories/Atcoder/"/>
    
    
      <category term="并查集" scheme="http://yexiaorain.github.io/Blog/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="gcd" scheme="http://yexiaorain.github.io/Blog/tags/gcd/"/>
    
      <category term="组合数" scheme="http://yexiaorain.github.io/Blog/tags/%E7%BB%84%E5%90%88%E6%95%B0/"/>
    
      <category term="数学" scheme="http://yexiaorain.github.io/Blog/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="有向图" scheme="http://yexiaorain.github.io/Blog/tags/%E6%9C%89%E5%90%91%E5%9B%BE/"/>
    
      <category term="所有环" scheme="http://yexiaorain.github.io/Blog/tags/%E6%89%80%E6%9C%89%E7%8E%AF/"/>
    
      <category term="树回边" scheme="http://yexiaorain.github.io/Blog/tags/%E6%A0%91%E5%9B%9E%E8%BE%B9/"/>
    
  </entry>
  
</feed>
