<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog</title>
  
  
  <link href="/Blog/atom.xml" rel="self"/>
  
  <link href="http://yexiaorain.github.io/Blog/"/>
  <updated>2022-07-07T17:16:42.314Z</updated>
  <id>http://yexiaorain.github.io/Blog/</id>
  
  <author>
    <name>Xiao Ye</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Codeforces 1699</title>
    <link href="http://yexiaorain.github.io/Blog/2022-07-05-CF1699/"/>
    <id>http://yexiaorain.github.io/Blog/2022-07-05-CF1699/</id>
    <published>2022-07-05T14:24:00.000Z</published>
    <updated>2022-07-07T17:16:42.314Z</updated>
    
    <content type="html"><![CDATA[<p>D(dp)E(双指针,部分更新,1/2+1/3+1/4+…)</p><p>这次Div2的D,E都不会了</p><h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><p><a href="https://codeforces.com/contest/1699/problem/D" target="_blank" rel="noopener">https://codeforces.com/contest/1699/problem/D</a></p><p>长度n数组A</p><p>每次操作可以删除相邻且不同的两个值, 剩下的拼在一起, 多次操作</p><p>要让最终的数组值全部相同,求最大长度</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>n 5000</p><p>2s</p><p>256MB</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>如果我们指定哪个值留下来</p><p>假设是v</p><p>那么 考虑两个v之间的其它值 v …. v</p><p>如果其中有值x出现次数超过一半, 那么剩下的必然是x - 非x</p><p>否则,如果是奇数个剩下任意一个, 偶数个则全部清除</p><p>最后可以得到一个 v 非v v 非v v …</p><p>的多段结果</p><p>然后我并没有什么办法 处理这个</p><p>如果有办法就是n^2 的总复杂度了</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>首先如果一个数出现次数超过一半,那最终剩下的一定是它,所以这种情况不用猜留哪个</p><p>如果整个长度是偶, 且没有数出现次数超过一半,那么可以被完全删除</p><p>然后通过O(n^2) 计算所有区间 最多出现的数字,或者全部可消除</p><p>啊 我知道啊</p><hr><p>dp[i] 表示a[0…i]删除以后 结果包含a[i] 的最大长度</p><p>初始化 如果[0..i-1] 能完全删除 dp[i] = 1, 否则 dp[i] = -INF</p><p>如果<code>j &lt; i, a[i] == a[j]</code> 且 <code>[j+1..i-1]</code> 能完全删除</p><p><code>dp[i] = max(dp[j]+1)</code></p><p>所以最后就是求所有中的最大的且后缀可删除<code>rm[j..end] == true</code>, 相当于找结果的末尾位置</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://codeforces.com/contest/1699/submission/162852461" target="_blank" rel="noopener">https://codeforces.com/contest/1699/submission/162852461</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readint n;int a[5010];  // 5000 n^2bool rm[5010][5010]; // rm[i][j] = [i..j] 完全删除int dp[5010]; // 前[0..i] 删完剩下 a[i] 的个数const int INF = 0x3f3f3f3f;void w(){  n = read();  rep(i,0,n) a[i] = read();  rep(i,0,n){    fill(rm[i],rm[i]+n,false);    vector&lt;int&gt;cnt(n+1,0); // 次数统计    int maxc = -1; // 出现最多的    rep(j,i,n){      cnt[a[j]]++;      if(maxc == -1 || cnt[maxc] &lt; cnt[a[j]]) maxc = a[j];      if((j-i)%2 == 0)continue;      if(cnt[maxc] &lt;= (j-i+1)/2) rm[i][j] = true;    }  }  rep(i,0,n) dp[i] = (i == 0 || rm[0][i-1]) ? 1: -INF; // 初始化  int ans = 0;  rep(i,0,n){    rep(j,0,i){      if((i-j)%2==0)continue;      if(a[i] != a[j]) continue;      if(j == i-1 || rm[j+1][i-1]) dp[i] = max(dp[i], dp[j]+1);    }    if(i == n-1 || rm[i+1][n-1]) ans = max(ans,dp[i]); // 后续可删  }  printf(&quot;%d\n&quot;,ans);}int main(){  int t = read();  while(t--) w();  return 0;}</code></pre><h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><p>给你长度n数组a</p><p>每次你可以把任意一个值v=a乘b,拆成a,b,</p><p>求 min(max(数组) - min(数组))</p><h2 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h2><p>n 1e6</p><p>ai [1..5e6]</p><p>4s</p><p>256MB</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h3><p>直接想 有点像是说, 能否把每个数拆分进[l..r] 之间</p><p>变个方向就是 给定l,求最小的r</p><p>那么考虑l的变化</p><p>因为任意两个ai,aj的拆分方案互不影响, 考虑单个 v 拆成最小&gt;=l时,最大r的最小值的</p><p>显然l增大时,r 非严格单增, 且l &lt;= min(ai)的</p><p>而问题是让区间尽量小</p><p>区间长度并没有单调性或凹凸性, 想法方向GG</p><hr><p>第二个想法是</p><p>我直接拆每个数, 去计算每个数的<code>map[间隔] = vector&lt; pair&lt;最小,最大&gt; &gt;</code></p><p>比如 <code>4: [0] = { { 2 , 2 } , { 4 , 4 } }</code></p><p>但不知道怎么拆, dfs暴力?</p><p>以及拆分后怎么在不同ai之间组合</p><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>和我第一个想法类似但是倒着for最小的因子</p><p>因为不同v的拆法互不影响,考虑一个具体的原数组中出现过的 v</p><p>若当前最小因子恰好为i, 那么</p><p>如果 v不是i的倍数, 则,之前v怎么拆分就怎么拆分</p><p>如果 <code>v &lt; i^2</code>, 显然不能拆,如果拆了 另一个因子就会小于i</p><p><code>v &gt;= i^2</code> 且<code>v = ik</code> , 那么会拆成<code>i 和 k</code>, 而对于<code>k</code>可能也有拆的方案</p><p>我们直接记录<code>dp[k] =</code>当前拆分方案中, 最大的因子</p><p>有<code>dp[ik] = min(old dp[ik], dp[k])</code>, 其中<code>k &gt;= i</code></p><p>这里要注意的是当一个数<code>v=ik</code>是i的倍数,它按i拆开仅是可能让最大因子更小,而不是一定, 所以要和之前的<code>dp[v]</code> 比较</p><hr><p>而最大值, 显然是非严格单调递减, 我们只需要 统计每个值拆分后的最大因子(也是非严格单调递减)出现次数, 就能知道最大值</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p><a href="https://codeforces.com/contest/1699/submission/162860620" target="_blank" rel="noopener">https://codeforces.com/contest/1699/submission/162860620</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readconst int N = 5000000;bool appear[N+10]; // 在数列中出现过int mxval[N+10]; // [v] = v当前被拆分出来的更大的因子 , 运算过程中每个值的变化是非严格单调递减int cnt[N+10]; // 遍历过程中 每个ai拆分后对应最大因子 的 次数统计int n;int m;void w(){  // clear  fill(appear,appear+m+1,false);  fill(cnt,cnt+m+1,0);  fill(mxval,mxval+m+1,0);  n = read();  m = read();  int mn = m; // 最小  int mx = 0; // 最大  rep(i,0,n){    int x = read();    appear[x] = true;    cnt[x] = 1;    mn = min(mn, x);    mx = max(mx, x);  }  iota(mxval,mxval+mx+1,0); // mxval[i] = i; 默认都未被拆分  int ptr = mx; // 最大值  ll ans = mx - mn;  per(i,1,mx+1){    for (ll j = i * i; j &lt;= mx; j += i) { // j = i * (k&gt;=i) , j 拆分成 i 和 k, k可能继续能拆      // 移除原有拆分方案      if (appear[j]) cnt[mxval[j]]--; // 从真的统计上讲 应该是 [i]--, [mxval[j]]--, 但i &lt;= mxval[j] 所以 这里 中间一段不影响结果      // 计算新的最优方案      mxval[j] = min(mxval[j], mxval[j / i]); // i 不一定是最小的, 所以吆喝之前的比较      // 加入新的拆分方案      if (appear[j]) cnt[mxval[j]]++;    }    while (cnt[ptr] == 0) ptr--;    if (i &lt;= mn) ans = min(ans, ptr - i); // 最小值为i, 最大值为ptr  }  printf(&quot;%lld\n&quot;,ans);}int main() {  int t = read();  while (t--) w();}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>D</p><p>核心其实还是dpi可以和ai挂钩,因为其它什么区间可删除都想到了, 感觉应该还很常见的</p><p>E</p><p>倒着处理</p><p>只更新会影响的部分内容</p><p>因为遍历的i就是最小, 所以拆分统计, 不需要统计非最大因子以外的内容, 优化统计</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://codeforces.com/blog/entry/104088" target="_blank" rel="noopener">官方</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;D(dp)E(双指针,部分更新,1/2+1/3+1/4+…)&lt;/p&gt;
&lt;p&gt;这次Div2的D,E都不会了&lt;/p&gt;
&lt;h1 id=&quot;D&quot;&gt;&lt;a href=&quot;#D&quot; class=&quot;headerlink&quot; title=&quot;D&quot;&gt;&lt;/a&gt;D&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https
      
    
    </summary>
    
      <category term="Codeforces" scheme="http://yexiaorain.github.io/Blog/categories/Codeforces/"/>
    
    
      <category term="DP" scheme="http://yexiaorain.github.io/Blog/tags/DP/"/>
    
      <category term="双指针" scheme="http://yexiaorain.github.io/Blog/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="部分更新" scheme="http://yexiaorain.github.io/Blog/tags/%E9%83%A8%E5%88%86%E6%9B%B4%E6%96%B0/"/>
    
      <category term="1/2+1/3+1/4+..." scheme="http://yexiaorain.github.io/Blog/tags/1-2-1-3-1-4/"/>
    
  </entry>
  
  <entry>
    <title>Atcoder abc258</title>
    <link href="http://yexiaorain.github.io/Blog/2022-07-03-ac_abc258/"/>
    <id>http://yexiaorain.github.io/Blog/2022-07-03-ac_abc258/</id>
    <published>2022-07-02T20:25:14.000Z</published>
    <updated>2022-07-07T17:16:42.314Z</updated>
    
    <content type="html"><![CDATA[<p>F(暴力)G(bitset)H/Ex(dp,矩阵快速幂)</p><h1 id="F"><a href="#F" class="headerlink" title="F"></a>F</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://atcoder.jp/contests/abc258/tasks/abc258_f" target="_blank" rel="noopener">https://atcoder.jp/contests/abc258/tasks/abc258_f</a></p><p>网格,4临移动</p><p>如果 x=Bn的线上移动或者y=Bn的线上移动,(B的倍数), 单位距离代价1</p><p>其它情况单位距离代价k</p><p>求(sx,sy) -&gt; (gx,gy) 的最小代价</p><h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h3><p>t 2e5 测试点</p><p>b,k [1,1e9]</p><p>sx,sy,gx,gy [0,1e9]</p><p>3s</p><p>1024mb</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h3><p>显然是个数学处理一下, 就做的题</p><p>两个点分开考虑</p><p>一个点计算它本身, 四个方向到x=bn or y=bn , 的点,再到四个角的点</p><p>点类型 (普通0,边点1,十字交点2)</p><p>(0-任何) 直接距离乘k</p><p>(边点 - 边/十字) = 在方向上同bn, 则x1, 否则直接距离乘k</p><p>(十字-十字) = 距离x1</p><p>写了二十多分钟</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc258/submissions/32973579" target="_blank" rel="noopener">https://atcoder.jp/contests/abc258/submissions/32973579</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 1000000007#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readll b;ll k;const int T_NORMAL = 0; // 普通const int T_SIDE = 1; // 边const int T_CROSS = 2; // 角int calctype(ll i,ll j){  return (int)(i%b == 0) + (int)(j%b == 0);}vector&lt;array&lt;ll,3&gt; &gt; calc(ll i,ll j){  // i , j , dis  vector&lt;ll&gt; ai = {i};  vector&lt;ll&gt; aj = {j};  if(i%b) {    ai.pb((i/b)*b);    ai.pb((i/b+1)*b);  }  if(j%b) {    aj.pb((j/b)*b);    aj.pb((j/b+1)*b);  }  vector&lt;array&lt;ll,3&gt; &gt; res;  for(auto ni:ai){    for(auto nj:aj){      if(ni != i &amp;&amp; nj != j){        res.pb({ni,nj, (abs(ni-i) + abs(nj-j) - max(abs(ni-i), abs(nj-j)))*k + max(abs(ni-i), abs(nj-j)) });      }else{        if(i % b != 0 &amp;&amp; j%b != 0){          res.pb({ni,nj, (abs(ni-i) + abs(nj-j))*k});        }else{          res.pb({ni,nj, (abs(ni-i) + abs(nj-j))});        }      }    }  }  return res;}void w(){  b = read();  k = read();  ll si = read();  ll sj = read();  ll gi = read();  ll gj = read();  auto ijds = calc(si,sj);  auto ijdg = calc(gi,gj);  ll ans = 0x3f3f3f3f3f3f3f3f;  for(auto [i0,j0,d0]:ijds){    int t0 = calctype(i0,j0);    for(auto [i1,j1,d1]:ijdg){      int t1 = calctype(i1,j1);      if(t0 == T_NORMAL || t1 == T_NORMAL){        ans = min(ans,d0+d1+ (abs(i1-i0) + abs(j1-j0))*k);      }else if(t0 == T_SIDE || t1 == T_SIDE){        if(i0 == i1 &amp;&amp; i0 % b == 0){          ans = min(ans,d0+d1+abs(j1-j0));        }else if(j0 == j1 &amp;&amp; j0 % b == 0){          ans = min(ans,d0+d1+abs(i1-i0));        }else{          ans = min(ans,d0+d1+(abs(i1-i0)+abs(j1-j0))*k);        }      }else{ // == CROSS        ans = min(ans,d0+d1+abs(i1-i0)+abs(j1-j0));      }    }  }  printf(&quot;%lld\n&quot;,ans);}int main(){  int t = read();  while(t--) w();  return 0;}</code></pre><h1 id="H-Ex"><a href="#H-Ex" class="headerlink" title="H/Ex"></a>H/Ex</h1><p><a href="https://atcoder.jp/contests/abc258/tasks/abc258_h" target="_blank" rel="noopener">https://atcoder.jp/contests/abc258/tasks/abc258_h</a></p><p>序列X满足</p><ol><li>所有元素正奇数</li><li>和为s</li><li>X前缀和的值不在集合A中, 集合A大小为N</li></ol><p>求满足的要求的序列X的个数</p><h2 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h2><p>n 1e5</p><p>ai [1,1e18]</p><p>s [1,1e18]</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h3><p>果然读错题, 读成了需要序列X长度也是N</p><p>实际上对序列长度无要求</p><hr><p>不考虑X而是直接考虑X的前缀和</p><p><code>dp[v] =</code> 构成v的方案数</p><p><code>dp[Aj] = 0</code></p><p><code>dp[0] = 1</code></p><p>递推关系</p><p><code>dp[v] = sum{dp[v-1]+dp[v-3]+ dp[v-5]+...}</code></p><p>令<code>f[i] = dp[i] + dp[i-2] + dp[i-4]</code></p><p>有<code>dp[v] = f[v-1]</code> <code>f[v] = dp[v] + f[v-2] = (v in A ? 0 :f[v-1]) + f[v-2]</code></p><p>所以可以直接算f 矩阵快速幂</p><p>然后问题是要处理掉v 在 A中的情况, 并且注意到v在A中是<code>dp[v] == 0</code> 并不意味<code>f[v-1] == 0</code></p><pre><code>(f[v-1] f[v-2]) (f[v] f[v-1])                (1/0    1   )                ( 1     0   )</code></pre><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc258/submissions/32981204" target="_blank" rel="noopener">https://atcoder.jp/contests/abc258/submissions/32981204</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 998244353#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readint n;ll s ;ll a[100010];// Wi = (f[i]  f[i-1])// (f[v] f[v-1]) = (f[v-1] f[v-2]) *//                                (1/0    1   )//                                ( 1     0   )vector&lt;vector&lt;ll&gt; &gt; mul(vector&lt;vector&lt;ll&gt; &gt;m0,vector&lt;vector&lt;ll&gt; &gt;m1){  vector&lt;vector&lt;ll&gt; &gt; r = vector&lt;vector&lt;ll&gt; &gt;(m0.size(), vector&lt;ll&gt;(m1[0].size(),0));  assert(m0[0].size() == m1.size());  rep(i,0,m0.size()){    rep(j,0,m1[0].size()){      rep(k,0,m0[0].size()){        (r[i][j] += m0[i][k] * m1[k][j] % MOD) %= MOD;      }    }  }  return r;}vector&lt;vector&lt;ll&gt; &gt; mypow(vector&lt;vector&lt;ll&gt; &gt;m0,ll pwr){  vector&lt;vector&lt;ll&gt; &gt; r = {    {1,0},    {0,1}  };  while(pwr){    if(pwr%2) r = mul(r,m0);    m0 = mul(m0,m0);    pwr/=2;  }  return r;}int main(){  n = read();  s = read();  rep(i,0,n) a[i] = read();  a[n] = s; // dp[s] = f[s-1] =&gt;  w[s][1]  n++;  vector&lt;vector&lt;ll&gt; &gt; w; // w[iw] = {f[iw], f[iw-1]}  ll iw = 1;  if(a[0] == 1) w = { {0,1} };  else w = { {1,1} };  rep(i,0,n){    ll ai = a[i];    if(iw == ai)continue;    if(iw == ai-1){      w = mul(w,{          {0,1},          {1,0}          });      iw = ai;    }else{      w = mul(          mul(w,mypow({              {1,1},              {1,0}              }, ai-iw-1)),{          {0,1},          {1,0}          });      iw = ai;    }    // printf(&quot;w[%lld] = {%lld %lld}\n&quot;,iw, w[0][0],w[0][1]);  }  printf(&quot;%lld\n&quot;,w[0][1]);  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>F</p><p>没啥难的</p><p>G</p><p>内置 bitset 优化一下效率就行了</p><p>Ex</p><p>也没啥难的</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://atcoder.jp/contests/abc258/editorial" target="_blank" rel="noopener">官方题解</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;F(暴力)G(bitset)H/Ex(dp,矩阵快速幂)&lt;/p&gt;
&lt;h1 id=&quot;F&quot;&gt;&lt;a href=&quot;#F&quot; class=&quot;headerlink&quot; title=&quot;F&quot;&gt;&lt;/a&gt;F&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="Atcoder" scheme="http://yexiaorain.github.io/Blog/categories/Atcoder/"/>
    
    
      <category term="暴力" scheme="http://yexiaorain.github.io/Blog/tags/%E6%9A%B4%E5%8A%9B/"/>
    
      <category term="bitset" scheme="http://yexiaorain.github.io/Blog/tags/bitset/"/>
    
      <category term="矩阵快速幂" scheme="http://yexiaorain.github.io/Blog/tags/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 1698</title>
    <link href="http://yexiaorain.github.io/Blog/2022-07-02-CF1698/"/>
    <id>http://yexiaorain.github.io/Blog/2022-07-02-CF1698/</id>
    <published>2022-07-02T14:24:00.000Z</published>
    <updated>2022-07-07T17:16:42.310Z</updated>
    
    <content type="html"><![CDATA[<p>F(数学,数组,相邻无序对)G(GF(2),meet in middle,不懂证明)</p><h1 id="F"><a href="#F" class="headerlink" title="F"></a>F</h1><p><a href="https://codeforces.com/contest/1698/problem/F" target="_blank" rel="noopener">https://codeforces.com/contest/1698/problem/F</a></p><p>给长度n的数组A和B</p><p>每次可以选择A数组中值相等两个数,把它们中间的区间颠倒顺序</p><p>求$n^2$次数内的方案得到B</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>n 500</p><p>1s</p><p>256MB</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>没有思路</p><p>只知道首个和末个 有重复的数字的一定位置不会变,且它们两侧的也不会变</p><p>但如何记录翻转并不知道</p><p>可行的话, 首先每个值个数要一样</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>数组不变量</p><p>首先a1和an是不会变的</p><p>然后是相邻元素构成无序对不变, 因为 区间 v…v颠倒,那么 中间和v连接的依然和v连接</p><p>必要显然</p><p>充分性, 我们具体构造</p><p>假设 前缀 a[..i] 和 b[..i] 相同, a[i] = x</p><p>a[i+1] = y</p><p>b[i+1] = z</p><p>如果存在 <code>a[i..] = [x,y,...,z,x,...]</code> 那么直接翻转 做1次</p><p>如果 <code>a[i...] = [x,y,...,x,z,...]</code>, 如果 <code>x,z</code> 右侧还有<code>x</code> 则翻转2次</p><p>否则 <code>x,z</code> 的<code>x</code>是最后出现的<code>x</code>, 所以, x至少2个</p><p>如果x恰好2个, 且是连着 <code>a[i..]= [x,y,x,z,...]</code>, <code>b[i..] = [x,z,....y,x,y,...]</code> , 这样转b</p><p>否则<code>a[i..]</code> 中 x相邻至少3对相邻</p><p>那么根据上面的,只有最后的那一个x的右侧不能通过,x本身交换 完成, 而a和b的操作是对称的</p><p>所以 <code>3对</code>中 最多<code>2对</code>无法交换,所以总存在一个相邻,可以0~2次 完成换到<code>a[i..] = [x,?,...]</code></p><p>即只要满足,无序对的性质</p><p>那么<code>a[0..i]</code> 一致了 就有办法让<code>b[0..i]</code> 一致</p><hr><p>直接暴力找 <code>O(n^2)</code></p><p>注意到的是算法实际的次数是不超过4n的</p><p>而需要的是小于$n^2$的次数,所以考察 <code>n=[1..4]</code>的合法的数组的操作次数时候</p><p>n=1 0次</p><p>n=2 0次</p><p>n=3 0次</p><p>n=4 0次/1次</p><p>所以也满足次数要求</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><a href="https://codeforces.com/contest/1698/submission/162605498" target="_blank" rel="noopener">https://codeforces.com/contest/1698/submission/162605498</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;#define MOD 1000000007#define rep(i,a,n) for (int i=a;i&lt;(int)n;i++)#define per(i,a,n) for (int i=n;i--&gt;(int)a;)int read(){int r;scanf(&quot;%d&quot;,&amp;r);return r;} // readint n;int a[510];int b[510];// 翻转区间void rev(int *arr,int i,int j){  rep(k,i,j+1){    int rk = j-(k-i);    if(rk &lt; k)break;    swap(arr[k],arr[rk]);  }}// 找arr[sti...]中 找 [x,y,...,z,x,...], 翻转成[x,z...]bool op(int *arr,int sti,int z,vector&lt;pair&lt;int,int&gt;&gt; &amp; ans){  int x = arr[sti];  rep(i,sti+1,n){    // [x,y........z,x]    // [sti............i]    if(arr[i] == x &amp;&amp; arr[i-1] == z){      rev(arr, sti+1,i-1);      ans.push_back({sti+1,i+1});      return true;    }  }  return false;}// 找arr[sti...]中 找 [x,y,...,x,z,...,x,...], 翻转成[x,z...]bool oprev(int *arr,int sti,int z,vector&lt;pair&lt;int,int&gt;&gt; &amp; ans){  int x = arr[sti];  rep(i,sti+1,n){    // [x,y........x,z,.....x]    // [sti..........i      j]    if(arr[i] == z &amp;&amp; arr[i-1] == x){      rep(j,i+1,n){        if(arr[j] == x){          rev(arr, sti+1,j-1);          ans.push_back({sti+1,j+1});          return op(arr,sti,z,ans);        }      }      return false;    }  }  return false;}void w(){  n = read();  rep(i,0,n) a[i] = read();  rep(i,0,n) b[i] = read();  if(a[0] != b[0]) {    printf(&quot;NO\n&quot;);    return ;  }  if(a[n-1] != b[n-1]){    printf(&quot;NO\n&quot;);    return ;  }  vector&lt;pair&lt;int,int&gt;&gt; pa;  rep(i,1,n){    int u = a[i-1];    int v = a[i];    if(u &gt; v) swap(u,v);    pa.push_back({u,v});  }  vector&lt;pair&lt;int,int&gt;&gt; pb;  rep(i,1,n){    int u = b[i-1];    int v = b[i];    if(u &gt; v) swap(u,v);    pb.push_back({u,v});  }  sort(pa.begin(),pa.end());  sort(pb.begin(),pb.end());  if(pa != pb){    printf(&quot;NO\n&quot;);    return ;  }  printf(&quot;YES\n&quot;);  // 一定可以  // -------------  vector&lt; pair&lt;int,int&gt; &gt;ans; // 正向  vector&lt; pair&lt;int,int&gt; &gt;revans; // 反向  rep(i,0,n){    if(a[i] != b[i]){      int x = a[i-1];      //      if(op(   a,i-1,b[i],ans))continue;      if(oprev(a,i-1,b[i],ans))continue;      if(op(   b,i-1,a[i],revans))continue;      if(oprev(b,i-1,a[i],revans))continue;      int w = -1; // 找既不等于 b[i] 也不等于a[i]的 x相邻的, 至少存在一个      rep(j,i+1,n){        if(a[j] == x){          if(a[j-1] != a[i] &amp;&amp; a[j-1] != b[i]){            w = a[j-1];          }else if(a[j+1] != a[i] &amp;&amp; a[j+1] != b[i]){            w = a[j+1];          }          assert(w!=-1);          break;        }      }      assert(w!=-1);      if(!op(a,i-1,w,ans)){        assert(oprev(a,i-1,w,ans));      }      if(!op(b,i-1,w,revans)){        assert(oprev(b,i-1,w,revans));      }    }  }  per(i,0,revans.size()) ans.push_back(revans[i]);  printf(&quot;%d\n&quot;,(int)ans.size());  for(auto [u,v]:ans){    printf(&quot;%d %d\n&quot;,u,v);  }}int main(){  int t = read();  while(t--) w();  return 0;}</code></pre><h1 id="G"><a href="#G" class="headerlink" title="G"></a>G</h1><p>S 是长度n的0/1串</p><p>让S与任意个S的任意正位移 做xor</p><p>求 结果中1的个数恰好2个,且字符串表示下字典序最大的串中, 这两个1的位置</p><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>n 35</p><p>2s</p><p>256MB</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h3><p>显然 第一次取S</p><p>然后把首个1以后的内容 的 首个1与S的首个1对齐 做xor, 直到后续剩余的只有1个1</p><p>这样的话,S的首个1和末个1各贡献一次, 位置就可以算了</p><p>为了简化运算,可以预处理掉S的前后缀0记录下来</p><hr><p>然而n有35, 虽然无法估计精确复杂度,但这样做上限是2的35次方会超时,写出来也果然tle 6 了</p><h3 id="官方"><a href="#官方" class="headerlink" title="官方"></a>官方</h3><p>多项式问题</p><p>首先 忽略S前后缀0, 这些零在最后的结果中会加回来</p><p>那么把S看作在GF(2)域中多项式P(x)</p><p>Galois Field, 只有0,1二元及+（异或运算）×（与运算）</p><p>那么要求的是$P(x)Q(x) = x^k+1$ 的最小k</p><p>P(x)的常数项是1, Q是任意的, 所以一定存在</p><p>证明, 显然 $x^k$ 随着k增大$x^k \mod P(x)$ 成周期,且始终不为0, 那么周期的就是一个$x^k \mod P(x) = 1$的解</p><p>所以$k \le 2^{35}$ 依然很大</p><p>要用的方法是meet in middle?</p><hr><p>emmmmm 就是直接除 然后meet in middle?</p><p>我没懂 这个prod 为何一定是 mod 为1, 以及GF(2)域上的相关性质</p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_back#define all(x) (x).begin(), (x).end()int n;char s0[100];ll mod;// (i*j)%mod in GF(2)ll mul(ll i, ll j) {  ll res = 0;  rep(x, 0, n-1) {    if (i &amp; (1LL &lt;&lt; x)) res ^= j;    j &lt;&lt;= 1;    if (j &amp; (1LL &lt;&lt; (n - 1))) j ^= mod; // 取mod in GF(2)  }  return res;}// (2**i)%mod in GF(2)ll pow2(ll pwr) {  ll res = 1; // result  ll b = 2; // base  while (pwr) { // pwr    if (pwr &amp; 1) res = mul(res, b);    b = mul(b, b);    pwr &gt;&gt;= 1;  }  return res;}// v的二进制最高位1在2的多少幂次, high1(3) = 1int high1(ll v){  int leadz = __builtin_clzll(v); // x 前缀0个数  return 63 - leadz;}int main() {  char *s = s0;  scanf(&quot;%s&quot;,s);  n = strlen(s);  vector&lt;int&gt; pos; // 只用来判断 &lt;= 2的1  rep(i,0,n){    if (s[i] == &#39;1&#39;) pos.push_back(i+1);  }  per(i,0,n) { // remove trailing zero    if(s[i] != &#39;0&#39;) break;    s[i] = 0;  }  rep(i,0,n) { // remove prefix zero    if(s[0] != &#39;0&#39;) break;    s++;  }  int offset = s - s0; // 前导0  n = strlen(s);  if (pos.size() == 0) { // all zero    printf(&quot;-1\n&quot;);    return 0;  }  if (pos.size() == 1) { // only 1 of 1    printf(&quot;%d %d\n&quot;,pos[0],pos[0]+1);    return 0;  }  if (pos.size() == 2) { // 恰好2个    printf(&quot;%d %d\n&quot;,pos[0],pos[1]);    return 0;  }  rep(i, 0, n) { // 正向和逆向结果一样的    if (s[i] == &#39;1&#39;) mod |= (1LL &lt;&lt; i); // s.trim().tobinary()  }  printf(&quot;s: %lld\n&quot;,mod);  int h = (n + 1) / 2; // 半长  ll val = mod;  ll prod = 1; // (2**h(x)-1)(2**h(x))**(pwr-1)  rep(x, 3LL, 1 &lt;&lt; h) { // GF(2)乘法还满足结合率    if (!(x &amp; 1)) continue; // x 末位是1    int pwr = 0; // val = x^pwr * ... 相当于 计算GF(2) 中 val的因子和幂次    while (true) {      ll curr = val;      ll other = 0;      rep(bit, 0, n) {        if (!(curr &amp; (1LL &lt;&lt; bit))) continue;        curr ^= x &lt;&lt; bit;        other ^= 1LL &lt;&lt; bit;      }      if (curr)  break;      // val = x * other in GF(2)      printf(&quot;%lld = %lld * %lld\n&quot;, val, x, other);      val = other;      pwr++;    }    if (pwr) { // x的pwr次方      printf(&quot;=&gt; %lld ** %d\n&quot;,x,pwr);      printf(&quot;high1[%lld] =  %d\n&quot;,x,high1(x));      // prod *= (10-1) * 10 * 10 ,        3**3      prod *= (1LL &lt;&lt; high1(x)) - 1;      rep(y, 1, pwr) prod *= 1LL &lt;&lt; high1(x);    }  }  // val 的 一次方  if (val &gt; 1) prod *= (1LL &lt;&lt; high1(val)) - 1;  // mod =&gt; GF(2) =&gt; 基的幂次 乘积 =&gt; (2的幂次)的幂次和2的(幂次-1) 的 积  ll ans = 1LL &lt;&lt; 60;  // printf(&quot;prod:%lld\n&quot;,prod);  assert(pow2(prod) == 1); // 2**prod ???????????????????????????????????????????  for (ll x = 1; x * x &lt;= prod; x++) { // 长度一定是prod的因子 ????????????????????????????????    if (prod % x ) continue;    if (pow2(x) == 1) ans = min(ans, x);    if (pow2(prod / x) == 1) ans = min(ans, prod / x);  }  printf(&quot;%d %lld\n&quot;,offset+1,offset+ans+1);}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>F</p><p>这个交换性质 厉害了,之前并不了解,也没有自己推出</p><p>相等的位置的交换,必定让相邻无序对是不变的,而且是充要条件</p><p>还是不变量的思考</p><p>G</p><p>GF(2) 真的没有系统学过</p><p>通过这个题看起来 乘法还 满足 结合率</p><p>加减也是对称的 A+B= C, A-B=C</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://codeforces.com/blog/entry/104310" target="_blank" rel="noopener">官方</a></p><p><a href="https://www.luogu.com.cn/paste/1z5pai9x" target="_blank" rel="noopener">洛谷 GF(2)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;F(数学,数组,相邻无序对)G(GF(2),meet in middle,不懂证明)&lt;/p&gt;
&lt;h1 id=&quot;F&quot;&gt;&lt;a href=&quot;#F&quot; class=&quot;headerlink&quot; title=&quot;F&quot;&gt;&lt;/a&gt;F&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://codefor
      
    
    </summary>
    
      <category term="Codeforces" scheme="http://yexiaorain.github.io/Blog/categories/Codeforces/"/>
    
    
      <category term="数学" scheme="http://yexiaorain.github.io/Blog/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="数组" scheme="http://yexiaorain.github.io/Blog/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="相邻无序对" scheme="http://yexiaorain.github.io/Blog/tags/%E7%9B%B8%E9%82%BB%E6%97%A0%E5%BA%8F%E5%AF%B9/"/>
    
      <category term="GF(2)" scheme="http://yexiaorain.github.io/Blog/tags/GF-2/"/>
    
      <category term="meet in middle" scheme="http://yexiaorain.github.io/Blog/tags/meet-in-middle/"/>
    
      <category term="不懂证明" scheme="http://yexiaorain.github.io/Blog/tags/%E4%B8%8D%E6%87%82%E8%AF%81%E6%98%8E/"/>
    
  </entry>
  
  <entry>
    <title>Atcoder arc143</title>
    <link href="http://yexiaorain.github.io/Blog/2022-06-27-ac_arc143/"/>
    <id>http://yexiaorain.github.io/Blog/2022-06-27-ac_arc143/</id>
    <published>2022-06-26T20:25:14.000Z</published>
    <updated>2022-07-07T17:16:42.310Z</updated>
    
    <content type="html"><![CDATA[<p>D(dfs,无向图无桥联通块,强连通分量)</p><p>哎 超时8min过了E,但这个D我还是不会</p><h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><p>评分2229</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://atcoder.jp/contests/arc143/tasks/arc143_d" target="_blank" rel="noopener">https://atcoder.jp/contests/arc143/tasks/arc143_d</a></p><p>左边1-n的点</p><p>右边1-n的点</p><p>左i-右i有边</p><p>给你m对数 (ai,bi), 你需要输出长度为m的0/1字符串</p><p>如果你要(左ai-右bi) 则第i个字符为0, 如果你要(左bi-右ai)则第i个字符是1</p><p>最终让图里的桥最少, 求一个字符串方案</p><h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h3><p>n 2e5</p><p>m 2e5</p><p>2s</p><p>1024mb</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h3><p>只想着贪心</p><p>首先如果一个边在任意环里那它就不是桥, 所以希望能贪心尽量让边进入环</p><p>统计给的m对数中, 每个值出现的次数</p><p>对于只出现一次的无药可救,先不管它</p><p>对于出现2次的,那就安排让它左右各连出一个</p><p>如果运算过程中某个点一侧被连了,另一侧没有连,还有关于这个点的数对,那么就去连另一测</p><p>已经两侧都连了的就不管</p><hr><p>但就写的来看似乎有问题, 还蛮多人过了这个题</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><blockquote><p>一句话 把它当成一个未定向的有向图， 然后在图上找环， 并定向即可</p></blockquote><p>首先考虑一个n个点, m边的无向图, 按照ai-bi的连接</p><p>如果有边在无向图中也是桥, 那么在题目问题中它只能是桥</p><p>对于无向图来说,移除了所有桥以后, 每个连通块可以单独独立处理</p><p>所以假设 拿到一个无向连通 无桥图</p><p>总有办法给所有边一个方向,让连通图变成强联通图</p><p>一个办法就是 直接做dfs树</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/arc143/submissions/32806181" target="_blank" rel="noopener">https://atcoder.jp/contests/arc143/submissions/32806181</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define pb push_backint read(){int r;scanf(&quot;%intd&quot;,&amp;r);return r;} // readint n;int m;char s[200010]; // answerpair&lt;int,int&gt; ab[200010];vector&lt;array&lt;int,3&gt;&gt; u2[200010]; // {v, ab idx, &#39;0&#39;,&#39;1&#39;}bool vis[200010];void dfs(int u){  vis[u] = true;  for(auto [v,i,o]:u2[u]){    if(s[i]) continue; // 边处理过    s[i] = (char)o;    if(!vis[v]) dfs(v);  }}int main(){  n = read();  m = read();  rep(i,0,m) ab[i].first = read();  rep(i,0,m){    int a = ab[i].first;    int b = ab[i].second = read();    u2[a].pb({b,i,(int)&#39;0&#39;});    u2[b].pb({a,i,(int)&#39;1&#39;});  }  rep(i,1,n+1){    if(vis[i])continue;    dfs(i);  }  rep(i,0,m){    if(!s[i]) s[i] = &#39;0&#39;;  }  printf(&quot;%s\n&quot;,s);  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>D</p><p>知道逻辑以后 10min 随便写了QAQ</p><p>我不知道应该怎么归类,信息提取,还是有向图无向图连通性质</p><p>我觉得有一点 算是 无向图的无桥联通块 能通过指定所有边 变成有向图的强连通分量这一点吧,但好像又是一个提炼性质</p><p>哎</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://atcoder.jp/contests/arc143/editorial/4210" target="_blank" rel="noopener">官方题解</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;D(dfs,无向图无桥联通块,强连通分量)&lt;/p&gt;
&lt;p&gt;哎 超时8min过了E,但这个D我还是不会&lt;/p&gt;
&lt;h1 id=&quot;D&quot;&gt;&lt;a href=&quot;#D&quot; class=&quot;headerlink&quot; title=&quot;D&quot;&gt;&lt;/a&gt;D&lt;/h1&gt;&lt;p&gt;评分2229&lt;/p&gt;
&lt;h2 i
      
    
    </summary>
    
      <category term="Atcoder" scheme="http://yexiaorain.github.io/Blog/categories/Atcoder/"/>
    
    
      <category term="dfs" scheme="http://yexiaorain.github.io/Blog/tags/dfs/"/>
    
      <category term="无向图无桥联通块" scheme="http://yexiaorain.github.io/Blog/tags/%E6%97%A0%E5%90%91%E5%9B%BE%E6%97%A0%E6%A1%A5%E8%81%94%E9%80%9A%E5%9D%97/"/>
    
      <category term="强连通分量" scheme="http://yexiaorain.github.io/Blog/tags/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 1696</title>
    <link href="http://yexiaorain.github.io/Blog/2022-06-26-CF1696/"/>
    <id>http://yexiaorain.github.io/Blog/2022-06-26-CF1696/</id>
    <published>2022-06-26T14:24:00.000Z</published>
    <updated>2022-07-07T17:16:42.310Z</updated>
    
    <content type="html"><![CDATA[<p>G(线性规划,对偶,dp,矩阵乘法,segtree)H(TODO)</p><h1 id="G"><a href="#G" class="headerlink" title="G"></a>G</h1><p><a href="https://codeforces.com/contest/1696/problem/G" target="_blank" rel="noopener">https://codeforces.com/contest/1696/problem/G</a></p><p>给一个长n数列</p><p>q个操作或询问</p><ol><li>操作修改 a[i] = v</li><li>询问[l,r] 区间上, 最小处理代价(不真实的修改区间)</li></ol><p>f(l,r) = 每次可以对 相邻元素,分别 (-xt,-yt) 或(-yt,-xt) 代价为t</p><p>问最小代价和让 a[l..r] 全部小于等于0</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>n 2e5</p><p>q 2e5</p><p>x,y [1,1e6]</p><p>ai, v [1,1e6]</p><p>6s</p><p>1024MB</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>因为对称,不妨设 ( x &lt; y)</p><p>开始没看到相邻以为任意,那么不就是维护区间和与区间最大值 = max(和/(x+y),最大值/y)</p><p>但是要相邻这样肯定不对了, 比如样例1, 不相邻可以3,相邻最少要3.5</p><hr><p>单次询问怎么做?</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><h3 id="线性规划对偶"><a href="#线性规划对偶" class="headerlink" title="线性规划对偶"></a>线性规划对偶</h3><p><a href="https://pic1.zhimg.com/80/v2-b780de4a3bd814944026ad22f51518f8_720w.jpg" target="_blank" rel="noopener">https://pic1.zhimg.com/80/v2-b780de4a3bd814944026ad22f51518f8_720w.jpg</a></p><p>$max \sum c_j x_j$</p><p>限制</p><p>$a_{ij} x_{j} \le b_i$</p><p>$x_j \ge 0$</p><p>$i=1\cdots m,j=1\cdots n$</p><p>它的对偶问题</p><p>$min \sum b_i y_i$</p><p>限制</p><p>$a_{ij} y_{i} \ge c_i$</p><p>$y_i \ge 0$</p><p>$i=1\cdots m,j=1\cdots n$</p><hr><p>我看了很多直觉的举例,反而没有理解,通过公式倒是理解了大流程, 下面youtube链接 感觉很清晰</p><p>小写字母表示列向量,大写字母表示矩阵</p><p>$max (c^Tx)$</p><p>$Ax \le b$</p><p>$x \ge 0$</p><p>对于任意$y \ge 0$满足</p><p>$c^Tx \le y^TAx$</p><p>有 $c^Tx \le y^TAx \le y^Tb$, 所以所有都满足,那么它的最大 = 右边的最小</p><p>所以对于所有$c^T \le y^TA$, $max(c^Tx) = min(y^Tb)$</p><p>$c^T \le y^TA$ 即是$Ay \ge c$</p><hr><p>更一般的转化</p><ol><li><p>min max 对换</p></li><li><p>列个数x 变成行个数y</p></li><li><p>右侧约束 和 表达式系数 兑换</p></li><li><p>偏序关系</p></li></ol><p>同偏序: max 变量(xi) 与 0关系 和 min 约束(不等式组xi) 左与右 关系</p><p>反偏序: min 变量(xi) 与 0关系 和 max 约束(不等式组xi) 左与右 关系</p><p>约束等于 对应 变量无约束</p><h2 id="回到题目"><a href="#回到题目" class="headerlink" title="回到题目"></a>回到题目</h2><p>线性规划 问题</p><p>原数组A</p><p>最小化  $\sum_{1\le i &lt; n} a_i+b_i $</p><p>限制</p><p>$Xa_1+Yb_1\ge A_1$</p><p>$Xa_i+Yb_i+Ya_{i-1}+Xb_{i-1}\ge A_i (2\le i &lt; n) $</p><p>$Ya_{n-1}+Xb_{n-1}\ge A_n $</p><p>$a_i,b_i\ge 0$</p><hr><p>那么对偶</p><p>最大化 $\sum_{1\le i \le n} A_iz_i $</p><p>限制</p><p>$xz_i + yz_{i+1} \le 1 (1 \le z &lt; n)$</p><p>$yz_i + xz_{i+1} \le 1 (1 \le z &lt; n)$</p><p>$z_i \ge 0$</p><p>很好的把上面要求的所有系数1变成了右侧的限制</p><hr><p>所以$z_i$ 可能取值$0,\frac{1}{y},\frac{1}{x+y}$</p><p>如果只有两个, 线性规划很明显 <a href="https://www.wolframalpha.com/input?i=2x%2B3y+%3C%3D+1%2C+2y%2B3x+%3C%3D+1" target="_blank" rel="noopener">https://www.wolframalpha.com/input?i=2x%2B3y+%3C%3D+1%2C+2y%2B3x+%3C%3D+1</a></p><p>去画3个的3d情况,你会发现,和2d一样虽然有些棱,但如果这个棱上最优,那么棱上的顶点也最优,但这些凸点的坐标都是这三个可能值中</p><hr><p>然后就可以dp了</p><p><code>dp[i][0/1/2]</code>, 即是算 $max \sum_{j \le i} A_jz_j$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>jiangly 的, 他整个G只花了15min??????</p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_back#define SEG_ROOT 1,0,n#define mid (l+r)/2#define SEG_L 2*p#define SEG_R 2*p+1#define SEG_L_CHILD SEG_L,l,mid#define SEG_R_CHILD SEG_R,mid,rll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readint n;int a[200010];template&lt;class Info,  class Merge = plus&lt;Info&gt; // 合并方法  &gt;  struct SegmentTree {    const int n;    const Merge merge;    vector&lt;Info&gt; info;    SegmentTree(int n) : n(n), merge(Merge()), info(4*n) {}    SegmentTree(vector&lt;Info&gt; init) : SegmentTree(init.size()) {      function&lt;void(int, int, int)&gt; build = [&amp;](int p, int l, int r) { // [l,r) 左闭右开        if (r - l == 1) { // 线段树叶子节点          info[p] = init[l];          return;        }        build(SEG_L_CHILD);        build(SEG_R_CHILD);        pull(p);      };      build(SEG_ROOT);    }    void pull(int p) {      info[p] = merge(info[SEG_L], info[SEG_R]);    }    void modify(int p, int l, int r, int x, const Info &amp;v) {      if (r - l == 1) {        info[p] = v;        return;      }      if (x &lt; mid) {        modify(SEG_L_CHILD, x, v);      } else {        modify(SEG_R_CHILD, x, v);      }      pull(p);    }    void modify(int p, const Info &amp;v) {      modify(SEG_ROOT, p, v);    }    Info rangeQuery(int p, int l, int r, int x, int y) {      if (l &gt;= y || r &lt;= x) return Info(); // 直接省去范围判断, 超过范围提前 返回可参与计算的空状态      if (l &gt;= x &amp;&amp; r &lt;= y) return info[p];      return merge(rangeQuery(SEG_L_CHILD, x, y), rangeQuery(SEG_R_CHILD, x, y));    }    Info rangeQuery(int l, int r) {      return rangeQuery(SEG_ROOT, l, r);    }  };int x, y;// 0: 0// 1: 1/(x+y)// 2: 1/y// 线段树每个节点struct Info {  double f[3][3];  Info(ll v = 0) {    rep(i,0,3){      rep(j,0,3){        if (i + j &gt; 2) {          f[i][j] = -1E18; // 不合法        } else { // 这里直接 值 * z_i(0,1/(x+y),1/y), 因为转移方程里始终要乘 值          f[i][j] = (j == 0 ? 0.0 : 1.0 * v / (j == 1 ? x + y : y));        }      }    }  }};// 实现合并方法Info operator+(const Info &amp;a, const Info &amp;b) {  Info c;  rep(i,0,3){    rep(j,0,3){      c.f[i][j] = -1E18; // 不合法      rep(k,0,3){        // max 矩阵乘法        c.f[i][j] = max(c.f[i][j], a.f[i][k] + b.f[k][j]);      }    }  }  return c;}int main() {  int n = read();  int q = read();  x = read();  y = read();  if (x &gt; y) swap(x, y); // 保证 x&lt;=y  vector&lt;int&gt; b(n);  rep(i,0,n) b[i] = read();  SegmentTree seg(vector&lt;Info&gt;(b.begin(), b.end())); // v =&gt; Info(v) =&gt; segtree(vector&lt;info()&gt;)  while(q--) {    int t = read();    if (t == 1) {      int k = read() - 1;      int v = read();      seg.modify(k, v);    } else {      int l = read() - 1;      int r = read();      auto info = seg.rangeQuery(l, r) + Info(); // + Info() 整合最大值,否则需要手动for 去取max      printf(&quot;%.15lf\n&quot;,info.f[0][0]);    }  }  return 0;}</code></pre><h1 id="H"><a href="#H" class="headerlink" title="H"></a>H</h1><p><a href="https://codeforces.com/contest/1696/problem/H" target="_blank" rel="noopener">https://codeforces.com/contest/1696/problem/H</a></p><p>给一个正整数k</p><p>大小为n,元素可重复的集合A</p><p>f(集合S) = S中恰好选出k个元素能得到的最大乘积</p><p>求 A所有元素个数不小于k的子集B,的f(B)的和</p><p>mod 1e9+7</p><h2 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h2><p>n 600</p><p>ai [-1e9,1e9</p><p>1.5s</p><p>512 MB</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h3><p>如果全非负, 则最大k个的乘积</p><p>如果全负</p><p>k为偶数, 则最小k个的乘积</p><p>k为奇数, 则最大k个的乘积</p><p>如果有负有非负</p><p>k为偶数, 则负 和 非负 分两组, 每组按照绝对值 从大到小,两两成对 构成新的乘积, 一对一对选</p><p>如果k 为奇数, 取一个最大非负, 剩下的 和偶数方案一样处理</p><p>所以肯定要对原来的集合拍个序</p><p>但贡献怎么统计没有思路</p><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>选k个指定它们最大? 计算会出现在多少个集合中??</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>G</p><p>低分题做多了, 太久没遇到线性规划了,很久以前学过, 但好像也是系数多限制多变量少的,</p><p>然后这个对偶学了一下, 希望下次能有用到的地方???</p><p>最后转化可以描述为矩阵max乘法,可以用segtree维护</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://codeforces.com/blog/entry/103479" target="_blank" rel="noopener">官方</a></p><p><a href="https://sites.math.washington.edu/~burke/crs/407/notes/section3.pdf" target="_blank" rel="noopener">https://sites.math.washington.edu/~burke/crs/407/notes/section3.pdf</a></p><p><a href="https://www.youtube.com/watch?v=yU8updOR87c" target="_blank" rel="noopener">https://www.youtube.com/watch?v=yU8updOR87c</a></p><p><a href="https://blog.csdn.net/qq_43539633/article/details/109150749" target="_blank" rel="noopener">https://blog.csdn.net/qq_43539633/article/details/109150749</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;G(线性规划,对偶,dp,矩阵乘法,segtree)H(TODO)&lt;/p&gt;
&lt;h1 id=&quot;G&quot;&gt;&lt;a href=&quot;#G&quot; class=&quot;headerlink&quot; title=&quot;G&quot;&gt;&lt;/a&gt;G&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://codeforces.com/c
      
    
    </summary>
    
      <category term="Codeforces" scheme="http://yexiaorain.github.io/Blog/categories/Codeforces/"/>
    
    
      <category term="dp" scheme="http://yexiaorain.github.io/Blog/tags/dp/"/>
    
      <category term="线性规划" scheme="http://yexiaorain.github.io/Blog/tags/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/"/>
    
      <category term="对偶" scheme="http://yexiaorain.github.io/Blog/tags/%E5%AF%B9%E5%81%B6/"/>
    
      <category term="矩阵乘法" scheme="http://yexiaorain.github.io/Blog/tags/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/"/>
    
      <category term="segtree" scheme="http://yexiaorain.github.io/Blog/tags/segtree/"/>
    
  </entry>
  
  <entry>
    <title>Atcoder abc257</title>
    <link href="http://yexiaorain.github.io/Blog/2022-06-25-ac_abc257/"/>
    <id>http://yexiaorain.github.io/Blog/2022-06-25-ac_abc257/</id>
    <published>2022-06-24T20:25:14.000Z</published>
    <updated>2022-07-07T17:16:42.310Z</updated>
    
    <content type="html"><![CDATA[<p>D(正确读题就能做)G(kmp+DP)Ex(TODO)</p><h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><p>天天卡D我服了,EF都过了就是卡D</p><p>题解这次出得好慢</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://atcoder.jp/contests/abc257/tasks/abc257_d" target="_blank" rel="noopener">https://atcoder.jp/contests/abc257/tasks/abc257_d</a></p><p>平面n个点</p><p>每个点一个倍率Pi</p><p>每个点可到达 PiS 曼哈顿距离以内的点</p><p>问最小的整数S让 可以选择某一点, 让其它点都可从此点跳跃到达,(不需要一次路径)</p><h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h3><p>n 200</p><p>坐标 x,y [-1e9,1e9]</p><p>p [1..1e9]</p><p>3s</p><p>1024mb</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h3><p>一眼 二分答案+tarjan+拓扑排序</p><p>关键这是abc的D题不应该,而且N也就200</p><p>不会这么难, 想不出啊,接近2k人比赛里过了,心态有点炸,还好跳了去做了EF,而且本来abc我也不算分了</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>不要读错题,</p><p>我读成选点 跳跃经过所有点</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>无</p><h1 id="G"><a href="#G" class="headerlink" title="G"></a>G</h1><p><a href="https://atcoder.jp/contests/abc257/tasks/abc257_g" target="_blank" rel="noopener">https://atcoder.jp/contests/abc257/tasks/abc257_g</a></p><p>两个只有小写字母的字符串S,T</p><p>让T 为 S的k个前缀的拼接</p><p>求最小的k 或报不可能</p><h2 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h2><p>|S| 5e5</p><p>|T| 5e5</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><h3 id="我的想法"><a href="#我的想法" class="headerlink" title="我的想法"></a>我的想法</h3><p>一眼像是kmp,但kmp写得真的少,</p><p>而且不确定kmp 怎么具体做,去计算t每个位置作为起始的最大长度</p><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>dp[i] = T[0..i] 和S匹配的答案</p><p>如果 T[i-p…i] == S[1..p], 那么有 dp[i] = min(dp[i-p]+1), p 可能有多种, 没有答案就INF</p><p>单调性</p><p>dp[i] &lt;= dp[i+1]</p><p>否则你把 dp[i+1]的方案中最后一个字符去掉,dp[i] 就能变小</p><p>因此你只需要关心最长的前缀匹配</p><hr><p>终究还是来到了kmp</p><p>经典的# 拼接</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p><a href="https://atcoder.jp/contests/abc257/submissions/32786655" target="_blank" rel="noopener">https://atcoder.jp/contests/abc257/submissions/32786655</a></p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 1000000007#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readclass KMP {  private :    vector&lt;int&gt; f; // 比它小的最长前缀的长度    char *s;    int sz;  public:    KMP(char *s,int sz):s(s),sz(sz){      f = vector&lt;int&gt;(sz,0);      int fa = 0;      rep(i,1,sz){        while (fa &amp;&amp; s[i] != s[fa]) fa = f[fa-1];        if (s[i] == s[fa]) fa++;        f[i] = fa;      }    }    vector&lt;int&gt; getPrefixLen(){      return f;    }    int posIn(char *t,int szt) {      int fa = 0;      rep(i,0,szt) {        while (fa &amp;&amp; t[i] != s[fa]) fa = f[fa-1];        if (t[i] == s[fa]) fa++;        if (fa == sz) return i-fa+1;      }      return -1;    }};char s[1000010];int ns;int nt;const int INF = 0x3f3f3f3f;int main(){  scanf(&quot;%s&quot;,s);  int ns = strlen(s);  s[ns] = &#39;#&#39;;  scanf(&quot;%s&quot;,s+ns+1);  int nt = strlen(s+ns+1);  int n = ns+1+nt;  vector&lt;int&gt; dp(nt+1,INF);  dp[0] = 0;  KMP kmp(s, n);  auto pl = kmp.getPrefixLen();  // rep(i,0,nt){  //   printf(&quot;%lld: %d\n&quot;,i,pl[i+ns+1]);  // }  rep(i,1,nt+1){    dp[i] = dp[i-pl[i+ns]]+1;    // printf(&quot;dp[%lld] = %d\n&quot;,i,dp[i]);  }  printf(&quot;%d\n&quot;, dp[nt] &gt;= INF?-1:dp[nt]);  return 0;}// k 个S前缀拼成 T// KMP?</code></pre><h1 id="Ex"><a href="#Ex" class="headerlink" title="Ex"></a>Ex</h1><p><a href="https://atcoder.jp/contests/abc257/tasks/abc257_h" target="_blank" rel="noopener">https://atcoder.jp/contests/abc257/tasks/abc257_h</a></p><p>n个6面dice,每个上面6个给定数字, 每个价格Ci</p><p>恰好买k个,</p><p>求期望sum(扔的数字)^2 - sum(价格) 最大</p><p>输出 mod 998244353</p><h2 id="范围-2"><a href="#范围-2" class="headerlink" title="范围"></a>范围</h2><p>n 1e3</p><p>k [1..N]</p><p>ci [1,1e5]</p><p>aij [1,1e5]</p><h2 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h3><p>先期望转化</p><p>E((?+xi)^2 - Ci) - E(?^2)</p><p>= E(?^2+2?xi+xi^2) - Ci - E(?^2)</p><p>= E(xi^2) - Ci + 2?E(xi)</p><p>看起来是?的线性函数, 不知道这个是否有局部性可以贪心, 或者<code>dp[前i][用了k] = {E(ans),E?}</code></p><h3 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h3><p>只有一个日文的 <a href="https://atcoder.jp/contests/abc257/editorial/4168" target="_blank" rel="noopener">https://atcoder.jp/contests/abc257/editorial/4168</a></p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>D</p><p>读错题好难受啊</p><p>G</p><p>然后我也更新了一下我的kmp板子多加了个外置函数</p><p>Ex</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://cp-algorithms.com/string/prefix-function.html" target="_blank" rel="noopener">KMP</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;D(正确读题就能做)G(kmp+DP)Ex(TODO)&lt;/p&gt;
&lt;h1 id=&quot;D&quot;&gt;&lt;a href=&quot;#D&quot; class=&quot;headerlink&quot; title=&quot;D&quot;&gt;&lt;/a&gt;D&lt;/h1&gt;&lt;p&gt;天天卡D我服了,EF都过了就是卡D&lt;/p&gt;
&lt;p&gt;题解这次出得好慢&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="Atcoder" scheme="http://yexiaorain.github.io/Blog/categories/Atcoder/"/>
    
    
      <category term="dp" scheme="http://yexiaorain.github.io/Blog/tags/dp/"/>
    
      <category term="kmp" scheme="http://yexiaorain.github.io/Blog/tags/kmp/"/>
    
  </entry>
  
  <entry>
    <title>Atcoder arc142</title>
    <link href="http://yexiaorain.github.io/Blog/2022-06-24-ac_arc142/"/>
    <id>http://yexiaorain.github.io/Blog/2022-06-24-ac_arc142/</id>
    <published>2022-06-23T20:25:14.000Z</published>
    <updated>2022-07-07T17:16:42.310Z</updated>
    
    <content type="html"><![CDATA[<p>D(树,dp)</p><h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><p>评分2900,远高于C的难度</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://atcoder.jp/contests/arc142/tasks/arc142_d" target="_blank" rel="noopener">https://atcoder.jp/contests/arc142/tasks/arc142_d</a></p><p>给你一个树,要上面放一些棋子</p><p>每个时间周期,所有棋子要向它相邻的任意一个点移动,确保移动时每条边最大负债1,移动后每个点最多棋子1个</p><p>且保证任意个时间周期的结果唯一</p><p>问所有合法放置方案数</p><h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h3><p>n 2e5</p><p>2s</p><p>1024mb</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h3><p>要唯一,考虑做树上dp</p><p><code>dp[from][to][tofa]</code> 每个点2x2x2=8 最多8个状态</p><p>from表示根原来有或没, to表示移动一次后有或没, tofa表示移动一次以后对父节点是否有贡献</p><p>但转移感觉只有手动推一推, 不知道自动怎么算</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>注意到是唯一的反复跳 <code>u-&gt;v-&gt;u-&gt;v</code></p><p>那么实际上树是由多个不相交的链组成的</p><p>如果分叉角度说</p><p>a-b a-c a-d</p><p>a总有一轮是1, 两轮都是0是不可能的(这样有多个摆放方案</p><p>那么移动一次后一是到b,c,d中的一个</p><p>而下一次会移动回来</p><p>说明a至多和两个位置跳来跳去剩下的就是和a不相关的链了</p><hr><p>那么<code>1110110</code>, 这样的看作两条链</p><p>问题就是如何划分链</p><p>potato167 的blog上画了很多方便理解的图</p><p>注意到每个独立的链都是 <code>111110</code> 的形式, 而不相交的相邻链是 1和0 相临的, 且独立的链最小长度为2</p><p>然后一条链的端点也不能和另一条链的中间点相邻, 但两条链的中点可以相邻</p><p>所以对于一个点来讲,它可以是头0,头1或者中间的1,</p><p>dp上 就考虑根的状态了</p><hr><p>0 端点 ( 另一个端点是这个端点的后代</p><p>1 端点 ( 另一个端点不是这个端点的后代</p><p>2 非端点, 且连接父节点</p><p>3 非端点, 且连接两个子节点</p><p>这里的状态划分也不再关心是端点是0还是1,因为你只需要保证端点之和端点相邻(相邻的端点相互决定),这样只用关心有多少自由端点的个数n即可, $2^n$</p><hr><p>手推4种状态</p><p>0: 1个子节点1/2, 剩余都是0</p><p>1: 所有子节点都是0</p><p>2: 1个子节点1/2, 剩余都是3</p><p>3: 2个子节点1/2, 剩余都是3</p><p>除了状态转移, 还需要统计自由度</p><p>中间的3 和 根的0 会让自由度+1</p><p>自由度+1, 相当于答案乘2, 所以直接统计答案比记录自由度更方便</p><hr><p>计算</p><p>0: </p><p>一种方案是</p><p><code>sum (dp[v][1]+dp[v][2]) * ((sum dp[..][0]) - dp[v][0])</code></p><p><code>sum (dp[v][1]+dp[v][2]) * (sum dp[..][0]) - sum (dp[v][1]+dp[v][2]) *  dp[v][0])</code></p><p><code>(sum1+sum2)*sum0 - sum( (v1+v2)(v0))</code></p><p>另一种按照循环增加的算法是</p><p><code>res = (res * dp[v][0]) + (dp[v][1] + dp[v][2])*(before all 0)</code></p><p>1: all0</p><p>2: 类似0的计算方法 采取循环子节点 的方法</p><p><code>res = (res * dp[v][3]) + (dp[v][1] + dp[v][2])*(before all 3)</code></p><p>3: 相当于双状态转移</p><p><code>res[2个满足子节点] = res[2] * dp3 + (dp1+dp2)*(before res[1])</code></p><p><code>res[1个满足子节点] = res[1] * dp3 + (dp1+dp2)*(before res[0] = before all 3)</code></p><p>最后记得3还要再乘2</p><p>当然注意到 1和2只有过程中的计算才是分开的, 父子之间处理是一起使用的, 还可以降低一个状态,虽然意义不大</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/arc142/submissions/32681890" target="_blank" rel="noopener">https://atcoder.jp/contests/arc142/submissions/32681890</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 998244353#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readvector&lt;int&gt; G[200010];int main() {  int n = read();  rep(i,1,n){    int u = read() - 1;    int v = read() - 1;    G[u].push_back(v);    G[v].push_back(u);  }  vector&lt;int&gt; fa(n,-1); // 父节点?  vector&lt;int&gt; order={0}; // 树上bfs 顺序, 反序就是树上dp  rep(i,0,n) {    int u = order[i];    for(auto v:G[u]){      if(v == fa[u]) continue;      fa[v] = u;      order.push_back(v);    }  }  vector&lt;vector&lt;ll&gt;&gt; dp(n,vector&lt;ll&gt;(4));  per(i,0,n){    int u = order[i];    ll all0 = 1;    ll all3 = 1;    ll pre1 = 0;    for(auto v:G[u]){      if(fa[v]!=u) continue;      ll s12 = (dp[v][1]+dp[v][2])%MOD;      // 0      dp[u][0] = (dp[u][0] * dp[v][0] % MOD + all0 * s12 % MOD)%MOD;      // 2      dp[u][2] = (dp[u][2] * dp[v][3] % MOD + all3 * s12 % MOD)%MOD;      // 3      dp[u][3] = (dp[u][3] * dp[v][3] % MOD + pre1 * s12 % MOD)%MOD;      pre1     = (pre1     * dp[v][3] % MOD + all3 * s12 % MOD)%MOD;      (all0 *= dp[v][0]) %= MOD;      (all3 *= dp[v][3]) %= MOD;    }    // 1    dp[u][1] = all0;    (dp[u][3] *= 2) %= MOD;  }  printf(&quot;%lld\n&quot;,(dp[0][0] * 2 % MOD + dp[0][3])%MOD);}</code></pre><p>如果再压缩1和2的状态</p><pre><code class="cpp">vector&lt;vector&lt;ll&gt;&gt; dp(n,vector&lt;ll&gt;(3)); // 0:0, 1:1&amp;2, 2:3per(i,0,n){  int u = order[i];  ll all0 = 1;  ll all3 = 1;  ll pre1 = 0;  for(auto v:G[u]){    if(fa[v]!=u) continue;    dp[u][0] = (dp[u][0] * dp[v][0] % MOD + all0 * dp[v][1] % MOD)%MOD; // 0    dp[u][1] = (dp[u][1] * dp[v][2] % MOD + all3 * dp[v][1] % MOD)%MOD; // 2    dp[u][2] = (dp[u][2] * dp[v][2] % MOD + pre1 * dp[v][1] % MOD)%MOD; // 3    pre1     = (pre1     * dp[v][2] % MOD + all3 * dp[v][1] % MOD)%MOD;    (all0 *= dp[v][0]) %= MOD;    (all3 *= dp[v][2]) %= MOD;  }  (dp[u][1] += all0) %= MOD; // 1 &amp; 2  (dp[u][2] *= 2) %= MOD;}printf(&quot;%lld\n&quot;,(dp[0][0] * 2 % MOD + dp[0][2])%MOD);</code></pre><h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><p>n 个巫师,</p><p>ai 能力</p><p>打败 bi 怪物</p><p>对任意巫师增加任意次1能力</p><p>(i,j) is good when (a[i] &gt;= bi and a[j] &gt;= bj) or (a[i] &gt;= b[j] and a[j] &gt;= b[i])</p><p>相当于直接打败或交叉打败</p><p>给你m 个 (x,y)</p><p>要最小增加能力, 让所有(x,y) 是good</p><h2 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h2><p>n 100</p><p>ai bi [1,100]</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>如果自己打败自己,那很好算,但是不一定是答案,但是答案上界至少是</p><p>考虑结果总有个每个巫师的大小顺序</p><p>如果<code>(a[i] - a[j])*(b[i]-b[j]) &gt;= 0</code> , 且存在限制 (x,y) = (i,j)</p><p>那么 必然<code>a[i] &gt;= b[i]</code> <code>a[j] &gt;= b[j]</code> , 如果</p><p>因为如果(i,j) good ,也就是 min(a[i],a[j]) &gt;= min(b[i],b[j]) , max(a[i],a[j]) &gt;= max(b[i],b[j]) </p><p>但是n是100 不可能去枚举顺序</p><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>首先, a[x],a[y] &gt;= min(a[x],a[y]) 这是必要的, 所以可以预处理掉这个</p><p>X 为 能力 小于 monter的 集合, 且在(x,y)中出现了的巫师</p><p>Y 是 其它的巫师</p><p>对于(x,y) 且 x属于X, y属于Y, 结果上期望 a[y] &gt;= b[x] 或 a[x] &gt;= b[x]</p><p>因为有预处理, 所以b[x] &gt; b[y], 因为如果 b[x] &lt;= b[y] 那么必然有 a[x] &gt;= min(b[x],b[y]) = b[x],  x不会属于X,</p><p>也就是X-Y的连接, 一定y中的b更小</p><p><code>b[x] &gt; a[x] &gt;= b[y]</code> 的顺序, <code>a[y] &gt;= b[y]</code></p><p>对于Y-Y的连接,不需要考虑,因为a只会增大,原来满足增加后还是满足</p><p>对于X-X的链接,不会存在,因为有了预处理, 这两个a大于min(b), 所以一定有一个属于Y</p><hr><p>回到X-Y</p><p><code>a[y] &gt;= b[x] &gt; a[x] &gt;= b[y]</code> 直接合法</p><p><code>b[x] &gt; (a[x],a[y]) &gt;= b[y]</code> 考虑上面是让<code>a[y] &gt;= b[x]</code> 还是 <code>a[x] &gt;= b[x]</code></p><hr><p>建图</p><p>点:</p><p>S源,T汇</p><p>X每个x一个点</p><p>Y每个y,100个点(y,i = 1..100)</p><p>边</p><p><code>S -&gt; x</code> 权重<code>b[x] - a[x]</code></p><p><code>(y,i) -&gt; T</code> 权重1</p><p><code>(y,i) -&gt; (y,i-1)</code> 权重无限大</p><p><code>x -&gt; (y,b[x] - a[y])</code> 权重无限大</p><hr><p>意义</p><p>先看假设只有一对</p><p><code>S-(bx-ax)-&gt;x-(无限)-&gt; (y, b[x]-a[y])-(1)-&gt; T</code>, 然后还有些<code>(y,i)-&gt;(y,i-1)</code>的边</p><p><code>S-&gt;X</code>这边限制了不会大于<code>bx-ax</code>, 右边限制了不会大于<code>bx-ay</code></p><p>最小割一定是 <code>S-&gt;x</code>和<code>(y,i)-&gt;T</code> 中的边,不会是那些无限的边</p><p>而如果<code>S-&gt;x</code> 不在最小割里,说明右侧对应的<code>(y,b[x]-a[y]) -&gt; T</code>, 以及更小的i的<code>(y,i)</code> 全部填满, 否则可至少可以再+1, 填满也就说明选择满足</p><hr><p>这个最小割的建图,我也是真不会啊(最大流,最小割还是会写)</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p><a href="https://atcoder.jp/contests/arc142/submissions/32759166" target="_blank" rel="noopener">https://atcoder.jp/contests/arc142/submissions/32759166</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // read#define N 100#define INF 0x3f3f3f3fint n,m;int a[N+10];int b[N+10];vector&lt;int&gt; p2[110]; // 双向关系int S = 0;int T = 1;// S,T,[2..101],[102...201][202..301][302..401]//int nodex(int x) {  assert(x &gt;=0 &amp;&amp; x&lt; 100);  return 2+x;}int nodey(int y,int value) {  assert(y &gt;=0 &amp;&amp; y&lt; 100);  assert(value &gt;=1 &amp;&amp; value &lt;= 100);  return 101 + y*100 + value;}class MinCut{  int sz ;  // TODO 优化成正反边下标  vector&lt;unordered_map&lt;int,ll&gt; &gt; G; // {idx,weight}  vector&lt;int&gt; d; // bfs 距离public:  MinCut(int n):sz(n){    G = vector&lt;unordered_map&lt;int,ll&gt; &gt;(sz);  }  void path(int u,int v,ll w){    assert(u != v);    G[u][v] += w;  }  int dfs(int u,int en, ll s){    if (u == en)return s;    for(auto [v,w]:G[u]){      if(w == 0) continue;      if(d[v] != d[u]+1) continue;      int r = dfs(v,en,min(s,w));      if(r){        G[u][v] -= r;        G[v][u] += r;        return r;      }    }    d[u] = 0; // 标记无效 替代vis    return 0;  }  bool bfs(int st,int en){    d = vector&lt;int&gt;(sz+10,-1);    vector&lt;int&gt; q = {st};    d[st] = 0;    rep(i,0,q.size()){      int u = q[i];      for(auto [v,w]: G[u]){ // u -&gt; v, weight =w        if(d[v] != -1) continue;        if(w == 0) continue;        d[v] = d[u] +1;        q.pb(v);      }    }    return d[en] &gt;= 0;  }  // 一次性计算  ll calc(int st,int en){    int ans = 0;    while (bfs(st, en)) ans += dfs(st, en, INF);    return ans;  }};int main(){  n = read();  S = 0;  T = 1;  rep(i,0,n){    a[i] = read();    b[i] = read();  }  m = read();  int ans = 0;  // 预处理 和 建边  rep(i,0,m){    int x = read() - 1;    int y = read() - 1;    int minv = min(b[x],b[y]);    ans += max(0,minv - a[x]);    a[x] = max(a[x],minv);    ans += max(0,minv - a[y]);    a[y] = max(a[y],minv);    p2[x].pb(y);    p2[y].pb(x);  }  MinCut mc(20000);  rep(i,0,n) {    if(a[i] &lt; b[i]){ // i in X      mc.path(S,nodex(i),b[i] - a[i]);      for(auto u:p2[i]){ // u in Y        if(a[u] &gt;= b[i]) continue;        mc.path(nodex(i),nodey(u,b[i]-a[u]),INF);      }    }else{ // i in Y      rep(j,1,101){        mc.path(nodey(i,j),T,1);        if(j &gt; 1){          mc.path(nodey(i,j),nodey(i,j-1),INF);        }      }    }  }  printf(&quot;%lld\n&quot;,ans + mc.calc(S,T) );  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>D</p><p>我突然觉得我的<code>dp[from][to][tofa]</code> 是不是也可能可以做?? 看起来是完全不同的思路</p><p>虽然想到反复横跳,但拆成链以及链的链接合法方式完全没想过</p><p>而且即使是拆成链,看了积分代码, 所做的树上dp也不相同, 能拆成这样四个也是很需要功力的</p><p>看potato167的代码学了一手非递归的树上dp, 通过先建立order,再逆序做</p><p>E</p><p>光是这个预处理就很厉害,解决了分类的问题, 能证明但完全没能自己挖掘出这个性质</p><p>然后这个建图我也是不会, 虽然学过最大流最小割,但是为啥这样想,没做过这种, 顺便整两个mincut板子</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://atcoder.jp/contests/arc142/editorial" target="_blank" rel="noopener">官方题解</a></p><p><a href="https://potato167.hatenablog.com/entry/2022/06/21/005732" target="_blank" rel="noopener">potato167 D</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;D(树,dp)&lt;/p&gt;
&lt;h1 id=&quot;D&quot;&gt;&lt;a href=&quot;#D&quot; class=&quot;headerlink&quot; title=&quot;D&quot;&gt;&lt;/a&gt;D&lt;/h1&gt;&lt;p&gt;评分2900,远高于C的难度&lt;/p&gt;
&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerl
      
    
    </summary>
    
      <category term="Atcoder" scheme="http://yexiaorain.github.io/Blog/categories/Atcoder/"/>
    
    
      <category term="dp" scheme="http://yexiaorain.github.io/Blog/tags/dp/"/>
    
      <category term="树" scheme="http://yexiaorain.github.io/Blog/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>June Lunchtime 2022 Division 1</title>
    <link href="http://yexiaorain.github.io/Blog/2022-06-22-LTIME109A/"/>
    <id>http://yexiaorain.github.io/Blog/2022-06-22-LTIME109A/</id>
    <published>2022-06-22T14:24:00.000Z</published>
    <updated>2022-07-07T17:16:42.310Z</updated>
    
    <content type="html"><![CDATA[<p>P5.MINXORSEG(XOR,fenwick)</p><h1 id="MINXORSEG"><a href="#MINXORSEG" class="headerlink" title="MINXORSEG"></a>MINXORSEG</h1><p>评分 3087, tourist 也没做出</p><p>给你长度n数组, q个询问,每次问区间[l,r]中任意两个数的异或的最小值</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>n 2e5</p><p>q 2e5</p><p>ai 2^30</p><p>3s</p><p>400MB</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>离线, 按查询的右端点排序</p><p>简单的扫描加入 是n方?</p><p>x=a[l]^a[r]</p><p>假设x最高位1在p位,那么高于p的bit,a[l]和a[r]一样</p><p>如果[l..r] 之间有同样的高于p的bit和它们一样的t,那么(l,r)这一对一定不是最小值,因为 (l,t) 或 (t,r) 比它小</p><p>如果区间有3个高w位一样,那么答案至少是高w位为0, 所以答案最小的只存两个高w一样,或者存在两个相等的数</p><p>这个观察很神奇,也就是说如果ai和aj高w位相同,那么要让它们可能是答案的必要条件是,它们中间没有高w位和它们相同的</p><p>换句话说, a[i]如果和它前面某个a[j]高w相同,贡献了最小xor,那么a[i]的w相同的前面最近的就是a[j]</p><p>所以直接记录每个数前面和它高0,1,2,3..位相同的最近的下标即可, 这可以简单的排序记录</p><hr><p>最后扫描+fenwick一下</p><p>其中把每对的左点为index,异或和为值,做后缀min fenwick 就可以了, 这样每次询问就是[l…  中的最小值</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://www.codechef.com/viewsolution/67421139" target="_blank" rel="noopener">https://www.codechef.com/viewsolution/67421139</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backconst ll INF = 0x3f3f3f3f3f3f;ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readll a[200010];int idxs[200010];struct fenwick_tree {  vector&lt;ll&gt; bit;  int n;  fenwick_tree(int n) : n(n) {    bit = vector&lt;ll&gt; (n + 1, INF); // 后缀min fenwick  }  void update(int u, ll v) {    for (u++; u &gt; 0; u -= u &amp; -u) bit[u] = min(bit[u], v);  }  int query(int u) {    ll r = INF;    for (u++; u &lt;= n; u += u &amp; -u) r = min(r, bit[u]);    return r;  }};int main() {  int n = read();  int q = read();  vector&lt;vector&lt;int&gt;&gt; lst(n);  vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; que(n);  rep(i,0,n) a[i] = read();  rep(b,0,30+1) { // 低位到高位    // 按高 30-p 位排序    iota(idxs,idxs+n,0);    sort(idxs,idxs+n,[=](int i,int j){return make_pair((a[i] &gt;&gt; b),i) &lt; make_pair((a[j] &gt;&gt; b),j); });    rep(i,1,n) {      if ((a[idxs[i]] &gt;&gt; b) == (a[idxs[i-1]] &gt;&gt; b)) { // 高位相同,建立可能对最小值贡献的关系        lst[idxs[i]].push_back(idxs[i-1]);      }    }  }  vector&lt;int&gt; ans(q);  rep(i,0,q) {    int l = read() - 1;    int r = read() - 1;    que[r].push_back({l, i});  }  fenwick_tree fen(n);  rep(i, 0, n) {    for (int v : lst[i]) fen.update(v, a[v] ^ a[i]);    for (auto [l, ind] : que[i]) ans[ind] = fen.query(l);  }  for(auto v:ans) printf(&quot;%d\n&quot;, v);}// n 2e5 个数// q询问,2e5// 查区间内 最小的两个值的 xor</code></pre><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote><p>MINXORSEG</p></blockquote><p>这个观察最小的可能贡献很厉害啊, 应该属于xor的一个神奇的知识点了?</p><p>另一个就是, 这种非统计的, 最大最小也是可以从”可能贡献”的角度去思考,这个我没有思路过,学到了</p><p>fenwick这个还有后缀写法,不需要做颠倒原数组的动作</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://discuss.codechef.com/search?q=tags%3Aeditorial%2BLTIME109" target="_blank" rel="noopener">官方</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;P5.MINXORSEG(XOR,fenwick)&lt;/p&gt;
&lt;h1 id=&quot;MINXORSEG&quot;&gt;&lt;a href=&quot;#MINXORSEG&quot; class=&quot;headerlink&quot; title=&quot;MINXORSEG&quot;&gt;&lt;/a&gt;MINXORSEG&lt;/h1&gt;&lt;p&gt;评分 3087, 
      
    
    </summary>
    
      <category term="CodeChef" scheme="http://yexiaorain.github.io/Blog/categories/CodeChef/"/>
    
    
      <category term="异或" scheme="http://yexiaorain.github.io/Blog/tags/%E5%BC%82%E6%88%96/"/>
    
      <category term="fenwick" scheme="http://yexiaorain.github.io/Blog/tags/fenwick/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 1700</title>
    <link href="http://yexiaorain.github.io/Blog/2022-06-21-CF1700/"/>
    <id>http://yexiaorain.github.io/Blog/2022-06-21-CF1700/</id>
    <published>2022-06-21T14:24:00.000Z</published>
    <updated>2022-07-07T17:16:42.310Z</updated>
    
    <content type="html"><![CDATA[<p>E(总体观察,数学),F(贪心)</p><h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><p><a href="https://codeforces.com/contest/1700/problem/E" target="_blank" rel="noopener">https://codeforces.com/contest/1700/problem/E</a></p><p>给你一个矩阵,每个数字都不相同</p><p>然后让你依次取1,2,3,4,… 取完所有</p><p>取的块需要和之前取过的至少一个4临</p><p>直接可取输出0</p><p>需要还是交换两个位置(可以不相邻)后可取,输出<code>1 方案数</code></p><p>还是都不行输出2</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>矩阵大小4e5</p><p>2s</p><p>256MB</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>0很好判断,vis染色+bfs</p><p>其实就是1的时候怎么算个数</p><p>不妨设按找上述方法最开始失败的是x</p><p>意味着, 小于x的连在一起了,</p><p>那么有两种方案</p><ol><li>交换x和小于x的外边界,这样小于等于x就连在一起了,</li><li>交换小于x的某一个和x的四临</li></ol><p>但是这两种如果一个一个检验是时间复杂度会炸掉的</p><hr><p>考虑可交换的,对于第一种没有什么思路</p><p>对于第二种,你可以考察每个依赖于它的是否仅依赖于它, 但也不一定</p><pre><code>1452.63?7.8.</code></pre><p>比如上面这样,7仅依赖于6,而6也可以移动</p><p>不知道怎么搞了</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>不要看一步一步,看总览性质</p><p>如果一个位置，它的四个邻居有比他小的，那么它就能连到小于它的数。矩阵为可遍历当且仅当所有点（除了1）的四个邻居都有比他小的。</p><p>这归纳法可证明</p><hr><p>所以判断可行,也不再需要vis+bfs, 而直接判断count(badpos)== 0</p><p>所以badpos 需要交换它或者它的邻居</p><p>两两不相同,显然badpos不相邻, 因为badpos需要小于4临, 说明4临都不是badpos</p><p>两两不同,说明交换以后的两个位置,一个比原来大,一个比原来小,</p><p>比原来大的位置4邻之前一定不是badpos, </p><p>比原来小的本身一定不是badpos</p><p>综上, badpos最多5个, 一个中心一个4临</p><p>5x5x4, 种</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>无</p><h1 id="F"><a href="#F" class="headerlink" title="F"></a>F</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://codeforces.com/contest/1700/problem/F" target="_blank" rel="noopener">https://codeforces.com/contest/1700/problem/F</a></p><p>2 * n 的01矩阵,两个</p><p>每次交换第一个中相邻位置的01,求最小次数得到第二个矩阵</p><h3 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h3><p>n 2e5</p><p>1s</p><p>256mb</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h3><p>写了个假的</p><p>两个变量记录未匹配的,然后进入则+,退出则-</p><p>发生 一正一负则消耗1抵消</p><p>竟然官方数据弱还过了system test</p><p>然后有错误样例</p><pre><code>0 1 01 0 00 1 00 0 1</code></pre><p>我的匹配会</p><pre><code>0 b 0a 0 00 a 00 0 b</code></pre><p>代价为4, 最小的是2</p><h3 id="官方"><a href="#官方" class="headerlink" title="官方"></a>官方</h3><p>直接可配消耗掉即可…….</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>无</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>E</p><p>这个总体观察没想到, 一直在想细节的步, 总体只想到vis+bfs 而不是这个充分性质</p><p>jiangly 也TLE了好像</p><p>F</p><p>贪心细节还是没想到啊</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://codeforces.com/blog/entry/103978" target="_blank" rel="noopener">官方</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;E(总体观察,数学),F(贪心)&lt;/p&gt;
&lt;h1 id=&quot;E&quot;&gt;&lt;a href=&quot;#E&quot; class=&quot;headerlink&quot; title=&quot;E&quot;&gt;&lt;/a&gt;E&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1700/probl
      
    
    </summary>
    
      <category term="Codeforces" scheme="http://yexiaorain.github.io/Blog/categories/Codeforces/"/>
    
    
      <category term="贪心" scheme="http://yexiaorain.github.io/Blog/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="数学" scheme="http://yexiaorain.github.io/Blog/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="总体观察" scheme="http://yexiaorain.github.io/Blog/tags/%E6%80%BB%E4%BD%93%E8%A7%82%E5%AF%9F/"/>
    
  </entry>
  
  <entry>
    <title>nowcoder 牛客挑战赛61 D</title>
    <link href="http://yexiaorain.github.io/Blog/2022-06-18-nowcoder-11201/"/>
    <id>http://yexiaorain.github.io/Blog/2022-06-18-nowcoder-11201/</id>
    <published>2022-06-18T02:37:14.000Z</published>
    <updated>2022-07-07T17:16:42.310Z</updated>
    
    <content type="html"><![CDATA[<p>D <a href="https://ac.nowcoder.com/acm/contest/11201/D" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/contest/11201/D</a></p><p>总思路没问题, dijkstra不能带log, 2s时间卡时限了</p><p>没有log的也800ms, 稍微一个3倍都过不了</p><p>所以需要的是点的值要么是初始的要么是推导(当前最大值-定值k)生成的, 双队列+指针实现</p><p>没过这题也能+3</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (int i=a;i&lt;(int)n;i++)#define per(i,a,n) for (int i=n;i--&gt;(int)a;)#define pb push_back#define c(a,b) ((a)*(m)+(b))int read(){int r; scanf(&quot;%d&quot;, &amp;r);return r;} // readint a[500010];int n,m,k;bool vis[500010];const int di[] = {-1,1,0,0,-1,1};const int dj[] = {0,0,-1,1,1,-1};vector&lt; array&lt;int,3&gt; &gt; startvij;ll cost(int diff){  fill(vis,vis + n*m,false);  vector&lt; array&lt;int,3&gt; &gt; vp = {}; // 优先队列等含有log的会TLE  ll sk = 0 ;  vp = {};  int i0 = 0;  int i1 = 0;  while(i0 &lt; startvij.size() || i1 &lt; vp.size()){    int v = 0;    int i = -1;    int j = -1;    if(i0 &lt; startvij.size() &amp;&amp; i1 &lt; vp.size()){      if(startvij[i0][0] &gt;= vp[i1][0]){        v = startvij[i0][0];        i = startvij[i0][1];        j = startvij[i0][2];        i0++;      }else{        v = vp[i1][0];        i = vp[i1][1];        j = vp[i1][2];        i1++;      }    }else if(i0 &lt; startvij.size()){      v = startvij[i0][0];      i = startvij[i0][1];      j = startvij[i0][2];      i0++;    }else {      v = vp[i1][0];      i = vp[i1][1];      j = vp[i1][2];      i1++;    }    if(vis[c(i,j)])continue;    vis[c(i,j)] = true;    sk += v - a[c(i,j)];    rep(w,0,6){      int ni = i + di[w];      int nj = j + dj[w];      if(ni &lt; 0 || ni &gt;= n || nj &lt; 0 || nj &gt;= m) continue;      if(a[c(ni,nj)] == -1) continue;      if(vis[c(ni,nj)]) continue;      if(v - diff &gt; a[c(ni,nj)]){        vp.pb({v - diff,ni,nj});      }    }  }  return sk;}int main(){  n = read();  m = read();  k = read();  rep(i,0,n){    rep(j,0,m){      a[c(i,j)] = read();      if(a[c(i,j)] != -1) startvij.pb({a[c(i,j)],i,j});    }  }  sort(startvij.begin(), startvij.end(), greater&lt;array&lt;int,3&gt;&gt;());  int l = 0;  int r = 1000;  int ans = 1000;  while(l &lt;= r){    int mid = (l+r)/2;    if(cost(mid) &lt;= k){      ans = mid;      r = mid - 1;    }else{      l = mid + 1;    }  }  cout&lt;&lt;ans&lt;&lt;endl;  return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;D &lt;a href=&quot;https://ac.nowcoder.com/acm/contest/11201/D&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ac.nowcoder.com/acm/contest/11201/D&lt;/a&gt;&lt;/p
      
    
    </summary>
    
      <category term="NowCoder" scheme="http://yexiaorain.github.io/Blog/categories/NowCoder/"/>
    
    
      <category term="dijkstra" scheme="http://yexiaorain.github.io/Blog/tags/dijkstra/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 1693 C D E F</title>
    <link href="http://yexiaorain.github.io/Blog/2022-06-17-CF1693/"/>
    <id>http://yexiaorain.github.io/Blog/2022-06-17-CF1693/</id>
    <published>2022-06-17T14:24:00.000Z</published>
    <updated>2022-07-07T17:16:42.310Z</updated>
    
    <content type="html"><![CDATA[<p>C(反向dijkstra)D(DP,数学,贡献)E(标记,延后,贪心,树状数组)F(0/1串,数学)</p><h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><p><a href="https://codeforces.com/contest/1693/problem/D" target="_blank" rel="noopener">https://codeforces.com/contest/1693/problem/D</a></p><p>给你一个排列</p><p>问多少个子区间 可以表示成 增序列和减序列合成的, 称作Decinc</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>n 2e5</p><p>2s</p><p>512MB</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>如果是判断一个是否合法</p><p>考虑</p><p>inc[i] 表示i在增序列, 减序列的最大值</p><p>dec[i] 表示i在减序列, 增序列的最小值</p><p>然后dp一下O(n) 就做了</p><p>然后这里考虑有没有办法转移</p><p>因为如果[i..j] 是decinc的,那么它的所有子区间也是</p><p>考虑有没有办法dp然后做转移, 发现并没有办法转移</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><h3 id="AmShZ"><a href="#AmShZ" class="headerlink" title="AmShZ"></a>AmShZ</h3><p>一样的, 但是说是可以证明均摊更新是常数倍?</p><p>对于给定i, 找最大的j, 使得 j &lt; i, a[j] &gt; a[j+1]</p><p>注意到<code>a[j],a[j+1]</code> 不会都在增序列里,必定一个在减序列里</p><p>情况1 <code>a[j+1]</code> 在增序列的话 =&gt; <code>a[j]</code> 在减序列</p><p>情况2 <code>a[j+1]</code> 在减序列</p><p>且因为它是最大的j, 所以<code>a[j] &gt; a[j+1]</code>, 且<code>a[j+1] &lt; a[j+2] &lt; a[j+3] &lt; ... &lt; a[i]</code></p><p><code>inc[i] = a[j](情况1) or a[j+1](情况2) or 0</code></p><p>而对于<code>inc[i]</code>初始化是是<code>inf</code>, 而对于<code>a[j+1]..a[i]</code>这一段都是<code>inf</code></p><p>所以每个位置的值只会有4种情况</p><p>dec对称关系同理</p><hr><p>换句话说</p><p>l从大到小,</p><p>每轮从小到大, 如果更新才会去算下一个位置, 否则提前退出</p><p>这里还有一点是就是 运算时,当给定l的时候, dp[i]仅依赖于dp[i-1]和a[i], 所以说如果dp[i]没有更新,则i以后的也不会更新, 所以更新的一定是连续的区间</p><p>所以sum 遍历 = sum 更新次数 = sum变化次数 = O(n)</p><h3 id="Koosha-Mv"><a href="#Koosha-Mv" class="headerlink" title="Koosha_Mv"></a>Koosha_Mv</h3><p>一个由升序和降序列合成的序列,当且仅当它不含 3412 也不含 2143</p><p>显然包含则不满足</p><p>怎么证明不满足一定包含这样的呢</p><p>回到dp的过程, 如果刚好在i不满足, </p><p>那么, 如果 a[i-1] &lt; a[i], (a[i-1] &gt; a[i] 对称同理</p><p>显然a[i-1] 在增序列不合法, (如果a[i-1] 在增序列有合法方案,那么把a[i]放到增序列即可</p><p>a[i-1]在减序列, 且 增序列最小值 &gt; a[i]</p><p>所以 存在a[j] &gt; a[i] &gt; a[i-1], j &lt; i-1</p><p>所以原序列是由</p><p>增序列 <code>..... a[j]</code> 和 减序列<code>.... a[i-1]</code>合成的</p><p>因为a[j] 是满足的最小的a[j]</p><p>也就是, a[j] 不能放进减序列里(如果可以则能得到更小的增序列值</p><p>那么 不妨设下标 w(可能不存在) &lt; j &lt; k ,且 a[k] 在减序列中, a[w] 在减数列中</p><p>那么<code>a[j] &lt; a[k] (j k i-1 i =&gt; 3 4 1 2)</code> 或 <code>a[j] &gt; a[w]</code>(a[j] 左侧至少一个</p><p>考虑把a[j]左侧分成三部分讨论, 大于a[j]的, a[i]到a[j]之间的, 小于a[i]的</p><p>如果a[i]到a[j]之间存在(3 4 1 2)`, 否则完全不存在, 且 小于a[i] 至少一个</p><p>如果大于a[j]的存在,则一定全属于减序列</p><p>如果小于a[i]的有不只1个, 那么一旦有其中两个递减 <code>=&gt; (? ? j i) =&gt; (2 1 4 3)</code> 即它的对称状态</p><p>小于a[i]的一定是升序列</p><p>总上可以重组 升序列<code>a[j] 左侧,小于a[i], 包含a[w] .... a[j]</code>, 降序列<code>a[j]左侧大于a[j]...a[j]右侧原减序列</code></p><p>注意到这样重组以后, <code>a[j]</code> 可以被放入减序列, 而增序列最小值将不再是a[j]</p><p>性质充要得证</p><hr><p>如何实现</p><p>注意到3412和2143是对称的,所以a[i] = n+1-a[i] ,再跑一次3412就行</p><p>那么如何计算3412</p><p>考虑计算的结果是对于当前位置i作为3,<code>min_r[i]</code>表示最近的<code>2</code>让<code>3412</code>出现</p><p>给定3以后,4要是最近的,如果有2,那么1是离2最近的</p><p>所以先预处理每个位置后面和它最近的比它大的,以及每个位置前面最近的比它小的的位置</p><p>但是记录并不是<code>[3]-&gt;4</code>, <code>[2] -&gt; 1</code></p><p>考虑反着来<code>4-&gt; array{3}</code>, <code>1-&gt;array{2}</code></p><p>为什么要这么样做呢,因为除了大小关系还有顺序,<code>1</code> 需要在<code>4</code>的右侧</p><p>那么我们倒着遍历4的位置</p><p>我们可以用fenwick记录i右侧, (1,2) 存在的<code>[值]-&gt;2的坐标</code></p><p>这样我们对于每个3, 去fenwick上查, 值 &lt; 3的值中存在的最大坐标, 就算出答案了</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><a href="https://codeforces.com/contest/1693/submission/160996027" target="_blank" rel="noopener">https://codeforces.com/contest/1693/submission/160996027</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readconst int N = 2e5 + 10;int n;int a[N]; // 数组int inc0[N]; // a[i] 在增数组时, 减数组的最大值int dec0[N]; // a[i] 在减数组时, 增数组的最小值int f[N]; // f[i] = 该轮次的计算中,当前点i到 以l为起点的终点 的距离ll ans;void udec0(int i){  if (n &gt;= i){    // 就硬算    int inc1 = max( (dec0[i - 1] &lt; a[i]?a[i - 1]:0), (a[i - 1] &lt; a[i] ? inc0[i - 1]: 0));    int dec1 = min( (a[i] &lt; inc0[i - 1]?a[i - 1]:n+1), (a[i] &lt; a[i - 1] ? dec0[i - 1]: n+1));    if (!(inc1 == inc0[i] &amp;&amp; dec1 == dec0[i])){ // 更新的一定是连续的区间, sum(遍历) = sum(更新) = sum(变化)      inc0[i] = inc1;      dec0[i] = dec1;      f[i] = 0; // 结束点 距离为0      if (dec1 &lt;= n || inc1) udec0(i+1);    }  }  f[i - 1] = f[i] + 1; // 到结束点距离+1}int main(){  n = read();  rep(i,1,n+1) a[i] = read();  per(i,1,n+1) { // 倒序l    inc0[i] = n + 1;    dec0[i] = 0;    udec0(i + 1);    ans += f[i];  }  printf(&quot;%lld\n&quot;, ans);  return 0;}</code></pre><p>3412,2143的</p><p><a href="https://codeforces.com/contest/1693/submission/161132167" target="_blank" rel="noopener">https://codeforces.com/contest/1693/submission/161132167</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readconst int N = 2e5 + 10;int INF = 0x3f3f3f3f;// 前缀最小值fenwickstruct Fenwick {  const int n;  vector&lt;int&gt; a;  Fenwick(int n) : n(n), a(n, INF) {}  // 支持 [0..n) 更新最大值  void setMin(int x, int v) {    for (int i = x + 1; i &lt;= n; i += i &amp; -i) a[i - 1] = min(a[i - 1], v);  }  // 获得 [0,x) 最大值  int get(int x) {    int ans = INF;    for (int i = x; i &gt; 0; i -= i &amp; -i) ans = min(ans, a[i - 1]);    return ans;  }};int n;int a[N]; // 数组int min_r[N];ll ans;stack &lt;int&gt; sk;vector &lt;int&gt; vec[2][N];// 如果指定3和2的位置,所以你需要的是3后面最近的4, 和2前面最近的1void find_3412(){  Fenwick f(n+10); // 下标是值, 前缀表示小于某个值的出现的最小坐标  rep(i,0,2) fill(vec[i]+1,vec[i]+n+1,vector&lt;int&gt;());  // vec[0][i] = vector&lt;int&gt; {j,...}, 表示 j 前面最近的比j小的是i, sk中保留单增的值对应的下标  sk = {};  rep(i,1,n+1) {    while (!sk.empty() &amp;&amp; a[i] &lt; a[sk.top()]) sk.pop();    if (!sk.empty()) vec[0][sk.top()].push_back(i);    sk.push(i);  }  // 倒着做一边, sk中保持值单调递减, vec[1][i] = {j...} , j后面最近的比a[j]大的是a[i]  sk = {};  per(i,1,n+1) {    while (!sk.empty() &amp;&amp; a[sk.top()] &lt; a[i]) sk.pop();    if (!sk.empty()) vec[1][sk.top()].push_back(i);    sk.push(i);  }  // 倒着做  per(i,1,n+1){    // f在遍历过程中,存的是(1,2) 的下标都&gt;=i, 然后[2的值] = 位置    // i=&gt;1, ind=&gt;2    for (auto ind : vec[0][i]) f.setMin(a[ind], ind); // (i,ind) 构成增序列    // 这次就是 i=&gt;4, ind =&gt; 3, 因为如果确定了3,那么4就最近最好, 所以查询的是(1,2)位置在(以后,且值小于3的,结束位置的最小值),    // 这里遍历过程之所以i=&gt;4 而不是3,主要因为 保证(1,2)在当前位置右侧    for (auto ind : vec[1][i]) min_r[ind] = min(min_r[ind], f.get(a[ind]));    // 得到的是min_r[3的位置] = 最近的2的位置能构成3 4 1 2    // 在反转过程中 min_r 直接取min,而f是清空  }}int main(){  n = read();  INF = n+1;  rep(i,1,n+1) a[i] = read();  fill(min_r, min_r + n + 2, INF);  find_3412();  rep(i,1,n+1) a[i] = n + 1 - a[i]; // 做对称, 因为对称不影响答案, 而3412和2143是对称的  find_3412();  per(i,1,n+1) {    min_r[i] = min(min_r[i], min_r[i + 1]);    ans += min_r[i] - i;  }  printf(&quot;%lld\n&quot;, ans);  return 0;}</code></pre><h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://codeforces.com/contest/1693/problem/E" target="_blank" rel="noopener">https://codeforces.com/contest/1693/problem/E</a></p><p>n+2 长度数组a</p><p>首尾元素值为0</p><p>最小操作次数让 所有值 = 0</p><p>每次操作可以任选以下一种</p><ol><li>最左的最大值=它的左侧的最大值</li><li>最右的最大值=它的右侧的最大值</li></ol><h3 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h3><p>n 2e5</p><p>2s</p><p>256mb</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h3><p>值挺友好,给你的是[0,n]的范围,(就算很大也可以手动离散</p><p>没思路了</p><h3 id="ecnerwala"><a href="#ecnerwala" class="headerlink" title="ecnerwala"></a>ecnerwala</h3><p>官方的代码实在太长了</p><p>ecnerwala 有个超短的代码</p><p><a href="https://codeforces.com/contest/1693/submission/160890042" target="_blank" rel="noopener">https://codeforces.com/contest/1693/submission/160890042</a></p><p>有点延后判断, 贪心选最小值的意味</p><pre><code>0 1 4 2 4 0 2 0. . . . . . . . // 初始. . ? . ? . . . // 最大的标记为?, 贡献 +2, 意义是第一轮处理2个. . . x x x x . // 准备处理2的也就是x覆盖区间的, 把区间左侧问号标成 &lt;(表示这个?位置的值比当前小,和左侧的最值相等, 右侧标成 &gt; (同理. . &lt; . ? . . . // 标记. . &lt; ? ? . ? . // 对2处理, 贡献 +3. . ? &gt; &gt; . &gt; . // 同理对于1, 但注意到 1右侧的 &lt; 会变成? 因为. ? ? &gt; &gt; . &gt; . // 贡献+2// 0 不需要处理</code></pre><p>总贡献是2+3+2 = 7</p><hr><p>样例2</p><pre><code>0 1 3 5 4 2 0. . . . . . .. . . ? . . . // +1. . . &lt; . . . // . . . &lt; ? . . // +1. . . ? &gt; . . //. . ? ? &gt; . . // +2. . &lt; &lt; ? . . //. . &lt; &lt; ? ? . // +2. . ? ? &gt; &gt; . //. ? ? ? . . . // +3</code></pre><p>1+1+2+2+3 = 9</p><p>再补充一个例子 <code>1 2 3</code></p><pre><code>0 1 2 3 0. . . . .. . . ? . // +1. . . &gt; . // . . ? &gt; . // +1. . &gt; &gt; . // . ? &gt; &gt; . // +1</code></pre><p>1+1+1 = 3</p><hr><p>总的来说, 每轮最大值,确定覆盖区间</p><p>区间左侧:</p><pre><code>? 变 &lt;&gt; 变?</code></pre><p>区间内部</p><pre><code>&lt; 变 ?&gt; 变 ?</code></pre><p>区间右侧</p><pre><code>? 变 &gt;&lt; 变 ?</code></pre><p>最后最大值的所有点都是? , 统计?个数即可</p><hr><p>实现</p><p>并不需要真的像上面思路那样维护4种 . , ? , &gt; , &lt;的状态</p><p>发现其实只需要统计?的个数</p><p>那么?个数有多少呢</p><p>区间内,所有大于它的都变成了问号, 所以区间内就是大于它的个数</p><p>区间左侧, 可能有 &gt;,?,&lt;</p><p>但 注意到一旦出现 &gt; ,说明上一轮 &gt; 的左侧有?, 如果出现 &lt; 说明上一轮右侧有 ?</p><p>引理, 每轮结束后 除开.的情况,剩下的一定是 &lt; ? &gt; 形状的</p><p>归纳法可证明</p><p>因此, 你需要统计的是</p><ol><li>相交关系</li></ol><pre><code>    ?   ?      // 上一轮结果&lt;  [l...r] &gt;   // 上一轮结果     [l...r]   // 本轮      ?   ?    // 本轮   &lt; [l...r]&gt;  // 结果</code></pre><ol start="2"><li>非相交关系</li></ol><pre><code>    ?   ?                 // 上一轮结果&lt;  [l...r] &gt;              // 上一轮结果                [l...r]   // 本轮                 ?   ?    // 本轮        &lt; [l      ...r]&gt;  // 结果</code></pre><p>有</p><pre><code>newl = min(l, lastr)newr = max(r, lastl)</code></pre><p>区间统计点 = 前缀差 = 树状数组维护</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>ecnerwaia <a href="https://codeforces.com/contest/1693/submission/160890042" target="_blank" rel="noopener">https://codeforces.com/contest/1693/submission/160890042</a></p><p>基于修改+注释+自己格式+bit改为fenwick: <a href="https://codeforces.com/contest/1693/submission/161139663" target="_blank" rel="noopener">https://codeforces.com/contest/1693/submission/161139663</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readint main() {  int n = read();  vector&lt;vector&lt;int&gt; &gt; idxs(n+1); // [值] = 下标数组  rep(i,1,n+1) idxs[read()].push_back(i);  vector&lt;int&gt; fenwick(n); // 树状数组, 大于等于当前的点记为1  ll ans = 0;  int lo = 1, hi = n + 1; // 左闭右开, [lo,hi)  per(v, 1, n+1) { // 从大到小    if (idxs[v].empty()) continue; // 忽略不存在的值    // 本轮全为问号的范围    std::tie(lo, hi) = make_pair(        min(idxs[v].front(), hi),        max(idxs[v].back()+1, lo)    );    // 本轮点 树状数组上标记为1,    for (int a : idxs[v]) {      for (; a &lt;= n; a += (a&amp;-a)) fenwick[a-1]++;    }    // 区间 [lo, hi) = pre[hi-1] - pre[lo-1]    for (int a = hi-1; a; a -= (a&amp;-a)) ans += fenwick[a-1];    for (int a = lo-1; a; a -= (a&amp;-a)) ans -= fenwick[a-1];  }  printf(&quot;%lld\n&quot;, ans);  return 0;}</code></pre><h1 id="F"><a href="#F" class="headerlink" title="F"></a>F</h1><p><a href="https://codeforces.com/contest/1693/problem/F" target="_blank" rel="noopener">https://codeforces.com/contest/1693/problem/F</a></p><p>0/1 字符串 S</p><p>每次选择一段 sort, 代价 |cnt(1) - cnt(0)| + 1</p><p>求最小总代价,让整个S有序</p><h2 id="范围-2"><a href="#范围-2" class="headerlink" title="范围"></a>范围</h2><p>n 2e5</p><h2 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h2><h3 id="我的想法"><a href="#我的想法" class="headerlink" title="我的想法"></a>我的想法</h3><p>假设最后一次操作了 [l..r]</p><p>那么说明 操作之前, [0..l-1] 和目标一样[r+1..n-1] 和目标一样</p><p>并且[l..r]中的1和0的个数尽可能的靠近</p><h3 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h3><p>结论: 只对0和1个数相等的进行排序</p><p>证明:</p><p>若最优方案中, 对[l,r]排序,且区间中,0比1多d个(d &gt; 0), 代价d+1</p><p>如果l上是0, 只需要对[l+1,r]排序,代价为d, 且效果相同, 所以l上一定是1</p><p>确定区间左端点,右端点增加时,0和1的差的变化为+1/-1</p><p>因此必然存在k &lt; r, 区间 [l,k] 的0和1的个数相等</p><p>排序[l,k],代价1, 再排序 [l+1,r] 代价 = d, 总代价 = d+1</p><p>所以任何一个0比1多排序, 可以拆成 (0和1相等的排序,代价1) + (0和1的差更小,更短,比原来代价更小的排序)</p><p>对于1比0多的情况, 对称关系同理可证</p><p>得证</p><p>问题变成如何选尽量少的0和1相等区间排序</p><hr><p>把0换为-1</p><p>又变成经典的,前缀和2维图形化了, 每次选择的是等高的点, 让等高点之间变成 V字形</p><p>假设1比-1多,那么也就是结束点比起点高, 如果最后一段是从一个和起点相等的值 一直+1达到 结束点的,那么 把起点和这个值的区间处理即可</p><p>所以就是让最后一个连续+1 到的结束点 的那一串尽量长</p><p>我们记录达到每个值的首先出现的点, 只考虑(&gt;=0的部分) 显然随着值越大,下标大,( 因为是从0涨过来的</p><p>而我们对末端的操作不会改变这个首次出现的位置</p><p>贪就完了</p><p>-1 比 1多 对称处理即可, 这里只要方案数不要操作细节,(所以还可以把 1变-1,0变1,并旋转字符串)</p><hr><p>样例输入1的最后一个数据</p><p><img src="/Blog/img/CF_1693F.jpeg" alt></p><p>这个和上面假设相反, 那就是 把头部可达的值的最小值的最后出现位置之间做区间处理</p><p>当然也可以双指针, (总代价移动是线性的</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><p><a href="https://codeforces.com/contest/1693/submission/162002156" target="_blank" rel="noopener">https://codeforces.com/contest/1693/submission/162002156</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;(int)n;i++)#define per(i,a,n) for (int i=n;i--&gt;(int)a;)int read(){int r;scanf(&quot;%d&quot;,&amp;r);return r;} // readchar s[200010];int pre[200010]; // 前缀和int pos[200010]; // 首次出现的位置int w(){  int n = read();  fill(pos,pos+n+1,-1);  scanf(&quot;%s&quot;,s);  int cnt[] = {0,0};  rep(i,0,n) cnt[s[i] == &#39;1&#39;] ++;  if(cnt[0] &gt; cnt[1]) { // 保证 个数1 &gt; 个数0    swap(cnt[0],cnt[1]);    rep(i,0,n) s[i] = (1 - (s[i] - &#39;0&#39;)) + &#39;0&#39;;    rep(i,0,n/2) swap(s[i],s[n-1-i]);  }  int d = cnt[1] - cnt[0];  rep(i,0,n) pre[i+1] = pre[i] + (s[i] == &#39;0&#39;? -1 : 1);  rep(i,0,n+1){    if(pre[i] &lt; 0) continue;    if(pos[pre[i]] != -1) continue;    pos[pre[i]] = i;  }  int minv = d; // 倒着最小能连续到达的值  per(i,-cnt[0],d+1){    if(pre[n - (d-i)] != i) break;    minv = i;  }  int ans = 0;  while(minv + cnt[0] &gt; 0){ // 已经完成排序    if(minv &lt; 0) return ans + 1; // 和l=0配    ans ++ ;    minv -= ((n-(d-minv))/*r*/-pos[minv]/*l*/)/2; // [l..r]  }  return ans;}int main(){  int t = read();  while(t--) printf(&quot;%d\n&quot;,w());  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>C</p><p>Dijkstra 性质还是不够熟啊</p><p>D</p><p>直接的dp能想到,也在想转移,倒是转移也可以倒着做, 而且需要推导这个变化的条件,从而得到必定是区间变化,有遍历次数=变化次数=可能次数</p><p>另一个方案, 我有大的方向, 说看能不能找不成立的,但是没有得到3412/2143, 一个是这个充要真不知道比赛能不能快速证明,</p><p>再就是3412, 就算我知道了, 也不知道怎么去算, 这个按中间位置做遍历, 预处理 两头算是又学了一手</p><p>E</p><p>总觉得好像见过类似的标记处理, 这里是标记+延后+贪心</p><p>哦 像python里的 a,b= b,a+b 可以写成 std::tie(a,b) = make_pair(b,a+b)</p><p>原来树状数组还有bit和fenwick写法区别</p><p>bit版本的是 a|=a+1</p><p>fenwick的是 a+=(a&amp;-a)</p><p>逻辑上 bit版本,统计的是末尾连续1的所有子集或上高位1的信息</p><p>而fenwick是当前结束向前(a&amp;-a)长度的信息</p><p>F</p><p>敢于去猜让解答变容易的特殊情况,并证明它</p><p>经典的0/1区间个数相等处理, 变成-1,1 和二维图</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://codeforces.com/blog/entry/103952" target="_blank" rel="noopener">官方</a></p><p><a href="https://codeforces.com/blog/entry/103952?#comment-923531" target="_blank" rel="noopener">ecnerwala E</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;C(反向dijkstra)D(DP,数学,贡献)E(标记,延后,贪心,树状数组)F(0/1串,数学)&lt;/p&gt;
&lt;h1 id=&quot;D&quot;&gt;&lt;a href=&quot;#D&quot; class=&quot;headerlink&quot; title=&quot;D&quot;&gt;&lt;/a&gt;D&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https:/
      
    
    </summary>
    
      <category term="Codeforces" scheme="http://yexiaorain.github.io/Blog/categories/Codeforces/"/>
    
    
      <category term="DP" scheme="http://yexiaorain.github.io/Blog/tags/DP/"/>
    
      <category term="贪心" scheme="http://yexiaorain.github.io/Blog/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="贡献" scheme="http://yexiaorain.github.io/Blog/tags/%E8%B4%A1%E7%8C%AE/"/>
    
      <category term="数学" scheme="http://yexiaorain.github.io/Blog/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="树状数组" scheme="http://yexiaorain.github.io/Blog/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
      <category term="标记" scheme="http://yexiaorain.github.io/Blog/tags/%E6%A0%87%E8%AE%B0/"/>
    
      <category term="延后" scheme="http://yexiaorain.github.io/Blog/tags/%E5%BB%B6%E5%90%8E/"/>
    
      <category term="0/1串" scheme="http://yexiaorain.github.io/Blog/tags/0-1%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 1697F(2-sat)</title>
    <link href="http://yexiaorain.github.io/Blog/2022-06-14-CF1697F/"/>
    <id>http://yexiaorain.github.io/Blog/2022-06-14-CF1697F/</id>
    <published>2022-06-14T14:24:00.000Z</published>
    <updated>2022-07-07T17:16:42.310Z</updated>
    
    <content type="html"><![CDATA[<p>我的第二次 2-SAT 练习</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://codeforces.com/contest/1697/problem/F" target="_blank" rel="noopener">https://codeforces.com/contest/1697/problem/F</a></p><p>给你m个限制, 分别可能是</p><ol><li>$a_i \neq x$</li><li>$a_i+a_j \ge x$</li><li>$a_i+a_j \le x$</li></ol><p>请构造一个满足限制的长n的数组a, 且每个元素在$[1,k]$之间</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>n 2e4</p><p>m 2e4</p><p>k 10</p><p>2s</p><p>512MB</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>一眼2-sat,写过但不熟, 来看看题解如何建立图的</p><p>tourist ,jiangly也是拖的板子, XD, 看来我要好好准备板子了?</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>一个值拆成2k个点</p><p>分别是$\le 1,\le 2,\cdots,\le k,&gt;1,&gt;2,\cdots,&gt;k$</p><p>其中$\le i, &gt; i$ 是一个互补对</p><p>$(i,v,0) = a_i \le v$</p><p>$(i,v,1) = a_i &gt; v$</p><p>因为2-sat 就是每个点选或不选 0/1, 而上面的两个必定一个满足一个不满足</p><p>$(i,v,0) \to (i,v+1,0)$ 不等式关系</p><p>$(i,v,1) \to (i,v-1,1)$ 不等式关系 (可以由上面自动建立对称关系</p><p>$(i,v,1) \to (i+1,v,1)$ 非严格单增</p><p>$(i,x,0) \to (i,x-1,0)$, $a_i \ne x$</p><p>$(i,x-1,1) \to (i,x,1)$, $a_i \ne x$ (可以由上面自动建立对称关系</p><p>$(i,v,1) \to (j,x-a_i-1,0)$, $a_i + a_j \le x$, 轮换$i,j$</p><p>$(i,v,0) \to (j,x-a_i-1,1)$, $a_i + a_j \ge x$, 轮换$i,j$ </p><hr><p>对于限制必定不合法的$(i,v,x)$ , 建立 $(i,v,x) \to (i,v,x\oplus 1)$</p><h2 id="2-sat-的选择"><a href="#2-sat-的选择" class="headerlink" title="2-sat 的选择"></a>2-sat 的选择</h2><p>之前有个问题, 我一直没想太通, 现在有点思路了</p><p>假设我们完成建边和tarjan的部分</p><p>如下, 这样那怎么顺序选都没问题</p><pre><code>a0 &lt;-&gt; b0a1 &lt;-&gt; b1</code></pre><p>而对于这种, 你是不能去选b1/c1 的,而这也是Tarjan 不会处理的,因为tarjan只是合并联通块, 这种还算有答案</p><pre><code>a0 &lt;-&gt; b0b1 &lt;-&gt; c1c1 -&gt; a0</code></pre><p>这种是没有答案, 而且tarjan 的时候是判断不了的</p><pre><code>a0&lt;-&gt;b0b1&lt;-&gt;c1c0&lt;-&gt;a1</code></pre><hr><p>那么两个办法我想的</p><p><strong>方法一</strong></p><p>如果我们要加 $a[x] \to b[y]$</p><p>考虑 如果 $b[y\oplus 1]$ ,那么a不能选x, 所以同时会产生$b[y\oplus 1] \to a[x\oplus1]$</p><p>这个好处是,本身可以利用tarjan</p><p><strong>方法二</strong></p><p>在tarjan处理完scc后, 对scc的每个点的<code>反点</code>做并查集, 缺点是还要跑并查集</p><hr><p>等价性 一个奇怪的视角可以证明就是 这些操作是对称性的, 比如方法一里面每次都是对称加的边, 而方法二,不妨设scc 中的反点个数比它大,那么scc必定会合其它scc连接,最终所有并查集完成后, scc和scc反点的scc个数相等</p><hr><p>这两个任选一种以后, 最后对scc/并查集 做原图的反向边 做倒序拓扑选择,必定有解?</p><p>再看上面的 3个例子</p><p>第一个不变</p><pre><code>a0 &lt;-&gt; b0a1 &lt;-&gt; b1</code></pre><p>第二个变成如下,你需要反向拓扑选择</p><pre><code>a0 &lt;-&gt; b0 &lt;-&gt; c0a1 &lt;-&gt; b1 &lt;-&gt; c1c1 -&gt; a0</code></pre><p>第三个则全部连到一个并查集里了, 直接确定不合法了</p><hr><p>第三个是限制的不可选状态</p><p>比如 $(i,x)$ 不可选, 之前的办法是做一个 失败的节点,让它和这个节点双向连通</p><p>而现在发现其实$(i,x) \to (i,x\oplus 1)$, 因为这样如果选$(i,x)$自动造成矛盾</p><hr><p>注意区别是<code>不可选</code>还是<code>选了一定满足</code></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>我先自己写了个twosat的板子,下次也可以用</p><p><a href="https://codeforces.com/contest/1697/submission/160657743" target="_blank" rel="noopener">https://codeforces.com/contest/1697/submission/160657743</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readclass TwoSat{  vector&lt;int&gt; low; // 能达到的最小的点  vector&lt;int&gt; dfn; // tarjan 用的深搜访问次序标识  stack&lt;int&gt; stk; // tarjan 用的stk  vector&lt;int&gt; res; // tarjan 结果  vector&lt;vector&lt;int&gt; &gt; p; // 所有点  int n;  void scc(int v) {    static int id = 0;    low[v] = dfn[v] = id++;    stk.push(v);    for(auto w:p[v]){      if(dfn[w] == -1){ // 未访问过        scc(w);        low[v] = min(low[v],low[w]);      } else if(res[w] == -1){ // 访问过但没有结果(在栈中)        low[v] = min(low[v],dfn[w]);      }    }    int u;    if(low[v] == dfn[v])  {      do{        res[u = stk.top()] = v;        stk.pop();      }while(u != v);    }  }public:  TwoSat(int SZ):n(SZ){ // 点范围[0..SZ-1]    low = vector&lt;int&gt;(2*n,-1);    dfn = vector&lt;int&gt;(2*n,-1);    stk = {};    res = vector&lt;int&gt; (2*n,-1);    p = vector&lt;vector&lt;int&gt; &gt;(2*n);  }  bool calc(vector&lt;bool&gt; &amp; ans){    rep(i,0,2*n) if(res[i] == -1) scc(i);    // rep(i,0,2*n) printf(&quot;scc[%lld] = %d\n&quot;,i,res[i]);    rep(i,0,n) if(res[i*2] == res[i*2+1]) return false; // 同一个块的真假都在一个scc里    vector&lt;int&gt; revscc(2*n); // 互斥scc    rep(i,0,n) {      revscc[res[i*2]] = res[i*2+1];      revscc[res[i*2+1]] = res[i*2];    }    vector&lt;set&lt;int&gt; &gt; scc2scc(2*n);    unordered_map&lt;int,int&gt; degree; // scc入度    unordered_map&lt;int,bool&gt; scctf; // scc 真假    rep(i,0,2*n) { // 跨scc的反向边, 做拓扑选择      degree[res[i]] = 0;      for(auto j:p[i]){ // i -&gt; j        if(res[i] == res[j]) continue;        scc2scc[res[j]].insert(res[i]);      }    }    for(auto s:scc2scc){      for(auto t:s) degree[t]++;    }    vector&lt;int&gt; d0; // 入度为0    for(auto [v,d]: degree) if(!d) d0.pb(v);    rep(i,0,d0.size()) {      if(!scctf.count(d0[i])){ // 没有选择过        // printf(&quot;pick %d, unpick %d\n&quot;,d0[i],revscc[d0[i]]);        scctf[d0[i]] = true;        scctf[revscc[d0[i]]] = false;      }      for(auto item:scc2scc[d0[i]]) { // 更新入度排序        if(!(--degree[item])) d0.pb(item);      }    }    ans = vector&lt;bool&gt;(n);    rep(i,0,n) ans[i] = scctf[res[i*2+1]];    return true;  }  void p2(pair&lt;int,bool&gt; pi, pair&lt;int,bool&gt; pj){ // {i,true/false} -&gt; {j,true/false}    auto [i,bi] = pi;    auto [j,bj] = pj;    // printf(&quot;(%d,%d) -&gt; (%d,%d)\n&quot;,i,(int)bi,j,(int)bj);    // printf(&quot;(%d,%d) -&gt; (%d,%d) (auto\n&quot;,j,(int)bj^1,i,(int)bi^1);    assert(i &gt;= 0 &amp;&amp; i &lt; n);    assert(j &gt;= 0 &amp;&amp; j &lt; n);    p[2*i+bi].pb(2*j+bj);    p[2*j+(!bj)].pb(2*i+(!bi)); // 自动建立逻辑边  }};int n;int m;int k;int c(int i,int j){  return i*k+j;}void w(){  n = read();  m = read();  k = read();  TwoSat ts(n*k);  // a[i][j=0..k-1] =&gt; i*k+j  // false : &lt;= j+1  // true  : &gt;  j+1  // 不等式关系  rep(i,0,n){    rep(j,0,k-1){      ts.p2({c(i,j),0},{c(i,j+1),0}); // 自动建立反向边 ts.p2({c(i,j+1),1},{c(i,j),1});    }    ts.p2({c(i,k-1),1},{c(i,k-1),0}); // 不能选 &gt; k  }  // 非严格单增  rep(i,0,n-1){    rep(j,0,k){      ts.p2({c(i,j),1},{c(i+1,j),1});    }  }  while(m--){    int op = read();    int i = read()-1;    if(op == 1){      int x = read()-1;      if(x){        ts.p2({c(i,x),0},{c(i,x-1),0});        // ts.p2({c(i,x-1),1},{c(i,x),1}); // 对称自动      }else{        ts.p2({c(i,x),0},{c(i,x),1}); // 输入的原始 x = 1 的时候, 不能选 &lt;= 1      }    }else if(op == 2){      int j = read() - 1;      int x = read(); // a[i] + a[j] &lt;= x , a[i] &gt; v : a[j] &lt;= x-a[i] &lt; x-v, a[j] &lt; x-v-1      rep(v,1,k+1){        int v2 = x - v - 1;        if(v2 &gt;= 1 &amp;&amp; v2 &lt;= k){          ts.p2({c(i,v-1),1},{c(j,v2-1),0});          // ts.p2({c(j,v-1),1},{c(i,v2-1),0}); // 对称自动建立        }else if(v2&lt;1){ // 不可选的v , ( v2 &gt; k 说明一定满足          ts.p2({c(i,v-1),1},{c(i,v-1),0});          ts.p2({c(j,v-1),1},{c(j,v-1),0});        }      }    }else if(op == 3){      int j = read() - 1;      int x = read(); // a[i] + a[j] &gt;= x, a[i] &lt;= v : a[j] &gt;= x - a[i] &gt;= x - v &gt; x - v - 1      rep(v,1,k+1){        int v2 = x - v - 1;        if(v2 &gt;= 1 &amp;&amp; v2 &lt;= k){          ts.p2({c(i,v-1),0},{c(j,v2-1),1});          // ts.p2({c(j,v-1),0},{c(i,v2-1),1}); // 对称自动建立        }else if(v2 &gt; k){ // 不可选的v, (v2 &lt; 1 是一定满足          ts.p2({c(i,v-1),0},{c(i,v-1),1});          ts.p2({c(j,v-1),0},{c(j,v-1),1});        }      }    }  }  vector&lt;bool&gt; ans;  vector&lt;int&gt; a(n);  if(!ts.calc(ans)){    printf(&quot;-1\n&quot;);  }else{    rep(i,0,n){      rep(j,0,k){        if(!ans[i*k+j]){          a[i] = j+1;          break;        }      }    }    rep(i,0,n) printf(&quot;%d%c&quot;,a[i],&quot; \n&quot;[i==n-1]);  }}int main(){  int t = read();  while(t--) w();  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这里的问题就是说 选则一个范围的值,怎么变成2-sat需要的 真/假</p><p>这里的办法是拆成大于小于</p><p>当然从逻辑上 用 $= v$ 和$\ne v$ 也可以, 但是这样的问题是, 在做上面的和的不等式的关系时, 边的量就很大了, 不是k条边了</p><p>之前2-sat 还有点问题,缺少了一些反向的连接,和缩点后的反向拓扑序选择</p><p>准备准备2sat的板子了</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://codeforces.com/blog/entry/103835" target="_blank" rel="noopener">官方</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我的第二次 2-SAT 练习&lt;/p&gt;
&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1697/pro
      
    
    </summary>
    
      <category term="Codeforces" scheme="http://yexiaorain.github.io/Blog/categories/Codeforces/"/>
    
    
      <category term="2-sat" scheme="http://yexiaorain.github.io/Blog/tags/2-sat/"/>
    
  </entry>
  
  <entry>
    <title>Atcoder abc254 G(倍增)</title>
    <link href="http://yexiaorain.github.io/Blog/2022-06-13-ac_abc254/"/>
    <id>http://yexiaorain.github.io/Blog/2022-06-13-ac_abc254/</id>
    <published>2022-06-12T20:25:14.000Z</published>
    <updated>2022-07-07T17:16:42.310Z</updated>
    
    <content type="html"><![CDATA[<p>G(倍增)</p><h1 id="G"><a href="#G" class="headerlink" title="G"></a>G</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://atcoder.jp/contests/abc254/tasks_print" target="_blank" rel="noopener">https://atcoder.jp/contests/abc254/tasks_print</a></p><p>n个楼, 每个楼高都是1..1e9</p><p>有m个电梯, 每个电梯在一个楼里,负责[li,ri] 之间</p><p>可以允许这个楼里, [li,ri] 范围中的移动</p><p>跨楼同楼层移动代价1</p><p>同楼电梯内移动,代价 高度差</p><p>q个询问, ai楼bi层 到 ci楼di层最小代价, 或它们不可达</p><h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h3><p>n 2e5</p><p>m 2e5</p><p>q 2e5</p><p>6s</p><p>1024mb</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h3><p>显然 同楼层答案是1或0</p><p>不同楼层,只会单调移动,不会先上再下这种, 答案 = 距离+跨楼数, 需要最小化跨楼数</p><p>而每次移动贪心距离, 这样模拟可做, 但是复杂度无法接受</p><p>显然同楼的重叠电梯可以合并</p><h3 id="官方"><a href="#官方" class="headerlink" title="官方"></a>官方</h3><p>显然上下还满足对称性, 那么只考虑从下向上</p><p>合并同楼重叠电梯(这样做了以后剩下的线段就不用考虑属于哪个楼了? 因为是一旦重叠肯定不重楼</p><p>如果 ai楼内bi移动到最高位置, ci 楼内 di 移动到最低位置, 合法提前输出</p><p><code>dp[i][j]</code> 当前建筑第i层,用j个电梯后最高能到达的楼层</p><p>考虑 离散+倍增</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>我写的按右断点跳右端点的map不知道为什么WA了除了测试点, 调了七八个小时,atcoder还没数据, 放弃了</p><p>下面是一个别人的代码,我改了部分格式,靠清理了一些线段,保持左右端点都严格单调递增, 然后用线段跳线段来做的, 我觉得完全一样啊, 吐了, 搞不动了,心态炸了</p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;(int)n;i++)#define per(i,a,n) for (int i=n;i--&gt;(int)a;)#define pb push_backint read(){int r;scanf(&quot;%d&quot;,&amp;r);return r;} // readvector&lt;array&lt;int,2&gt; &gt; ilr[200010];vector&lt;array&lt;int, 2&gt;&gt; segs;vector&lt;vector&lt;int&gt;&gt; jump;int N;int lg = 20;int n, m, q;int query(){  int i0, f0, i1, f1;  i0 = read() - 1;  f0 = read();  i1 = read() - 1;  f1 = read();  if(f0 == f1) return i0 != i1;  if (f0 &gt; f1) {    swap(i0, i1);    swap(f0, f1);  }  int ans = f1 - f0;  auto it =    lower_bound(ilr[i0].begin(), ilr[i0].end(), array&lt;int, 2&gt;{f0 + 1, -1});  if (it != ilr[i0].begin()) f0 = max(f0,(*--it)[1]);  it = lower_bound(ilr[i1].begin(), ilr[i1].end(), array&lt;int, 2&gt;{f1 + 1, -1});  if (it != ilr[i1].begin()) {    it--;    if (f1 &lt;= (*it)[1]) {      f1 = (*it)[0];    }  }  if (f0 &gt;= f1) return ans + (i0 != i1);  // 跳到一个右端点 保证f0 是右端点  ans++;  int idx = lower_bound(segs.begin(), segs.end(), array&lt;int, 2&gt;{f0 + 1, -1}) - segs.begin();  // 未被覆盖到  if (!idx) return -1;  idx--;  if (f0 &gt; segs[idx][1]) return -1;  if (segs[idx][1] &gt;= f1) return ans + 1;  if (segs[jump[idx][lg]][1] &lt; f1) return -1;  per(k,0,lg+1){    if (segs[jump[idx][k]][1] &gt;= f1) continue;    idx = jump[idx][k];    ans += 1 &lt;&lt; k;  }  idx = jump[idx][0];  return ans + 2;}int main() {  n = read();  m = read();  q = read();  rep(i,0,m){    int a, b, c;    a = read() - 1;    b = read();    c = read();    ilr[a].push_back({b, c});  }  // 每组内部 排序 与 合并  rep(i,0,n){    sort(ilr[i].begin(), ilr[i].end());    vector&lt;array&lt;int, 2&gt;&gt; temp;    for (auto [l, r] : ilr[i]) {      if (!temp.empty() &amp;&amp; l &lt;= temp.back()[1]) {        temp.back()[1] = max(temp.back()[1], r);      } else {        temp.push_back({l, r});      }    }    ilr[i] = temp;    for (auto s : temp) segs.push_back(s);  }  sort(segs.begin(), segs.end());  vector&lt;array&lt;int, 2&gt;&gt; temp;  for (auto [l, r] : segs) {    if (!temp.empty() &amp;&amp; r &lt;= temp.back()[1]) { //      continue;    }    if (!temp.empty() &amp;&amp; l == temp.back()[0]) {      temp.pop_back();    }    temp.push_back({l, r});  }  segs = temp;  N = segs.size();  jump = vector&lt;vector&lt;int&gt;&gt;(N, vector&lt;int&gt;(lg + 1));  // jump[段id][pwr] = 段id  for (int i = 0, j = 0; i &lt; N; i++) {    while (j + 1 &lt; N &amp;&amp; segs[j + 1][0] &lt;= segs[i][1]) {      j++;    }    jump[i][0] = j;  }  rep(j,0,lg){    rep(i,0,N){      jump[i][j + 1] = jump[jump[i][j]][j];    }  }  while(q--) printf(&quot;%d\n&quot;, query());  return 0;}</code></pre><p>我的代码 不知道WA在哪里了</p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readint n,m,q;vector&lt;pair&lt;int,int&gt; &gt; ilr[200010]; // 每个楼vector&lt;pair&lt;int,int&gt; &gt; segs; // 所有楼vector&lt;int&gt; maxr = {0}; // 前缀 最大rmap&lt;int,vector&lt;int&gt;&gt; jump = {}; // jump[结束位置][2**i次跳跃] = 最高位置const int lg = 20;int query(){  int i0 = read();  int f0 = read();  int i1 = read();  int f1 = read();  // 同楼层  if(f0 == f1) return i0 != i1;  // 从低到高 f0 &lt; f1  if(f0 &gt; f1){    swap(i0,i1);    swap(f0,f1);  }  int ans = f1-f0;  // 注意不在区间的情况不会跳  int itr0 = lower_bound(ilr[i0].begin(),ilr[i0].end(),make_pair(f0+1,-1)) - ilr[i0].begin();  if(itr0 &gt; 0) f0 = max(f0, ilr[i0][itr0-1].second);  int itr1 = lower_bound(ilr[i1].begin(),ilr[i1].end(),make_pair(f1+1,-1)) - ilr[i1].begin();  if(itr1 &gt; 0 &amp;&amp; ilr[i1][itr1-1].second &gt;= f1) f1 = ilr[i1][itr1-1].first;  if(f1 &lt;= f0) return ans + (i0 != i1);  // next0 可能不是某个右端点, 不可能一次跳到, 否则 perv1 &lt;= next0, 所以直接贪心去最大可达右端点  // 跳一次 保证f0 是右端点  int idx = lower_bound(segs.begin(),segs.end(),make_pair(f0+1,-1)) - segs.begin();  if(idx == 0 || maxr[idx] &lt; f0) return -1; // 未被覆盖到  f0 = maxr[idx]; // 当不可达时可能是比它小的右端点, 但是不影响结果逻辑  ans ++;  if(f1 &lt;= f0) return ans + 1;  // ? 需要吗 TODO  // if(!h.count(f0)) return -1;  if(jump[f0][lg] &lt; f1) return -1;  per(pwr,0,lg+1){    if(jump[f0][pwr] &gt;= f1) continue;    f0 = jump[f0][pwr];    ans += (1&lt;&lt;(pwr));  }  assert(f0 &lt; f1 &amp;&amp; jump[f0][0] &gt;= f1);  // printf(&quot;%d\n&quot;,ans+1 +1); // 分别是跳到比f1 大的和跳到恰好f1  return ans + 2; // 分别是跳到比f1 大的和跳到恰好f1}int main(){  n = read();  m = read();  q = read();  rep(i,0,m) {    // 注意g++ 函数处理顺序问题    // ilr[read()].pb(make_pair(read(),read()));    int pos = read();    int l = read();    int r = read();    ilr[pos].pb({l,r});  }  // 合并同楼 重叠  rep(i,1,n+1){    sort(ilr[i].begin(),ilr[i].end());    vector&lt;pair&lt;int,int&gt; &gt; tmp = {}; // 合并辅助    for(auto [l,r]: ilr[i]){      if(tmp.size() == 0 || l &gt; tmp.back().second){ // 不连续 [l0,r0] .. [l1..r1]        tmp.pb({l,r});      }else{        tmp.back().second = r;      }    }    ilr[i] = tmp;    for(auto o:tmp) segs.pb(o);  }  sort(segs.begin(),segs.end()); // 所有楼的  for(auto item:segs) maxr.pb(max(maxr.back(), item.second));  // 倍增  for(auto item:segs){    auto r = item.second;    if(jump.count(r)) continue;    jump[r] = vector&lt;int&gt;(lg+1,r);    // [...r] [r+1...    int idx = lower_bound(segs.begin(),segs.end(),make_pair(r+1,-1)) - segs.begin();    jump[r][0] = maxr[idx]; // 初始化跳2^0 = 1次  }  rep(pwr,1,lg+1){    for(auto item:segs){ // 会重复计算,不影响      auto r = item.second;      jump[r][pwr] = jump[jump[r][pwr-1]][pwr-1];    }  }  while(q--) printf(&quot;%d\n&quot;, query());  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>G</p><p>倍增, 编码速度也是问题, 写几个小时还在wa,哎</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>官方题解 <a href="https://atcoder.jp/contests/abc254/editorial" target="_blank" rel="noopener">https://atcoder.jp/contests/abc254/editorial</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;G(倍增)&lt;/p&gt;
&lt;h1 id=&quot;G&quot;&gt;&lt;a href=&quot;#G&quot; class=&quot;headerlink&quot; title=&quot;G&quot;&gt;&lt;/a&gt;G&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/
      
    
    </summary>
    
      <category term="Atcoder" scheme="http://yexiaorain.github.io/Blog/categories/Atcoder/"/>
    
    
      <category term="倍增" scheme="http://yexiaorain.github.io/Blog/tags/%E5%80%8D%E5%A2%9E/"/>
    
  </entry>
  
  <entry>
    <title>CodeChef June Div1 Prefix Suffix Distinct(数学)</title>
    <link href="http://yexiaorain.github.io/Blog/2022-06-12-COOK142A-4/"/>
    <id>http://yexiaorain.github.io/Blog/2022-06-12-COOK142A-4/</id>
    <published>2022-06-12T14:24:00.000Z</published>
    <updated>2022-07-07T17:16:42.310Z</updated>
    
    <content type="html"><![CDATA[<p>主要问题不在算法,在自己写bug</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://www.codechef.com/submit-v2/PRFSUFDSTNCT" target="_blank" rel="noopener">https://www.codechef.com/submit-v2/PRFSUFDSTNCT</a></p><p>一个数组, 的前缀i个数,不重复的数值个数为pi</p><p>后缀i到结束,不重复的数值个数为si</p><p>给你p和s,问是否存在数组满足, 返回是否即可</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>n 1e5</p><p>1s</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>首先最直接的,</p><p>p[0] = s[n-1] = 1</p><p>p[n-1] = s[0]</p><p>然后 p的增量为0/1,s的增量为0/-1</p><p>再因为每个值至少贡献1次</p><p>所以如果p[i] + s[i+1] == p[n-1], 那么说明 i 和i+1 可以切开,并且这位置p增量为1,s增量为-1</p><p>对于切开后的每一段 找到变化的位置(增量为1/-1)的位置</p><p>分别跑后缀的前缀 应该小于等于前缀(与前缀首个的差)</p><p>和 前缀的后缀 应该小于等于后缀(与后缀最后一个的差)</p><h2 id="官方"><a href="#官方" class="headerlink" title="官方"></a>官方</h2><p>反而没有切割的操作,上面几个倒是有</p><p>官方 判断了个<code>a[i]+b[i] &lt;= a[n-1]</code> 跟我切割操作有点像,但是 不是错位的判断</p><p>原理和我那个也是类似,所有数贡献一次,左右统计的第i个两侧都有贡献,所以至少是a[n-1]+1</p><p>–</p><p>分析的是同一位的(p[i]-p[i-1],s[i]-s[i+1]) 的四种情况</p><p>1,1 原数组中唯一的值, 不需要额外判断, 甚至可以考虑原数组删除它</p><p>0,1 和 1,0 是对称的, 如果全部都是这两个</p><p>那么1,0 的出现意味着 右侧会有一个0,1 也就是从后缀上这个数首次出现的</p><p>可以看成1,0左括号,0,1右括号做括号匹配, 但不完全是相邻位置的, 如 (()), 可以1和3,2和4配</p><p>0,0 说明没有变化,应该被包含在某个值中, 如果记作.</p><p>那么<code>(.)(.)</code>是好的, 而<code>().()</code>,0,0无值可选</p><p>如此检查</p><hr><p><code>(.)(.)</code> 如</p><pre><code>p 111222s 222111</code></pre><p>正好一个答案是<code>111222</code></p><p><code>().()</code>如</p><pre><code>1112222111</code></pre><p>再换句 (, 上面+1, 右括号下面后一个-1, 所以考虑上下的总和变化, 出现问题就是 a[i]+b[i] &lt;= a[n-1]</p><hr><p>看了一下应该是有真的代码被我判否了, 因为我把答案逻辑塞到我代码后面return false也不对</p><p>最后发现是因为我代码 if 的l和r复制漏改了</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>按照我的逻辑AC的代码</p><p><a href="https://www.codechef.com/viewsolution/66653363" target="_blank" rel="noopener">https://www.codechef.com/viewsolution/66653363</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 1000000007#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readll p[100010]; // a 前缀 [..i] 不同的个数ll s[100010]; // a 后缀 [i..] 不同的个数bool p0[100010];bool p1[100010];// 只用 yes or noint n;// 保证范围 单增 单减 , 跨度 0/1bool check(int l,int r){  // [st..en]  if(l &gt; 0 &amp;&amp; p[l] != p[l-1]+1) return false;  if(r &lt; n - 1 &amp;&amp; p[r] != p[r+1]-1) return false;  if(l &gt; 0 &amp;&amp; s[l] != s[l-1]-1) return false;  if(r &lt; n - 1 &amp;&amp; s[r] != s[r+1]+1) return false; // 这里写成l了  if(p[r] - p[l] != s[l] - s[r])return false;  // 计算变化的点  rep(i,l,r+1){    if(i == r || p[i] != p[i+1]){      p0[i] = true;    }  }  rep(i,l,r+1){    if(i == l || s[i] != s[i-1]){      p1[i] = true;    }  }  // 跑前缀 &lt;= 前缀  {    int cur = 0;    rep(i,l,r+1){      cur += p1[i];      if( cur &gt; p[i] - p[l]+1) return false;    }  }  {    int cur = 0;    per(i,l,r+1){      cur += p0[i];      if( cur &gt; s[i] - s[r]+1) return false;    }  }  return true;}bool w(){  // 清空  n = read();  fill(p0,p0+n,0);  fill(p1,p1+n,0);  rep(i,0,n) p[i] = read();  rep(i,0,n) s[i] = read();  // p [n-1] 不同的总数  if(p[n-1] != s[0]) return false;  if(p[0] != s[n-1]) return false;  if(p[0] != 1) return false;  // 跨度 0/1  rep(i,1,n)if(p[i] &lt; p[i-1] || p[i] &gt; p[i-1] + 1)return false;  rep(i,1,n)if(s[i] &gt; s[i-1] || s[i] &lt; s[i-1] - 1)return false;  int itr = 0;  rep(i,0,n-1){    if(p[i] + s[i+1] == p[n-1]){      if(!check(itr,i)) return false;      itr = i+1;    }else if(p[i] + s[i+1] &lt; p[n-1]){      // ???      return false;    }  }  return check(itr,n-1);}int main(){  int t = read();  while(t--) printf(&quot;%s\n&quot;,w()?&quot;YES&quot;:&quot;NO&quot;);  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>BUG 是我AC失败一个重大阻碍</p><p>题解的转化我也是没想到的学习了</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://discuss.codechef.com/t/prfsufdstnct-editorial/101414" target="_blank" rel="noopener">官方</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;主要问题不在算法,在自己写bug&lt;/p&gt;
&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.codechef.com/submit-v2/PR
      
    
    </summary>
    
      <category term="CodeChef" scheme="http://yexiaorain.github.io/Blog/categories/CodeChef/"/>
    
    
      <category term="数学" scheme="http://yexiaorain.github.io/Blog/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 1687E(数学,构造,min-max容斥,kmin/kmax容斥)</title>
    <link href="http://yexiaorain.github.io/Blog/2022-06-07-CF1687E/"/>
    <id>http://yexiaorain.github.io/Blog/2022-06-07-CF1687E/</id>
    <published>2022-06-07T14:24:00.000Z</published>
    <updated>2022-07-07T17:16:42.310Z</updated>
    
    <content type="html"><![CDATA[<p>评分3500,题是国内洛谷大佬出的, t神都炸了</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://codeforces.com/contest/1687/problem/E" target="_blank" rel="noopener">https://codeforces.com/contest/1687/problem/E</a></p><p>长n的数列a</p><p>初始 v = 1</p><p>不超过1e5操作,让gcd(all(ai * aj)) = v,i != j, 就是所有不相同的两个数的乘积的gcd</p><p>一次操作, 选取a的一个子序列b,(子序列=保持顺序不要求连续)</p><p>并执行<code>v = v * lcm(b)</code>或 <code>v = v / lcm(b)</code>, 注意的是过程中,v 可以不是整数, 这里是数学除,不是整除</p><p>同时保证,所有选取的b的长度和 小于1e6</p><p>输出任何一个满足要求的方案</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>n 1e5</p><p>ai 1e6</p><p>3s</p><p>512MB</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>考虑所有与 a1 乘的</p><p><code>a1 * gcd(a2,...,an)</code></p><p>所有与a2乘的</p><p><code>a2 * gcd(a1,a3,...,an)</code></p><p>但怎么组合并不知道</p><p>反过来,既然是gcd/lcm,乘法,那么就考虑质数的出现计数</p><p>所有ai的两两相乘的gcd,其实就是 每个质数出现次数, 最小的两个和</p><p>所以目标的v 是O(n log ai) 可以得到的</p><hr><p>那么问题是如何通过lcm去搞, 题目里说 It can be shown that the answer exists</p><p>如果是两个数的gcd</p><p>gcd(a,b) * lcm(a,b) = ab</p><p>gcd(a,b) = lcm(a,a) * lcm(b,b) / lcm(a,b)</p><hr><p>考虑一下小的情况</p><blockquote><p>两个数</p></blockquote><p>v = a0 a1 = lcm(a0,a0) * lcm(a1,a1)</p><blockquote><p>三个数</p></blockquote><p>a0 = k0 q x y</p><p>a1 = k1 q y z</p><p>a2 = k2 q z x</p><p>其中 q = gcd(a0,a1,a2)</p><p>gcd(a0,a1) = qy</p><p>gcd(a1,a2) = qz</p><p>gcd(a2,a0) = qx</p><p>那么有 lcm(a0,a1,a2) = k0 k1 k2 q x y z</p><p>lcm(a0,a1) = k0 k1 q x y z</p><p>lcm(a1,a2) = k1 k2 q x y z</p><p>lcm(a2,a0) = k2 k0 q x y z</p><p>那么 目标 v = q q x y z</p><p>而观察上面的lcm, 注意到如果用一个的, 会出现如果要x y z 相等 那么会造成 q比它们多, 需要使用一个元素</p><p>那么 q x y z = lcm0 lcm1 lcm2 / lcm 012</p><blockquote><p>四个数</p></blockquote><p>考虑从三个数变形</p><p>a0 = k0 q x y</p><p>a1 = k1 q y z</p><p>a2 = k2 q z x</p><p>a3</p><p>目标是 v = gcd(a3 q,q q x y z)</p><p>这相当于 v(a0,a1,a2,a3) = gcd(a3 gcd(a0,a1,a2),v(a0,a1,a2))</p><p>如果按照这个写法,去看3个数</p><p>v(a0,a1,a2) = gcd(a2 gcd(a0,a1), v(a0,a1))</p><p>= lcm(a2 gcd(a0,a1) lcm(v(a0,a1)) / lcm(a2 gcd(a0,a1), v(a0,a1))</p><p>= v(a0,a1) a2 gcd(a0,a1) / lcm(a2 gcd(a0,a1), v(a0,a1))</p><p>= v(a0,a1) lcm(a2) lcm(a0) lcm(a1) / (lcm(a2 gcd(a0,a1), v(a0,a1)) lcm(a0,a1))</p><p>= ???</p><p>= 0 1 2 / 012</p><p>只能说 v(a0,a1) / (lcm(a2 gcd(a0,a1), v(a0,a1) lcm(a0,a1) == lcm(0,1,2) ?</p><p>没有什么思路</p><hr><p>再会看题目 n是1e5, 但希望操作不要超过1e5</p><p>但注意到上面3个数的时候用了4次,</p><p>具体例子</p><p>a0 = 11 2 3 5</p><p>a1 = 13 2 5 7</p><p>a2 = 17 2 7 3</p><p>lcm(0,1) = 11 13 2 3 5 7</p><p>lcm(1,2) = 13 17 2 3 5 7</p><p>lcm(2,0) = 17 11 2 3 5 7</p><p>lcm(0,1,2) = 11 13 17 2 3 5 7</p><p>v(0,1,2) = 2 2 3 5 7 = lcm0 lcm1 lcm2 / lcm012</p><p>说明3个的做法对于大的n并不通用, 通用的应该要能达到n个是n次的样子</p><p>对于大的n, 不会使用单个, 因为单个会有独立的系数, 任何其它gcd无法消掉</p><hr><p>那不如强行拆一下四个数</p><p>其中k是独立的部分</p><pre><code>a0 = k0  b c d        w x y    qa1 = k1  b     e f    w x   z  qa2 = k2    c   e   g  w   y z  qa3 = k3      d   f g    x y z  q</code></pre><p>发现其中出现次数都是C(4,i)对应的表现</p><p><code>v = w x y z q q</code></p><p>一个为组的轮换 (1次) (2次) (3次) (4次)</p><p>两个为组的轮换 (3次) (5次) (6次) (6次)</p><p>三个为组的轮换 (3次) (4次) (4次) (4次)</p><p>四个为组的轮换 (1次) (1次) (1次) (1次)</p><p>以线性方程组的知识, 显然 <code>(0 0 1 2) = (1 2 3 4) + 2(1 1 1 1) - (3 4 4 4)</code>, 次数是 <code>4 + 2 * 1 + 4</code> 要10次</p><hr><p>剩下的观察就是, n 1e5, 而 ai 1e6</p><p>也就是说可能有不少的因子被干掉了</p><p>并不知道如何量化分析了</p><p>只知道 k0,k1,k2,k3,b,c,d,e,f,w,x,y,z 应该是两两互质的, 否则把它们的gcd提取出来转到下一级别</p><p>而如果全部互质, 那么<code>2*3*5*7*8*11*13 = 240240</code> 在超界的边缘</p><p>似乎不可能构成的样子</p><h2 id="官方"><a href="#官方" class="headerlink" title="官方"></a>官方</h2><p>考虑容斥原理</p><p>一样的, 对于一个质数的幂次 在结果中 = 这个质数最小出现的两个幂次的和</p><p>广义 容斥</p><p>$\gcd_{i\ne j}{A_i\times A_j}=\prod_{T\subseteq U}\text{lcm}(T)^{(-1)^{|T|}(|T|-2)}$</p><p>证明一下这个表达式</p><p>因为对于不同质数,可以独立的看其幂次</p><p>不妨设对于一个具体质数, 它在这些数组元素中的幂次从小到大为 <code>p0 p1 &gt;=p1 &gt;=p1 ...</code>, 也就是a0按照p的幂次排序</p><p>需要的是$p_1+p_2$</p><p>$(lcm(a_1)) \cdot (lcm(a_2) \cdot lcm(a_1,a_2)^0 ) \cdot ( a_3^{ 1 + 0 + (-1) } \cdot (a4^{ 1 + 0 + (-1 \cdot 3) + 2 \cdot 1}) \cdot (a_5^{1 + 0 + (-1 \cdot 6) + (2 \cdot 4) + (-3 \cdot 1)}) \cdots$</p><p>$ = a_1 \cdot a_2 = p^{p_1+p_2}$</p><p>这么神奇的吗</p><p>你会发现$lcm_k, k \ge 3$ 的幂次为</p><p>$ \sum_{i=1}^k (-1)^i \cdot (i-2) \cdot C(k-1,i-1) $</p><p>$ = - \sum_{i=0}^{k-1} (-1)^i \cdot (i-1) \cdot C(k-1,i)$</p><p>$ = - \sum_{i=0}^{w} (-1)^i \cdot (i-1) \cdot C(w,i) , w = k-1 \ge 2$</p><p>$ = - \sum_{i=0}^{w} (-1)^i \cdot i \cdot C(w,i)$ ( 因为$w \ge 2 &gt; 0 时, 0 = (1-1)^w = \sum_{i=0}^{w} (-1)^i \cdot C(w,i)$</p><p>$ = - \sum_{i=0}^w (-1)^i \cdot i \cdot \frac{w!}{i!(w-i)!} $</p><p>$ = - \sum_{i=1}^w (-1)^i \cdot i \cdot \frac{w!}{i!(w-i)!} $</p><p>$ = - \sum_{i=1}^w (-1)^i \cdot \frac{w!}{(i-1)!(w-i)!} $</p><p>$ = - w \sum_{i=1}^w (-1)^i \cdot \frac{(w-1)!}{(i-1)!(w-i)!} $</p><p>$ = - w \sum_{i=1}^w (-1)^i \cdot C(w-1,i-1) $ ( 同上 因为$w-1 \ge 2-1 &gt; 0 时, 0 = (1-1)^w = \sum_{i=0}^{w} (-1)^i \cdot C(w,i)$</p><p>$ = - w \cdot 0$</p><p>$ = 0 $</p><p>其中 $ k - 1 = w \ge 2$</p><p>算强行证明了</p><hr><p>题解的过程是 有得到第k小的数的反演公式 $k\text{-th}\min{S}=\sum\limits_{\varnothing\ne T\subseteq S}(-1)^{|T|-k}\tbinom{|T|-1}{k-1}\max{T}$</p><p>那么 其实就是最小的(k=1) + 次小的(k=2) 得到</p><hr><p>一个可重整数集$S$, 其中整数范围$[1,10^6]$, 那么 总能选出大小不超过7的子集$T\subseteq S$, 让$\gcd(S)=\gcd(T)$</p><p>易证,因为$gcd(S) \le 10^6$ 所以它的质因子个数不超过7个, T只需要每个质因子的最小幂次选出来就行了</p><p>但和本题还是有区别</p><p>本题是 $gcd_2(S)$的情况, 两两下标不同乘积的gcd</p><p>这样考虑 先让集合$T$为空, 然后我们针对质数p 的幂次来讲, 假设前面已经选了几轮了, 那么最坏情况, 没有选p的最低和次低幂次, 所以为了让p的幂次满足, 任选两个最低和次低幂次, 也就是填2个, 而这种情况说明$gcd_2(S)$ 至少包含p的一次方</p><p>所以 最多有7个不同的有效p,最多选14个就能达成</p><hr><p>这样也没要求最小数量</p><p>直接用上面的lcm和gcd的min/max 表达式就可以了</p><hr><p>因为可能其它数字 虽然贡献是两个0次,但是因为, 只做了幂次最小限制,会让它们的gcd不止是对应的幂次</p><p>wa5或者看下面的例子</p><pre><code>2   3 5 72     52 2 32 2     7</code></pre><p>注意到3,5,7的最小两个幂次和都是0,而2的最小两个幂次和为1+1=2</p><p>但是如果你只选前两个去做集合运算,那么gcd = 2 5</p><p>所以你可以通过数量控制</p><h3 id="关于Min-Max-容斥"><a href="#关于Min-Max-容斥" class="headerlink" title="关于Min-Max 容斥"></a>关于Min-Max 容斥</h3><p>$max_k(S) = $ 集合$S$的第$k$大元素</p><p>TODO 再整理一篇文章: 反演 =&gt; 二项式反演 =&gt; min-max 反演 =&gt; kmax/kmin 反演</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>感觉代码还真不难写, 纯代码不到100行,毕竟给了3s</p><p><a href="https://codeforces.com/contest/1687/submission/159885371" target="_blank" rel="noopener">https://codeforces.com/contest/1687/submission/159885371</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_back#define all(O) O.begin(),O.end()ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readint n;int a[100010];int v2p[1000010]; // 每个数的质数拆解const int INF = 0x3f3f3f3f;int getpwr(int v,int p){  int r = 0;  while(v % p == 0){    r++;    v/=p;  }  return r;}int main(){  int n = read();  rep(i,1,n+1) a[i] = read();  // 质数 到最低两个幂次 和对应的数的下标  unordered_map&lt;int, vector&lt; pair&lt;int,int&gt; &gt; &gt; p2low2;  // 质数  rep(i,2, 1000000){    if(v2p[i])continue; // 合数    p2low2[i] = vector(2,make_pair(INF,-1));    for(ll j = i*i;j &lt;= 1000000;j+=i){      v2p[j] = i;    }  }  // 筛出至多14个数  rep(i,1,n+1) {    vector&lt;int&gt; rm;    for(auto &amp;item: p2low2){      auto &amp;[p,low2] = item;      low2.push_back({getpwr(a[i],p),i});      sort(all(low2));      low2.pop_back();      if(low2.back().first == 0 &amp;&amp; p2low2.size() &gt;= 7 + 1 + rm.size()){ // wa5, 0 幂次贡献也有作用        rm.push_back(p);      }    }    for(auto p:rm) p2low2.erase(p);  }  vector&lt;int&gt; pos;  for(auto &amp;[p,low2]:p2low2){    pos.push_back(low2[0].second);    pos.push_back(low2[1].second);  }  assert(pos.size() &lt;= 14);  // 排序去重  sort(all(pos));  pos.erase(unique(all(pos)),pos.end());  int cnt = 0;  // 公式输出  rep(bits,1,(1&lt;&lt;pos.size())){    // lcm{set} ^ ( (-1)^|set| (|set| - 2))    int t = __builtin_popcount(bits);    int pwr = (t%2?-1:1) * (t-2);    cnt += abs(pwr);  }  printf(&quot;%d\n&quot;,cnt);  rep(bits,1,(1&lt;&lt;pos.size())){    // lcm{set} ^ ( (-1)^|set| (|set| - 2))    int t = __builtin_popcount(bits);    int pwr = (t%2?-1:1) * (t-2);    if(!pwr) continue;    int op = pwr &lt; 0 ? 1 : 0;    pwr = abs(pwr);    while(pwr--){      printf(&quot;%d %d&quot;,op,t);      rep(i,0,pos.size()){        if(bits &amp; (1&lt;&lt;i)){          printf(&quot; %d&quot;, pos[i]);        }      }      printf(&quot;\n&quot;);    }  }  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>光是这个容斥公式, 我都得不出, 全靠手工算了个特例</p><p>知识点1, kmin/kmax 反演 有地一个公式</p><p>知识点2, 从gcd 集合, 推理到gcd2集合的元素个数上限和一种构造方案</p><p>gcd2(S) =&gt; gcd2(T) =&gt; kmin容斥</p><hr><p>思考角度从小量枚举和得到的线性公式是可以的,而主要缺乏相关反演知识,应该去补充</p><p>然后有感觉到可能被值的范围限制了运算, 但是没想到考虑从gcd 演变到gcd2</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://codeforces.com/blog/entry/103493" target="_blank" rel="noopener">官方</a></p><p><a href="https://www.luogu.com.cn/problem/solution/CF1687E" target="_blank" rel="noopener">luogu</a></p><p><a href="https://www.luogu.com.cn/blog/command-block/xuan-ku-fan-yan-mo-shu" target="_blank" rel="noopener">反演</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;评分3500,题是国内洛谷大佬出的, t神都炸了&lt;/p&gt;
&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contes
      
    
    </summary>
    
      <category term="Codeforces" scheme="http://yexiaorain.github.io/Blog/categories/Codeforces/"/>
    
    
      <category term="构造" scheme="http://yexiaorain.github.io/Blog/tags/%E6%9E%84%E9%80%A0/"/>
    
      <category term="数学" scheme="http://yexiaorain.github.io/Blog/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="min-max容斥" scheme="http://yexiaorain.github.io/Blog/tags/min-max%E5%AE%B9%E6%96%A5/"/>
    
      <category term="kmin/kmax容斥" scheme="http://yexiaorain.github.io/Blog/tags/kmin-kmax%E5%AE%B9%E6%96%A5/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 1687D(数学,跳点)</title>
    <link href="http://yexiaorain.github.io/Blog/2022-06-05-CF1687D/"/>
    <id>http://yexiaorain.github.io/Blog/2022-06-05-CF1687D/</id>
    <published>2022-06-05T14:24:00.000Z</published>
    <updated>2022-07-07T17:16:42.310Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://codeforces.com/contest/1687/problem/D" target="_blank" rel="noopener">https://codeforces.com/contest/1687/problem/D</a></p><p>f(x) =比x小最大平方数</p><p>g(x) =比x大最小平方数</p><p>如果 x - g(x) &lt; f(x) - x 那么x是好的</p><p>给长度n的单调数组a, 求最小非负k,使得 ai+k 全为好的</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>n 1e6</p><p>ai 2d6</p><p>2s</p><p>256MB</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>先做点数学变形</p><p>易知, 如果 $x \in [w^2,w^2+w]$ 那么x是好的</p><p>然后 真不会了</p><h2 id="官方"><a href="#官方" class="headerlink" title="官方"></a>官方</h2><p>显然 $k \le a_n^2$, 因为 $[a_n^2,a_n^2+a_n]$ 的长度都是 $a_n$ 一定能放下所有数</p><p>有$w \le a_n$</p><p>令$f(x) = w$</p><p>枚举$f(a_1 + k) le a_n$ 得到$le a_n$个区间</p><p>然后枚举 $f(a_i + k)$ 的所有区间</p><p>伪代码</p><pre><code>for w = sqrt(a_1)...: //枚举根号后的结果  krange = [...]  for i = 2..n:    krange = krange 交 calc(krange, a_i) // 注意到 合法与不合法的间隔单调递增, 所以 交完后还是连续区间  if len(krange) == 0:      break  if len(krange) &gt; 0:    return krange.start</code></pre><p>这样 n个 和$a_n$ 个区间, 复杂度$O(n a_n)$</p><p>实际上 你需要考虑的是$f(a_i+k) \neq f(a_{i-1} + k)$, </p><p>也就是 这里的 对于给定的 $f(a_1+k) = w$</p><p>那么 相邻的f不等的情况只有w 种, 所以你考虑 不等的时候, 不等的前一个 和 后一个 都会对区间更新有影响</p><p>但是中间的, 因为是连续的范围,所以不会有额外影响</p><p>所以 $O(\sum{\frac{a_n}{w}})$ 期望 是 $a_n log (a_n)$,</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://codeforces.com/contest/1687/submission/159707568" target="_blank" rel="noopener">https://codeforces.com/contest/1687/submission/159707568</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readint n;ll a[1000010]; // 有序 ai &lt; 2e6ll mysqrt(ll v){  ll l = 1;  ll r = v;  while(l != r){    ll mid = (l+r)/2;    // 先控范围防止 overflow    if( v/mid &lt; mid ){      r = mid - 1;    }else if( mid * mid &lt;= v &amp;&amp; (mid+1)*(mid+1) &gt; v){      return mid;    }else if( (mid+1) * (mid+1) &lt;= v){      l = mid + 1;    }else {      r = mid - 1;    }  }  return l;}//  [l...r]bool calc(ll w,ll &amp;l,ll &amp;r){  // printf(&quot;calc %lld [%lld %lld] [%lld %lld]\n&quot;,w,w*w,w*(w+1),l,r);  while(true){    // [w^2,w^2+w, 因为长度单增,不可能和 [(w+1)**2 有交集    // 找同为w的最大的 w^2 &lt;= a[idx-1] + kmin &lt;= w^2 + w, a[idx-1] &lt;= w(w+1) - kmin    int idx = lower_bound(a,a+n,w*(w+1)-l+1) - a;    // 首个 ?    ll v = a[idx-1];    r = min(r,w*(w+1) - v);    // printf(&quot;lower_bound a[%d]:%lld =&gt; [%lld %lld]\n&quot;,idx-1,a[idx-1],l,r);    if(l &gt; r) return false;    if(idx == n)return true; // 最后一个    w = mysqrt(a[idx]+r); // 下一个位置的    ll nl = w*w - a[idx];    ll nr = w*(w+1) - a[idx];    l = max(l,nl);    r = min(r,nr);    // printf(&quot;next %lld =&gt; [%lld %lld]\n&quot;,a[idx],l,r);    if(l &gt; r) return false;  }  assert(false);  return true;}int main(){  n = read();  rep(i,0,n) a[i] = read();  rep(w,mysqrt(a[0]),a[n-1]+1){    ll l = max(w*w - a[0],(ll)0);    ll r = w*(w+1) -a[0];    // printf(&quot;\t rep %lld [%lld %lld] [%lld %lld]\n&quot;,w,w*w,w*(w+1),l,r);    if(r &lt; l) continue;    if(calc(w,l,r)){      printf(&quot;%lld\n&quot;,l);      return 0;    }  }  assert(false);  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过枚举w来, 让a的是多个连续的一段,且只有区间端点有影响, 这样, 通过枚举的初始值 让总枚举量为接近自然数分之一的级数 表达,而在有限范围时 , 区域log级别</p><p>完全没想到是通过 w来划分的, 也就是还是有点按结果划分,又不是二分的划分形式</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://codeforces.com/blog/entry/103493" target="_blank" rel="noopener">官方</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1687/problem/D&quot; target=&quot;_blank
      
    
    </summary>
    
      <category term="Codeforces" scheme="http://yexiaorain.github.io/Blog/categories/Codeforces/"/>
    
    
      <category term="数学" scheme="http://yexiaorain.github.io/Blog/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="跳点" scheme="http://yexiaorain.github.io/Blog/tags/%E8%B7%B3%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 1691F(贡献统计,组合数,树)</title>
    <link href="http://yexiaorain.github.io/Blog/2022-06-04-CF1691F/"/>
    <id>http://yexiaorain.github.io/Blog/2022-06-04-CF1691F/</id>
    <published>2022-06-04T14:24:00.000Z</published>
    <updated>2022-07-07T17:16:42.310Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://codeforces.com/contest/1691/problem/F" target="_blank" rel="noopener">https://codeforces.com/contest/1691/problem/F</a></p><p>树,n个点,点上1~n</p><p>给定k</p><p>对于点r, 树的一个k个点的子点集S, 令f(r,S) = 根为r, 且包含所有S中点的原树的子树最少的点的个数</p><p>你需要计算 所有 r和S的组合 求 所有f(r,S)的和</p><p>答案mod 1e9+7</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>n 2e5</p><p>3s</p><p>512MB</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>看数据范围n方都不行, 既然又是求和</p><p>那么估计又是算贡献一类</p><p>从树的结构讲, 与其算贡献不如算不被贡献</p><p>一个点u,连接了很多点v0,v1,v2,v3</p><p>如果要u不被贡献, 那么r和S的所有点一定在某个vi的联通块内,不会是不同vi的联通块内</p><p>而选择来讲, 对于S, 就是C(联通块大小,k), 对于r就是联通块大小</p><p>注意联通块 &lt; k时 方案为0</p><hr><p>感觉就过了???不想写代码</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>鸽</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>感觉给时间, 就这样随便搞一搞就完了?</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>无</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1691/problem/F&quot; target=&quot;_blank
      
    
    </summary>
    
      <category term="Codeforces" scheme="http://yexiaorain.github.io/Blog/categories/Codeforces/"/>
    
    
      <category term="树" scheme="http://yexiaorain.github.io/Blog/tags/%E6%A0%91/"/>
    
      <category term="组合数" scheme="http://yexiaorain.github.io/Blog/tags/%E7%BB%84%E5%90%88%E6%95%B0/"/>
    
      <category term="贡献统计" scheme="http://yexiaorain.github.io/Blog/tags/%E8%B4%A1%E7%8C%AE%E7%BB%9F%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Pollard-Rho 质数拆分</title>
    <link href="http://yexiaorain.github.io/Blog/2022-06-03-pollard-rho/"/>
    <id>http://yexiaorain.github.io/Blog/2022-06-03-pollard-rho/</id>
    <published>2022-06-03T02:37:14.000Z</published>
    <updated>2022-07-07T17:16:42.310Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h1><p>在之前做Project Euler 216 的时候</p><p>学了一下 如何利用别人的答案,在log n时间内判断n是否是一个 64位以内的质数的 Miller-Rabin 判别法</p><p>但如果这个数不是质数, 如何能拆解还没有解决</p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h2><p>回到最初的起点, for一遍 那也是$\sqrt(n)$</p><p>而众所周知, $\sqrt {2^{64}} = 2^{32} = $ 4.2e9</p><p>单独算一次的时间复杂度都接受不了</p><h2 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h2><p>相信随机的力量, 先特判是否质数</p><p>在不停的随一个判断是否<code>gcd != 1</code> 来找因数</p><hr><p>问题是, 生日悖论(一个房间里有23个人，则他们中有两人生日相同的概率超过一半)</p><p>换句话说, 反复生成随机数,有很高几率生成了不少一样的</p><h2 id="Pollard-的伪随机数"><a href="#Pollard-的伪随机数" class="headerlink" title="Pollard 的伪随机数"></a>Pollard 的伪随机数</h2><p>问题变成 我们希望它概率上看起来随机,值上有不重复得不那么随机</p><p>$x_{n+1} = f(x_n) = (x_n^2 + c) mod N$</p><p>但也不一定如期望, 例如 x = 0, c= 24,N = 9400, 很有规律, 因为这个递推式说白了就是下一项由上一项决定,肯定有循环,只是循环的早晚</p><p>低空间,低时间判断环? 那不是经典面试题双指针吗?(floyd判环算法)</p><p>初始$x_1 = y_1$</p><p>$x_{n+1} = f(x_n)$</p><p>$y_{n+1} = f(f(y_n))$</p><p>每次判断$gcd(|x_n - y_n|,N) &gt; 1$, 和是否到达环, 成环则换一个c来跑</p><hr><p>性质 |i-j| 是p的倍数,则 |f(i)-f(j)| 也是p的倍数</p><p>如果看作环上指针, 也就意味这两个指针距离相等时,其它距离和这个距离相等的两个指针之差,都是p的倍数,</p><p>而快慢指针每次会让距离+1, 而对于环上的视角, 其实追上慢指针相当于逐渐减少</p><h2 id="实现和细节"><a href="#实现和细节" class="headerlink" title="实现和细节"></a>实现和细节</h2><p>据说$O(n^{\frac{1}{4}}\log n)$</p><p>$N = 4,N = 1$ 需要特判</p><p>素数平方提前判断</p><p>让x=0</p><pre><code class="cpp">ll Pollard_Rho(ll N) {  assert(N!=1);  if (N == 4) return 2;  if (is_prime(N)) return N;  if (is_prime_square(N)) return prime_square(N);  while(true) {    ll c = randint(1, N - 1); // 生成随机的c    auto f = [=](ll x) { return ((lll)x * x + c) % N; }; // lll表示__int128，防溢出    ll t = 0, r = 0;    do{      t = f(t);      r = f(f(r));      ll d = gcd(abs(t - r), N);      if (d &gt; 1) return d;    }while (t != r)  }}</code></pre><h2 id="固定128距离"><a href="#固定128距离" class="headerlink" title="固定128距离"></a>固定128距离</h2><p>减少求gcd的次数, 128次 或者 即将乘起来是N的倍数</p><p>大概是$O(n^{\frac{1}{4}})$</p><pre><code class="cpp">ll Pollard_Rho(ll N) {  assert(N!=1);  if (N == 4) return 2;  if (is_prime(N)) return N;  if (is_prime_square(N)) return prime_square(N);  while(true){    ll c = randint(1, N - 1);    auto f = [=](ll x) { return ((lll)x * x + c) % N; };    ll t = 0, r = 0, p = 1, q;    do {      for (int i = 0; i &lt; 128; ++i) { // 令固定距离C=128        t = f(t), r = f(f(r));        if (t == r || (q = (lll)p * abs(t - r) % N) == 0) break; // 如果发现环，或者积即将为0，退出        p = q;      }      ll d = gcd(p, N);      if (d &gt; 1) return d;    } while (t != r);  }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前情提要&quot;&gt;&lt;a href=&quot;#前情提要&quot; class=&quot;headerlink&quot; title=&quot;前情提要&quot;&gt;&lt;/a&gt;前情提要&lt;/h1&gt;&lt;p&gt;在之前做Project Euler 216 的时候&lt;/p&gt;
&lt;p&gt;学了一下 如何利用别人的答案,在log n时间内判断n是否
      
    
    </summary>
    
      <category term="Math" scheme="http://yexiaorain.github.io/Blog/categories/Math/"/>
    
    
      <category term="math" scheme="http://yexiaorain.github.io/Blog/tags/math/"/>
    
      <category term="prime" scheme="http://yexiaorain.github.io/Blog/tags/prime/"/>
    
  </entry>
  
  <entry>
    <title>Atcoder arc141 C D E</title>
    <link href="http://yexiaorain.github.io/Blog/2022-06-02-ac_arc141/"/>
    <id>http://yexiaorain.github.io/Blog/2022-06-02-ac_arc141/</id>
    <published>2022-06-01T20:25:14.000Z</published>
    <updated>2022-07-07T17:16:42.310Z</updated>
    
    <content type="html"><![CDATA[<p>C(math, 括号对)D(math,集合,数论,动归)E(并查集)</p><h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://atcoder.jp/contests/arc141/tasks/arc141_c" target="_blank" rel="noopener">https://atcoder.jp/contests/arc141/tasks/arc141_c</a></p><p>他给两个排列p和q, 长度2n</p><p>构造 长2n的括号字符串,含有n个左括号,n个右括号</p><p>使得p是所有 让 s[p[i]] 为合法括号序列中的字典序最小的</p><p>同时q是所有 让 s[q[i]] 为合法括号序列中的字典序最大的</p><h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h3><p>n&lt;=2e5</p><p>2s</p><p>1024mb</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h3><p>显然开始和最后的位置分别是 左右括号</p><p>对于p, 当左右括号都可以选时,一定会选没有被选坐标最小的</p><p>当前缀完成匹配时, 只能选左括号, 这时选左括号坐标最小的</p><p>于是, 如果当前坐标以前的没有选完,那么说明当前位置是左括号,且没有被选的是右括号</p><p>对于q,类似的, 先选最大的, 左括号也是先选最大的</p><p>这样分别确定的右括号不少于 左括号个数</p><hr><p>但是对于剩余没有填的位置怎么做,我没有思路了,因为它不只需要保证一个排列合法,它需要保证p和q都合法</p><h3 id="官方"><a href="#官方" class="headerlink" title="官方"></a>官方</h3><p>前面还是一样的, 但这里强调了是 奇数处出现, 因为 要前面匹配完,说明前面用了偶数个</p><p>而且不像我那样 需要 前缀未填完, 而只是 奇小于下一个偶, P[2i-1] &lt; P[2i]</p><p>但说是 如果还是有多个候选的,那么就是没有方案</p><p>如果只有一个候选S,就看是否同时满足p和q</p><p>简单的来讲如果S或它的逆序是一个合法的括号序列, (一般情况也可以类似证明, 因为一般的S 可以表示成合法和 和 逆序合法的连接</p><p>令 L1 &lt; L2 &lt; L3 … &lt; LN 分别是左括号的下标</p><p>R1 &lt; R2 &lt; R3 … &lt; RN 分别是右括号的下标</p><p>既然S是合法的,那么有 Li &lt; Ri</p><p>因此字典序最大的排列是$L_N,R_N,L_{N-1},R_{N-1},…,L_1,R_1$</p><p>因此 S是唯一的</p><p>并且确定的过程和上述描述的也是一致的</p><hr><p>如果S的逆序是合法的</p><p>那么有</p><p>令 L1 &lt; L2 &lt; L3 … &lt; LN 分别是左括号的下标</p><p>R1 &lt; R2 &lt; R3 … &lt; RN 分别是右括号的下标</p><p>既然S的逆序列是合法的,那么有 Li &gt; Ri</p><p>所以字典序最小的是$L_1,R_1,L_2,R_2,…,L_N,R_N$</p><p>并且确定的过程和上述描述的也是一致的</p><hr><p>再对于一般序列来讲</p><p>又回到 括号序列的常用技巧,左括号+1,右括号-1</p><p>那么其实就是 一些在正平面的一些曲线和负平面的一些曲线,</p><p>显然由和0点隔开的 顺序上也相互独立(见官方youtube上画的图</p><p>这样 对于每一段来说,是正平面则由最大序列唯一确定, 是负平面则由最小序列</p><p>所以 整体都是唯一的</p><p>这样就是官方提接说的一般序列的 拼接类似</p><p>综上得证</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/arc141/submissions/32155305" target="_blank" rel="noopener">https://atcoder.jp/contests/arc141/submissions/32155305</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;(int)n;i++)int read(){int r;scanf(&quot;%d&quot;,&amp;r);return r;} // readint p[400010];int q[400010];char s[400010];char sets(int i,char ch){  return (s[i] &amp;&amp; s[i] != ch) ? 0 : (s[i] = ch);}bool work(){  int n = read() * 2; // 2e5 * 2  rep(i,0,n) p[i] = read() - 1;  rep(i,0,n) q[i] = read() - 1;  for(auto [arr, cmp]:vector&lt;pair&lt;int *,int&gt; &gt; {{p, 1},{q,-1}}){    rep(i,0,n-1) {      if((arr[i] - arr[i+1]) * cmp &lt;= 0) continue; // 出现反序列      if(!sets(arr[i],&#39;(&#39;) || !sets(arr[i+1],&#39;)&#39;)) return false;    }  }  rep(i,0,n) if(!s[i]) return false; // 不唯一  // check 可能一个合法 另一个不合法  for(auto [arr,st,d]:vector&lt;tuple&lt;int*,int,int&gt; &gt;{{p,0,1},{q,n-1,-1}}){    // 双指针    int i0 = st; // 找所有值    int i1 = st; // 只找左括号    int cnt = 0;    vector&lt;bool&gt; vis(n,false);    rep(i,0,n){      int pos ; // 选取的位置      if(cnt == 0){        while(vis[i1] || s[i1] != &#39;(&#39;) i1+=d;        pos = i1;      }else{ // cnt &gt; 0        while(vis[i0])i0+=d;        pos = i0;      }      if(arr[i] != pos) return false; // 和提供的不一致      vis[pos] = true;      cnt += s[pos] == &#39;(&#39;?1:-1;    }    if(cnt) return false;  }  printf(&quot;%s\n&quot;,s);  return true;}int main(){  if(!work()) printf(&quot;-1\n&quot;);  return 0;}</code></pre><h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p><a href="https://atcoder.jp/contests/arc141/tasks/arc141_d" target="_blank" rel="noopener">https://atcoder.jp/contests/arc141/tasks/arc141_d</a></p><p>对于一个集合S, 任意两个元素不成倍数关系,那么认为是一个好集合</p><p>给一个n个元素,元素值范围在[1,2m]之间的集合, 元素值不重复, 给值时从小到大</p><p>对于每个元素,判断是否存在一个S的子集,包含该元素且是好集合</p><h3 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h3><p>M&lt;=N&lt;2M</p><p>M 3e5</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><h3 id="我的想法"><a href="#我的想法" class="headerlink" title="我的想法"></a>我的想法</h3><p>既然给值就是从小到大, 那么省去了排序</p><p>既然一定要a[i], 那么它的倍数和约数一定不可行,而约数是log级别的个数,</p><p>这里虽然问是否能恰好m个, 但如果&gt;=m 合法,删掉多于m的依然合法</p><p>所以变成能否有不少于m个</p><p>对于即不是ai倍数,也不是ai约数的, 考虑最多能取多少个</p><p>于是集合被化分成(ai,ai约数,ai倍数) (其它), 那么包含ai的最大的个数是 1+max(其它)</p><hr><p>首先 值的倍数从均摊上讲 也是 log级别的, 因为 1/2+1/3+1/4… 在小的时候是 常数倍</p><p>但 剩下的如何尽可能多的取, 以及如果只是暴力去尝试的话, 显然 会达到至少 n平方</p><hr><p>另一个就是互斥关系,  如果建立互斥关系的2-sat图, 跑tarjan ,能一次计算</p><p>注意到互斥关系不会变, 所以2-sat不会变, 但是怎么选一个而不选其它</p><h3 id="官方-1"><a href="#官方-1" class="headerlink" title="官方"></a>官方</h3><p><strong>其实是个卡着边界的问题</strong></p><p>考虑所有奇数的2的幂次倍</p><p><code>(1,2,4,8,16...),(3,6,12,24...),(5,10,20...)</code></p><p>注意到的是 ,一共有m组,且每组内部两两是倍数关系, 因此我们选的答案,不会同时出现在一组中, 所以 至多选m个</p><hr><p>这个对答案也有帮助, 如果题目给的S, 在上述的2的幂次倍中 有的组不存在,那么显然达不到m</p><p>现在问题是跨组会不会有 倍数关系</p><p>假设 $x_1 &lt; x_2$ 都是奇数, 选了 $x_1 2^{p_1},x_22^{p_2}$</p><p>那么如果成倍数一定是 $p_2 \ge p_1$ 且 $x_2$是$x_1$的倍数</p><p>换句话说, 要想合法, 那么一个数的约数对应的2的幂次要比它本身大</p><hr><p>考虑 每个奇数的2的幂次的上下界, [Li,Ri]</p><p>直接动归转移方程</p><p>对于<code>R[value] = min(R[value 的因子]) - 1 且存在于S</code></p><p>对于<code>L[value] = max(L[value的倍数]) + 1 且存在于S</code></p><p><code>R1,R2,R3,...R,被选的值,L,...,L</code> 将是合法解, <code>[Li &lt;= 被选的幂次 &lt;= Ri]</code></p><p>因为前面的尽可能大,后面尽可能小且 被选值在范围中</p><hr><p>综上 因为因子数和均摊倍数个数都是log级别,所以总的均摊代价就是log级别</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/arc141/submissions/32169715" target="_blank" rel="noopener">https://atcoder.jp/contests/arc141/submissions/32169715</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readbool exist[600010];vector&lt;int&gt; ys[600010]; // 所有真奇数约数int L[600010];int R[600010];int a[600010];int n,m;bool w(){  n = read();  m = read()*2;  rep(i,0,n) {    exist[a[i] = read()] = 1;  }  rep(i,1,m/2+1){    if(i%2 == 0)continue;    rep(t,3,m/2+1){      if(t%2 == 0)continue;      if(i*t &gt; m)break;      ys[i*t].push_back(i);    }  }  // 先检查是否所有组都有  rep(i,1,m+1){    if(i%2==0)continue;    bool found = false;    int itr = i;    while(itr &lt;= m){      if(exist[itr]){        found = true;        break;      }      itr*=2;    }    if(!found)return false;  }  // 计算R  rep(i,1,m){    if(i%2 == 0) continue;    int pwr = 20;    // 计算它因数对它的限制    for(auto item:ys[i]){      pwr = min(pwr,R[item]-1);    }    // 找一个范围内且存在的    bool found = false;    while(pwr &gt;= 0){      if(i * (1&lt;&lt;pwr) &lt;= m){ // 小心 out bound        if(exist[i * (1&lt;&lt;pwr)]){          R[i] = pwr;          found = true;          break;        }      }      pwr--;    }    // printf(&quot;L %lld =&gt; %d\n&quot;,i,pwr);    if(!found) return false; // 不存在合法范围的值  }  // 计算L  per(i,1,m){    if(i%2 == 0) continue;    int pwr = 0;    // 计算它倍数对它的限制    rep(k,3,m+1){      if(k%2==0)continue;      if(i*k &gt; m)break;      pwr = max(pwr,L[i*k]+1);    }    // 找一个范围内且存在的    bool found = false;    while( i*(1&lt;&lt;pwr) &lt;= m){      if(exist[i * (1&lt;&lt;pwr)]){        L[i] = pwr;        found = true;        break;      }      pwr++;    }    if(!found) return false; // 不存在合法范围的值    if(L[i] &gt; R[i]) return false;  }  // 计算答案  rep(i,0,n){    int v = a[i];    int pwr = 0;    while(v%2 == 0){      pwr++;      v/=2;    }    printf(&quot;%s\n&quot;, L[v] &lt;= pwr &amp;&amp; pwr &lt;= R[v]?&quot;Yes&quot;:&quot;No&quot;);  }  return true;}int main(){  if(!w()) rep(i,0,n) printf(&quot;No\n&quot;);  return 0;}</code></pre><h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p><a href="https://atcoder.jp/contests/arc141/tasks/arc141_e" target="_blank" rel="noopener">https://atcoder.jp/contests/arc141/tasks/arc141_e</a></p><p>n方个点, <code>(1..n,1..n)</code></p><p>q 个询问</p><p>每个询问 a,b,c,d</p><p>会把 点((a+k)%n,(b+k)%n) 和 点((c+k)%n,(d+k)%n) 相连, 其中k取 0 到 n-1</p><p>询问之间是影响的, 是在上一次结果上继续连</p><p>每次回答一个询问操作后,剩下的联通块数</p><h3 id="范围-2"><a href="#范围-2" class="headerlink" title="范围"></a>范围</h3><p>n 2e5</p><p>q 2e5</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h3><p>首先, 其实让a,b,c,d 变成 a1=(a+n-a)%n,b1=(b+n-a)%n,c1=(c+n-a)%n,d1=(d+n-a)%n, 因为k取[0..n-1], 所以等价</p><p>变成 k,(b1+k)%n,(c1+k)%n,(d1+k)%n</p><p>画图, 会发现 (k,(b1+k)%n) 在一条45度角的一条斜线上,((c1+k)%n,(d1+k)%n) 也在一条45度角的一条斜线上</p><ol><li>如果共线, 那么 如果原来不是一个联通块,则 减少了 n-1个联通块, 如果原来是多个联通, 那么对结果影响 = -(个数-1)</li></ol><p>有了这个思路, 我们问题通过图像可以变一变</p><p>沿着+1,+1的45度, 形成n组点,每组点有个属性内部是否相连</p><p>考虑两组之间的关系, </p><p>1次连接, 那么这两组形成的是n个连通块, 且内部联通关系,一旦有一个联通则连通</p><p>而这个值其实 = gcd(偏移量间隔)</p><p>所以未连接和 连接一次的偏移量间隔为 n</p><p>而对两个组的影响是相同的</p><p>所以变成</p><p>哪些组属于一个并查集合, 它们自身内部的偏移量等价(一个值) 它们与根的偏移量等价</p><hr><p>似乎就可以做了</p><p>但感觉在合并并查集时更新需要注意</p><hr><p>然后 真的 我就AC了???? atcoder真的是数学场吗</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/arc141/submissions/32185372" target="_blank" rel="noopener">https://atcoder.jp/contests/arc141/submissions/32185372</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 1000000007#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readint gcd(int a,int b){  while(b!=0){    a=a%b;    swap(a,b);  }  return a;}int fa[200010];int a[4];int inner[200010]; // 组内部最小间隔, 一定是n的因子int tofa[200010]; // 跨组偏移距离ll n;int getfa(int i){  if(i == fa[i]) return i;  int newfa = getfa(fa[i]);  tofa[i] = ((tofa[i] + tofa[fa[i]])%n)%inner[newfa];  return fa[i] = newfa;}// new root u// u and v is old rootvoid link(int u,int v,int off){  fa[v] = u;  inner[u] = gcd(inner[u],inner[v]);  tofa[v] = off % inner[u];}int main(){  n = read();  ll q = read();  ll ans = n*n;  iota(fa,fa+n,0);  fill(inner,inner+n,n);  rep(i,0,q){    rep(j,0,4) a[j] = read();    per(j,0,4) (a[j] += n-a[0])%=n;    int g1 = a[1] - a[0];    int g2 = (a[3]-a[2]+n)%n;    int off = a[2] - a[0];    int f1 = getfa(g1);    int f2 = getfa(g2);    // 同组更新内部间隔    if(f1 == f2){      // ans -= inner[f1] - inner[f1];      // printf(&quot;SAME %d[%d] =&gt; &quot;,f1,inner[f1]);      ans -= inner[f1];      inner[f1] = gcd(inner[f1], 2*n + tofa[g1] - tofa[g2] + off); // 不是off      ans -= -inner[f1];      // printf(&quot;%d \n&quot;,inner[f1]);    }else{ // 不同组 合并组      // printf(&quot;DIFF %d[%d] + %d[%d] =&gt; &quot;,f1,inner[f1],f2,inner[f2]);      // g1-&gt;f1, g2-&gt;f2      // f2-&gt;f1?      // f1 - f2 = (f1 - g1) - (f2 - g2) + (g2 - g1)      // ans -= inner[f1] + inner[f2] - inner[f1];      ans -= inner[f1] + inner[f2];      link(f1,f2, (2*n + tofa[g1] - tofa[g2] + off)%n);      ans -=  - inner[f1];      // printf(&quot;%d \n&quot;,inner[f1]);    }    printf(&quot;%lld\n&quot;,ans);  }  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>C</p><p>这个基本的能想到, 但是没有尝试更多数据, 去考虑它的唯一性, 还在想怎么填中间的</p><p>这方面要培养,有点像反过来想题目, 如果题目本身设计上有唯一性只是需要证明, 这个思路方向, 因为毕竟是确定有答案的题目而不是开放性问题</p><p>另外就是括号序列还是不熟悉, 如果熟悉常见+1,-1套路,画图去思考也会简单不少</p><p>虽然从逻辑上 我的 当前前面未填完,则当前(,未填都是),  数学上好像 更多信息, 但这里反而成了干扰</p><p>据说能用DP做?</p><p>D</p><p>这数学性好强啊, 知识点是属于集合论的和数论的,甚至有点抽屉原理,</p><p>能想到奇数与它的2的幂次倍数的分组是这个题的核心一点</p><p>这一想出后面就自然很多了</p><p>E</p><p>我这赛后没有看题解,竟然AC了 ??????</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>官方题解 <a href="https://atcoder.jp/contests/arc141/editorial/" target="_blank" rel="noopener">https://atcoder.jp/contests/arc141/editorial/</a></p><p><a href="https://www.youtube.com/watch?v=_oUQyyjp4Wk" target="_blank" rel="noopener">官方youtube</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;C(math, 括号对)D(math,集合,数论,动归)E(并查集)&lt;/p&gt;
&lt;h1 id=&quot;C&quot;&gt;&lt;a href=&quot;#C&quot; class=&quot;headerlink&quot; title=&quot;C&quot;&gt;&lt;/a&gt;C&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;he
      
    
    </summary>
    
      <category term="Atcoder" scheme="http://yexiaorain.github.io/Blog/categories/Atcoder/"/>
    
    
      <category term="math" scheme="http://yexiaorain.github.io/Blog/tags/math/"/>
    
      <category term="并查集" scheme="http://yexiaorain.github.io/Blog/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="动归" scheme="http://yexiaorain.github.io/Blog/tags/%E5%8A%A8%E5%BD%92/"/>
    
      <category term="括号对" scheme="http://yexiaorain.github.io/Blog/tags/%E6%8B%AC%E5%8F%B7%E5%AF%B9/"/>
    
      <category term="集合" scheme="http://yexiaorain.github.io/Blog/tags/%E9%9B%86%E5%90%88/"/>
    
      <category term="数论" scheme="http://yexiaorain.github.io/Blog/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 1685 C D1</title>
    <link href="http://yexiaorain.github.io/Blog/2022-06-01-CF1685_C_D1/"/>
    <id>http://yexiaorain.github.io/Blog/2022-06-01-CF1685_C_D1/</id>
    <published>2022-05-31T19:24:00.000Z</published>
    <updated>2022-07-07T17:16:42.310Z</updated>
    
    <content type="html"><![CDATA[<p>C(括号对,前缀和,数学)D1(构造,排列,并查集)</p><h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://codeforces.com/contest/1685/problem/C" target="_blank" rel="noopener">https://codeforces.com/contest/1685/problem/C</a></p><p>给你一个 n个左括号 n个右括号 的序列</p><p>最小次数, 翻转子区间,让整个括号合法</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>n 1e5</p><p>1s</p><p>256MB</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h3><p>括号嘛, 认知还在任意前缀1的个数大于等于0的个数</p><p>想的是先转换成0/1,两个指针包裹 两头贪心</p><p>没了, 没思路了, 感觉贪心都不对的</p><p>写了果然wa了</p><h3 id="官方"><a href="#官方" class="headerlink" title="官方"></a>官方</h3><p>别统计1和0, 直接 左括号1贡献,右括号-1贡献 XD</p><p>同样的也就是前缀和 大于等于0</p><p>一个数学结论, 至多两次就能让结果合法</p><p>如果 前缀i是 所有前缀中最大的,那么翻转 <code>[1..i]</code>和<code>[i+1,2n]</code> </p><p>因为 对于 j&lt;=i,新的前缀 newpre[j] = pre[i] - pre[j] &gt;= 0</p><p>因为 对于 j&gt; i,新的前缀 newpre[j] = pre[2n] - pre[j] + pre[i] = pre[i] - pre[j] &gt;= 0</p><hr><p>那么问题变成有没有办法一次翻转, 因为0次是直接合法,很容易判断,2次有上述方案</p><p>对于一次反转, 如果是<code>[L,R]</code>, 那么必然有 <code>L &lt;= 首个负前缀l, R&gt;= 最后一个负前缀r</code></p><p>再数学一点 对于 $i \in [L,R] $, <code>newpre = pre[R] - pre[i-1] + pre[L] &gt;= 0</code></p><p><code>pre[i-1] &lt;= pre[L] + pre[R]</code> 也就是 区间里所有的都不大于两头的和</p><p>而<code>pre[i]</code> 的可选值是 <code>[L..l-1][l..r][r+1..R]</code></p><p>注意到<code>[l..r]</code> 始终被选, 而两头的随着<code>L</code>和<code>R</code>变化</p><p>如果<code>L</code>选<code>[0..l-1]</code>中最大</p><p>如果<code>R</code>选<code>[r+1..2n]</code>中最大</p><p>那么对于两头的来说, 一定成立,而对<code>[l..r]</code> 来说 它们是能选到的最大的,如果这个还不满足,则没有办法了</p><p>如果这个满足则是答案</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://codeforces.com/contest/1685/submission/159099077" target="_blank" rel="noopener">https://codeforces.com/contest/1685/submission/159099077</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 1000000007#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // read// n对括号// reverse substringchar s[200010];int n;int pre[200010];void calc(int st){  int last = -1;  per(i,0,n){    if(pre[i+1] &lt; 0){      last = i;      break;    }  }  // printf(&quot;[%d %d]\n&quot;,st,last);  int ml = 0;  int mr = 0;  rep(i,0,st){    ml = max(ml,pre[i+1]);  }  rep(i,last,n){    mr = max(mr,pre[i+1]);  }  rep(i,st,last+1){    if(pre[i+1] &gt; ml+mr){      // rev2      printf(&quot;2\n&quot;);      int maxi = 0;      rep(i,0,n){        if(pre[i+1] &gt; pre[maxi]){          maxi = i+1;        }      }      printf(&quot;1 %d\n&quot;,maxi);      printf(&quot;%d %d\n&quot;,maxi+1,n);      return ;    }  }  printf(&quot;1\n&quot;);  int maxl = 0;  rep(i,0,st){    if(pre[i+1] &gt; pre[maxl]) maxl = i+1;  }  int maxr = n-1;  rep(i,last,n){    if(pre[i+1] &gt; pre[maxr]) maxr = i+1;  }  printf(&quot;%d %d\n&quot;,maxl+1,maxr);}void w(){  n = read();  n*=2;  scanf(&quot;%s&quot;,s);  rep(i,0,n) pre[i+1] = pre[i] + (s[i] ==&#39;(&#39;?1:-1);  rep(i,0,n){    if(pre[i+1] &lt; 0){      calc(i);      return ;    }  }  printf(&quot;0\n&quot;);}int main(){  int t = read();  while(t--)w();  return 0;}</code></pre><h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p><a href="https://codeforces.com/contest/1685/problem/D1" target="_blank" rel="noopener">https://codeforces.com/contest/1685/problem/D1</a></p><p><a href="https://codeforces.com/contest/1685/problem/D2" target="_blank" rel="noopener">https://codeforces.com/contest/1685/problem/D2</a></p><p>给一个1到n的排列p</p><p>定义一个排列p的代价为</p><p>$\sum {q_i - p_{q_{i+1}}}$</p><p>找最小代价的排列q</p><p>D2: Hard version: 最小代价排列中字典序最小的</p><h2 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h2><p>t 100 组测试</p><p>n 200, $\sum{n} \le 400$</p><p>1s</p><p>256mb</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h3><p>注意到上面的求和表达式,也就是每一项和它的后一项的差的绝对值,</p><p>那么如果一个排列q合法,那么 对它循环的旋转也合法</p><p>再来看期望最小值, 如果能够成 |1-1|+..+|v-v| ,全部是相同相减, 那么最小就是0, 而这种需要所有的跳转关系构成一个大环, 而这样解法也就唯一(对于循环的最小来说)</p><p>以样例中的2 1, =&gt; |1 - (P2=1)| + |2 - (P1=2)| = 0</p><p>对于不够成大环的, 必定跳转关系是多个小环</p><p>以样例中的2 3 1 4, 这样 是 1-&gt;3-&gt;2 构成环 ,4 单独一个环, 那么如果让环内代价为0, 那剩下的就是两头的链接代价, </p><p>|1 - (P3=1)| + |3 - (P2=3)| + |2 - (P4=4)| + |4 - (P1=2)| = 2+2</p><p>|3 - (P2=3)| + |2 - (P1=2)| + |1 - (P4=4)| + |4 - (P3=1)| = 3+3</p><p>|2 - (P1=2)| + |1 - (P3=1)| + |3 - (P4=4)| + |4 - (P2=3)| = 1+1</p><p>其实是环中选出一个值 和 其它环作拼接, (这里保证环内最小 不知道细节怎么证,但感觉看起来这样贪没啥问题</p><p>再比如样例 5 4 3 2 1, 环分别是 1-&gt;5, 2-&gt;4, 3</p><p>分别拿出来1,2,3</p><p>(5-&gt;1) (3) (4-&gt;2)</p><p>代价就是 |1-3| + |3-2| + |2-1|</p><p>这里也很清晰的是, 这样如果确定了拿出来的值,那么最小代价 = 2|max - min|</p><hr><p>综上所述</p><ol><li><p>找环</p></li><li><p>每个环拿出一个值来连接, 让所有拿出来的值 最大减最小尽量小, 这样D1 做完了</p></li><li><p>需要在这样的方法中, 1. 正负顺序, 2, 循环平移到1开始 的字典序列最小</p></li></ol><hr><p>问题来了</p><p>找环很简单, 但是如何让每个环拿出来一个值,差尽量小?</p><p>这里我想到的是染色+滑动窗口, 记录最小的滑动窗口和位置</p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 1000000007#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readint p[210];int p2i[210];int c[210]; // 染色void w(){  int n = read();  fill(c+1,c+n+1,-1);  rep(i,1,n+1) {    p[i] = read();    p2i[p[i]] = i;  }  int color = 0;  rep(i,1,n+1) {    if(~c[i])continue;    int itr = i;    do{      c[itr] = color;      itr = p2i[itr];    }while(itr != i);    color++;  }  // 单个环唯一  if(color == 1){    int itr = 1;    do{      printf(&quot;%d &quot;,itr);      itr = p2i[itr];    }while(itr != 1);    printf(&quot;\n&quot;);    return ;  }  vector&lt;int&gt;cnt(color,0); // 当前滑窗各种颜色个数  // 答案 起始位置  int ansst = 0;  int anssz = n+1;  // 滑窗  int l = 1;  int r = 0;  int cur = 0; // 滑窗内颜色种数  while(cur &lt; color &amp;&amp; r+1 &lt; n+1) if(++cnt[c[++r]] == 1) cur ++;  // [l..r] 包含所有颜色  while(l &lt;= r){    if( r-l+1 &lt;= anssz){      anssz = r-l+1;      ansst = l;      // printf(&quot;[%d %d]\n&quot;,l,r);    }    if( -- cnt[c[l++]] == 0 ) cur--;    while(cur &lt; color &amp;&amp; r+1 &lt; n+1){      ++r;      cnt[c[r]] ++;      if(cnt[c[r]] == 1) cur ++;    }    if(cur &lt; color)break;  }  // [ansst..ansst+anssz-1]  fill(c+1,c+n+1,-1);  rep(i,ansst,ansst+anssz - 1 + 1){    if(~c[i])continue;    int itr = i;    do{      printf(&quot;%d &quot;,p2i[itr]);      c[itr] = 1;      itr = p2i[itr];    }while(itr != i);  }  printf(&quot;\n&quot;);}int main(){  int t = read();  while(t--)w();  return 0;}</code></pre><p>然而实现以后wa2的第11个样例了</p><pre><code>41 3 2 4</code></pre><p>如果按照我上面所说的, (2,3) (1) (4) 这样的三个环, 那么 最大最小差是|4-1| = 3, 所以答案是6</p><p>然而, 给了一个拆掉环还更小的方法</p><p>q = <code>1 3 4 2</code></p><p><code>|1 - P3| + |3 - P4| + |4 - P2| + |2 - P1| = |1 - 2| + |3 - 4| + |4 - 3| + |2 - 1| = 4</code></p><p>emmmmmmm</p><p>所以我的思路的细节并卜行</p><h3 id="官方-D1"><a href="#官方-D1" class="headerlink" title="官方 D1"></a>官方 D1</h3><p>也是先考虑什么时候可以得到零</p><p>也是按照 跳转构成的环 来看, 假设有k个环</p><p>跨环 的链接 至少是1, 所以下界是 2(k-1)</p><hr><p>给出一种构造方法</p><p>初始化 p1 = p</p><p>for x = 1..n-1 如果 对当前p1 来说 x和 x+1在不同的环中, 则交换他们</p><p>显然根据学过的 排列的环的性质来讲, 每次交换两个环里的值 相当于把两个环合并</p><p>那么 也就是k-1次操作就可以全部合并成一个环</p><hr><p>最后 $q_i = p1_{q_{i+1}}$ 了, 显然这就是一个环, 这个答案对于p1来说,就是0</p><p>但我们求的是对于p</p><p>$|q_i - p1_{q_{i+1}}| = |p1_{q_{i+1}} - p_{q_{i+1}}|$ 了, 反过来看操作毕竟交换是对称的, 考虑从p1变到p, 每一次交换至多会让结果+2, 因为交换的是两个相邻的值, 所以 答案不大于2(k-1)</p><p>综上 从下界看 不小于2(k-1),  从操作上看不大于2(k-1), 所以这个方案就是2(k-1)</p><hr><p>至此 并查集随便搞一搞 D1 就做了</p><p>D2 现场只有4个人AC了 XD</p><p>pi向i连一条有向边</p><p>问题变成, 添加一些 i-&gt;i-1 和  i-1 -&gt; i 变成 存在欧拉回路</p><p>其实和上面 等价的, 这里的环和上面的边对应, 而成欧拉回路, 就是和变成新的环</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><h3 id="D1"><a href="#D1" class="headerlink" title="D1"></a>D1</h3><p><a href="https://codeforces.com/contest/1685/submission/159201728" target="_blank" rel="noopener">https://codeforces.com/contest/1685/submission/159201728</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 1000000007#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readint p[210];int p2i[210];int vis[210]; // 染色int fa[210];int getfa(int i){ return i==fa[i]?i:(fa[i] = getfa(fa[i]));}void link(int u,int v){  int fu = getfa(u);  int fv = getfa(v);  if(fu == fv)return;  fa[fu] = fv;}void w(){  int n = read();  fill(vis+1,vis+n+1,false);  iota(fa,fa+n+1,0);  rep(i,1,n+1) {    p[i] = read();    p2i[p[i]] = i;  }  rep(i,1,n+1){    if(vis[i])continue;    int itr = i;    do{      vis[itr] = true;      link(itr,i);      itr = p2i[itr];    }while(itr != i);  }  rep(v,1,n){    if(getfa(v) == getfa(v+1))continue;    swap(p[p2i[v]],p[p2i[v+1]]);    swap(p2i[v],p2i[v+1]);    link(v,v+1);  }  int itr = 1;  do{    printf(&quot;%d &quot;,itr);    itr = p2i[itr];  }while(itr != 1);  printf(&quot;\n&quot;);}int main(){  int t = read();  while(t--)w();  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>C</p><p>括号匹配还是不熟, 1,-1贡献 比1和0统计好很多</p><p>这最大值翻转只需要两次也是妙啊</p><p>后面的切割和最值</p><p>完全就是math,math,math</p><p>D1</p><p>想到环 和 环之间是好的</p><p>但是我构造能力实在是太菜了</p><p>而且下界估计想法也有问题,错误的下界估计也会影响思路</p><p>感觉这个题还是属于排列的环相关的知识点</p><p>然后有上下界相等, 和操作与逆向操作对结果的影响</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://codeforces.com/blog/entry/103198" target="_blank" rel="noopener">官方</a></p><p><a href="https://www.cnblogs.com/QQQ0000/p/16321569.html" target="_blank" rel="noopener">https://www.cnblogs.com/QQQ0000/p/16321569.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;C(括号对,前缀和,数学)D1(构造,排列,并查集)&lt;/p&gt;
&lt;h1 id=&quot;C&quot;&gt;&lt;a href=&quot;#C&quot; class=&quot;headerlink&quot; title=&quot;C&quot;&gt;&lt;/a&gt;C&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="Codeforces" scheme="http://yexiaorain.github.io/Blog/categories/Codeforces/"/>
    
    
      <category term="并查集" scheme="http://yexiaorain.github.io/Blog/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="前缀和" scheme="http://yexiaorain.github.io/Blog/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
      <category term="构造" scheme="http://yexiaorain.github.io/Blog/tags/%E6%9E%84%E9%80%A0/"/>
    
      <category term="数学" scheme="http://yexiaorain.github.io/Blog/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="排列" scheme="http://yexiaorain.github.io/Blog/tags/%E6%8E%92%E5%88%97/"/>
    
      <category term="括号对" scheme="http://yexiaorain.github.io/Blog/tags/%E6%8B%AC%E5%8F%B7%E5%AF%B9/"/>
    
  </entry>
  
</feed>
