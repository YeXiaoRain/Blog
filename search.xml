<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Atcoder abc230</title>
      <link href="/Blog/2022-09-01-ac-abc230/"/>
      <url>/Blog/2022-09-01-ac-abc230/</url>
      
        <content type="html"><![CDATA[<p>G(Möbius函数)H()</p><p><a href="https://atcoder.jp/contests/abc230/tasks" target="_blank" rel="noopener">https://atcoder.jp/contests/abc230/tasks</a></p><h1 id="G-GCD-Permutation"><a href="#G-GCD-Permutation" class="headerlink" title="G - GCD Permutation"></a>G - GCD Permutation</h1><p>给一个1~N的排列p</p><p>问有多少个有序对 (i,j), (i&lt;=j), 满足 gcd(i,j) != 1, gcd(p[i],p[j]) != 1</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>n 2e5</p><p>5s</p><p>1024mb</p><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>有点想暴力 然后证明复杂度?</p><p>对于 (i,Pi), 取两个中较小的一个, 找所有包含它下标的, 用较大的去验证gcd</p><p>最多有6个不同质数因子, 最坏情况 1/2+1/3+1/5+1/7+1/11+1/13 = 1.3左右</p><p>所以最坏情况是 找n个坐标</p><p>先写个代码再说</p><p><a href="https://atcoder.jp/contests/abc230/submissions/34500571" target="_blank" rel="noopener">https://atcoder.jp/contests/abc230/submissions/34500571</a></p><hr><p>显然 有很多是2 的倍数的,它们如果每个都会去访问n/2, 那么已经就是n^2了, 肯定会超时</p><hr><p>想法就是 如果 (2的倍数,3的倍数) 之类做容斥? 但是我容斥完全不会</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>$\tilde{\mu}(n)= 1,-1,0$</p><p>1: 当n为奇数个不同的质数乘积</p><p>-1: 当n为偶数个不同的质数乘积</p><p>0: 其它</p><p>相当于 Möbius函数 取相反数,且 $\mu(1) = 0$</p><p>那么满足 $\sum_{d|n} \tilde{\mu}(d)=<br>\begin{cases}<br>0 &amp; (\text{if }n=1)  \\<br>1 &amp; (\text{if }n\geq 2)<br>\end{cases}$</p><p>这和Möbius函数 很像, <code>和= 1-Möbius的和</code></p><hr><p>定义函数</p><p>$f(a,b;i,j) = 1/0$, 表示 i,j是a的倍数且 pi,pj 是b的倍数</p><p>对于和$S=\sum_{1\leq i\leq j\leq N} \sum_{a=1}^N \sum_{b=1}^N  \tilde{\mu}(a) \tilde{\mu}(b)f(a,b;i,j).$</p><p>对于给定的$(i,j)$ 令$g=GCD(i,j),g’=GCD(p_i,p_j)$</p><p>考虑右侧f要为1, 那么需要同时a是g的约数,b是g’的约数</p><p>$\sum_{1\leq i\leq j\leq N} \sum_{a=1}^N \sum_{b=1}^N  \tilde{\mu}(a) \tilde{\mu}(b)f(a,b;i,j) = \sum_{1\leq i\leq j\leq N} \sum_{a|g} \sum_{b|g’}  \tilde{\mu}(a) \tilde{\mu}(b)$</p><p>$= \sum_{1\leq i\leq j\leq N} \sum_{a|g} \tilde{\mu}(a) \sum_{b|g’}  \tilde{\mu}(b)$</p><p>所以考虑右侧, 只要g,g’ 同时大于等于2,则为1, 否则为0</p><p>$= \sum_{1\leq i\leq j\leq N} (g \ge 2 , g’ \ge 2)$, 这里证明了和原题意等价, 因此S就是要求的答案</p><hr><p>令$num(a,b) = (a|i,b|p_i)$ 的个数</p><p>对于给定$(a,b)$ 有 $\sum_{1\le i\le j\le N}f(a,b;i,j)=\frac{num(a,b)(num(a,b)+1)}{2}$, 相当于找出所有满足$(a|i,b|p_i)$ 的然后组成顺序对</p><p>因此又有$S=\sum_{a=1}^N \sum_{b=1}^N  \tilde{\mu}(a) \tilde{\mu}(b)<br>\frac{num(a,b)(num(a,b)+1)}{2}.$</p><p>这样你可以计算S了, 虽然是N^2<br>但是实际上, 对于a, 因为有$(a|i,b|p_i)$, 所以 b 的可选值很小</p><h3 id="附加"><a href="#附加" class="headerlink" title="附加"></a>附加</h3><p>讲了一下Möbius function 函数的定义,和约数和的结果, 提到了$\displaystyle\sum_{d|n} \tilde{\mu}(d)=1-\sum_{d|n}\mu(d)$</p><p>因此每个都可以被快速计算</p><h2 id="正向思路"><a href="#正向思路" class="headerlink" title="正向思路?"></a>正向思路?</h2><p>其实从上面过程中还是能看见一点</p><p>本身是要求 $= \sum_{1\leq i\leq j\leq N} (GCD(i,j) \ge 2 , GCD(p_i,p_j) \ge 2)$</p><p>有莫比乌斯函数知识有 $[x = 1] = \sum_{i|x} \mu(i)$, 这里$\mu$是莫比乌斯函数</p><p>因此可以变形为</p><p>$= \sum_{1\leq i\leq j\leq N} (1-\sum_{t_0|GCD(i,j)} \mu(t_0))\cdot (1-\sum_{t_1|GCD(p_i,p_j)} \mu(t_1))$</p><p>$= \sum_{1\leq i\leq j\leq N} 1-(\sum_{1\leq i\leq j\leq N}\sum_{t_0|GCD(i,j)} \mu(t_0) + \sum_{1\leq i\leq j\leq N}\sum_{t_1|GCD(p_i,p_j)} \mu(t_1)) + \sum_{1\leq i\leq j\leq N}\sum_{t_0|GCD(i,j)} \mu(t_0) \sum_{t_1|GCD(p_i,p_j)} \mu(t_1)$</p><p>3部分</p><p>第一部分就是$i\le j$的个数</p><p>第二部分,对于$t_0,t_1$ 分别考虑,都是类似的,找都是$t_0 / t_1$的倍数</p><p>第三部分,从$t_0,t_1$ 的角度看, 就是上面所谓的num(a,b) 一样的想法</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>map 850ms <a href="https://atcoder.jp/contests/abc230/submissions/34500944" target="_blank" rel="noopener">https://atcoder.jp/contests/abc230/submissions/34500944</a></p><p>vector+vis 270ms <a href="https://atcoder.jp/contests/abc230/submissions/34500900" target="_blank" rel="noopener">https://atcoder.jp/contests/abc230/submissions/34500900</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;typedef long long ll;#define rep(i,a,n) for (int i=a;i&lt;(int)n;i++)int read(){int r;scanf(&quot;%d&quot;,&amp;r);return r;} // read#define N 200000int p[N+10]; // 读入,排列bool pr[N+10]; // prime[i] = true/falseint mu[N+10]; // mu, 新定义的mu, mu(1) = 0, mu(i) = -莫比乌斯函数(i), i&gt; 1std::vector&lt;int&gt;d[N+10]; // d[v] = `v的mu不为0的因子`int main() {  int n = read();;  ll ans = 0;  rep(i,1,n+1) p[i] = read();  std::fill(pr+2,pr+n+1,true);  std::fill(mu+2,mu+n+1,-1);  rep(i,2,n+1){    if (pr[i]) {      mu[i] *= -1;      for (int j = 2*i; j &lt;= n; j+=i) {        pr[j] = false;        mu[j] *= ((j/i)%i) ? -1 :0;      }    }    if (mu[i] != 0) for (int j = i; j &lt;= n; j += i) d[j].push_back(i);  }  rep(a,2,n+1) if(mu[a] != 0) { // mu(a) * mu(b) * (num(a,b)(num(a,b)+1))/2    std::unordered_map&lt;int, ll&gt; b2c; // 对于给定a, 的b2c[b] = num(a,b)    for (int i = a; i &lt;= n; i += a) for (int b : d[p[i]]) b2c[b]++;// a|i, b|p[i]    for (auto [b,c]: b2c) ans += mu[a] * mu[b] * (c * (c + 1)) / 2;  }  printf(&quot;%lld\n&quot;,ans);  return 0;}</code></pre><h1 id="H-Bullion"><a href="#H-Bullion" class="headerlink" title="H - Bullion"></a>H - Bullion</h1><p>无限数量的块分别重w1,w2,…,wk, 每个两两不同</p><p>无限数量包,重量1</p><p>包可以容纳 任意个非空包 和 任意个块</p><p>安排一辆卡车, 运载力W,</p><p>考虑 w=2..W 的每个情况</p><p>你需要 让最终外层包重量为w的打包方案数, 包可以嵌套,不能有空包</p><p>物品重量相同视为相同, 包内没有顺序,看成可重集合</p><p>输出对于每个w的方案数 mod 998244353</p><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>w 2.5e5</p><p>8s</p><p>1024mb</p><h2 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h2><p>先考虑给定w</p><p>那么它的内容重量和=w-1</p><p>假设包的部分是重k, 那么剩余直接的块重量和为w-k-1</p><p>所以f(w) = sum g(k) h(w-k-1)</p><p>g(x) = 多个包裹总重量为x的方案数</p><p>h(x) = 多个块总重量为x的方案数</p><p>像生成函数, 但不会了</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>这里也提到了上次的222H</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>G</p><p>感觉还是莫比乌斯反演相关的知识点</p><p>这个S的定义 感觉凭空出现啊, 这题解有一点搞</p><p>但如果不知道这种定义, 还是可以从莫比乌斯函数推导出的</p><p>H</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://atcoder.jp/contests/arc230/editorial" target="_blank" rel="noopener">官方题解</a></p><p><a href="https://yexiaorain.github.io/Blog/2019-01-06-MobiusInversionFormula/">之前写的莫反笔记</a></p><p><a href="https://yexiaorain.github.io/Blog/2019-03-23-cfP1139D/">莫反 CF 548 Div2 D</a></p><p><a href="https://yexiaorain.github.io/Blog/2020-11-07-nowcoder8282D/">莫反NowCoder 8282 D</a></p><p><a href="http://localhost:4000/Blog/2022-08-08-ac_abc222/" target="_blank" rel="noopener">222H</a></p>]]></content>
      
      
      <categories>
          
          <category> Atcoder </category>
          
          <category> ABC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Möbius function </tag>
            
            <tag> Möbius函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atcoder abc229</title>
      <link href="/Blog/2022-08-31-ac-abc229/"/>
      <url>/Blog/2022-08-31-ac-abc229/</url>
      
        <content type="html"><![CDATA[<p>G(二分)H(博弈论,非公平博弈论, surreal number)</p><p><a href="https://atcoder.jp/contests/abc229/tasks" target="_blank" rel="noopener">https://atcoder.jp/contests/abc229/tasks</a></p><h1 id="G-Longest-Y"><a href="#G-Longest-Y" class="headerlink" title="G - Longest Y"></a>G - Longest Y</h1><p>一个包含字符’Y’和’.’的长n字符串S,</p><p>可以操作[0,k] 次,交换S中的两个相邻字符</p><p>问可以得到的最终S的内部最长的连续Y的长度</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>n 2e5</p><p>k 1e12</p><p>2s</p><p>1024mb</p><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>考虑移动</p><p>最终假设是[l..r]</p><p>那么对于初始这些y的位置的大范围是[l0..r0]</p><p>那么一定可以分成两部分</p><p><code>[l0..m0][m0+1..r0]</code></p><p>一部分向右,一部分向左</p><p>显然有个点不需要动</p><p>如果选定了第i个点p[i]和期望个数c那么,移动代价为<code>min( 左侧k0, 右侧k1个), k0+k1+1=c</code></p><p><code>= min(sum(p[i]-k0..p[i]-1) - sum(p[i-k0]..p[i-1]) + sum(p[i+1]..p[i+k1]) - sum(p[i]+1..p[i]+k1))</code></p><hr><p>换个角度</p><p>所有值变成<code>p[i]-cnt1[i]</code></p><p>那么就是找一个值,  尽量多的数变成它, 且代价和 &lt;= K</p><p>显然每多一个,代价的增量是非严格递增的</p><p>是个凸函数(下凹)</p><hr><p>但感觉, 这样看起来, 其实左侧右侧影响不大,而是距离影响更大,</p><p>所以直接枚举中点,二分距离(选定的点的最大距离) =&gt; 去计算距离和范围,以及点数范围</p><p>这里 &lt; 距离的必选, &gt;距离必定不选, =距离可选可不选</p><p>似乎就没了?</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc229/submissions/34483869" target="_blank" rel="noopener">https://atcoder.jp/contests/abc229/submissions/34483869</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readchar s[200010];ll k;vector&lt;int&gt; v;vector&lt;ll&gt; pre = {0};tuple&lt;ll,ll,ll&gt; calc(ll x,ll d){ // value = x, distance = d , return { &lt; d 的和, &lt; d 的个数, =m的个数}  // [x-d,x+d]  int i  = lower_bound(v.begin(),v.end(),x    ) - v.begin();  int i0 = lower_bound(v.begin(),v.end(),x-d  ) - v.begin();  int i1 = lower_bound(v.begin(),v.end(),x-d+1) - v.begin();  int i2 = lower_bound(v.begin(),v.end(),x+d  ) - v.begin();  int i3 = lower_bound(v.begin(),v.end(),x+d+1) - v.begin();  if(d == 0) return {0,0,i1-i0};  // [i0 [i1 i  i2] i3]  // [i1..i-1] + [i..i2-1]  ll sum = (i-i1) * x - (pre[i] - pre[i1])    + (pre[i2] - pre[i]) - (i2-i) * x;  return {sum, i2-i1, (i1-i0)+(i3-i2) };}ll f(ll x){  ll l = 0;  ll r = max(x-v[0],v.back()-x)+1;  while(l+1 &lt; r){    ll mid = (l+r)/2;    (get&lt;0&gt;(calc(x, mid)) &gt; k ? r : l) = mid;  }  auto [sum, c0, c1] = calc(x, l);  return c0 + (l==0 ? c1 : min((k-sum)/l,c1));}int main(){  scanf(&quot;%s&quot;,s);  int n = strlen(s);  k = read();  rep(i,0,n) if(s[i] == &#39;Y&#39;){ v.push_back(i-v.size()); }  rep(i,0,v.size()) pre.push_back(pre.back() + v[i]);  ll ans = 0;  for(auto x:v) ans = max(ans, f(x));  printf(&quot;%lld\n&quot;,ans);  return 0;}</code></pre><h1 id="H-Advance-or-Eat"><a href="#H-Advance-or-Eat" class="headerlink" title="H - Advance or Eat"></a>H - Advance or Eat</h1><p>n 行n列棋盘,每个格子可能三种状态 空/白/黑, 题目提供</p><p>T和S交替游戏</p><p>T, 将一个白色向上移动一格(不能重叠不能出棋盘) 或者 吃掉一个黑色</p><p>S, 将一个黑色向上移动一格(不能重叠不能出棋盘) 或者 吃掉一个白色</p><p>无法行动的输掉</p><h2 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h2><p>n &lt;= 8</p><p>2s</p><p>1024mb</p><h2 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h2><p>显然需要博弈论</p><p>然后不同列之间没有关系</p><p>3^8 = 6561</p><p>如果每个状态算出sg函数也就做出来了?</p><p>但这里好像不是公平的游戏</p><hr><p>想让对手不能走</p><p>通过移动自己的向上并不会产生影响, 因为如果原来在前面的不受影响, 在后面的要么不受影响, 要么可移动的长度更长</p><p>你能走的步数, 在不考虑被删除的情况下, 你能走的步数就是每个向上移动的步数+对手棋子数</p><p>而对手的棋子数最终都会变成你的步数</p><p>但你向上移动, 可以通过移动掉对手的棋子来增加步数, 也会受到对手的移动而减少</p><p>因此显然如果你当前指定一列要移除一个,几个对手同色的连续(可以有空格,没有其它颜色), 你移动掉的一定是最下方的那个, 更好的方案不会比这个好</p><p><code>f(T/S) = 对面个数+ sum( pos[i] - cnt[i])</code>, 位置-同色第几个</p><p>游戏结束时,一定一方的棋子被完全移除了</p><p>每次T 做移动,会让一个pos-1, f(T) -1,</p><p>每次T 做删除,会让对面一个棋子消失f(T) -1,f(S)中移除某个(pos-cnt)</p><p>S 是对称的</p><p>例如游戏结束时,B被删完了,W还有剩余,f(T) = 0, f(S) &gt; 0</p><p>T 输, 所以</p><p>可以看成每次你的值-1,你可以降低对面一个值</p><p>谁先0谁输</p><p>考虑f(T) 和 f(S) 的差的变化</p><hr><p>所以直接贪心,每次删除对手一个最大的即可?</p><hr><p>写了以后发现并不对</p><p><a href="https://atcoder.jp/contests/abc229/submissions/34484702" target="_blank" rel="noopener">https://atcoder.jp/contests/abc229/submissions/34484702</a></p><p>问题在于, 当需要移W或删B时</p><p>B都是无法移动,意味删除代价为1, 移动也是1, 删B-&gt;对手删-&gt;无法移动 肯定是比 移动-&gt;对手删-&gt;删B 多步的,而这种情况, 移动不一定是能操作的</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>哦!!! 还是SG</p><p>显然根据SG的知识, DAG上面一些点上有多个棋子, 交替操作,每次沿着一个边移动一个棋子, 不能操作的输掉</p><p>然后就是mex 和sg函数</p><p>然后也是需要Impartial game, 可以转换成DAG, 否则需要其它的额外方法</p><hr><p>如何处理 Partisan Games</p><p>考虑同样DAG,但是边染色了(黑/白), 但是第一个玩家,只能走白边, 第二个玩家只能走黑边</p><p>但是是对每个点给予一个评估实数</p><p>对于第一个玩家(只走白)来说,每个点的值越大越好, 对于第二个玩家(只走黑)来说,每个点的值越小越好, 同时每个值随着走白边下降,走黑边增加</p><hr><p>如何计算评估值</p><p>如果连出的边的点存在未定义,则当前未定义</p><p>否则的话 max(白出点) &lt; eval(当前) &lt; min(黑出点), 如果不存在这样的值 则当前为未定义</p><p>当上述存在方案时, 如果有整数满足, 则定义为绝对值最小整数</p><p>否则用分母为2的幂次,且分母最小的分数来表示</p><hr><p>如何判断赢家</p><p>计算所有点上的值的和, 如果为正,第一个赢, 如果 &lt;= 0, 则第二个赢</p><hr><p>证明</p><p>对于所在的和为正时, 轮到第一个玩家操作</p><p>如果 为正, 那么可以找到一个白色路径, 让结果 &gt;= 0</p><p>假设和的2的幂次为w, 则加和中至少一个棋子所在的分母的2的幂次w1大于等于这个幂次w(-1/2+1/2 = 0/1,-1/2+1=1/2), 那么让这个值沿着白边走, 则它的变化就是1/2^(&gt;=w1)(因为上面的分数赋值的设计关系,最大的白色和它关系), 所以 ?/2^w - 1/2^(&gt;=w1) &gt;= 0</p><p><code>max(=1/4) &lt; eval &lt; min(1) =&gt; eval = 1/2</code></p><p>如果 为&lt;= 0, 则一次白色边移动后 一定为负数</p><p>对于第二个玩家所在</p><p>走黑边是同理的,</p><p>因此 如果 <code>正 =&gt; (&gt;=0) =&gt; 正 =&gt; (&gt;=0) ...</code></p><p>如果 <code>(&lt;=0) =&gt; (&lt;0) =&gt; (&lt;=0) =&gt; (&lt;0) ...</code></p><p>可以看成不变量会保持了</p><p>至此证明了, 如此设置eval,以及 先后手的目标分别是让值更大, 和让值更小, 会有这个结果, 一个是 单次操作和总答案的关系是否有局部性? 第二格式为啥这个目标和原不能移动 是等价?</p><p>如何和原题联系起来?</p><hr><p>TODO 虽然移动和结束状态等价, 为啥分别追求larger和smaller是等价的?</p><hr><p>追求larger和smaller 为何与单步的保证上面变化序列等价</p><p>显然 如果 <code>正 -&gt; (&lt;0)</code> 那么对手一定不会让你再回到正, 所以为了最大,一定要<code>正 =&gt; (&gt;=0)</code>, (对称显然)</p><p>但是这里并没有说一定要 <code>正 =&gt; (最大的&gt;=0)</code>, 上面相当于证明了方案存在性</p><p>就是如果一个追求larger,一个追求smaller, 那么必然是按照这两种走法去走, 所以都能维持自己的状态</p><h3 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h3><p>就是不同列之间无关, 建立3^n的图, 然后算每点的eval值</p><p>然后 需要证明任何点都能有值, 其实可以按照DAG的拓扑顺序赋值, v 以前的假设都有值了</p><p>那么需要证明的就是 最大白出边v-&gt;a &lt; 最小黑出边v-&gt;b</p><ol><li>如果这两个边k 对应操作都是 删除一个对手的子, 那么有v 吃两个子的状态c,因为 v白a黑c, v黑b白c,满足 eval(a) &lt; eval(c) &lt; eval(b)</li><li>如果a和b对应的实际操作 不会互相影响, 可以先a再b和先b再a,都和上面同理</li><li>考虑会互相影响, 也就是一个删掉对手棋子(a), 另一个操作恰好是移动这个棋子(b), 但这种情况会出现 b -&gt; a的边, 因此eval(a) &lt; eval(b)</li></ol><p>因此证明了可以建图,且每个点都有值</p><hr><p>学了下snuke的代码</p><p><a href="https://atcoder.jp/contests/abc229/submissions/27565297" target="_blank" rel="noopener">https://atcoder.jp/contests/abc229/submissions/27565297</a></p><p>有eval(状态) = -eval(状态翻转B/W)</p><p>因为 从状态在DAG上走 的结构, 和其翻转的状态在DAG上走的结构对称</p><p>所以如果它依赖的点也满足 互为相反数, 那么它就满足互为相反数(根据依赖关系, 每次取2幂次最小的绝对值最小,得证)</p><hr><p>然后这里用long long 而不是double</p><p>这里想知道的是one = 1ll &lt;&lt; 30 有啥办法推得吗, 虽然实际运算可以得到最高幂次, 如果不算的话有办法推得吗?</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>TODO url</p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define pb push_backint read(){int r;scanf(&quot;%d&quot;,&amp;r);return r;} // readconst ll ONE = 1ll&lt;&lt;7; // 1&lt;&lt;30 不用浮点数. TODO 30 为什么够?, 实际跑下来 1&lt;&lt;7就够了const ll INF = 1ll&lt;&lt;60; // 实际跑下来 最大x是1024ll eval(ll l, ll r) { // l &lt; ret &lt; r  assert(l &lt; r);  if (l &lt; 0 &amp;&amp; r &gt; 0) return 0;  if (l &lt; 0) return -eval(-r,-l);  ll b = ONE; // 1/2^k  while (1) { // 幂次最小的 绝对值最小 的 l &lt; x &lt; r    ll x = (l/b+1)*b; //  0 &lt;= l &lt; x &lt;? r    if (x &lt; r) {      return x;    }    b &gt;&gt;= 1; // k+=1  }  assert(false);  return 0;}map&lt;string,ll&gt; mp; // 字符 -&gt; eval 记忆化ll f(string s) {  if (mp.count(s)) return mp[s]; // 记忆化  vector&lt;ll&gt; d; // max(白边), min(黑边)  rep(ri,0,2) { // 第一轮计算 移W,删B, 第二轮翻转计算 移B删W    ll x = -INF;    rep(i,0,s.size()) {      if (s[i] == &#39;B&#39;) { // 删除B        string ns = s;        ns[i] = &#39;.&#39;;        x = max(x,f(ns));      }      if (s[i] == &#39;W&#39; &amp;&amp; i &amp;&amp; s[i-1] == &#39;.&#39;) { // W 上移        string ns = s;        ns[i] = &#39;.&#39;; ns[i-1] = &#39;W&#39;;        x = max(x,f(ns));      }    }    d.push_back(ri ? -x : x);    rep(i,0,s.size()) if (s[i] != &#39;.&#39;) s[i] ^= &#39;B&#39;^&#39;W&#39;; // 翻转B,W  }  return mp[s] = eval(d[0],d[1]); // d[0] &lt; mp[s] &lt; d[1], 没有后置状态则 -INF &lt; mp[s] &lt; INF, 而对于只是一方没有后置状态的, 可能是 0 &lt; max &lt; mp[s], mp[s] &lt; min &lt; 0 产生的非零值}int main() {  int n = read();  vector&lt;string&gt; s(n); // 每列  rep(i,0,n) {    string t;    cin &gt;&gt; t;    rep(j,0,n) s[j] += t[j];  }  ll x = 0;  rep(i,0,n) x += f(s[i]);  printf(&quot;%s\n&quot;,x &gt; 0?&quot;Takahashi&quot;:&quot;Snuke&quot;);  return 0;}// https://atcoder.jp/contests/abc229/submissions/27565297</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>G</p><p>没啥难的</p><p>H</p><p>算是会了基础的SG函数, 但是对于这种Partisan Games还是没学过, 又学了一手, 另外加深一下对博弈论建立DAG的理解</p><p>然后这里的 eval存在性需要保证</p><p>然后上面证明的细节还是不会(据说要 surreal number相关知识, orz)</p><p>TODO &lt; winning ways for your mathematical plays &gt;</p><p>TODO &lt; surreal number &gt;</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://atcoder.jp/contests/arc229/editorial" target="_blank" rel="noopener">官方题解</a></p>]]></content>
      
      
      <categories>
          
          <category> Atcoder </category>
          
          <category> ABC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分 </tag>
            
            <tag> 博弈论 </tag>
            
            <tag> 非公平博弈论 </tag>
            
            <tag> surreal number </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atcoder abc228</title>
      <link href="/Blog/2022-08-30-ac-abc228/"/>
      <url>/Blog/2022-08-30-ac-abc228/</url>
      
        <content type="html"><![CDATA[<p>F(博弈论,矩阵,二维前缀和,st表)G(DP,bitmask)H(DP,斜率优化)</p><p><a href="https://atcoder.jp/contests/abc228/tasks" target="_blank" rel="noopener">https://atcoder.jp/contests/abc228/tasks</a></p><h1 id="F-Stamp-Game"><a href="#F-Stamp-Game" class="headerlink" title="F - Stamp Game"></a>F - Stamp Game</h1><p>w乘h的矩阵初始全白色,每个有数字aij</p><p>T 可以染黑 h1 w1</p><p>A 可以染白 h2 w2</p><p>T 操作一次, S操作一次</p><p>分数= 黑色块之和</p><p>T 让尽可能大, A让T尽可能小, 求答案</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>h,w 1000</p><p>aij [1,1e9]</p><p>2s 1024mb</p><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>感觉就是二维常见运算</p><p>因为长度如果超了长度, 可以贪心把对应位置全覆盖,可以取min, h2=min(h2,h1), w2=min(w2,w1)</p><p>ans = max(f(i,j))</p><p>f(i,j) = sum(i,j) - max(g((range))</p><p>应该就过了吧</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>果然就过了</p><p><a href="https://atcoder.jp/contests/abc228/submissions/34466225" target="_blank" rel="noopener">https://atcoder.jp/contests/abc228/submissions/34466225</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readll a[1010][1010];int H;int W;int h[2];int w[2];ll mems[2][1010][1010]; // [0]ll memcol[2][1010][1010]; // [0]ll st[1010][1010];ll col(int o,int i,int j){  ll &amp; r = memcol[o][i][j];  if(r) return r;  if(i == 0){    rep(y,0,h[o]) r += a[i+y][j];  }else{    r = col(o,i-1,j) - a[i-1][j] + a[i+h[o]-1][j];  }  return r;}ll s(int o,int i,int j){  ll &amp; r = mems[o][i][j];  if(r) return r;  if(j == 0){    rep(x,0,w[o]) r+= col(o,i,j+x);  }else{    r = s(o,i,j-1) - col(o,i,j-1) + col(o,i,j + w[o]-1);  }  return r;}int main(){  H = read();  W = read();  h[0] = read();  w[0] = read();  h[1] = read();  w[1] = read();  h[1] = std::min(h[1],h[0]); // h[0] &gt;= h[1]  w[1] = std::min(w[1],w[0]); // w[0] &gt;= w[1]  rep(i,0,H) rep(j,0,W) a[i][j] = read();  ll ans = 0;  rep(i,0,H-h[1]+1) rep(j,0,W-w[1]+1) st[i][j] = s(1,i,j);  int hp = 0; // h pwr  int wp = 0; // w pwr  for(;(1&lt;&lt; (hp+1))&lt;=h[0]-h[1]+1;hp++)rep(i,0,H-h[1]+1)rep(j,0,W-w[1]+1)st[i][j]=std::max(st[i][j],st[i+(1&lt;&lt; hp)][j]);  for(;(1&lt;&lt; (wp+1))&lt;=w[0]-w[1]+1;wp++)rep(i,0,H-h[1]+1)rep(j,0,W-w[1]+1)st[i][j]=std::max(st[i][j],st[i][j+(1&lt;&lt; wp)]);  rep(i,0,H-h[0]+1) rep(j,0,W-w[0]+1) ans = std::max(ans, s(0,i,j) - std::max(      std::max(st[i                    ][j],st[i                    ][j+w[0]-w[1]-(1&lt;&lt;wp)+1]),      std::max(st[i+h[0]-h[1]-(1&lt;&lt;hp)+1][j],st[i+h[0]-h[1]-(1&lt;&lt;hp)+1][j+w[0]-w[1]-(1&lt;&lt;wp)+1])  ));  printf(&quot;%lld\n&quot;,ans);  return 0;}</code></pre><h1 id="G-Digits-on-Grid"><a href="#G-Digits-on-Grid" class="headerlink" title="G - Digits on Grid"></a>G - Digits on Grid</h1><p>高h宽w的矩阵</p><p>每个包含数字1~9</p><p>首先T放一个棋子, 然后两个交替N次</p><ol><li>T把棋子移动到同一行的任意一个格子上,移动后记录所在的值</li><li>S把棋子移动到同一列的任意一个格子上,移动后记录所在的值</li></ol><p>把这些数按顺序连起来, 形成一个长2n的数</p><p>问能形成多少种</p><p>注: 这里根据样例知道 可以停在原格子上</p><p>mod 998244353</p><h2 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h2><p>h,w [2,10]</p><p>n 300</p><p>3 s</p><p>1024 mb</p><h2 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h2><p>想法是记录开始第i步到<code>[i][j]</code> 有多少种, 但直接这样搞的话, 没法处理重复的问题</p><p>第二个想法是有没有办法聚类,</p><p><code>f[{下标集合}] = 方案数</code></p><p>问题是 不知道这种下标集合 的上限是多少</p><p>S0横 + ch和其中一个同行 -&gt; S1纵</p><p>S0纵 + ch和其中一个同列 -&gt; S1横</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>哇,就是类似的</p><p>但是注意到 比如 S0横 + ch和其中一个同行 -&gt; S1纵</p><p>真正有关系的只有 s0中占了多少行</p><p>这样的话 状态数 就不是2^100 而是2^10了</p><p>剩下就暴力就完了</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc228/submissions/34466640" target="_blank" rel="noopener">https://atcoder.jp/contests/abc228/submissions/34466640</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;#include &lt;atcoder/modint&gt;using mint = atcoder::modint998244353;#define rep(i,a,n) for (int i=a;i&lt;(int)n;i++)int read(){int r;scanf(&quot;%d&quot;,&amp;r);return r;} // readconst int N = 10;int a[N+10][N+10]; // 输入数字矩阵int r2c[1 &lt;&lt; N][N]; // [行bitmask][数字digit] = 列bitmaskint c2r[1 &lt;&lt; N][N]; // [列bitmask][数字digit] = 行bitmaskint main() {  int n = read();  int m = read();  int k = read();  char tmp[N+10];  rep(i,0,n){    scanf(&quot;%s&quot;,tmp);    rep(j,0,m) a[i][j] = tmp[j] - &#39;1&#39;; // 1-9 转换成 0~8  }  // s bit集合  rep(s,1,1&lt;&lt;n)rep(i,0,n)if(s&amp;(1&lt;&lt;i))rep(j,0,m) r2c[s][a[i][j]] |= 1&lt;&lt;j;  rep(s,1,1&lt;&lt;m)rep(j,0,m)if(s&amp;(1&lt;&lt;j))rep(i,0,n) c2r[s][a[i][j]] |= 1&lt;&lt;i;  std::vector&lt;mint&gt; r(1&lt;&lt;n,0);  r.back() = 1; // 一个都没选的时候, 满集  while(k--){    std::vector&lt;mint&gt; c(1&lt;&lt;m,0);    rep(s,1,1&lt;&lt;n) rep(d,0,9) c[r2c[s][d]] += r[s]; // row -&gt; col    r = std::vector&lt;mint&gt;(1&lt;&lt;n,0);    rep(s,1,1&lt;&lt;m) rep(d,0,9) r[c2r[s][d]] += c[s]; // col -&gt; row  }  mint ans = 0;  rep(s,1,1&lt;&lt;n) ans += r[s];  printf(&quot;%d\n&quot;, ans.val());  return 0;}</code></pre><h1 id="H-Histogram"><a href="#H-Histogram" class="headerlink" title="H - Histogram"></a>H - Histogram</h1><p>长n的整数序列, A,C, 可以操作任意次</p><p>每次任选一个 A[i] +1, 代价C[i]</p><p>所有操作结束后, 还需要花费代价 X 乘 A中不同数的个数</p><h2 id="范围-2"><a href="#范围-2" class="headerlink" title="范围"></a>范围</h2><p>n 2e5</p><p>x 1e6</p><p>ai,ci[1,1e6]</p><p>2s</p><p>1024mb</p><h2 id="我的思路-2"><a href="#我的思路-2" class="headerlink" title="我的思路"></a>我的思路</h2><p>考虑直接对A排序,</p><p>那么对于i来说,如果a[j…i] 都提升到i</p><p>那么代价是 a[j..i] 变成a[i] 每个和a[i]差乘上系数, 再减去 X 乘上 (原来种数-1)</p><p><code>dp[i] = max(dp[j-1] + cost[j..i])</code></p><p>但是显然这样直接搞是n^2的</p><p><code>cost[j..i] = sum t=j..i, (a[i] - a[t])c[t] - X * (cnt[i] - cnt[j-1])</code></p><p>有一点是 如果 a[j..k] 一段是相等, 根据那么要么全部变成i, 要么全部不变, 所以对答案可能有贡献的j一定满足a[j-1] != a[j]</p><p>上面的表达式<code>cost(j,i)</code>另一个角度对于给定的i</p><p><code>cost[j..i] = sum t=j..i, c[t]a[i] - a[t]*c[t] - X * (cnt[i] - cnt[j-1])</code></p><p>可以拆分成3部分</p><ol><li>常数部分 <code>-Xcnt[i]</code></li><li>与i 无关,随着j越小增加的部分, <code>-a[t]c[t] + Xcnt[j-1]</code>, 虽然本身右侧cnt不是每个+1, 但是可以把这整个合并成一个只与t相关的部分, 还可以和<code>dp[j-1]</code> 合并</li><li>与i,t相关 的c[t]a[i]</li></ol><p><code>f(i,j) = k(j) a[i] + g(j) + C</code></p><p>问题是这个 似乎并不知道如何找最小值</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>排序和贪心显然</p><p>但是dp 不用反过来, 直接正向</p><p><code>dp[i] = min(dp[j]+X + sum t=j+1..i, (a[i] - a[t])c[t] )</code></p><p><code>dp[i] = X + min(dp[j] + a[i](prec[i]-prec[j]) - (preac[i] - preac[j]))</code></p><p><code>dp[i] - a[i]prec[i] + preac[i] = X + min(dp[j] - a[i]prec[j] + preac[j])</code></p><hr><p>令 <code>y[i] = y[i]+preac[i]</code></p><p>要求的<code>ans = y[i] - preac[i]</code></p><p><code>y[i] - a[i]prec[i] - X = min(y[j] -a[i]prec[j])</code></p><p>看成一次函数<code>b[i] = y[j] - k[i]x[j]</code></p><p>其实就是很多过点<code>(x[j],y[j])</code> 斜率为<code>k[i]</code>的直线 的最小截距</p><p>注意到<code>k[i] = a[i]</code>, 所以斜率随着i增大而增大</p><p>而<code>x[j] = prec[j]</code> 也是随j增大而增大</p><hr><p>因此需要维护一个凹(下凸)点集</p><p>查询的时候二分即可</p><hr><p>然后边界如果是把i以前全部变成a[i]</p><p><code>y[i] - a[i]prec[i] - X = min(y[0] -a[i]prec[0])</code></p><p>均为0即可</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc228/submissions/34483299" target="_blank" rel="noopener">https://atcoder.jp/contests/abc228/submissions/34483299</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readconst int N = 200000;pair&lt;ll,ll&gt; in[N+10];vector&lt;int&gt; que = {0}; // 凸的下标ll pc[N+10]; // pre sum cll y[N+10]; // y[0] = [0]bool le(pair&lt;ll,ll&gt;k0, pair&lt;ll,ll&gt;k1){ // k0 &lt; k1  auto [y0,x0] = k0;  auto [y1,x1] = k1;  ll b0 = y0/x0;  ll b1 = y1/x1;  if(b0 != b1) return b0 &lt; b1;  ll r0 = y0 % x0;  ll r1 = y1 % x1;  if(!r0 || !r1) return r0 &lt; r1; // 其中一个是0  // r0/x0 &lt; r1/x1  &lt;-&gt;  x1/r1 &lt; x0/r0  return le({x1,r1},{x0,r0});}int k2j(int k) { // 斜率 k =&gt; 最小截距 对应切点idx  int idx = 0;  for(int i=(1&lt;&lt;17);i;i&gt;&gt;=1) if(idx+i &lt; (int)que.size()) { // 2^17 = 131072, 2^20 &gt; 200000    int i0=que[idx+i-1];    int i1=que[idx+i];    if(le({y[i1]-y[i0],pc[i1]-pc[i0]},{k,1})) idx += i; // k of (i0-&gt;i1) &lt; k  }  return que[idx];}int main() {  int n = read();  ll X = read();  rep(i,1,n+1) { // in[0] = {0,0}    ll a = read();    ll c = read();    in[i] = {a,c};  }  sort(in+1,in+n+1); // 按a排序  rep(i,1,n+1) pc[i] = pc[i-1] + in[i].second; // c前缀和  rep(i,1,n+1){    int j = k2j(in[i].first);    y[i] = y[j] + (pc[i]-pc[j])*in[i].first+X; // y[i] - a[i]prec[i] - X = min(y[j] -a[i]prec[j])    while(que.size() &gt; 1) { // 至少两个点 保证 (yi-y1)/(xi-x1) &gt; (y1-y0)/(x1-x0)      int i0=que[que.size()-2];      int i1=que.back();      // 注意overflow      if(le({y[i1]-y[i0],pc[i1]-pc[i0]},{y[i]-y[i1],pc[i]-pc[i1]})) break;      que.pop_back();    }    que.push_back(i);  }  ll ans = y[n];  rep(i,1,n+1) ans -= in[i].first*in[i].second;  printf(&quot;%lld\n&quot;,ans);  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>F</p><p>没啥难的</p><p>G</p><p>大的方向对了, 但是在提取必要信息时有问题, 没提取出只和行/列相关</p><p>H</p><p>算是又看了一个斜率优化的实际例子吧</p><p>大概是 <code>f(i) = g(j) + n(i)(单调递增) * m(j)(单调递增?), (j &lt; i)</code> 的形式可以考虑 把<code>k_i = n(i)</code>, 剩下的, 且单调递增</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://atcoder.jp/contests/arc228/editorial" target="_blank" rel="noopener">官方题解</a></p>]]></content>
      
      
      <categories>
          
          <category> Atcoder </category>
          
          <category> ABC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
            <tag> bitmask </tag>
            
            <tag> 二维数组 </tag>
            
            <tag> 斜率优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atcoder abc227</title>
      <link href="/Blog/2022-08-28-ac-abc227/"/>
      <url>/Blog/2022-08-28-ac-abc227/</url>
      
        <content type="html"><![CDATA[<p>D(数学)E(DP)F(DP,第k大)G(数筛)H(欧拉回路,网络流)</p><p>这场UI还有红色特效</p><p><a href="https://atcoder.jp/contests/abc227/tasks" target="_blank" rel="noopener">https://atcoder.jp/contests/abc227/tasks</a></p><h1 id="D-Project-Planning"><a href="#D-Project-Planning" class="headerlink" title="D - Project Planning"></a>D - Project Planning</h1><p>长n数组a</p><p>每次选k个不同的下标, 让值减1,(保证所有值非负), 求多减的次数</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>n 2e5</p><p>ai [1..1e12]</p><p>2s</p><p>1024mb</p><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>感觉如果数据量小,每次最大k个下标减1</p><p>但这样每次要排序, 而且ai很大</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>对答案考虑, 是否能做p次</p><p>s = sum min(ai,p)</p><p>如果 kp &gt; s, 显然不可能, 因为左边是需要的个数, 右边是’可能’的上界</p><hr><p>然后就是精彩的 可以数学证明 如果 kp &lt;= s 则一定可以</p><p>如果有多于k个 ai &gt;= p, 那么就指定其中k个 然后做p次即可</p><p>否则, 选择最大的k个做1次, 那么 kp &lt;= s 不等式 左边相当于-k, 右边最多减k</p><p>因此 不等式依然成立, 而变成子问题就是归纳法了</p><p>得证</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc227/submissions/34432305" target="_blank" rel="noopener">https://atcoder.jp/contests/abc227/submissions/34432305</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readll a[200010]; // 2e5int main(){  int n = read();  int k = read();  rep(i,0,n) a[i] = read();  ll l = 0, r =  1e18 / k; // 左行 右不行  while(l + 1 &lt; r){    ll mid = (l + r) / 2;    ll s = 0;    rep(i,0,n) s += min(a[i], mid);    (s &gt;= k * mid ? l : r) = mid;  }  printf(&quot;%lld\n&quot;,l);  return 0;}</code></pre><h1 id="E-Swap"><a href="#E-Swap" class="headerlink" title="E - Swap"></a>E - Swap</h1><p>只包含KEY3种字符的字符串, 问 &lt;= k次相邻交换能产生多少种字符串</p><h2 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h2><p>len &lt; 30</p><p>k [0..10^9]</p><h2 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h2><p>k 最多30+29+28+… &lt; 500次 能得到所有字符</p><p>然后字符串种树并不是3的30次方</p><p>而是假设最开始 a,b,30-a-b 个的排列方式</p><p>30 !/ ( a! b! (30-a-b) !)</p><p>依然很大可能达到 &gt; 10^12 次方量级</p><p>考虑</p><p><code>dp[i][k][e][&lt;=op]</code></p><p><code>30*30*30*500</code></p><p>但不太知道如何转移</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>考虑说如果给定S,T 如何求最小交换次数, 显然 按位置就近移动</p><p><code>dp[i][x][e][y] =</code> 长度为i的字符串T, e个E,y个Y, at least x 次操作, 让S[0..i] 变成T的方案数</p><p>ti指定的话, 它的来源一定是剩余s中 同个字符的第一个</p><p>这样就可以转移了</p><p>而且注意到, 当前i个指定e和y的个数后,k的个数也是确定的, 而相当于对s 去掉了最前的e个E,y个Y和k个K, 所以剩余的s的内容是唯一的!!!</p><p>剩下就是实现了</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc227/submissions/34432995" target="_blank" rel="noopener">https://atcoder.jp/contests/abc227/submissions/34432995</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readchar s[100];unordered_map&lt;int,unordered_map&lt;int,unordered_map&lt;int,pair&lt;string,ll&gt;&gt;&gt;&gt; dp;// dp[x最小操作代价][e个数][y个数] = (剩余字符串内容, 方案数), 滚动掉一维int main(){  scanf(&quot;%s&quot;,s);  int n = strlen(s);  int k = read();  dp[0][0][0] = {s,1};  rep(_,0,n){    unordered_map&lt;int,unordered_map&lt;int,unordered_map&lt;int,pair&lt;string,ll&gt;&gt;&gt;&gt; ndp; // next dp    for(auto [x,d1]:dp) for(auto [e,d2]:d1) for(auto [y,sv]:d2) {      auto [s0,c] = sv;      for(auto ch: {&#39;K&#39;,&#39;E&#39;,&#39;Y&#39;}) rep(idx,0,s0.size()) if(ch == s0[idx]){        int x1 = x+idx; // 最小代价        int e1 = e+(ch == &#39;E&#39;);        int y1 = y+(ch == &#39;Y&#39;);        string s1 = s0.substr(0,idx) + s0.substr(idx+1);        if(!ndp[x1][e1].count(y1)) ndp[x1][e1][y1] = {s1, 0};        ndp[x1][e1][y1].second += c;        break; // 只找每个字符在剩余中首次出现的      }    }    dp = ndp;  }  ll ans = 0;  for(auto [x,d1]:dp) if(x &lt;= k) for(auto [e,d2]:d1) for(auto [y,sv]:d2) ans += sv.second;  printf(&quot;%lld\n&quot;,ans);  return 0;}</code></pre><h1 id="F-Treasure-Hunting"><a href="#F-Treasure-Hunting" class="headerlink" title="F - Treasure Hunting"></a>F - Treasure Hunting</h1><p>h * w 的矩阵, 左上走到右下, 只能向下或向右</p><p>问 路径中最大的K个数字的和最小值</p><h2 id="范围-2"><a href="#范围-2" class="headerlink" title="范围"></a>范围</h2><p>h,w 30</p><p>aij [1,1e9]</p><h2 id="我的思路-2"><a href="#我的思路-2" class="headerlink" title="我的思路"></a>我的思路</h2><p>想从两端做meet in middle, 但是 一半也有2的30次方</p><p>记录从开始 到当前位置的maxk 最小的</p><p>但是并没有局部性</p><p>例如两条路径分别是</p><pre><code>5 5 51 1 7</code></pre><p>显然后面的会更小, 但是如果未来接了更多大的, 就会更大</p><p>并没有局部性</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>固定第k大是矩阵中的哪一个,来做, 令其为<code>x</code></p><p><code>dp[i][j][&gt;= x的个数] =</code> 路径中大于等于 x的所有值的和 的最小值</p><p>这样做的话显然对于指定的x是有局部性的, 因为个数也拆出来了</p><p><code>dp[i][j][c] = min(dp[i-1][j][c-(a[i][j] &gt;= x)],dp[i][j-1][c-(a[i][j] &gt;= x)])</code></p><p>然后</p><p>结果就是</p><p><code>dp[h][w][k??]</code>, 这里的问题是,当选定x以后, 个数可能无法刚好是k(比如反例所有值都一样的时候)</p><hr><p>解决方案是, 这里的c 并不是记录所有<code>&gt;=x</code> 的个数</p><p>而是变成选择了的<code>&gt;=x</code>的个数,当然结果还是对应的被选的值的和</p><p>但是这里保证的是<code>&gt;x</code>是必选, 而<code>=x</code> 是可选可不选</p><p>这样一来,其实是看成<code>x</code> 是当前路径上排序第<code>c</code>大下标的, dp的值是前<code>c</code>大的和</p><p>这样一是 依然有局部性, 而又保证了不会出现中间空白的情况, dp的有效的一定是连续的一段</p><p>这样的话结果就是 <code>min(dp[h][w][k])</code></p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc227/submissions/34442116" target="_blank" rel="noopener">https://atcoder.jp/contests/abc227/submissions/34442116</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readconst ll INF = 1e11; // &gt; 1e9 * 60void setmin(ll&amp;a,ll b){if(a&gt;b) a = b;}int main(){  int h = read();  int w = read();  int k = read();  auto a = vector(h,vector(w,0));  rep(i,0,h) rep(j,0,w) a[i][j] = read();  ll ans = INF;  for(auto row: a) for(auto x : row) { // 从矩阵中指定一个x,    auto dp = vector(k+1,vector(h,vector(w,INF))); // dp[count(&gt;= x)][i][j] = min(sum(&gt;=x))    if(a[0][0] &gt;= x) dp[1][0][0] = a[0][0];    if(a[0][0] &lt;= x) dp[0][0][0] = 0;    rep(c,0,k+1) rep(i,0,h) rep(j,0,w) if(i || j){ // 收集式递推      if(a[i][j] &gt;= x &amp;&amp; c){ // 选择 (&gt;x 必选 ==x 可选可不选)        setmin(dp[c][i][j], a[i][j] + (i ? dp[c-1][i-1][j] : INF));        setmin(dp[c][i][j], a[i][j] + (j ? dp[c-1][i][j-1] : INF));      }      if(a[i][j] &lt;= x){ // 不选 注意这里和上面不是互斥 而是==x可以选也可以不选, (&lt;x 必不选)        setmin(dp[c][i][j],           (i ? dp[c  ][i-1][j] : INF));        setmin(dp[c][i][j],           (j ? dp[c  ][i][j-1] : INF));      }    }    setmin(ans, dp[k][h-1][w-1]);  }  printf(&quot;%lld\n&quot;, ans);}</code></pre><h1 id="G-Divisors-of-Binomial-Coefficient"><a href="#G-Divisors-of-Binomial-Coefficient" class="headerlink" title="G - Divisors of Binomial Coefficient"></a>G - Divisors of Binomial Coefficient</h1><p>题意如标题,计算binom(n,k) 的因子个数</p><p>答案mod998244353</p><h2 id="范围-3"><a href="#范围-3" class="headerlink" title="范围"></a>范围</h2><p>n 1e12</p><p>k 1e6</p><p>2s</p><p>1024mb</p><h2 id="我的思路-3"><a href="#我的思路-3" class="headerlink" title="我的思路"></a>我的思路</h2><p>我掏出了我之前写的 质数判别+质数拆解的板子</p><p>想暴力 + map 做</p><p>但是sample3我本地就跑了31s, 很久很久</p><p>另一个思路是</p><p>n/1 (n-1) /2 的顺序算</p><p>但还是免不了对大数做分解?</p><hr><p>再有就是, 直接去 <code>n-k+1~n</code>里找i的倍数,做除发</p><p>问题是对于单个很好找, 但是对于多个来说, 可能两个数都找到同一个导致除法不够除</p><h2 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h2><p>一样的 , ans = prod(pwr+1)</p><p>直接数筛法去 对小的进行质因数分解</p><p>对于大的一样类似的暴力!!!!!!, sqrtN个质因子去尝试K个数</p><p>因为复杂度依然是 = k/1 + k/2 + k/3 +.. +… k/sqrt(N)</p><p>哇! 又是会的知识变形了就不会用了…..</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc227/submissions/34448377" target="_blank" rel="noopener">https://atcoder.jp/contests/abc227/submissions/34448377</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;const int MOD = 998244353;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)const int N = 1000000;const int P = N + 10;bool pr[P]; // 1e6ll a[2][N+10]; // [0] 1~k 分母, [1] n-k+1 ~ n, 分子ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readint main(){  ll n = read();  ll k = read();  std::fill(pr+2,pr+P,true);  for(ll p=2;p*p &lt; P;p++) if(pr[p]) for(ll i = p*p;i &lt; P;i+=p) pr[i]=false;  ll s[] = {n-k+1,1}; // 最小的数的起始, n-k+1~n 分子部分, 1~k 分母部分  rep(o,0,2) std::iota(a[o],a[o]+k,s[o]);  ll ans = 1;  rep(p,2,P) if(pr[p]){    int power = 0; // 质因子p的幂次    rep(o,0,2) for(ll v=((s[o]+(p-1))/p)*p;v&lt;=s[o]+k-1;v+=p) while(a[o][v-s[o]]%p==0){      power+= (const int[]){1,-1}[o]; // 对幂次影响, 分子+1, 分母-1,      a[o][v-s[o]] /= p;    }    (ans *= power+1) %= MOD;  }  rep(i,0,k) (ans *= (1+(a[0][i] != 1)))%=MOD; // &gt; P 的质数因子  printf(&quot;%lld\n&quot;,ans);}</code></pre><h1 id="H-Eat-Them-All"><a href="#H-Eat-Them-All" class="headerlink" title="H - Eat Them All"></a>H - Eat Them All</h1><p>3 x 3的矩阵</p><p>上面数字aij</p><p>(1,1) 出发, 每次, 当前-1(保证非负), 再四临移动</p><p>当所在为0时,终止</p><p>现在需要找一个方案消耗所有值并回到(1,1), 输出具体方案</p><h2 id="范围-4"><a href="#范围-4" class="headerlink" title="范围"></a>范围</h2><p>aij [1,100]</p><p>2 s</p><p>1024 mb</p><h2 id="我的思路-4"><a href="#我的思路-4" class="headerlink" title="我的思路"></a>我的思路</h2><p>看起来向个多重边的欧拉回路?</p><p>目前想法是本质上很多个环的叠加, 而每个环自身是每个点至多经过一次</p><p>所以 如果有办法,把数拆成多个环的和再把环拼起来就好了</p><p>其中有一点特殊的两个点构成的环</p><p>2个点 12 种</p><p>4个点4种</p><p>6个点4种</p><p>8个点5种</p><p>然后有点像解25元一次线性方程组, 看有没有解, 不过这里行为9行,所以rank不超过9</p><p>而且因为这里需要方案合并的关系 还要保证方案中可以重叠构成一个连通的</p><hr><p>然后想了一下, 4个6个8个 都是可以 由两个的 组合得到</p><p>所以可以变成 12种2个点的 线性方程组</p><hr><p>问题就是如果得到的方案可以拼接  那肯定是一种解, 但如果不能拼接 是否有办法转换成另一个线性方程组的解, 来得到有效解?</p><h2 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h2><p>考虑9点12边的二分图</p><p>指定每条边通过的次数</p><p>每个点的值和它的出度/入度相等</p><p>移除了那些未经过的边, 剩余的还是连通</p><ol><li>计算边通过的次数</li></ol><p>枚举边的选择情况2^{12}种, 做9个点的树(保证连通性), </p><p>也就是 如果有方案, 是可以拆成 树的方案+ 剩余做最大流的, 而合并树上和最大流的边代价,再做欧拉回路</p><p>确保每条边经过至少一次</p><p>然后计算最大流</p><ol start="2"><li>实际构建一个方案</li></ol><p>欧拉回路 = (dfs记录边+逆序)</p><pre><code class="cpp">vector&lt;int&gt; euler_circuit(vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; G, int n/*点*/, int m/*边*/) { // 欧拉回路    vector&lt;int&gt; path;    vector&lt;bool&gt; used(m, false); // 边是否被使用    function&lt;void(int)&gt; dfs=[&amp;](int u) {        for(auto [v,e]: G[u]) { // (点, 边)            if(!used[e]) {                used[e] = true;                dfs(v);            }        }        path.push_back(u);    };    dfs(0);    reverse(path.begin(), path.end());    return path;}</code></pre><h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc227/submissions/34449940" target="_blank" rel="noopener">https://atcoder.jp/contests/abc227/submissions/34449940</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;#include &lt;atcoder/all&gt;#define rep(i,a,n) for (int i=a;i&lt;(int)n;i++)int read(){int r;scanf(&quot;%d&quot;,&amp;r);return r;} // readconst int N = 3;const int M = N*N;const int P = 12;int a[M]; // 输入int c[1&lt;&lt;P]; // bit 中1的个数std::pair&lt;int,int&gt; i2xy(int i){ // 边id -&gt; (偶,奇)  int x = i&lt;6?i/3+i%3*3:i-6;  int y = i&lt;6?x+1:x+3;  if(x&amp;1) std::swap(x,y);  return {x,y}; // 偶 -&gt; 奇数}const int di[] = {0,1,0,-1};const int dj[] = {1,0,-1,0};std::pair&lt;int,int&gt; dec(int v){ return {v/N,v%N};}int enc(int i,int j) { return i*N+j;}template&lt; class T&gt;void f(int k, T &amp;e) {  auto [i,j] = dec(k);  rep(l,0,4){    int I=i+di[l];    int J=j+dj[l];    if(I&lt;0||J&lt;0||I&gt;=N||J&gt;=N)continue;    int K = enc(I,J);    int m=std::min(k,K); // 两个点中较小的点    m = (l&amp;1) ? m+6 : m/3+m%3*3; // 横向/纵向, 计算边id    while(e[m].flow){      e[m].flow--;      f(K, e);      printf(&quot;%c&quot;,&quot;LURD&quot;[l]); // 本来欧拉回路是 dfs 然后倒序点输出, 因为这里起点终点一致, 所以正向反向都是 构成回路, 所以直接考虑点间关系    }  }  // push(k) 常见的是写在这里, 最后reverse 点};int main(){  rep(i,0,M) a[i] = read() * 2;  rep(t,1,1&lt;&lt;P){    c[t] = c[t&amp;(t-1)]+1;    if(c[t] != M-1)continue; // 这里建树 , 所以是点-1条边    int b[M]={1}; // b[点] = 访问次数    int u[P]={}; // u[边] = 访问次数    atcoder::mf_graph&lt;int&gt;g(M+2); // 加起始和终点    const int S = M; // 源    const int T = S+1; // 汇    rep(i,0,P) {      auto [x,y] = i2xy(i);      g.add_edge(x,y,1000); // 无限容量, 这里也是对应了 mf_graph 内的边id和外的边id一致    }    rep(k,0,M-1) rep(i,0,P){ // 简易bfs      auto [x,y] = i2xy(i);      if(((t&gt;&gt;i)&amp;1) &amp;&amp; !u[i] &amp;&amp; b[x]+b[y]) {// 未访问过的边, 有访问过的点, 两点访问次数+1        u[i]++;        b[x]++;        b[y]++;      }    }    b[0]--; // 去掉bfs初始的一次    bool ok = true;    rep(i,0,M) if(!b[i]||b[i]&gt;a[i]) ok = false; // 非连通或这个树会让某个点访问次数比需求大    if(!ok)continue;    int x[] = {0,0}; // 源和汇的容量    rep(i,0,M){      int d=a[i]-b[i]; // 对于每个点剩余需要的经过次数      if(i&amp;1) g.add_edge(i,T,d);      else g.add_edge(S,i,d);      x[i&amp;1] += d;    }    if(x[0]!=x[1] || g.flow(S,T) != x[0]) continue; // 最大流 未 跑满    auto e = g.edges(); // 获取边的流量    rep(i,0,P) if(u[i]) e[i].flow++; // 把树上的流量补上去    f(0,e); // 跑欧拉回路    printf(&quot;\n&quot;);    return 0;  }  printf(&quot;NO\n&quot;);  return 0;}// 边:点    点//  0: 0 &lt;=&gt; 1//  1: 3 &lt;=&gt; 4//  2: 6 &lt;=&gt; 7//  3: 1 &lt;=&gt; 2//  4: 4 &lt;=&gt; 5//  5: 7 &lt;=&gt; 8//  6: 0 &lt;=&gt; 3//  7: 1 &lt;=&gt; 4//  8: 2 &lt;=&gt; 5//  9: 3 &lt;=&gt; 6// 10: 4 &lt;=&gt; 7// 11: 5 &lt;=&gt; 8</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>D</p><p>这1643评分的蓝题也不会啊</p><p>看来 还是需要大胆猜测+归纳证明</p><p>E</p><p>dp的感觉和方向是对的, 但是问题在于说 没有考虑S也是前i项目</p><p>然后转移不是把si 插入到前面i-1中,因为这样难处理重复(我的思路方向), 而是说ti指定的话, 它的来源一定是剩余s中这个字符的第一个</p><p>并且还会有制定i,e,y后,剩余的是固定的字符串</p><p>F</p><p>还是dp但是这里是把第k大, 直接先变成大于某个值的个数,(值-&gt;个数) 而不是原来的(个数-&gt;值)</p><p>然后这里是第<code>c</code>大的想法后, 对于<code>&gt;x</code>必选,<code>==x</code>可选可不选,<code>&lt;x</code>必不选, 这样也有局部性</p><p>G</p><p>emmm 可以说数筛小的值,学了自己也用了无数次了, 对于大的来说, 这样限定了一个范围, 这样想我是真没想到,</p><p>感觉需要一个思维陷入一个方向以后跳出来机制</p><p>H</p><p>感觉算欧拉回路相关的知识点</p><p>一个是怎么求</p><p>一个是怎么判断</p><p>这么说起来 如果有了指定树,先提出一个树的步骤, 那好像解线性方程依然不行, 可能有负解? , 但如果解出就是和树合并上去即可</p><p>以及atcoder mf_graph按照顺序加边, 最后还可以取边上的流量</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://atcoder.jp/contests/arc227/editorial" target="_blank" rel="noopener">官方题解</a></p>]]></content>
      
      
      <categories>
          
          <category> Atcoder </category>
          
          <category> ABC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
            <tag> 网络流 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 第k大 </tag>
            
            <tag> 数筛 </tag>
            
            <tag> 欧拉回路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atcoder arc146 C</title>
      <link href="/Blog/2022-08-21-ac_arc146/"/>
      <url>/Blog/2022-08-21-ac_arc146/</url>
      
        <content type="html"><![CDATA[<p>C(数学,组合数,集合,dp)</p><h1 id="C-Even-XOR"><a href="#C-Even-XOR" class="headerlink" title="C - Even XOR"></a>C - Even XOR</h1><p><a href="https://atcoder.jp/contests/arc146/tasks/arc146_c" target="_blank" rel="noopener">https://atcoder.jp/contests/arc146/tasks/arc146_c</a></p><p>求多少个 元素值范围在[0,2^N)的集合满足</p><p>集合的任意偶数个数的非空子集合,元素xor均不为0</p><p>mod 998244353</p><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>先是在想 线性基, 但实际上 1 2 3 4, 也是合法的, 因为, 虽然3可以由2线性表出,但是它们是3个不是偶数个</p><hr><p>然后想转移 n -&gt; n+1</p><p>显然集合合法,它的子集也是合法</p><p>如果n 合法的方案, 拆一部分 高位填,0 另一部分高位填1, 这样的方案一定是合法, 那么 <code>ans[n][len]</code> 乘<code>2^len</code>, 贡献到<code>a[n+1][len]</code></p><p>如果对于n合法,必定不存在 a,a+高位,b,b+高位 同时存在的情况, 因此至多有一个 自身和自身+高位同时存在</p><p>那么考虑 合法的选定一个 做这种自身和高位都存在, 剩下的依然拆分, 这样依然是合法的, <code>ans[n][len] * len * 2^{len-1}</code> 贡献到<code>a[n+1][len+1]</code></p><hr><p>然后这样似乎能多次做路径计算+组合数可以做</p><p>但是问题是 这样算出来 n=3时答案=141, 而正确的是149</p><p>也就是漏情况了</p><p>可能存在 不合法的n的方案 但是赋予高位0,1 以后变成n+1的方案 就合法了?</p><p>那么就是任意在n中 的 xor(A)^xor(B) = 0, </p><p>在n+1中 = xor(A)^xor(B+高位) = 高位</p><p>也就是n+1 中所有低位产生xor = 0 的必然对应的高位个数是奇数</p><p>不会推了</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>$S$如果合法</p><p>$T \subset S,size(T) = 1 \pmod 2, X = xor(T)$</p><p>如果$X$加入, 则显然$T + X$ 不合法</p><p>因此$S$ 的所有奇个数子集的xor不能被加</p><p>任意$U,V \subset S$, 且都是奇数大小</p><p>下面证明它们的xor不同</p><p>显然 如果相同, 那么两个集合元素合并起来,去掉出现两次的元素, 得到的是个偶数大小且xor = 0 的集合</p><p>得证</p><p>这里还有个好处是, 本身一个元素也是奇数个,所以不需要额外判重</p><p>个数就是经典的 ((1-1)^n + (1+1)^n)/2</p><hr><p>然后dp一下就没了</p><p>dp[0] = 1</p><p>dp[1] = 2^n</p><p>dp[i] = (dp[i-1] * (2^n - 2^{i-2})  )/i , 每个集合被统计了i次因此除以i</p><hr><p>emmm 其实我好奇, 我那个想法是不是没法搞</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/arc146/submissions/34195315" target="_blank" rel="noopener">https://atcoder.jp/contests/arc146/submissions/34195315</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;#include &lt;atcoder/modint&gt;using mint = atcoder::modint998244353;typedef long long ll;const int MOD = 998244353;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readmint inv[200010] = {0,1};mint _pwr2[200010] = {0,1}; // 令 2^-1 = 0mint *pwr2 = _pwr2+1;int main(){  int n = read();  rep(i,2,n+1+1) inv[i] = (MOD-MOD/i) * inv[MOD%i];  rep(i,1,n+1) pwr2[i] = pwr2[i-1]*2;  mint ans = 1; // dp[0] + dp[1] * (1+k1(1+k2(1+k3(...)))), dp[n+2] = 0  per(i,1,n+1+1) (ans *= (pwr2[n] - pwr2[i-2]) * inv[i]) += 1;  printf(&quot;%d\n&quot;,ans.val());  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>C</p><p>感觉不知道怎么找切入点, 事后看起来也觉得显然, 也没有不会的知识点</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://atcoder.jp/contests/arc146/editorial" target="_blank" rel="noopener">官方题解</a></p>]]></content>
      
      
      <categories>
          
          <category> Atcoder </category>
          
          <category> ARC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> 数学 </tag>
            
            <tag> 组合数 </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atcoder abc226</title>
      <link href="/Blog/2022-08-13-ac_abc226/"/>
      <url>/Blog/2022-08-13-ac_abc226/</url>
      
        <content type="html"><![CDATA[<p>F(DP,组合数,gcd)G(贪心)H(概率论,微积分)</p><h1 id="F-Score-of-Permutations"><a href="#F-Score-of-Permutations" class="headerlink" title="F - Score of Permutations"></a>F - Score of Permutations</h1><p>排列P, </p><p>初始,i号人有球i</p><p>每次 所有 i != pi 的人, 把球给pi号人</p><p>在 &gt; 0 次后,如果所有人又是i号人有球i, 那么就停止</p><p>分数 = 最小的次数</p><hr><p>求所有排列方案 的分数的k次方的和</p><p>mod 998244353</p><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>N 50</p><p>k 1e4</p><p>2 s</p><p>1024 mb</p><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>很明显, 交换的圈构成环, 次数 = lcm(每个环长)</p><p>N 很小, 是不是可以枚举因数</p><p><code>dp[i][j] =</code> 使用i个,最大是j,的<code>{lcm,方案数}</code></p><p><code>dp[i][j]</code> 贡献来自 <code>dp[i- tm][m],m &gt; j, t &gt; 0</code>, 即<code>n-i+tm</code>个中选<code>tm</code>个, 然后分成<code>t</code>组每组m个</p><p>因为组合tm中分成t组,每组m个</p><p>这样想,tm中最小的作为开头,依次剩下的选m-1个, 然后剩余就是(t-1)m 同样的</p><p>这样每次考虑最小的所在环, 就不重不漏</p><p>$\binom{n-i+tm}{tm} A(tm-1,m-1) \cdot A((t-1)m-1,m-1) \cdots$</p><p>$ = \binom{n-i+tm}{tm} \frac{(tm)!}{m\cdot 2m \cdots tm}$</p><p>$ = \binom{n-i+tm}{tm} \frac{(tm)!}{m^t * t!}$</p><p>似乎就对了</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc226/submissions/33934208" target="_blank" rel="noopener">https://atcoder.jp/contests/abc226/submissions/33934208</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;#include &lt;atcoder/modint&gt;using mint = atcoder::modint998244353;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readll gcd(int a,int b){ return b == 0? a: gcd(b,a%b);}map&lt;int,mint&gt; dp[60][60]; // dp[选最小i个][最大的环为j] = {lcm, count}mint fac[100] = {1};mint ifac[100];mint binom(int n,int m) { return fac[n] * ifac[m] * ifac[n-m];}int main(){  rep(i,1,51) fac[i] = fac[i-1] * i;  ifac[50] = fac[50].inv();  per(i,0,50) ifac[i] = ifac[i+1] * (i+1);  int n = read();  int k = read();  dp[0][0][1] = 1;  rep(i,1,n+1) rep(j,1,i+1){    mint invj = mint(j).inv();    rep(t,1,n+1){      int oldi = i - j*t; // [i - j*t][&lt;j]      if(oldi &lt; 0) break;      rep(k,0,j) for(auto [lcm,cnt]: dp[oldi][k]){        dp[i][j][lcm * j / gcd(lcm,j)] += cnt * binom(n-oldi,j*t) * fac[j*t] * ifac[t] * invj.pow(t);      }    }  }  mint ans = 0;  rep(j,1,n+1) for(auto [lcm,cnt]:dp[n][j]) ans += cnt * mint(lcm).pow(k);  printf(&quot;%d\n&quot;,ans.val());  return 0;}</code></pre><h1 id="G-The-baggage"><a href="#G-The-baggage" class="headerlink" title="G - The baggage"></a>G - The baggage</h1><p>重量1~5的物品每个Ai个</p><p>搬运能力1~5的人每个Bi个</p><p>问是否有方法, 让所有物品被至少一个人搬运,且每个人搬运的物品重量和不大于他的能力</p><p>一共T个询问</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>T 5e4</p><p>Ai,Bi [0,10^16]</p><p>2s</p><p>1024mb</p><h2 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h2><p>一样看上去, 枚举或者数学题</p><p>考虑 物品重量不超过5的组合</p><p>再 组合x能力, 应该大概有 5x2^5以内的选项 </p><p>每个选项有限制, 一些之间的和小于等于Bi, 一些之间的和 = Ai, 看是否有方案</p><p>似乎变成2sat? 然后是 偏序的样子, 但Ai,Bi范围大, 似乎没法那么多点</p><hr><p>另一个从能力从小到大</p><p>能力1的只能消耗重量1,那么贪心</p><p>能力2的可以消耗 1个2,2个1,1个1, 而如果同时有1个2和2个1, 显然后面的更灵活,所以贪心消耗1个2,再消耗1</p><p>能力3的也是先1个3,然后2+1,然后剩余1</p><p>能力4的,先1个4, 问题来了, 是3+1先还是2+2先呢? 如果都考虑3+1还是2+2了, 说明4消耗完了,对5来说 5,3,2,1的处理肯定先整个5,然后先3找2,再去2+2+1</p><p>所以对于4来说,先2+2,后3+1</p><p>就这样? 似乎贪心就没了?</p><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readint n;ll a[10];ll b[10];vector&lt;vector&lt;pair&lt;int,int&gt; &gt; &gt; child[10];void w(){  rep(i,1,5+1) a[i] = read();  rep(i,1,5+1) b[i] = read();  rep(i,1,5+1) per(j,1,i+1) for(auto arr: child[j]){    ll c = b[i];    for(auto [v,t]:arr) c = min(c, a[v] / t);    b[i] -= c;    for(auto [v,t]:arr) a[v] -= c*t;  }  ll s = 0;  rep(i,1,5+1) s += a[i];  printf(&quot;%s\n&quot;,s == 0 ? &quot;Yes&quot; : &quot;No&quot;);}int main(){  child[1] = {    {{1,1}} // 1  };  child[2] = {    {{2,1}}, // 2    {{1,2}} // 1+1  };  child[3] = {    {{3,1}}, // 3    {{2,1},{1,1}}, // 2+1    {{1,3}} // 1+1+1  };  child[4] = {    {{4,1}}, // 4    {{2,2}}, // 2+2    {{3,1},{1,1}},// 3+1    {{2,1},{1,2}}, // 2+1+1    {{1,4}} // 1+1+1+1  };  child[5] = {    {{5,1}}, // 5    {{4,1},{1,1}}, // 4+1    {{3,1},{2,1}}, // 3+2    {{3,1},{1,2}}, // 3+1+1    {{2,2},{1,1}}, // 2+2+1    {{2,1},{1,3}}, // 2+1+1+1    {{1,5}} // 1+1+1+1+1  };  int t = read();  while(t--) w();  return 0;}</code></pre><p>但ac x15, wa x33</p><p>看起来贪假了</p><hr><p>原因大概是<code>{1,5}</code> 优先级比<code>{3,1},{1,1}</code> 高了?</p><p>调了半天优先顺序都没对</p><p>好神奇啊这题</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>还是贪心,</p><p>但是说</p><p>5拿5</p><p>4拿4</p><p>5拿4</p><p>3拿3</p><p>5拿3</p><p>4拿3</p><p>5拿2</p><p>4拿2</p><p>3拿2</p><p>2拿2</p><p>5拿1</p><p>4拿1</p><p>3拿1</p><p>2拿1</p><p>1拿1</p><p>????????????? 学不会</p><p>tourist 都wa了一次</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc226/submissions/33953558" target="_blank" rel="noopener">https://atcoder.jp/contests/abc226/submissions/33953558</a></p><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readint n;ll a[10];ll b[10];void pack(ll x, ll y) {  ll c = min(a[x], b[y]);  a[x] -= c;  b[y] -= c;  if(y-x) b[y - x] += c; // c个工人的负重还剩下y-x  return;}void w(){  rep(i,1,5+1) a[i] = read();  rep(i,1,5+1) b[i] = read();  per(i,1,5+1){    pack(i,i);    per(j,i+1,5+1) pack(i,j);    pack(i,i);  }  bool ans = true;  rep(i,1,5+1)if (a[i] &gt; 0)ans = false;  printf(&quot;%s\n&quot;, ans? &quot;Yes&quot;: &quot;No&quot;);}int main(){  int t = read();  while(t--) w();  return 0;}</code></pre><h1 id="H-Random-Kth-Max"><a href="#H-Random-Kth-Max" class="headerlink" title="H - Random Kth Max"></a>H - Random Kth Max</h1><p>N 个随机量</p><p>Xi 均匀分布于[Li,Ri]的实数区间</p><p>输出 期望 E(第k大的元素) mod 998244353</p><h2 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h2><p>N 50</p><p>Li,Ri 100</p><p>2 s</p><p>1024 mb</p><h2 id="我的思路-2"><a href="#我的思路-2" class="headerlink" title="我的思路"></a>我的思路</h2><p>概率论, 日常不会</p><p>如果指定了哪个是第k大的, 那么剩下有k-1个小于等于它的(虽然等于可能带来重复计算,但是在样本区间是连续的里面,单个的不会影响</p><p>但问题是如果制定了第k大的,它依然是区间而不是值</p><p>$v_i \in [L_i,R_i]$</p><p>其它的不大于它的概率为 $p_j = (v_i-l_j)/(r_j-l_j)$</p><p>感觉上会变成v的k次方的表达式</p><p>然后再积分??</p><p>不会了</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>考虑其分布函数 $F_X(x) = P(X \le x) = x$</p><p>$P(a &lt; X \le b ) = F(b) - F(a)$</p><p>$F(x) = \int_{-\infty}^x f(t)dt.$</p><p>若$X$在$[a,b]$之间分布</p><p>$1 = \int_{a}^b f(x)dx,$</p><p>$E \lbrack X \rbrack = \int_{a}^b xf(x)dx,$</p><p>$ = \int_{a}^b x d F(x) $</p><p>$ = (bF(b) - aF(a)) - \int_{a}^b F(x) d x $</p><p>$ = b - \int_{a}^b F(x) d x $</p><p>$ = a + (b - a) + \int_{a}^b -F(x) d x $</p><p>$ = a + \int_{a}^{b} (1 - F(x)) dx.$</p><hr><p>考虑子问题</p><p>N个随机变量都是 (0,1) 随机分布, 求第k大的数的期望</p><p>比x大的期望是$1-x$ 比x小的期望是$x$</p><p>因此第k大的数比x大的期望是 $1-F(x) = \overline{F}(x) = \sum_{i=k}^n \binom{n}{i} (1-x)^i x^{n-i}.$</p><p>解释一下,就是n个中选$i = [k\cdots n]$个大于x, 而剩余的小于x</p><p>根据上面的期望表达式有(这里用了beta function</p><p>$\begin{aligned}<br>f(n,k) &amp;= E\lbrack X \rbrack \\<br>&amp;= \int_{0}^{1} \left\lbrace \sum_{i=k}^n \binom{n}{i} (1-x)^i x^{n-i} \right\rbrace dx \\<br>&amp;= \sum_{i=k}^n \binom{n}{i}  \int_{0}^{1} (1-x)^i x^{n-i} dx \\<br>&amp;= \sum_{i=k}^n \binom{n}{i} \frac{i!(n-i)!}{(n+1)!} \\<br>&amp;= \sum_{i=k}^n \frac{n!}{i!(n-i)!} \frac{i!(n-i)!}{(n+1)!} \\<br>&amp;= \sum_{i=k}^n \frac{1}{n+1} \\<br>&amp;= \frac{n-k+1}{n+1} \\<br>&amp;= 1 - \frac{k}{n+1}.<br>\end{aligned}$</p><h3 id="Beta-Function-Gamma-Function"><a href="#Beta-Function-Gamma-Function" class="headerlink" title="Beta Function, Gamma Function"></a>Beta Function, Gamma Function</h3><p>beta function , $\forall P,Q &gt; 0$</p><p>$B(P,Q) = \int_0^1 x^{P-1}(1-x)^{Q-1}dx$</p><p>Gamma Function</p><p>$\Gamma(x) \equiv \int_0^{+\infty} t^{x-1}  \mathrm{e} ^{-t}  \,\mathrm{d}{t}  \qquad (x &gt; 0)$</p><p>$x! = \Gamma(x+1)$</p><p>$B(P,Q) = \frac{\Gamma(P)\Gamma(Q)}{\Gamma(P+Q)}$</p><p>对于整数$m,n$ 有 $\int_{0}^{1} x^m (1-x)^n dx = B(m+1,n+1) = \frac{\Gamma(m+1)\Gamma(n+1)}{\Gamma(n+m+2)} = \frac{m!n!}{(m+n+1)!},$</p><h2 id="回到原问题"><a href="#回到原问题" class="headerlink" title="回到原问题"></a>回到原问题</h2><p>!!!!!拆线段, 让每个值都在 多个长度为1的线段里分布,再计算答案</p><p>对于每个线段<code>[A,A+1]</code>算dp,最后算贡献</p><p><code>dp[i][j][t] =</code> 前i个随机变量, j个大于A+1, t 个在<code>[A,A+1]</code> 之间 的概率</p><p>第<code>i</code>无非3种, <code>&lt; A</code>, <code>[A,A+1]</code>之间<code>&gt; A+1</code></p><p><code>&lt; A</code>: <code>+dp[i-1][j][t] * (min(A,ri)-li)/(ri-li)</code>, 需要<code>A &gt;= li</code></p><p><code>[A,A+1]</code>: <code>+dp[i-1][j][t-1] * 1/(ri-li)</code>, 且<code>[A,A+1]</code> 在<code>[li,ri]</code> 之间</p><p><code>&gt; A</code>: <code>+dp[i-1][j-1][t] * (ri-max(li,(A+1)))/(ri-li)</code>, 需要 <code>ri &gt;= A+1</code></p><p>滚动可以空间$O(N^2)$</p><hr><p><code>j</code>个大于<code>A+1</code>, <code>t</code>个在<code>[A,A+1]</code>中, 那么第<code>k</code>大的期望就是 <code>[A,A+1]</code>中第<code>k-j</code>大的期望</p><p>那么<code>[A,A+1]</code> 对答案的贡献, $\sum dp_{n,j = 0 \cdots n, t = 0 \cdots n} \cdot (A + 1 - \frac{k-j}{t+1})$ </p><p>看起来$O(n^4)$ 但是有些状态达不到, 常数一般 </p><hr><p>看起来还有$O(N^3)$ 甚至 taylor shift 分治可以$N^2 log^2 N$ 的做法</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc226/submissions/34060577" target="_blank" rel="noopener">https://atcoder.jp/contests/abc226/submissions/34060577</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;#include &lt;atcoder/modint&gt;using mint = atcoder::modint998244353;using namespace std;typedef long long ll;#define MOD 998244353#define rep(i,a,n) for (int i=a;i&lt;(int)n;i++)#define per(i,a,n) for (int i=n;i--&gt;(int)a;)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readll inv[110] = {0,1}; // inv[i] = 1/iint l[60];int r[60];int main() {  rep(i,2,100+1) inv[i] = (MOD-MOD/i) * inv[MOD%i] % MOD;  int n = read();  int K = read();  rep(i,1,n+1){    l[i] = read();    r[i] = read();  }  int minl = *min_element(l+1,l+n+1);  int maxr = *max_element(r+1,r+n+1);  mint ans = 0;  rep(A,minl,maxr){// 处理区间[A,A+1]    // dp[i][j][t] = 前i个, j个大于, t个在`[A,A+1]`, 滚动掉一个维度    auto dp = vector(n+1,vector&lt;mint&gt;(n+1,0));    dp[0][0] = 1;    rep(i,1,n+1){      int invrl = inv[r[i]-l[i]];      per(j,0,i+1) if(j &lt;= K) per(t,0,i-j+1){        // val[i] &lt; A        dp[j][t] = (l[i] &lt;= A) ?                  dp[j  ][t  ]*(min(r[i],A) - l[i])*invrl : 0;        // val[i] \in [A,A+1]        if(l[i]&lt;=A &amp;&amp; A+1&lt;=r[i] &amp;&amp; t) dp[j][t] += dp[j  ][t-1]                     *invrl;        // val[i] &gt; A+1        if(A+1&lt;=r[i] &amp;&amp; j )           dp[j][t] += dp[j-1][t  ]*(r[i]-max(l[i],A+1))*invrl;      }    }    rep(j,0,K) rep(t,0,n+1) if (K-j &lt;= t) ans += dp[j][t] * (A+1-(K-j)*inv[t+1]);  }  printf(&quot;%d\n&quot;,ans.val());  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>F</p><p>dp 组合数, 主要是看到和很小,所以lcm估计也很少,没啥难的</p><p>G</p><p>贪心完全不会</p><p>H</p><p>概率论完全不会, 这里思路还是积分类的</p><p>就是对于连续的概率分布,转变成 概率分布以后,就方便计算分布函数的概率,而不是单点的概率表达式, 这样再反推概率表达式也行, 直接得到E(X)也行</p><p>这个拆线段也是很神奇, 没想到, 感觉大量的dp做的还是离散的,这里的有针对这种连续的处理方法</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://atcoder.jp/contests/abc226/editorial" target="_blank" rel="noopener">官方题解</a></p><p><a href="https://baike.baidu.com/item/%E8%B4%9D%E5%A1%94%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">贝塔函数 百度百科</a></p><p><a href="https://wuli.wiki/changed/Gamma.html" target="_blank" rel="noopener">wuli.wiki gamma</a></p>]]></content>
      
      
      <categories>
          
          <category> Atcoder </category>
          
          <category> ABC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
            <tag> 概率论 </tag>
            
            <tag> 微积分 </tag>
            
            <tag> beta function </tag>
            
            <tag> Gamma Function </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>maspy 生成方程与问题解决</title>
      <link href="/Blog/2022-08-12-generate_function/"/>
      <url>/Blog/2022-08-12-generate_function/</url>
      
        <content type="html"><![CDATA[<h1 id="生成方程"><a href="#生成方程" class="headerlink" title="生成方程"></a>生成方程</h1><p>感谢google翻译和maspy大佬的几篇博客, 见下方链接</p><p>用很多例子来实例如何使用 多项式乘积</p><p>状態ごとに何らかの値が計算されているときに、その計算結果を多項式の形で持ちます。この際、 「多項式の次数」が「考えている状態」、「係数」が状態ごとの「計算した値」（多くの場合、数え上げ）を表すように多項式を持つのが原則です。</p><p>括号内是或关系, 括号间幂次是加和关系,系数是代价倍数一般是1</p><p>翻译了一下, 统一了一下格式,增加了一些步骤</p><p>以下未强调的都是非负整数</p><p>注意的是有不少都可以写成无限次方的上限,因为超过n不会影响n,看具体情况哪个更好用用哪个</p><h2 id="maspy-1-如何把问题转化"><a href="#maspy-1-如何把问题转化" class="headerlink" title="maspy 1 如何把问题转化"></a>maspy 1 如何把问题转化</h2><blockquote><p>问题1, $A=\{2,3\},B=\{2,4\},C=\{3,5,7\} , a+b+c=n$ 有多少种方法可以</p></blockquote><p>$\lbrack x^n \rbrack (x^2+x^3)(x^2+x^4)(x^3+x^5+x^7)$, 就是乘开后$n$次项的系数</p><blockquote><p>问题2. $a \le 2,b\le 3,c\le 4, a+b+c = n$ 有多少种</p></blockquote><p>$\lbrack x^n \rbrack (1+x+x^2)(1+x+x^2+x^3)(1+x+x^2+x^3+x^4)$</p><blockquote><p>问题3. 无限制的$a,b,c \ge 0, a+b+c=n$ 有多少种</p></blockquote><p>$\lbrack x^n \rbrack (1+x+x^2+\cdots)^3$</p><p>$\lbrack x^n \rbrack (1+x+x^2+\cdots+x^n)^3$, (因为高次不影响n</p><blockquote><p>问题4(ABC149E), $A=\{a_1,a_2,\cdots,a_k\}, n = a_i + a_j$ 有多少种</p></blockquote><p>$\lbrack x^n \rbrack (x^{a_1}+x^{a_2}+\cdots+x^{a_k})^2$</p><blockquote><p>问题5, 从1开始,每次+2或+3, 恰好n次移动到N的方案数</p></blockquote><p>$\lbrack x^{N-1} \rbrack (x^2+x^3)^n$, 从增量的角度</p><p>$\lbrack x^{N} \rbrack x(x^2+x^3)^n$, 从状态的角度</p><blockquote><p>问题6, 从1开始,每次+2或+3, 移动到N的方案数</p></blockquote><p>$\lbrack x^{N-1} \rbrack \sum_{n=0}^{\infty}(x^2+x^3)^n$</p><p>$\lbrack x^{N-1} \rbrack \sum_{n=0}^{\frac{N}{2}}(x^2+x^3)^n$</p><blockquote><p>问题7, 1元,5元,10元有无限多, 组合成n元方案数</p></blockquote><p>$\lbrack x^{n} \rbrack (1+x^1+x^2+x^3+\cdots)(1+x^5+x^{10}+x^{15}+\cdots)(1+x^{10}+x^{20}+x^{30}+\cdots)$</p><blockquote><p>问题8, 重量分别$w_i$, 总重量不超过$W$ 有多少方案</p></blockquote><p>$\sum_{n=0}^W \lbrack x^n \rbrack (1+x^{w_1})(1+x^{w_2})\cdots (1+x^{w_k})$</p><p>$\sum_{n=0}^{W}[x^n]\prod_{i=1}^k$</p><blockquote><p>问题9, $0\le a_i \le N$, $a_1+\cdots+a_8=6N$ $a_i$的方案数</p></blockquote><p>$\lbrack x^{6N} \rbrack (1+x^1+x^2+\cdots+x^N)^8$</p><blockquote><p>问题10, $0\le a,b,c \le N$且为素数,$a+b+c$ 也是素数方案数</p></blockquote><p>$\sum_{p=2}^{3N} \lbrack x^{p} \rbrack (x^2+x^3+x^5+x^7+\cdots+x^{prime,\le N})^3$, 且$p$为素数</p><blockquote><p>问题11, $N$ 拆成正整数求和表达式(关心顺序)</p></blockquote><p>$\sum_{n=1}^{\infty} \lbrack x^{N} \rbrack (x^1+x^2+x^3+\cdots+x^N)^n$</p><p>$\sum_{n=1}^{N} \lbrack x^{N} \rbrack (x^1+x^2+x^3+\cdots+x^N)^n$</p><p>$\lbrack x^{N} \rbrack \sum_{n=1}^{N} (x^1+x^2+x^3+\cdots+x^N)^n$</p><blockquote><p>问题12, $N$ 拆成正整数求和表达式, 但是数字从小到大(不关心顺序)</p></blockquote><p>$\lbrack x^{N} \rbrack \prod_{k=1}^{\infty} (\sum_{i=0}^{\infty} x^{ki})$, 相当于数字相同的视作一致,只有每个的数字的个数</p><p>$\lbrack x^{N} \rbrack \prod_{k=1}^{n} (\sum_{i=0}^{n} x^{ki})$</p><blockquote><p>问题13, $N$ 拆成多个不同整数的和, 但是数字从小到大(不关心顺序)</p></blockquote><p>$\lbrack x^{N} \rbrack \prod_{k=1}^{\infty} (1+x^k)$, 选或不选</p><p>$\lbrack x^{N} \rbrack \prod_{k=1}^{N} (1+x^k)$</p><blockquote><p>问题14, $N,M &gt; 0, 0 &lt; A_1 \le A_2 \le \cdots \le A_N = M$, 相邻$A_i$的差在$[3,5]$, 求方案数</p></blockquote><p>$\lbrack x^M \rbrack (x^1+x^2+\cdots+x^M)(x^3+x^4+x^5)^{N-1}$, 相当于一个是$A_1$ 的选择,后面是增加到$A_N$的选择</p><blockquote><p>问题15, $N,M &gt; 0, 0 &lt; A_1 \le A_2 \le \cdots \le A_N &lt; M$, 相邻$A_i$的差在$[3,5]$, 求方案数, 和上面不同的是最后</p></blockquote><p>$\sum_{m=0}^{M-1} \lbrack x^m \rbrack (x^1+x^2+\cdots+x^m)(x^3+x^4+x^5)^{N-1}$, 相当于枚举$A_N$的值</p><p>$\lbrack x^M \rbrack (x^1+x^2+\cdots+x^M)(x^3+x^4+x^5)^{N-1}(x^1+x^2+\cdots+x^M)$, 相当于想象多一个$A_{N+1} = M$</p><blockquote><p>问题16, $[1,6]$的骰子,扔100次, 总和为$n$的概率</p></blockquote><p>$\lbrack x^{n} \rbrack (\frac{x^1+x^2+x^3+x^4+x^5+x^6}{6})^{100}$ 这里系数终于不是1了,而是概率倍数的贡献</p><blockquote><p>问题17, $p+q = 1,p,q\ge 0$是 实数概率, $p$概率$+1$,$q$概率$-1$, 总和$=100$的概率</p></blockquote><p>$\lbrack x^{n} \rbrack (px+qx^{-1})^{100}$ , 这里一个是再次展示了系数,一个是出现了负数幂次, 称作 Laurent polynomial, 几乎没有区别 </p><p>$\lbrack x^{n+100} \rbrack x^{100}(px+qx^{-1})^{100}$</p><p>$\lbrack x^{n+100} \rbrack (px^2+q)^{100}$</p><blockquote><p>问题18(AGC013E), 对N划分成有序的正整数的和, 划分后 获得价值 = 所有正整数的平方的乘积, 求所有方案的 价值和</p></blockquote><p>$\lbrack x^N \rbrack \sum_{n=0}^{N} (x+4x^2+9x^3+16x^4+\cdots+N^2x^N)^n$, 代价拆散到每个选择上</p><h3 id="高维"><a href="#高维" class="headerlink" title="高维"></a>高维</h3><blockquote><p>问题19, A:3元,4克; B:5元,6克, 每个最多选2个, 构成n元,m克的方案数</p></blockquote><p>$\lbrack x^ny^m \rbrack (1+x^3y^4+x^6y^8)(1+x^5y^6+x^{10}y^{12})$</p><blockquote><p>问题20, 1元,5元,10元,无限个, 用n个,组成m元方案数</p></blockquote><p>$\lbrack x^my^n \rbrack (1+x^1y^1+x^2y^2+x^3y^3+\cdots)(1+x^5y^1+x^{10}y^2+x^{15}y^3+\cdots)(1+x^{10}y^1+x^{20}y^2+x^{30}y^3+\cdots)$</p><blockquote><p>问题21(ARC012D), 每次随机$x\pm 1$或$y\pm 1$, 问$(0,0)$在恰好$T$次走到$(a,b)$的概率</p></blockquote><p>$\lbrack x^ay^b \rbrack (\frac{x+x^{-1}+y+y^{-1}}{4})^T$</p><blockquote><p>问题22, $x,y,z$ 每次随机一个$\pm 1$或 全部一起$\pm 1$, 问$(0,0,0)$在恰好$T$次走到$(a,b,c)$的方案数</p></blockquote><p>$\lbrack x^ay^bz^c \rbrack (x+x^{-1}+y+y^{-1}+z+z^{-1}+xyz+(xyz)^{-1})^T$, 很能表达或关系</p><p><a href="https://maspypy.com/atcoder-k-one-or-all%ef%bc%88kupc-2019%ef%bc%89" target="_blank" rel="noopener">21,22, maspy 具体计算方案</a></p><blockquote><p>问题23, $(x,y,z)$ 每次任意非0正增量,任意维度变化$\ge 0$, 至少一个维度变化$ &gt; 0$, 求原点到$(a,b,c)$的方案数</p></blockquote><p>$\lbrack x^ay^bz^c \rbrack \sum_{n=0}^{\infty} ((1+x+x^2+x^3+\cdots)(1+y+y^2+y^3+\cdots)(1+z+z^2+z^3+\cdots) - 1)^n$</p><blockquote><p>问题24, $(x,y,z)$ 每次随机一个方向随机$\pm 1$, T次,$3a+4b+5c=n$的概率</p></blockquote><p>$\sum_{3a+4b+5c=n} \lbrack x^ay^bz^c \rbrack (\frac{x+x^{-1}+y+y^{-1}+z+z^{-1}}{6})^T$</p><p>$\lbrack t^n \rbrack (\frac{t^3+t^{-3}+t^4+t^{-4}+t^5+t^{-5}}{6})^T$, 其实对各个坐标没限制 只对总和限制,$3,4,5$看成贡献倍数</p><h2 id="maspy-2-如何计算"><a href="#maspy-2-如何计算" class="headerlink" title="maspy 2 如何计算"></a>maspy 2 如何计算</h2><h3 id="二项式定理"><a href="#二项式定理" class="headerlink" title="二项式定理"></a>二项式定理</h3><p>$(x+y)^n = \sum_{i=0}^{n} \binom{n}{i} x^iy^{n-i}$</p><p>其中$\binom{n}{i} = \frac{n!}{i!(n-i)!}$是排列数, 为了方便当$ i &lt; 0 $或$ i &gt; n$ 时令它为$0$</p><p>$(x+y)^n = \sum_{i=0}^{\infty} \binom{n}{i} x^iy^{n-i}$</p><h3 id="等比数列求和"><a href="#等比数列求和" class="headerlink" title="等比数列求和"></a>等比数列求和</h3><p>$r\neq 1$时</p><p>$\sum_{i=0}^{n} r^i = \frac{1-r^{n+1}}{1-r}$</p><h3 id="形式幂级数-运算法则"><a href="#形式幂级数-运算法则" class="headerlink" title="形式幂级数 运算法则"></a>形式幂级数 运算法则</h3><p>形式幂级数 $F = \sum_{n=0}^{\infty} f_nx^n$</p><p>若$G = \sum_{n=0}^{\infty} g_nx^n$</p><p>加减: $\lbrack x^n \rbrack (F\pm G) = f_n \pm g_n$</p><p>乘法: $\lbrack x^n \rbrack (FG) =  \sum_{i+j=n}f_ig_j.$</p><p>在运算中可以 只考虑 小于等于 $x^n$的部分</p><p>满足,交换律,结合律,分配律, 被称作 环</p><h3 id="形式的べき級数環の位相"><a href="#形式的べき級数環の位相" class="headerlink" title="形式的べき級数環の位相"></a>形式的べき級数環の位相</h3><p>形式的べき級数$F$は、最低次の項が高いほど、 $0$に近いと考えて扱います。このことを利用して、形式的べき級数の列の極限を定義することができます：</p><p>【定義】</p><p>形式的べき級数列$F1,F2,F3\cdots F$ に収束するとは、任意の$k$ に対してある$N$が存在して、$n\ge N$ ならば $F_n$ と $F$ の $k$ 次未満部分が一致することを指す。</p><p>我没看懂翻译以后的XD</p><h3 id="形式幂级数的倒数"><a href="#形式幂级数的倒数" class="headerlink" title="形式幂级数的倒数"></a>形式幂级数的倒数</h3><p>$FG = 1$, 则$F = \frac{1}{G}$</p><p>也可以和正常分数类似的计算规则$\frac{F_1}{G_1}\pm\frac{F_2}{G_2}=\frac{F_1G_2\pm F_2G_1}{G_1G_2}$</p><p>最常用的一个</p><p>$\frac{1}{1-x} = 1 + x + x^2 + x^3 + x^4 + \cdots = \sum_{n=0}^{\infty}x^n$</p><p>因为$(1-x)(1+x+x^2+x^3+\cdots) $, 而对于一个具体$x^n$ 前面乘了以后会变成$1-x^{\infty}$, 又高于$x^n$不会对$x^n$的系数有影响, 所以即使 从级数收敛角度看起来 $x \ge 1$ 时它不收敛, 但从求系数意义上它是合理 </p><p>对于<strong>没有常数项的</strong>多项式 $F$, 也有, 原理也是相同的, 也需要注意没有常数项</p><p>$\frac{1}{1-F} = 1 + F + F^2 + F^3 + F^4 + \cdots  = \sum_{n=0}^{\infty}F^n.$</p><h3 id="幂级数-示例"><a href="#幂级数-示例" class="headerlink" title="幂级数 示例"></a>幂级数 示例</h3><blockquote><p>问题 N拆成正整数和的表达式</p></blockquote><p>前面已经有转换了</p><p>$\lbrack x^N \rbrack \sum_{n=0}^{\infty} (x+x^2+x^3+\cdots)^n$</p><p>然后利用这里幂级数</p><p>$ = \lbrack x^N \rbrack \sum_{n=0}^{\infty} (\frac{x}{1-x})^n$</p><p>$ = \lbrack x^N \rbrack \frac{1}{1- \frac{x}{1-x}}$</p><p>$ = \lbrack x^N \rbrack \frac{1-x}{1-2x}$</p><p>$ = \lbrack x^N \rbrack (1-x)(1+2x+4x^2+8x^3+\cdots)$</p><p>$ = 2^N - 2^{N-1}$</p><p>$ = 2^{N-1} $</p><p>同样在分数过程也可以简化掉 分子</p><p>$ = \lbrack x^N \rbrack \frac{1-x}{1-2x}$</p><p>$ = \lbrack x^N \rbrack \frac{1}{2} + \frac{1}{2} \cdot \frac{1}{1-2x}$</p><p>$ = \lbrack x^N \rbrack \frac{1}{2} + \frac{1}{2}(1+2x+4x^2+8x^3+\cdots)$</p><h3 id="因式分解-示例"><a href="#因式分解-示例" class="headerlink" title="因式分解 示例"></a>因式分解 示例</h3><blockquote><p>问题 $\lbrack x^ay^b\rbrack(x+x^{-1}+y+y^{-1})^T$</p></blockquote><p>$ = \lbrack x^ay^b \rbrack ((xy)^{-1}(xy+1)(x+y))^T$</p><p>$ = \lbrack x^ay^b \rbrack \sum_{i,j} \binom {T}{i}\binom{T}{j}x^{i+j-T}y^{i-j}.$</p><p>只会有唯一的$(i,j)$</p><h3 id="积累和-推到-dp转换"><a href="#积累和-推到-dp转换" class="headerlink" title="积累和 推到 dp转换"></a>积累和 推到 dp转换</h3><blockquote><p>问题 $xi \in [0,a_i]$, 选择$x_1+\cdots+x_N = M$, 找出方案数, $a_i \le M \le 10^5, N \le 100$</p></blockquote><p>$\lbrack x^M \rbrack \prod_{i=1}^N (\sum_{j=0}^{a_i} x^j)$</p><p>$\lbrack x^M \rbrack \prod_{i=1}^N \frac{1-x^{a_i+1}}{1-x}$</p><hr><p>分解成一个稀疏多项式(项少,就可以DP)的方法, $(1-x)Q = P$, 那么$p_n = q_n-q_{n-1}$, 有可以$q_n = q_{n-1}+p_n$递推</p><p>$1-x^{a_i+1}$ 也是类似, 相当于$dp[j] = dp[j] - dp[j-(a_i+1)]$</p><p>这样是$O(NM)$, 这里$NM \le 10^7$ 可做</p><p>据说$N = 1e5$ 也有方法可搞?</p><h3 id="DP的推导返回"><a href="#DP的推导返回" class="headerlink" title="DP的推导返回"></a>DP的推导返回</h3><blockquote><p>问题 $xi \in [0,a_i]$, 选择$x_1+\cdots+x_N = M$, 找出方案数<br>但是Q个独立询问, 让$x_{p_j} = c_j$<br>$a_i \le M \le 2000, N \le 2000, Q \le 500000$</p></blockquote><p>对i以外的前后缀来计算 $\prod$, 再用FFT 可以得到</p><p>另一个思路是,能否接受除法</p><p>先算出所有的$\prod$ 再除以被更改部分的</p><h3 id="交换律-和-迭代平方法"><a href="#交换律-和-迭代平方法" class="headerlink" title="交换律 和 迭代平方法"></a>交换律 和 迭代平方法</h3><p>没看懂翻译</p><hr><p>鸽</p><h3 id="负二项式定理"><a href="#负二项式定理" class="headerlink" title="负二项式定理"></a>负二项式定理</h3><p>$(1-rx)^{-d} = \sum_{n=0}^{\infty}\binom{n+d-1}{d-1}(rx)^n$</p><p>证明:</p><p>归纳+导数, 可证 <code>-d</code>成立,那么<code>-d-1</code>也成立</p><p>这个在百度百科上也有</p><p>$(1+x)^{-d} = \sum_{n=0}^{\infty} (-1)^n \binom{d+n-1}{n}x^n$</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://maspypy.com/category/%e5%bd%a2%e5%bc%8f%e7%9a%84%e3%81%b9%e3%81%8d%e7%b4%9a%e6%95%b0%e8%a7%a3%e8%aa%ac" target="_blank" rel="noopener">maspy</a></p><p><a href="https://baike.baidu.com/item/%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%AE%9A%E7%90%86" target="_blank" rel="noopener">百度百科 二项式定理推广</a></p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生成方程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atcoder abc225</title>
      <link href="/Blog/2022-08-11-ac_abc225/"/>
      <url>/Blog/2022-08-11-ac_abc225/</url>
      
        <content type="html"><![CDATA[<p>F(字符串,偏序,DP,倒着DP,局部性)G(题意转化,最小割,最大流)H(NTT,FFT,生成方程,分治,归并)</p><h1 id="F-String-Cards"><a href="#F-String-Cards" class="headerlink" title="F - String Cards"></a>F - String Cards</h1><p>给N个字符串, 恰好选其中K个, 拼接出的最小字典序的字符串是什么</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>N 50</p><p>|Si| [1,50], 每个长度</p><p>只含小写英文字母</p><p>2s</p><p>1024 mb</p><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>例如</p><p>b和ba</p><p>b &lt;= ba</p><p>但是</p><p>bab &lt;= bba</p><p>非前缀的 s1 &lt; s2, 一定s1</p><p>s1 是 s2的前缀的  s1 &lt; s2</p><p>如果只剩下一个,则s1</p><p>否则,形如</p><pre><code>[A][A][B][A][B][C][A][B][C][D][A][A] ?[A][B] [A] ?[A][B][C] [A] ?[A][B][C][D] [A] ?</code></pre><p>如果本身A和B有直接大小, 那么就能知道第一个还是后面3个,A和C再比,A和D再比</p><p>但如果A和B依然是前后缀关系, 这会考虑长度,也会考虑要选的个数</p><hr><p>少考虑一点, 对于两个</p><pre><code>AAB</code></pre><p>两种排列</p><pre><code>AABABA</code></pre><p>长度一致, 考虑是否交换</p><p>但感觉两个到三个之间局部性不知道是否成立:</p><p>(A,AB)组合A 放在前,  (AB,ABC) 组合 AB 放在前, 能否推出 (A,ABC) 中 A要放在前</p><pre><code>AABABC</code></pre><hr><p>其实我在想,是不是n^4 可以暴力dp?, 好像会是n^6?</p><p><code>dp[i][j][length]</code>, <code>前i选j,长度=length的最小前缀</code></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>有意思, 还给了一些错误解法的反例</p><blockquote><p>反例1, sort取前k个连起来</p></blockquote><p>就是我已经想到的 b, ba</p><blockquote><p>反例2, 还是sort, 保证相邻拼接 &lt; 相邻逆序拼接, 的前k 个</p></blockquote><p>这也是想到了的, 当个数为1时ba,b 还是会选b</p><blockquote><p>反例3, sort, 保证相邻拼接 &lt; 相邻逆序拼接</p></blockquote><p>定义<code>dp[i][j]=</code> 前i个选j个能得到的最小字典序</p><p><code>dp[i][j] = min(dp[i-1][j],dp[i-1][j-1] + Si)</code> 的转移方程, 输出<code>dp[N][K]</code></p><p>对于 baa,ba,b, 选出两个, 期望是baab, 而输出是baaba</p><p>应该就是没有最小的性质</p><p>前两个选1个最小是ba, 拼接b得到bab</p><p>而前两个选2个最小是baaba, 这两个都不是最小答案</p><p>最小的构成是 baab = 前两个中大的一个 和最后一个拼接</p><blockquote><p>反例4</p></blockquote><p>同样的排序, 同样的<code>dp</code>定义</p><p>但是改变转移方程</p><p><code>dp[i][j] = min(dp[i-1][j],dp[k &lt; i][j-1] + Si)</code> 的转移方程, 输出<code>dp[N][K]</code></p><p>然后</p><p>bbaba</p><p>bba</p><p>b</p><p>b</p><p>选3个也是反例</p><hr><p>其实这列我们可以看到, dp的定义 只能说是希望它是这样,一旦你的转移方程之类出现问题, 它的结果将不满足定义</p><hr><p>正确方案</p><p>尝试排序 让排序后 任意(i &lt; j) 满足,  Si+Sj &lt; Sj + Si</p><p>这里有点和我想的有没有偏序关系的问题了一样了, 怎么证明存在啊?</p><p>证明</p><p>把字符串变成数字 a,b</p><p>AB &lt; BA</p><p>等价<code>a * 26^len(B) + b &lt; b * 26^len(A) + a</code></p><p>a/(26^len(A)-1) &lt; b/(26^len(B)-1)</p><p>好有道理, 事后看起也不难, 我咋自己想不到简单转换一下就证明了</p><p>那这样整个问题就简单了</p><p>也就是 如果选定了字符串, 那么 它们的顺序就是一定的, 有偏序关系,就可以按照上面的排序来排</p><hr><p>那么这样再<code>dp[i][j]</code>= S[i..N] 中选j个能构成的最小字典需</p><p>和前面不一样的是, 变成后缀中选j个</p><p>转移方程<code>dp[i][j] = min(dp[i+1][j], S[i]+ dp[i+1][j-1])</code></p><p>显然如果<code>S[i]</code> 本来就非前缀的小于<code>S[i+1]</code>, 那么min 一定取右侧, 且子问题已经被计算了</p><p>而如果要<code>S[i]</code> 则<code>S[i]</code> 一定是开头的</p><p>答案是<code>dp[1][K]</code></p><hr><p>这里其实dp的问题在于 为啥正着做不对,而倒着的是对的?</p><p>其实问题就在于 选第i个时</p><p>正着选第 i个时, 它也在末尾, 但是并不一定意味着 前缀是<code>dp[i-1][j-1]</code>, 因为<code>dp[i-1][j-1]</code> 可能是通过长度胜出的最小,而不是字符胜出的最小,</p><p>可能有 D0 &lt; D1, 但是D0是D1前缀,</p><p>从而 D1+Si &lt; D0+Si的情况, 没有了局部性</p><p>而倒过来, Si放在最前</p><p>如果同样有 有 D0 &lt; D1, 但是D0是D1前缀</p><p>但 Si+D0 &lt; Si + D1始终成立的, 保证了局部性</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc225/submissions/33909604" target="_blank" rel="noopener">https://atcoder.jp/contests/abc225/submissions/33909604</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readchar s[60][60];int sz[60];int idx[60];char dp[60][60][2500];int main(){  int n = read();  int k = read();  rep(i,0,n) {    scanf(&quot;%s&quot;,s[i]);    sz[i] = strlen(s[i]);  }  iota(idx,idx+n,0);  sort(idx,idx+n,[=](int i,int j){      rep(p,0,sz[i]+sz[j]){        char ch0 = p &lt; sz[i] ? s[i][p] : s[j][p-sz[i]];        char ch1 = p &lt; sz[j] ? s[j][p] : s[i][p-sz[j]];        if(ch0 != ch1) return ch0 &lt; ch1;      }      return false;  });  rep(i0,0,n){    char *t = s[idx[n-1-i0]];    rep(j,0,i0+1){ // 选 j+1 个      // dp[n-1-i][j] = min(dp[n-1-i+1][j], s[n-1-i] + dp[n-1-i+1][j-1]);      strcpy(dp[i0][j], t);      if(i0 &gt; 0) {        if(j &gt; 0) strcpy(dp[i0][j] + strlen(t), dp[i0-1][j-1]);        if(i0 &gt; j &amp;&amp; strcmp(dp[i0][j], dp[i0-1][j]) &gt; 0) strcpy(dp[i0][j], dp[i0-1][j]);      }    }  }  printf(&quot;%s\n&quot;,dp[n-1][k-1]);  return 0;}</code></pre><h1 id="G-X"><a href="#G-X" class="headerlink" title="G - X"></a>G - X</h1><p><a href="https://atcoder.jp/contests/abc225/tasks/abc225_g" target="_blank" rel="noopener">https://atcoder.jp/contests/abc225/tasks/abc225_g</a></p><p>矩阵H x W, 每个上面Aij</p><p>选任意个格子,每个被选的格子画X, 连通左上右下,左下右上角</p><p>然后 分数 = 画了X的格子的数字和 - C 乘 画X的最小需要的线段数, 没有选的格子不能画,任何东西</p><p>例如这样选的话, 左下角到右上只需要一个长线段,一共是3个线段</p><pre><code> XX</code></pre><p>求 最大分数 = sum(选的格子) - C 倍最小画线段数</p><h2 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h2><p>H,W 100</p><p>C 1e9</p><p>Aij [1,1e9]</p><p>2s</p><p>1024 mb</p><h2 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h2><p>先试试形状</p><pre><code>X</code></pre><p>1个格子, -2C</p><pre><code>XXXX</code></pre><p>4个格子, -6C</p><pre><code>XXXXXXXXX</code></pre><p>9个格子, -10C</p><pre><code>XXXXXXXXXXXXXXXX</code></pre><p>16个格子,-14C</p><pre><code> XX X X</code></pre><p>4个格子,-4C</p><pre><code>  X X XX X X X X  X</code></pre><p>9个格子, -6C</p><p>收获不大至少说明一点,即使格子本身小于C,但是可以通过相邻的线段可以贯通,而让均摊下来每个减去的不到C</p><hr><p>第二个思路就是</p><p>如果一排一排的铺</p><p><code>dp[state i] =&gt; dp[state i+1]</code>, 根据上面左上角和右上角的两个是否被选决定当前选择的贡献是什么</p><p>这样 做个类似插头dp的样子, 每次转移O(1) 但是,因为要存边界状态</p><p>所以状态 高达 <code>N^2 * 2^N</code>, 分别是切割线的位置, 和 切割线的状态</p><p>这里最主要的就是 会受到它顶部两个的选择状态的影响它的贡献</p><hr><p>然后考虑说在位置上相邻,在实际填写中互不影响, 其实可以把 横纵坐标和为奇数/ 和偶数分开考虑</p><pre><code>ABABABABABABABABABAB</code></pre><hr><p>然后可以转个45度, 补成个长方形, 原来空白的地方放0,问题变成选一些数的 和 - C 乘 (纵向连续块数+横向连续块数), 这样最大答案不会变</p><pre><code>0A00AAA0AAAA0AA0</code></pre><p>但这依然有和左侧和上面的关联决定一个块的贡献</p><p>整体的考虑</p><pre><code>Y? Y</code></pre><p>如果出现这样的选择, 那么? 必然选择,因为选择它不会增加带来的收益$\ge 0$</p><p>因此在新的里面选的一定是长方形</p><p>但可能不止一个长方形</p><pre><code>000000000YY111100YY11YY001111YY0</code></pre><p>例如这样 = S - 8C</p><pre><code>000000000YYYYYY00YYYYYY00YYYYYY0</code></pre><p>而这样是 = S+10-9C</p><p>如果是C很大,则上面的更优</p><hr><p>每个长方形代价 = sum(长方形) - C 乘 (长+高)</p><p>并且显然长方形的 轮廓的 横向和 &gt;= C, 纵向和 &gt;= C,( 内部不一定</p><pre><code>YYYY1111YYYY</code></pre><p>这样是 = S - 10C</p><pre><code>YYYYYYYYYYYY</code></pre><p>这样是 = S+4 - 7C</p><p>C很大,后面会更好,但中间行和可能 &lt; C</p><hr><p>找不到什么合并不合并规则</p><hr><p>如何在100x100量级中 选多个长方形, 每个贡献 = Sum - C(长 + 宽)</p><p>让贡献最大</p><p>虽然对于单个来说, 可以矩阵前缀,很快算出单个的贡献</p><p>不太会了</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>每个选, +Aij</p><p>每个选 左上角不选, -C</p><p>每个选 右上角不选, -C</p><p>又有加又有减, 不好</p><hr><p>变化</p><p>如果你不选, Aij代价, 选无代价</p><p>每个选 左上角不选, C代价</p><p>每个选 右上角不选, C代价</p><p>这样就全是 增加了</p><p>现在答案 = sum A - 代价</p><p>要总代价最小</p><hr><p>代价最小 =&gt; 最小割问题</p><p>S源(与S同块的视作选择),T汇(与T同块的视作不选)</p><p>S -&gt; (i,j), 容量Aij, (割这条边相当于不选它 的代价)</p><p>对于左上角没有块的(i,j): (i,j) -&gt; T , 容量C (割这条边相当于选它的代价)</p><p>对于右上角没有块的(i,j): (i,j) -&gt; T , 容量C (同理,割这条边相当于选它的代价), 相当于可能重边</p><p>对于左上角有块的, (i,j) -&gt; (i-1,j-1) 容量C, (割这条边,相当于它和S同块(选择),左上角和T同块(不选择),所产生的代价)</p><p>对于右上角有块的, (i,j) -&gt; (i-1,j+1) 容量C, (同理, 割这条边,相当于它和S同块(选择),右上角和T同块(不选择))</p><hr><p>这个复杂度, 不理解???</p><p>看数据, 似乎没有调小, 还是和题目说的量级</p><p>但实际跑起来, 我本地i7-7700HQ, 跑数据最长的0.2~0.3s</p><p>但是提交的远端是几十ms</p><pre><code>TestCase G.in.014 =&gt; G.out.014 Time spend: 0.002467sTestCase G.in.006 =&gt; G.out.006 Time spend: 0.002532sTestCase G.in.033 =&gt; G.out.033 Time spend: 0.264098sTestCase G.in.031 =&gt; G.out.031 Time spend: 0.235067sTestCase G.in.021 =&gt; G.out.021 Time spend: 0.012753sTestCase G.in.012 =&gt; G.out.012 Time spend: 0.00644sTestCase G.in.015 =&gt; G.out.015 Time spend: 0.003208sTestCase G.in.039 =&gt; G.out.039 Time spend: 0.04113sTestCase G.in.002 =&gt; G.out.002 Time spend: 0.002386sTestCase G.in.034 =&gt; G.out.034 Time spend: 0.193138sTestCase G.in.028 =&gt; G.out.028 Time spend: 0.227858sTestCase G.in.005 =&gt; G.out.005 Time spend: 0.002228sTestCase G.in.000 =&gt; G.out.000 Time spend: 0.014386sTestCase G.in.045 =&gt; G.out.045 Time spend: 0.163sTestCase G.in.001 =&gt; G.out.001 Time spend: 0.002495sTestCase G.in.049 =&gt; G.out.049 Time spend: 0.166109sTestCase G.in.040 =&gt; G.out.040 Time spend: 0.143258sTestCase G.in.016 =&gt; G.out.016 Time spend: 0.003306sTestCase G.in.018 =&gt; G.out.018 Time spend: 0.003002sTestCase G.in.023 =&gt; G.out.023 Time spend: 0.012607sTestCase G.in.025 =&gt; G.out.025 Time spend: 0.255023sTestCase G.in.042 =&gt; G.out.042 Time spend: 0.150962sTestCase G.in.003 =&gt; G.out.003 Time spend: 0.001938sTestCase G.in.017 =&gt; G.out.017 Time spend: 0.011363sTestCase G.in.0 =&gt; G.out.0 Time spend: 0.001994sTestCase G.in.004 =&gt; G.out.004 Time spend: 0.018588sTestCase G.in.051 =&gt; G.out.051 Time spend: 0.152942sTestCase G.in.037 =&gt; G.out.037 Time spend: 0.017386sTestCase G.in.047 =&gt; G.out.047 Time spend: 0.195896sTestCase G.in.029 =&gt; G.out.029 Time spend: 0.244589sTestCase G.in.009 =&gt; G.out.009 Time spend: 0.017067sTestCase G.in.041 =&gt; G.out.041 Time spend: 0.185784sTestCase G.in.053 =&gt; G.out.053 Time spend: 0.134323sTestCase G.in.046 =&gt; G.out.046 Time spend: 0.199048sTestCase G.in.019 =&gt; G.out.019 Time spend: 0.004681sTestCase G.in.030 =&gt; G.out.030 Time spend: 0.24435sTestCase G.in.1 =&gt; G.out.1 Time spend: 0.002198sTestCase G.in.035 =&gt; G.out.035 Time spend: 0.277394sTestCase G.in.024 =&gt; G.out.024 Time spend: 0.269645sTestCase G.in.032 =&gt; G.out.032 Time spend: 0.276123sTestCase G.in.026 =&gt; G.out.026 Time spend: 0.235927sTestCase G.in.010 =&gt; G.out.010 Time spend: 0.015773sTestCase G.in.027 =&gt; G.out.027 Time spend: 0.239164sTestCase G.in.013 =&gt; G.out.013 Time spend: 0.00688sTestCase G.in.022 =&gt; G.out.022 Time spend: 0.119993sTestCase G.in.038 =&gt; G.out.038 Time spend: 0.038151sTestCase G.in.007 =&gt; G.out.007 Time spend: 0.002414sTestCase G.in.020 =&gt; G.out.020 Time spend: 0.015595sTestCase G.in.052 =&gt; G.out.052 Time spend: 0.134451sTestCase G.in.044 =&gt; G.out.044 Time spend: 0.151272sTestCase G.in.011 =&gt; G.out.011 Time spend: 0.015062sTestCase G.in.043 =&gt; G.out.043 Time spend: 0.163996sTestCase G.in.036 =&gt; G.out.036 Time spend: 0.019596sTestCase G.in.050 =&gt; G.out.050 Time spend: 0.187503sTestCase G.in.054 =&gt; G.out.054 Time spend: 0.123545sTestCase G.in.048 =&gt; G.out.048 Time spend: 0.162755sTestCase G.in.055 =&gt; G.out.055 Time spend: 0.124003sTestCase G.in.008 =&gt; G.out.008 Time spend: 0.016901sTestCase G.in.2 =&gt; G.out.2 Time spend: 0.00257s</code></pre><hr><p>这样看来, 如果变成我的那样转化, 其实也可以类似的, 左侧依赖,上侧依赖,不选负贡献 来做最小割</p><p>甚至可以变成新的题?</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc225/submissions/33910465" target="_blank" rel="noopener">https://atcoder.jp/contests/abc225/submissions/33910465</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;#include&lt;atcoder/maxflow&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readint A[110][110];int main(){  int H = read();  int W = read();  int C = read();  auto enc = [=](int i,int j){return i*W+j;};  atcoder::mf_graph&lt;ll&gt; graph(H*W+2);  rep(i,0,H) rep(j,0,W) A[i][j] = read();  int S = H*W; // 源,同块表示选  int T = S+1; // 汇,同块表示不选  // S-&gt;(i,j), 容量A[i][j], 不选  rep(i,0,H) rep(j,0,W) graph.add_edge(S,enc(i,j),A[i][j]);  // (i,j) -&gt; (i-1,j-1), 当前选, 左上不选; (i,j) -&gt; T 当前选,左上不存在  rep(i,0,H) rep(j,0,W) graph.add_edge(enc(i,j),(i &amp;&amp; j    )?enc(i-1,j-1):T,C);  // (i,j) -&gt; (i-1,j+1), 当前选, 右上不选; (i,j) -&gt; T 当前选,右上不存在  rep(i,0,H) rep(j,0,W) graph.add_edge(enc(i,j),(i &amp;&amp; j+1&lt;W)?enc(i-1,j+1):T,C);  ll ans = -graph.flow(S,T);  rep(i,0,H) rep(j,0,W) ans += A[i][j];  printf(&quot;%lld\n&quot;,ans);}</code></pre><h1 id="H-Social-Distance-2"><a href="#H-Social-Distance-2" class="headerlink" title="H - Social Distance 2"></a>H - Social Distance 2</h1><p><a href="https://atcoder.jp/contests/abc225/tasks/abc225_h" target="_blank" rel="noopener">https://atcoder.jp/contests/abc225/tasks/abc225_h</a></p><p>N个椅子排成一排, 每个最多坐一个人</p><p>M个人坐(每个人两两不同)</p><p>分数 = 相邻坐标差的乘积,</p><p>给定编号1~K的人的坐的位置</p><p>问剩下的M-K 的所有坐的方案的分数的和</p><p>mod 998244353</p><h2 id="范围-2"><a href="#范围-2" class="headerlink" title="范围"></a>范围</h2><p>2e5</p><p>2s</p><p>1024 mb</p><h2 id="我的思路-2"><a href="#我的思路-2" class="headerlink" title="我的思路"></a>我的思路</h2><p>类型应该至少是组合数+ 贡献统计吧</p><p>要么就是想法容斥</p><p>那么考虑是如何归类</p><p>一个不满足范围的DP </p><p><code>dp[i][j] =</code>小于等于给定的第i大的位置内, 坐了j个人的乘积的和,</p><p>`dp[i][j] = sum_t ( dp[i-1][t] * (A[i]-A[i-1] 空隙中(最后位置要放一个), 放入 j-t 个 的乘积和) )</p><p>状态就是 N^2的</p><p>如果后面的乘积和能直接算的话, 也需要N^3的时间复杂度, 即使走fft一类, 也是 N^2 log^2 N</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>先学一下maspy的三篇博文, 见底部链接</p><hr><p>对于未确定的$M-K$, 我们不要关心它们的区别, 直接所有方案乘上 $(M-K)!$ 即可</p><p>定义<code>f1[n][k] =</code>, 跨度<code>n</code>的椅子,两端都坐了人, 一共<code>k+2</code>个人,的内部的乘积权和</p><p>定义<code>f2[n][k] =</code>, 跨度<code>n</code>的椅子,左端坐了人, 一共<code>k+1</code>个的 内部的乘积权和</p><p>定义<code>f3[n][k] =</code>, 跨度<code>n</code>的椅子, 一共<code>k</code>个的 内部的乘积权和</p><p>其实区别只在端上</p><hr><p>那么有</p><p>$\displaystyle f_1(n,k) = \lbrack x^{n-1} \rbrack (x + 2x^2 + 3x^3 + \cdots)^{k+1} $</p><p>相当于 从$1$走到$n$,走$k+1$次,每步任意正长度(每步对最终的贡献倍数也是长度的贡献)</p><p>$ = \lbrack x^{n-k-2} \rbrack (1 + 2x + 3x^2 + \cdots)^{k+1} $</p><p>$ = \lbrack x^{n-k-2} \rbrack \frac{1}{((1-x)^2)^{k+1}}$</p><p>$ = \lbrack x^{n-k-2} \rbrack \frac{1}{(1-x)^{2k+2}}$</p><p>$ = \lbrack x^{n-k-2} \rbrack \frac{1}{(1-x)^{2k+2}}$</p><p>$ = \binom{(n-k-2) + (2k+2-1)}{2k+2-1}$</p><p>$ = \binom{n+k-1}{2k+1}$</p><hr><p>类似的有</p><p>$f_2(n,k) = \binom{n+k-1}{2k}$</p><p>$f_3(n,k) = \binom{n+k-1}{2k-1}$</p><hr><p>那么对于原问题, 如果$K=0$, 就是所有人都未确定, 使用$f_3$</p><p>对于$K\neq 0$</p><p>那么其实就是 两端用$f_2$, 中间是$K-1$个$f_1$</p><p>然后不要挨个乘,用归并的思想,尽量小乘小,大乘大, 不要太多 大乘小, 就可以了</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><p>看起来atcoder的执行是没有<code>-fsanitize</code>参数的, 很快</p><p><a href="https://atcoder.jp/contests/abc225/submissions/33929839" target="_blank" rel="noopener">https://atcoder.jp/contests/abc225/submissions/33929839</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;#include &lt;atcoder/modint&gt;#include &lt;atcoder/convolution&gt;using mint=atcoder::modint998244353;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readconst int N = 200000;ll a[N+10];mint fac[2*N+10] = {1}; // fac[i] = i!mint ifac[2*N+10]; // ifac[i] = 1/i!vector&lt;mint&gt; polys[N+10]; // 总长 &lt;= O(n + k)mint C(int n,int m){return fac[n]*ifac[m]*ifac[n-m];}ll n; // 2e5ll m; // 2e5ll k; // 2e5// 本质就是 尽量小乘小, 大乘大, 不要大量 大*小vector&lt;mint&gt; solve(ll l,ll r) {  if(l == r) return polys[l];  auto res = atcoder::convolution(solve(l,(l+r)/2),solve((l+r)/2+1,r));  if((int)res.size() &gt; m-k+1) res.resize(m-k+1); // 删除不影响结果的  return res;}int main() {  rep(i,1,2*N+1) fac[i] = fac[i-1]*i;  ifac[2*N] = fac[2*N].inv();  per(i,0,2*N) ifac[i] = ifac[i+1]*(i+1);  n = read(); // 2e5  m = read(); // 2e5  k = read(); // 2e5  rep(i,0,k) a[i] = read();  if(k==0) { // f_3(n,m) * m!    printf(&quot;%d\n&quot;,(C(n+m-1,2*m-1) * fac[m]).val()); // 无序变有序 * m!    return 0;  }  rep(i,0,k-1) { // f_1 中间间隔    ll len = a[i+1]-a[i]+1; // 区间长度, 两端已经放了    rep(seg,0,len-1) polys[i].pb(C(len+seg-1,2*seg+1)); // seg = 中间自由的元素个数  }  rep(i,0,2) { // f_2 首尾    auto len = (i==0) ? a[0] : (n-a[k-1]+1); // 区间长度, 一侧已经放了    rep(seg,0,len) polys[k-1+i].pb(C(len+seg-1,2*seg)); // seg = 中间自由的元素个数  }  printf(&quot;%d\n&quot;,(solve(0,k)[m-k] * fac[m-k]).val()); // 无序变有序 * (m-k)!  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>F</p><p>这个字符串的偏序证明 事后看起来还挺简单的,虽然我有这个方向想法, 但没去简单尝试一下</p><p>然后就是倒着dp的局部性保证了, 感觉对于这种通过长度悬空,的非真实的小于 似乎都可以类似思考一下</p><p>G</p><p>题意转化 成 只有增的世界, 题意转化还是不会</p><p>最小 转化成 最小割</p><p>不过感觉看了第二次这种 最小变成 最小割的建图, 悟出了一点东西</p><p>大概,想表达的意思就是,每个点和S同块还是T同块, 而和S同块/T同块 分别表示选和不选的一个对立状态, 而建立的容量边, 便是这些选择状态会长生的代价贡献</p><p>H</p><p>学了maspy的生成方程,感觉又多会了一点</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://atcoder.jp/contests/abc225/editorial" target="_blank" rel="noopener">官方题解</a></p><p><a href="https://maspypy.com/category/%e5%bd%a2%e5%bc%8f%e7%9a%84%e3%81%b9%e3%81%8d%e7%b4%9a%e6%95%b0%e8%a7%a3%e8%aa%ac" target="_blank" rel="noopener">maspy</a></p><p><a href="http://yexiaorain.github.io/Blog/2022-08-12-generate_function/">我基于maspy做的翻译和笔记</a></p>]]></content>
      
      
      <categories>
          
          <category> Atcoder </category>
          
          <category> ABC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
            <tag> 网络流 </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 分治 </tag>
            
            <tag> NTT </tag>
            
            <tag> FFT </tag>
            
            <tag> 生成方程 </tag>
            
            <tag> 归并 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atcoder abc224</title>
      <link href="/Blog/2022-08-10-ac_abc224/"/>
      <url>/Blog/2022-08-10-ac_abc224/</url>
      
        <content type="html"><![CDATA[<p>G(概率论,二分)H(线性规划,对偶问题,费用流,MCMF)</p><h1 id="G-Roll-or-Increment"><a href="#G-Roll-or-Increment" class="headerlink" title="G - Roll or Increment"></a>G - Roll or Increment</h1><p><a href="https://atcoder.jp/contests/abc224/tasks/abc224_g" target="_blank" rel="noopener">https://atcoder.jp/contests/abc224/tasks/abc224_g</a></p><p>1~N 骰子</p><p>初始S, 得分f(X) = X</p><p>A元, 让得分+1</p><p>B元, 重新转</p><p>求最小期望代价, 让得分为T</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>N 1e9</p><p>A,B [1,1e9]</p><p>2s</p><p>1024 mb</p><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>日常不会概率论</p><p>猜一个</p><p>S &lt; T</p><p>直接通过A, (T-S)A</p><p>转一次的期望 E</p><p>(N-T)/N * (B+E), 大于T 部分的贡献</p><p>1/N ( min(0,B+E) + min(A,B+E) + min(2A,B+E) + … + min((T-1)A,B+E)),  $\le T$ 部分的贡献</p><p>$E = \frac{N-T}{N} \cdot (B+E) + \frac{1}{N} ( min(0,B+E) + min(A,B+E) + min(2A,B+E) + \cdots + min((T-1)A,B+E))$</p><p>若能求出E, 就做出来了</p><p>转化一下</p><p>$NB + \sum_{i=0}^{T-1} \text{min}(iA-(B+E),0) = 0$</p><p>只有E是变化的, 随着E 增大, 表示式变小, 单调, 可二分</p><hr><p>好像还真就过了</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc224/submissions/33889681" target="_blank" rel="noopener">https://atcoder.jp/contests/abc224/submissions/33889681</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef long double LD;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readint main(){  ll N = read();  ll S = read();  ll T = read();  ll A = read();  ll B = read();  auto calc = [=](LD E){    ll l = 0;    ll r = T-1;    if(r*A-B-E&lt;=0){      l = r;    }else{      while(l+1&lt;r){        ll m = (l+r)/2;        if(m*A-B-E&lt;=0) l = m;        else r = m;      }    }    // nb + sum min(iA-B - E,0), i = 0~T-1;    return N * B+ A * l * (l+1) / 2 - (B+E) * (l+1) ;  };  LD LE = 0;  LD RE = A * T;  while(calc(RE) &gt; 0) RE *= 2;  rep(t,0,10000){ // E增, 和减    LD E = (LE+RE)/2;    (calc(E) &gt; 0 ? LE : RE) = E;  }  LD ans = B + LE;  if(S &lt;= T) ans = min(ans,(LD)((T-S) * A));  printf(&quot;%.15Lf&quot;,ans);  return 0;}</code></pre><h1 id="H-Security-Camera-2"><a href="#H-Security-Camera-2" class="headerlink" title="H - Security Camera 2"></a>H - Security Camera 2</h1><p><a href="https://atcoder.jp/contests/abc224/tasks/abc224_h" target="_blank" rel="noopener">https://atcoder.jp/contests/abc224/tasks/abc224_h</a></p><p>二分图, 左侧L个点,右侧R个点</p><p>在点i上每次安装摄像头, 有 Ai(左侧),Bj(右侧) 的代价, 一个点可安多次</p><p>目标 让 i上安装的个数 + j上安装的个数 &gt;= Cij</p><p>一左一右侧</p><p>问最小安装代价</p><h2 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h2><p>L,R 100</p><p>Ai,Bi [1,10]</p><p>Cij, [0,100]</p><p>2s</p><p>1024mb</p><h2 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h2><p>这个数还不少, 而代价的范围还挺小的?</p><p>然后有点费用流又有点2sat的感觉</p><p>emmmm</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这个题主要在练习线性规划的技术和,对偶问题的创造能力</p><hr><p>首先是构造线性规划</p><p>li 表示左侧每个安装的个数</p><p>ri 表示左侧每个安装的个数</p><p>要求 $min(\sum_{i} A_il_i + \sum_{i}B_ir_i)$</p><p>限制</p><p>$li+rj \ge C_{i,j}$</p><p>$li \ge 0, ri \ge 0$ 且都是整数(需要存在整数的方案最优)</p><hr><p>然后 构造对偶问题</p><p>对于限制</p><p>$l_i+r_j \ge C_{i,j}$</p><p>同时乘上$k_{i,j} \ge 0$</p><p>$k_{i,j}(l_i+r_j) \ge k_{i,j} C_{i,j},$</p><p>对于$k_{i,j},p_i,q_i \ge 0$</p><p>$\sum_{i,j} k_{i,j} (l_i+r_j) + \sum_i p_i l_i + \sum_i q_i r_i \ge \sum_{i,j} k_{i,j} C_{i,j}$</p><p>这样不等式左边如果和目标一致,那么右边的值就是它的下界</p><p>也就是 对于任意k的选取</p><p>找p和q, 让 $\sum_{i,j} k_{i,j} (l_i+r_j) + \sum_i p_i l_i + \sum_i q_i r_i = \sum_i (\sum_j k_{i,j} + p_i) l_i + \sum_j (\sum_i k_{i,j} + q_j) r_j = \sum_i A_il_i + \sum_j B_jr_j.$</p><p>那么 原目标 大于右侧的$\sum$</p><p>也就是任何满足$0\le \sum_j k_{i,j} \le A_i, 0 \le \sum_i k_{i,j} \le B_j $的 $\forall k$, 会产生不大于原目标的$\sum_{i,j} k_{i,j} C_{i,j}$</p><p>那么 原目标 $\ge max(\sum_{i,j} k_{i,j} C_{i,j})$</p><p>emmmm 有个问题是 只是证明了, min(原) &gt;= max(sum kc) </p><p>这个<strong>等号</strong>好像没证明????</p><hr><p>怎么算对偶问题呢</p><p>就是最小费用流了</p><p>左点A, 右点B</p><p>源到Ai, 容量Ai, 单位代价0</p><p>Bi到汇, 容量Bi, 单位代价0</p><p>Ai到Bj, 容量无限, 单位代价$-C_{i,j}$</p><p>求最大流的最小代价</p><hr><p>注意到atcoder自带的mcmf(min cost max flow)是无法处理负边权的, 让所有每单位流量增加max(c) 即可</p><p>手写的话, 也可以就是做最大流时找新的流的过程用spfa来更新最近距离</p><p>之前做abc 214 也写到过mcmf,见下方</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc224/submissions/33906446" target="_blank" rel="noopener">https://atcoder.jp/contests/abc224/submissions/33906446</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;#include &lt;atcoder/mincostflow&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readint c[110][110];int main(){  int L = read();  int R = read();  atcoder::mcf_graph&lt;int, int&gt; network(L+R+2); // 点个数  int S = L+R; // 源  int T = S+1; // 汇  rep(i,0,L) network.add_edge(S,i,read(),0); // ai  rep(j,0,R) network.add_edge(L+j,T,read(),0); // bi  int maxc = 0;  rep(i,0,L) rep(j,0,R) maxc = max(maxc, c[i][j] = read());  rep(i,0,L) rep(j,0,R) network.add_edge(i,L+j,10,maxc-c[i][j]); // 保证全部非负  auto [maxflow, mincost] = network.flow(S,T);  printf(&quot;%d\n&quot;, maxflow * maxc - mincost); // - (mincost - maxflow * maxc)  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>G</p><p>概率论, 竟然对了</p><p>H</p><p>线性规划,对偶问题</p><p>对偶问题学了几次感觉也没有悟到</p><p>但是从技术上讲,应该能看出这个类型的, 这里没看出是线性规划问题也是有问题</p><hr><p>有一说一,这atcoder 题解真的细, 我之前做cf,和一些其它的线性规划对偶, 都是直接甩公式, 然后找了各种博客,都在那里比喻来比喻去的, 这里竟然数学公式教会了我证明的一部分, 而且其实过程也没几步</p><p>Atcoder yyds</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://atcoder.jp/contests/abc224/editorial" target="_blank" rel="noopener">官方题解</a></p><p><a href="http://yexiaorain.github.io/Blog/2022-07-30-ac_abc214/">abc 214 mcmf</a></p><p><a href="http://yexiaorain.github.io/Blog/2022-06-26-CF1696/">cf 1969 线性规划对偶</a></p><p><a href="https://www.slideshare.net/wata_orz/ss-91375739" target="_blank" rel="noopener">wata 对偶讲义</a></p>]]></content>
      
      
      <categories>
          
          <category> Atcoder </category>
          
          <category> ABC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分 </tag>
            
            <tag> 线性规划 </tag>
            
            <tag> 费用流 </tag>
            
            <tag> 概率论 </tag>
            
            <tag> 对偶问题 </tag>
            
            <tag> MCMF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atcoder abc223</title>
      <link href="/Blog/2022-08-09-ac_abc223/"/>
      <url>/Blog/2022-08-09-ac_abc223/</url>
      
        <content type="html"><![CDATA[<p>G(树,dp,换根dp)H(线性基)</p><h1 id="G-Vertex-Deletion"><a href="#G-Vertex-Deletion" class="headerlink" title="G - Vertex Deletion"></a>G - Vertex Deletion</h1><p><a href="https://atcoder.jp/contests/abc223/tasks/abc223_g" target="_blank" rel="noopener">https://atcoder.jp/contests/abc223/tasks/abc223_g</a></p><p>N 点, 标号1到N, 的树</p><p>找有几个点满足, 删了它和它直接相连的边以后, 最大匹配个数 = 原图最大匹配个数</p><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>N 2e5</p><p>2 s</p><p>1024 mb</p><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>显然如果删了u以后最大匹配个数不变, 那么在原图中u所直接连的点,在删除以后的图中都被选了</p><p>否则的话, 其中一个和u可以让匹配数+1</p><p>并且这些和u直接相连的点在最大匹配中是<code>必选</code>, 也就是不存在方案让它不被选</p><p>又因为结构是树</p><p>假设断开u-v的连接</p><p>以v为根的连通块为根做树</p><p>v必选(和子节点匹配)的条件是,任何一个子树的根未被选</p><p>v不被选(不和子节点匹配,可能和父节点匹配)的条件是,所有子树的根被选</p><hr><p>感觉像是换根dp</p><p>也就是求u作为根 f(u) 为不和子节点匹配的 u的个数</p><p>f(u) = !(f(v1) &amp; f(v2) &amp; f(v3))</p><p>为了减少枚举,可以变成 子点0的个数统计</p><p>f(u) = count(f(v) == 0) &gt; 0</p><hr><p>u 交换 v</p><p>u 的子节点里没有了v, 更新u</p><p>v 的子节点里没有了u, 更新v</p><p>顺序就dfs顺序就完了</p><p>好像就AC了</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc223/submissions/33887853" target="_blank" rel="noopener">https://atcoder.jp/contests/abc223/submissions/33887853</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readvector&lt;int&gt;p2[200010];int c[200010]; // count 0int x(int u){ return c[u] &gt; 0;} // 根据子节点0的个数 推断是否和子节点匹配void dfs(int u,int f){  for(auto v:p2[u]) if(v != f) {    dfs(v,u);    c[u] += !x(v);  }}void swaproot(int u,int v){  c[u] -= !x(v);  c[v] += !x(u);}int dfs2(int u,int f){  int r = !x(u);  for(auto v:p2[u]) if(v != f) {    swaproot(u,v);    r += dfs2(v,u);    swaproot(v,u);  }  return r;}int main(){  int n = read();  rep(i,1,n){    int u = read();    int v = read();    p2[u].pb(v);    p2[v].pb(u);  }  dfs(1,0);  printf(&quot;%d\n&quot;, dfs2(1,0));  return 0;}</code></pre><h1 id="H-Xor-Query"><a href="#H-Xor-Query" class="headerlink" title="H - Xor Query"></a>H - Xor Query</h1><p><a href="https://atcoder.jp/contests/abc223/tasks/abc223_h" target="_blank" rel="noopener">https://atcoder.jp/contests/abc223/tasks/abc223_h</a></p><p>N个整数数组A[1…N]</p><p>做Q次询问, 每次询问[L..R]区间,是能选出一些数 使得它们的xor = Xi</p><p>不用给方案,只用输出Yes/No</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>N 4e5</p><p>Q 2e5</p><p>Ai [1,2^60]</p><p>Xi [1,2^60]</p><p>3s</p><p>1024 mb</p><h2 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h2><p>无</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>线性代数的一点基础知识</p><p>每个数字可以表示成60个维度的向量</p><p>xor = 每个维度和 %2</p><p>选一些数 xor = x</p><p>等同于 选一些数,做向量各维度和 % 2</p><p>对x的集合$X$, span(X)表示 集合中能构成所有xor的结果的集合</p><hr><p>本身是在一个 2^{60} 的空间里</p><p>如果区间[L..R] 中能选出一些让xor的值 = X</p><p>那么 span({a[k..R]}) 能产生向量X, 其中k &gt;= L</p><p>对于给定R</p><p>如果 span{a[k..R]} 不等于 span{a[k+1..R]}</p><p>那么说明 a[k] 是 a[k..R]的一个线性基</p><p>那么对L 来说, a{L..R} 的能生成的 只和中间这些满足 的k有关</p><hr><p>那么枚举右端点, 维护的每次如果不增加基,更新掉最前面一个和它冲突的</p><p>这样每个右端点都记录了最近的一些到它的线性基的下标了</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc223/submissions/33888843" target="_blank" rel="noopener">https://atcoder.jp/contests/abc223/submissions/33888843</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // read#define N 400000int n, m;pair&lt;ll,int&gt; a[N+10][100]; // [区间右端点 i][pwr] = pwr对应修改bit的 距离最近的 {线性基,下标}bool query(){  int l = read();  int r = read();  ll x = read();  rep(i,0,61) if ((x&gt;&gt;i)&amp;1) { // x 的 i 位bit 是1    auto [base,idx] = a[r][i];    if (!base || idx &lt; l) return false; // 找不到, 或者最近的修改 超出范围    x ^= base;  }  return true;}int main() {  int n = read();  int q = read();  rep(pos,1,n+1) {    int i = pos;    ll x = read();    rep(pwr,0,61) a[pos][pwr] = a[pos-1][pwr];// 拷贝一份    rep(pwr,0,61) if ( (x&gt;&gt;pwr) &amp; 1) { // x 位是1 , 这里和query的 位顺序一致即可, 可以从小到大,也可以从大到小      auto [base,idx] = a[pos][pwr];      if (!base) { // 新增基        a[pos][pwr] = {x,i}; // 基,下标        break;      } else if (i &gt; idx) { // 换离pos更近的基        swap(a[pos][pwr].first, x);        swap(a[pos][pwr].second, i);      }      x ^= a[pos][pwr].first; // 把pwr位的1删掉, 变换基    }  }  while (q--) printf(&quot;%s\n&quot;,query()?&quot;Yes&quot;:&quot;No&quot;);  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>G</p><p>没啥难的</p><p>H</p><p>线性基的知识点</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://atcoder.jp/contests/abc223/editorial" target="_blank" rel="noopener">官方题解</a></p>]]></content>
      
      
      <categories>
          
          <category> Atcoder </category>
          
          <category> ABC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性基 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atcoder abc222</title>
      <link href="/Blog/2022-08-08-ac_abc222/"/>
      <url>/Blog/2022-08-08-ac_abc222/</url>
      
        <content type="html"><![CDATA[<p>G(数学, 欧拉定理,phi,miller-robin,pollard-rho)H(题意转化,DP,FFT,生成函数,拉格朗日反演,P-recursive )</p><h1 id="G-222"><a href="#G-222" class="headerlink" title="G - 222"></a>G - 222</h1><p><a href="https://atcoder.jp/contests/abc222/tasks/abc222_g" target="_blank" rel="noopener">https://atcoder.jp/contests/abc222/tasks/abc222_g</a></p><p>在数列2,22,222,2222,22222,….中</p><p>N个X, 首个是 Xi的倍数的下标是?, 或者不存在</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>N 200</p><p>Xi [1,1e8]</p><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>一眼看上去很数学, 很像Project Euler的题</p><p>$2222222 = 2 * 1111111 = 2 * \frac{(10^7 - 1)}{9}$</p><p>其实就是问对于x</p><p>是否 2 * (10^7 - 1) = 9 k x</p><p>首先x的2的幂次为0/1</p><hr><p>好像有点绕</p><p>$kx = 1111111 = 10^0+10^1+10^2+\cdots$</p><p>右边虽然项数为合数时可以拆分, 例如$6 = 3 * 2$,  $111111 = 111 \cdot 1001 = 11 \cdot 10101$</p><p>但不知道是否能拆出所有</p><hr><p>另一个就是对于比较小的<code>11111</code>的部分,可以<code>pollard-rho</code>分解</p><hr><p>考虑长除法?</p><p>每次 除法取mod 乘10 加1</p><p>但1e8 不知道效率怎么样</p><hr><p><a href="http://yexiaorain.github.io/Blog/2020-12-03-pe129/">PE 129</a> 做过类似的, 但是问题是首个 让是它倍数的最小$111\cdots 111$长度超过百万的是哪个因子</p><p>而有一些可用的结论</p><p>除了上面$2,5$因子外$kx = 111\cdots 111$始终有解, 且$111\cdots 111$ 的长度不超过$n$ (因为模数随着长度变化成环)</p><p>因此 如果暴力的话, 期望值是在 $O(NAi)$ 的</p><hr><p>想了下打表 超过1e6的记录下来, 未超过的现场算, 但很多 超过1e6的</p><pre><code class="cpp">int two(int v){  int c = 0;  ll m = 0;  do{    m*=10;    m+=2;    c++;    m%=v;  }while(m!=0);  return c;}void calc(){  rep(i,1000000, 100000000+1){    if(i % 1000000 == 0) printf(&quot;progress %lld\n&quot;,i/1000000);    if(i % 4 == 0 || i % 5 == 0)continue;    int res = two(i);    if(res &gt; 1000000) printf(&quot;ans[%lld] = %d\n&quot;,i,res);  }}</code></pre><hr><p>另一个就是根据PE129的证明过程, 反正有$\phi(n)$ 或者$\phi(9n)$ 是一个解</p><p>那么可以找$\phi(n) , \phi(9n)$的因子尝试, 但这样是否能保证是最小的呢????? 根据倍数, 显然最小的是这个解的因子</p><p>$\phi(n) = n \cdot (1-1/p1) \cdot (1-1/p2) \cdots$</p><p>似乎可做?</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>题解说不需要这么多, 就欧拉定理+暴力找phi就够了</p><p>看来我用高级算法乱搞了太多</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc222/submissions/33867609" target="_blank" rel="noopener">https://atcoder.jp/contests/abc222/submissions/33867609</a></p><p>16ms 还不是最快的, 有人10ms</p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef __int128 lll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readll quick_p(ll b, ll p,ll mod){  ll r = 1;  while(p){    if(p%2)(r*=b)%=mod;    (b*=b)%=mod;    assert(r&gt;0);    assert(b&gt;0);    p/=2;  }  return r%mod;}bool is_prime_32(ll v){  if(v == 2)return true;  if(v &lt; 2)return false;  if(v%2 == 0)return false;  ll test_g[] = {2, 325, 9375, 28178, 450775, 9780504, 1795265022};  ll startp = v-1;  while(startp%2 == 0)startp&gt;&gt;=1;  rep(i,0,7){    ll p = startp;    ll base = test_g[i];    // don&#39;t break may cause 4033 bug    if(base % v == 0)continue;    bool find = false;    ll r = quick_p(base,p,v);    while(p != v-1){      if(r == v-1){        find = true;        break;      }      // -1 开始的序列, 或全1序列      if(r == 1){        if(p == startp){          find = true;          break;        }        return false;      }      p*=2;      (r*=r)%=v;    }    if(!find){      return false;    }  }  return true;}ll my_sqrt(ll v){  assert(v &gt; 1);  ll l = 1;  ll r = v; // care overflow  ll ret = 1;  while(l &lt; r){    ll m = (l+r)/2;    ll m2 = m*m;    if(m2 == v) return m;    if(m2 &lt; v) {      ret = m;      l = m + 1;    } else {      r = m - 1;    }  }  return ret;}ll randint(ll low,ll hi){  return low + (rand() % static_cast&lt;int&gt;(hi - low + 1));}ll Pollard_Rho(ll N) { // 返回一个&gt; 1的因数  assert(N &gt; 1);  if (N == 4) return 2;  ll ret = my_sqrt(N); // 质数平方 效率低 提前判断  if(ret * ret == N) return ret;  while(true) {    ll c = randint(1, N - 1); // 生成随机的c    auto f = [=](ll x) { return ((lll)x * x + c) % N; }; // ll 表示__int128，防溢出    ll t = 0, r = 0; // 初始两个相同    do{      t = f(t); // 1倍速度      r = f(f(r)); // 2倍速度      ll d = gcd(abs(t - r), N);      if (d &gt; 1 &amp;&amp; d &lt; N) return d;    }while (t != r);  }}// 分解x为质因数, sorted, {prime,power}vector&lt;pair&lt;ll,int&gt; &gt; fenjie(ll x) {  vector&lt;int&gt; res = {};  deque &lt;ll&gt; arr = {x};  while(arr.size()){    ll v = arr.front();    arr.pop_front();    if(v == 1) continue;    if(is_prime_32(v)) {      res.pb(v);      continue;    }    ll divisor = Pollard_Rho(v);    arr.push_back(divisor);    arr.push_back(v/divisor);  }  sort(res.begin(),res.end());  vector&lt;pair&lt;ll,int&gt; &gt; ret;  rep(i,0,res.size()){    if(i == 0|| res[i] != res[i-1]) ret.push_back({res[i], 1});    else ret.back().second++;  }  return ret;}ll phi(ll n){  auto primes = fenjie(n);  // printf(&quot;%lld =&quot;,n);  // for(auto [v,pwr]:primes) printf(&quot;[%lld %d]&quot;,v,pwr);  // printf(&quot;\n&quot;);  ll ret = n;  for(auto [v,pwr]:primes) ret = (ret/v)*(v-1);  return ret;}// -------------------------- lib -------------------------- int n ;void dfs(int idx, vector&lt;pair&lt;ll,int&gt;&gt; primes, ll mul, ll &amp; ans){  if(idx == (int)primes.size()){    // test pwr 10^p = k 9v + 1,  10^p % 9v == 1    if(quick_p(10,mul,9*n) == 1) ans = min(ans,mul);    return ;  }  rep(pwr,0,primes[idx].second+1){    if(mul &gt; ans) return;    dfs(idx+1,primes,mul,ans);    mul *= primes[idx].first;  }}void w(){  n = read();  if(n % 4 == 0 || n % 5 == 0){    printf(&quot;-1\n&quot;);    return ;  }  if(n % 2 == 0) n /= 2;  ll phin = n % 3 == 0 ? phi(9*n) : phi(n);  if(phin == 1){    printf(&quot;1\n&quot;);    return ;  }  auto primes = fenjie(phin);  ll ans = phin;  dfs(0, primes, 1, ans);  printf(&quot;%lld\n&quot;,ans);}int main(){  int t = read();  while(t--) w();  return 0;}</code></pre><h1 id="H-Beautiful-Binary-Tree"><a href="#H-Beautiful-Binary-Tree" class="headerlink" title="H - Beautiful Binary Tree"></a>H - Beautiful Binary Tree</h1><p><a href="https://atcoder.jp/contests/abc222/tasks/abc222_h" target="_blank" rel="noopener">https://atcoder.jp/contests/abc222/tasks/abc222_h</a></p><p>给定N, 问多少个满足条件的有根二叉树, 每个点上有数字 0 或 1, 叶子点上都是1</p><p>至多n-1次操作, 让根上值为N, 其它所有点的值为0</p><p>每次操作, 把一个点的值全部加到它的父节点或,父节点的父节点上</p><p>答案mod 998244353</p><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>N 1e7</p><p>3s</p><p>1024 mb</p><h2 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h2><p>首先 叶子上全是1, 且n-1次内全部移动完, 限制了最大的树的高度</p><p>而这里 二叉树 还可能有多个点只有一个子节点的</p><p>至于如何操作呢</p><p>那感觉上也是贪心从下向上,</p><p>而如果叶子向上看是 x-1-?的形式, 那么中间的一定会操作, 所以叠加上去, 0-(1+x)-?</p><p>而如果是 <code>x-0-?</code>, 那就直接跳过</p><p>这里要注意的是 可能有 长成这样的</p><pre><code> 0 01 0   1</code></pre><p>因此顺序应该是 从深度从大到小,而不是所有叶子做bfs</p><hr><p>再看如果给定图 做dfs的话,</p><p>dfs(i) 表示把低层的都收集到i的次数</p><p>那么 对于一个节点 u-v-k</p><p>v 原来是1, 那么次数 = dfs(v) + 1</p><p>如果v 原来是0, 那么 次数 = sum (dfs(k) + 1), k 是v的所有子节点</p><hr><p>换句话说, dfs过程中 一部分是在合并和, 还有一部分是在+1</p><p>所以本质上,能让所有的和 = N, 就要看所有+1的来源, 当然根上可以直接放1</p><p>又注意到上面写的 dfs转移方程式, 其实每次+1, 对应一个次移动</p><p>那么一共n-1次+1, 也就意味 根上一定是1</p><hr><p>然后感觉上, 可以考虑左右树拆分</p><p>左树贡献 i的话, 右侧贡献为 n-1 - i</p><p>两边独立, 似乎就可以fft/ntt 来搞了</p><hr><p>然后如何变成和主问题等价的子问题呢?</p><p>考虑其中一个子节点 让它对根贡献i, 记作$h(i)$</p><p>子节点为空, 则贡献i = 0,方案1</p><p>子节点为1, 则贡献为 i = 子树贡献(和原问题等价) + 1</p><p>子节点为0, 则考虑它的子节点, 因为它不能是叶子,它至少有一个子节点</p><p>那么1个的情况 i = 子树贡献() + 1, 方案数 x 2</p><p>那么2个的情况 i = 左子树贡献x + 1 + 右子树贡献y + 1, 方案数加和, </p><hr><p>有点问题是 这样下面贡献可能根是非1的, 因此<code>f(x)</code> 的意义改成产生的+1贡献, 根也是0的情况</p><hr><p>$f(x) = \sum_{i=0}^{x} h(i)\cdot h(x-i)$,</p><p>$h(0) = 1$ // 对应无节点</p><p>$h(x) = f(x-1) + 2 * f(x-1) + \sum_{i=0}^{x-2} f(i)\cdot f(x-2-i), x &gt; 0$</p><p>答案就是$f(n-1)$</p><p>这种自身相互依赖的用cdq二分 好像能做?吗?</p><hr><p><strong> 好像我的过程漏掉了总和, 只考虑操作步数……… 推了半天推了个锤子,白推了 </strong></p><h2 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a>官方题解</h2><p>满足条件的树的充要</p><ol><li>根和叶子都是1</li><li>所有1的和 = N</li><li>0不连续</li></ol><p>证明</p><p>首先所有1 要汇总到根, 所有不在根上的1, 至少操作1次, 而最多n-1次,因此 根有1,且所有其它1恰好被操作1次,而非1的地方不被操作</p><p>因此也不能有连续的0</p><p>问题变成统计上面的树的个数了</p><hr><p>定义,对于$i &gt; 0$</p><p>$a_i = i$个点是1,根也是1的满足要求的树的方案数</p><p>$b_i = i$个点是1,根是0的,满足剩余要求的树的方案</p><p>因为没有连续零,那么bi 要么有单个子树 $2 a_i$, 要么两个子树都不为空</p><p>所以 $b_i = 2a_i + \sum_{j=1}^{i-1} a_ja_{i-j}$</p><p>类似的,对于$a_i$</p><p>$a_1 = 1$</p><p>一个子节点时 $2(a_{i-1}+b_{i-1})$</p><p>所以 $a_i = 2(a_{i-1}+b_{i-1}) + \sum_{j=1}^{i-2} (a_j+b_j)(a_{i-1-j} + b_{i-1-j}), i &gt; 1$</p><hr><p><del>一点简化?(并不是) 是不是令$a_0 = 1,b_0 = 0$ 可以让上面变成完全的求和式子</del></p><hr><p>这里也说 分治类fft 可以做到 $N log^2 N$, 虽然没试过两个怎么做分治, 但会超时</p><h3 id="生成方程"><a href="#生成方程" class="headerlink" title="生成方程"></a>生成方程</h3><p>$a_0 = b_0 = 0$</p><p>分别把$a_i$和$b_i$作为系数做它们的生成方程$A(x),B(x)$</p><p>那么第一个表达式和$B=2A+A^2$等价</p><p>第二个和$A = x + 2x(A+B) + x(A+B)^2$</p><p>然后两个生成式带入一下</p><p>$A = x(1+A+B)^2 = x(1+3A+A^2)^2$</p><p>用 Newton’s algorithm 据说可以 $O(N log N)$, 也会超时</p><h3 id="Lagrange-inversion-theorem-拉格朗日反演"><a href="#Lagrange-inversion-theorem-拉格朗日反演" class="headerlink" title="Lagrange inversion theorem 拉格朗日反演?"></a>Lagrange inversion theorem 拉格朗日反演?</h3><p>解决的问题, 给定F(x)</p><p>找G(x) 使得 G(F(x)) = x</p><p><strong>这里有一点要用到,但是没有证明的是 $G(F(x)) = x$ 则 $F(G(x)) = x$</strong>, 只能说在$F(x)$的值域内$F(G(F(x)) = F(x)$即$F(G(x)) = x$可以证明, 但在值域外不知道如何证明…</p><p>如果 F,G满足, 且它们0次项系数均为0, 1次项系数均非0</p><p>那么有$\lbrack x^n \rbrack G(x) = \frac{1}{n} \lbrack x^{n-1} \rbrack \left(\frac{x}{F(x)}\right)^n.$</p><p>即是G的n次项 = $(\frac{x}{F(x)})^n$ 的$n-1$次项的$\frac{1}{n}$</p><p>证明</p><hr><p>辅助lemma: 对于任何0次系数为0,存在非0次系数不为0的$F(x)$, 有对于整数$k$</p><p>$\lbrack x^{-1} \rbrack F’(x) F(x)^k = \lbrack k = -1\rbrack$, 即是$k=-1$时$-1$次系数为$1$,否则$-1$次系数为$0$</p><p>证明lemma:</p><p>对于$k\neq -1$, 显然求导法则$F’(x) F(x)^k = \frac{\left ( F(x)^{k+1} \right)’}{k+1}$</p><p>对于$k = -1$, $F(x) = \sum_{i&gt;0} a_i x^i$</p><p>$\frac{F’(x)}{F(x)} = \frac{a_1+2a_2x+3a_3x^2+\cdots}{x(a_1+a_2x+a_3x^2+\cdots}= x^{-1} \frac{1 + 2\frac{a_2}{a_1}x + \cdots}{1 + \frac{a_2}{a_1}x + \cdots}$</p><p>也就是右侧这个分式除完以后是$1+k_1x+k_2x^2+\cdots$的样子, 因此 -1 次方的系数是 1, lemma 证毕.</p><hr><p>因此$G(F(x)) = x$, 的$G$ 满足条件</p><p>$G’(F)\cdot F’ = 1$ ( 同时求导</p><p>展开$\sum_i i(\lbrack x^i\rbrack G(x) ) F^{i-1} F’ = 1$, (基本的求导法则 $(ax^i)’ = iax^{i-1}$, 注意到前两项都是系数而非生成函数</p><p>$\sum_{i} i (\lbrack x^i \rbrack G (x)) F^{i-1-n} F’ = F^{-n}.$ ( 同乘上$F^{-n}$</p><p>$\lbrack x^{-1}\rbrack \left(\sum_{i} i (\lbrack x^i \rbrack G (x)) F^{i-1-n} F’\right) = \lbrack x^{-1}\rbrack \left(F^{-n}\right).$ (提取$-1$次项目的系数</p><p>因为左侧$i (\lbrack x^i \rbrack G (x)) $ 整个都是系数,以及上面的lemma, 左侧只有$i=n$时 生成系数的内容才为$1$,其它则是$0$</p><p>$n[x^n]G = [x^{-1}]F^{-n}$</p><p>变形一下,就有了最初要证明的$\lbrack x^n \rbrack G(x) = \frac{1}{n} \lbrack x^{n-1} \rbrack \left(\frac{x}{F(x)}\right)^n.$</p><hr><p>这玩意 百科上说建立了函数方程和幂级数之间的联系</p><h3 id="使用示例-卡特兰数Catalan-number"><a href="#使用示例-卡特兰数Catalan-number" class="headerlink" title="使用示例: 卡特兰数Catalan number"></a>使用示例: 卡特兰数Catalan number</h3><p>$c_0 = 1$</p><p>$c_{n+1} = \sum_{i=0}^n c_{i} \cdot c_{n-i}$</p><p>令$C$为以卡特兰数 1,1,2,5,14为系数的生成方程</p><p>令$F(x) = C(x) - 1$, 保证0次项系数为0, 1次系数非0</p><p>那么$F(x) = x(F(x)+1)^2$ , 根据卡特兰数本身推导的定义的到的</p><p>令$G(x) = \frac{x}{(x+1)^2}$</p><p>那么有$G(F(x)) = \frac{F(x)}{(F(x)+1)^2} = x$</p><p>那么$c_n$ 就有了</p><p>因此</p><p>$<br>\begin{aligned}<br>[x^n]F(x) &amp;= \frac{1}{n} \lbrack x^{n-1} \rbrack \left(\frac{x}{G(x)}\right)^n \\<br>&amp;= \frac{1}{n} \lbrack x^{n-1} \rbrack (x + 1)^{2n} \\<br>&amp;= \frac{1}{n} \binom{2n}{n-1} = \frac{1}{n+1} \binom{2n}{n},<br>\end{aligned}$</p><h3 id="回到原问题"><a href="#回到原问题" class="headerlink" title="回到原问题"></a>回到原问题</h3><p>$A(x) = x(1+3A(x)+A(x)^2)^2$</p><p>令$G(x) = \frac{x}{(1+3x+x^2)^2}$</p><p>感觉到一点点套路了, 就是如果本身A(x) 的等式里是 $A(x) = x W(A)$的形式,直接$G(x) = \frac{x}{W(x)}$ 就行了,因为这样就有 $G(A) = \frac{A}{W(A)} = \frac{xA}{xW(A)} = \frac{xA}{A} = x$</p><p>同时$A(G(x)) = x$, 可以验证$x = A(G) = G(1+3A(G)+A(G)^2)^2 = \frac{x}{(1+3x+x^2)^2}(1+3x+x^2)^2$</p><p>$\lbrack x^n \rbrack A(x) = \frac{1}{n}\lbrack x^{n-1}\rbrack \left(\frac{x}{G(x)}\right)^{2n}= \frac{1}{n}\lbrack x^{n-1}\rbrack (1+3x+x^2)^{2n}$</p><hr><p>现在只要找到$(1+3x+x^2)^{2N} $的$N-1$次的系数,再除以$N$就是要的答案了</p><p>$\left((1+3x+x^2)^{2N}\right)’ = 2N(1+3x+x^2)^{2N-1}(1+3x+x^2)’$</p><p>$(1+3x+x^2)\left((1+3x+x^2)^{2N}\right)’ = 2N(1+3x+x^2)^{2N}(1+3x+x^2)’$</p><p>把这个用生成方程表示$\sum u_k x^k = (1+3x+x^2)^{2N}$</p><p>$(1+3x+x^2)\left(\sum u_k x^k\right)’ = 2N(1+3x+x^2)’ (\sum u_k x^k)$</p><p>$(1+3x+x^2)(\sum ku_k x^{k-1}) = 2N(3+2x)(\sum u_k x^k)$</p><p>考虑两边$x^{k-1}$次项系数</p><p>$ku_k + 3(k-1)u_{k-1} + (k-2)u_{k-2} = 2N(3u_{k-1}+2u_{k-2})$</p><p>$u_k = \frac{(6N-3k+3)u_{k-1} + (4N - k + 2)u_{k-2}}{k}$</p><p>这样可以O(N) 递推, ??? 这样会触发很多乘法逆元的出现吗? 还是用分数做中间过程?</p><hr><p>不做递推的直接求</p><p>$\begin{aligned}<br>u_k &amp;= \lbrack x^k \rbrack (1+3x+x^2)^{2N} \\<br>&amp;= \lbrack x^k \rbrack ( (1+3x)+x^2)^{2N} \\<br>&amp;=\lbrack x^k \rbrack \sum_{0 \leq j \leq 2N} \binom{2N}{j}x^{2j} (1+3x)^{2N-j} \\<br>&amp;=\sum_{0 \leq j \leq 2N} \binom{2N}{j}\lbrack x^{k-2j} \rbrack (1+3x)^{2N-j} \\<br>&amp;=\sum_{0 \leq j \leq 2N} \binom{2N}{j} \binom{2N-j}{k-2j} 3^{k-2j},<br>\end{aligned}$</p><p>至此可以$O(N)$, 算出</p><hr><p>再次注意,要算的是$N-1$次项系数再除以$N$</p><h3 id="继续优化-P-recursive"><a href="#继续优化-P-recursive" class="headerlink" title="继续优化 P-recursive"></a>继续优化 P-recursive</h3><p>TODO, orz</p><p>据说能做到$O(\sqrt{N} log N)$</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>基于 最后那个非递推求的</p><p>maspy 的只有46ms</p><p><a href="https://atcoder.jp/contests/abc222/submissions/33870319" target="_blank" rel="noopener">https://atcoder.jp/contests/abc222/submissions/33870319</a></p><p>300+ms</p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 998244353#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readint n;int qpow(ll v,int pwr){  ll r = 1;  while(pwr){    if(pwr%2) (r*=v)%=MOD;    (v*=v)%=MOD;    pwr/=2;  }  return r;}int fac[20000010] = {1};int ifac[20000010];ll binom(ll n,ll m){  if(n &lt; 0 || m &lt; 0 || m &gt; n) return 0;  return fac[n]*(ll)ifac[m]%MOD*(ll)ifac[n-m]%MOD;}int main(){  int n = read();  rep(i,1,2*n+1) fac[i] = fac[i-1]*(ll)i % MOD;  ifac[2*n] = qpow(fac[2*n],MOD-2);  per(i,0,2*n) ifac[i] = ifac[i+1] * (ll)(i+1) % MOD;  ll ans = 0;  ll p3 = qpow(3,n-1);  ll inv3_sq = qpow(3*3, MOD-2);  // sum_{i=[0..2n]}binom(2n,i)binom(2n-i,n-1-2i) 3^{n-1-2i}  rep(i,0,2*n+1) {    if(n-1-2*i &lt; 0) break;    (ans += binom(2*n,i)*binom(2*n-i,n-1-2*i)%MOD*p3) %= MOD;    (p3 *= inv3_sq)%=MOD;  }  printf(&quot;%lld\n&quot;,ans*qpow(n,MOD-2) % MOD); // 1/n  return 0;}</code></pre><h3 id="使用了atcoder-modint"><a href="#使用了atcoder-modint" class="headerlink" title="使用了atcoder modint"></a>使用了atcoder modint</h3><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;#include &lt;atcoder/modint&gt;using mint = atcoder::modint998244353;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readint n;mint fac[20000010] = {1};mint ifac[20000010];mint binom(ll n,ll m){  if(n &lt; 0 || m &lt; 0 || m &gt; n) return 0;  return fac[n] * ifac[m] * ifac[n-m];}int main(){  int n = read();  rep(i,1,2*n+1) fac[i] = fac[i-1] * i ;  ifac[2*n] = fac[2*n].inv();  per(i,0,2*n) ifac[i] = ifac[i+1] * (i+1);  mint ans = 0;  mint p3 = mint(3).pow(n-1);  mint inv3_sq = mint(3*3).inv();  // sum_{i=[0..2n]}binom(2n,i)binom(2n-i,n-1-2i) 3^{n-1-2i}  rep(i,0,2*n+1) {    if(n-1-2*i &lt; 0) break;    ans += binom(2*n,i)*binom(2*n-i,n-1-2*i)*p3;    p3 *= inv3_sq;  }  printf(&quot;%d\n&quot;,(ans/n).val()); // 1/n  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>G</p><p>欧拉公式, $gcd(a,n) = 1$时$a^{\phi(n)} \equiv 1 \pmod n$</p><p>后面乱搞也行, 枚举算$\phi$也行</p><p>H</p><p>题意转化</p><p>DP</p><p>FFT</p><p>生成方程</p><p>拉格朗日反演</p><p>可以又学了一堆新知识点</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://atcoder.jp/contests/abc222/editorial" target="_blank" rel="noopener">官方题解</a></p><p><a href="https://en.wikipedia.org/wiki/Repunit" target="_blank" rel="noopener">wikipedia repunits</a></p><p><a href="http://yexiaorain.github.io/Blog/2020-12-03-pe129/">Project Euler 129 repunits</a></p><p><a href="http://yexiaorain.github.io/Blog/2021-06-12-project-euler216/">Project Euler 216 miller robin 质数判别</a></p><p><a href="http://yexiaorain.github.io/Blog/2022-06-03-pollard-rho/">pollard-rho质数拆分</a></p><p><a href="https://baike.baidu.com/item/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E5%8F%8D%E6%BC%94/20844121" target="_blank" rel="noopener">拉格朗日反演</a></p><p><a href="https://chaoli.club/index.php/6072" target="_blank" rel="noopener">超理论坛 拉格朗日反演</a></p><p><a href="https://www.luogu.com.cn/blog/tiw-air-oao/post-ke-pu-xiang-la-ge-lang-ri-fan-yan-di-ji-zhong-xing-shi" target="_blank" rel="noopener">洛谷 拉格朗日反演</a></p>]]></content>
      
      
      <categories>
          
          <category> Atcoder </category>
          
          <category> ABC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
            <tag> 数学 </tag>
            
            <tag> 欧拉定理 </tag>
            
            <tag> phi </tag>
            
            <tag> miller-robin </tag>
            
            <tag> pollard-rho </tag>
            
            <tag> 题意转化 </tag>
            
            <tag> FFT </tag>
            
            <tag> 生成函数 </tag>
            
            <tag> 拉格朗日反演 </tag>
            
            <tag> P-recursive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atcoder abc221</title>
      <link href="/Blog/2022-08-07-ac_abc221/"/>
      <url>/Blog/2022-08-07-ac_abc221/</url>
      
        <content type="html"><![CDATA[<p>F(树的直径)G(坐标转化,笛卡尔系)H(差分转化,前缀和,滑窗和,动态规划)</p><h1 id="F-Diameter-set"><a href="#F-Diameter-set" class="headerlink" title="F - Diameter set"></a>F - Diameter set</h1><p><a href="https://atcoder.jp/contests/abc221/tasks/abc221_f" target="_blank" rel="noopener">https://atcoder.jp/contests/abc221/tasks/abc221_f</a></p><p>N 点树, 找染色法, 染&gt;=2个点为红色,让红色点两两之间距离为直径</p><p>方案数 mod 998244353</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>N 2e5</p><p>2s</p><p>1024mb</p><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>首先直径 是经典算法, 随机点u,找最远点v, 再以v找最远点 便是直径</p><p>如果选v</p><p>那么可以把v看作根, 相当于做树上dp</p><p>因为有深度和直径都知道, 那么对于到叶子距离2倍小于直径的分叉至多选一个,</p><p>而2倍大于直径的分叉(不可能都有直径,否则这样能得到更大的长度)</p><p>如果直径是偶数, 那么从v到1/2直径点u再到最远点, 这样的点u只有一个,并且这个u可以看成重心</p><p>因此可以从重心去找 直径/2 的距离做树上统计 即可</p><p>问题来到了奇数长度的直径, 如果直径是奇数, 选了v到最远点的方案 就是最远点的个数</p><hr><p>任意两个直径 必有交点, 否则 两个直径上 p1..p2 有一个简单路径 取 p1 — 最远, p2 — 最远, p1-p2, 大于等于 直径/2向上取整 + 1</p><p>这样的话</p><p>任取一条来看,</p><p>v …. x - y…..t</p><p>假设,x和y是中间距离的两个点</p><p>那么不可能有不经过y的v..x…t1, 否则 t..x..t1 更长</p><p>换句话说</p><p>一定所有直径有x-y</p><p>类似的证明</p><p>已经证明了有公共点,</p><p>那么假设是y右侧的最近的某个p</p><p>同样v ….p…更长的一半, 将会比直径长</p><p>x对称同理</p><hr><p>所以奇数情况,就是, x 去找距离的方案 乘上 y 去找距离的方案</p><hr><p>似乎就推出来了?</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc221/submissions/33847992" target="_blank" rel="noopener">https://atcoder.jp/contests/abc221/submissions/33847992</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 998244353#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readvector&lt;int&gt; p2[200010];// {distance, node}pair&lt;int,int&gt; dfs(int u,int fa,int d = 0){  pair&lt;int,int&gt; r = {d ,u};  for(auto v:p2[u]) if(v != fa) r = max(r, dfs(v,u,d +1));  return r;}int D = 0;bool dfsxy(int u,int fa,int findv,int &amp;x,int &amp;y,int d = 0){  bool ok = u == findv;  for(auto v:p2[u]) if(v!=fa) ok = ok || dfsxy(v,u,findv,x,y,d+1);  if(ok &amp;&amp; d == D/2) x = u;  if(ok &amp;&amp; d == D/2 + 1) y = u;  return ok;}int dfscnt(int u,int fa,int d){  int r = d==0;  for(auto v:p2[u])if(v!=fa) r += dfscnt(v,u,d-1);  return r;}int main(){  int n = read();  rep(i,1,n){    int u = read();    int v = read();    p2[u].pb(v);    p2[v].pb(u);  }  auto [_,u] = dfs(1,0);  auto [d,v] = dfs(u,0);  D = d;  int x,y; // x: d/2, y: d/2+1  dfsxy(u,0,v,x,y);  if(d % 2){ // 奇数长度    ll cx = dfscnt(x,y,D/2);    ll cy = dfscnt(y,x,D/2);    printf(&quot;%lld\n&quot;,cx*cy % MOD);  }else{ // 偶数长度    ll s = 1;    ll r = 1;    for(auto p:p2[x]){      ll c = dfscnt(p,x,D/2-1);      (r*=(c+1))%=MOD;      s += c;    }    printf(&quot;%lld\n&quot;,(r+MOD-s)%MOD);  }  return 0;}</code></pre><h1 id="G-Jumping-sequence"><a href="#G-Jumping-sequence" class="headerlink" title="G - Jumping sequence"></a>G - Jumping sequence</h1><p><a href="https://atcoder.jp/contests/abc221/tasks/abc221_g" target="_blank" rel="noopener">https://atcoder.jp/contests/abc221/tasks/abc221_g</a></p><p>能否从(0,0) 恰好N次,跳到(A,B)</p><p>第i次可以向, x正/x负/y正/y负(4选1),跳恰好Di</p><p>如果可以,给一个方案</p><h2 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h2><p>N 2000</p><p>A,B [-3.6e6,3.6e6]</p><p>Di 1800</p><p>5s</p><p>1024</p><h2 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h2><p>顺序其实没有关系,因为是向量加和</p><p>那一个角度转化就是</p><p>分成4组,</p><p>其中两组的差 = X</p><p>另外两组的差 = Y</p><hr><p>另一个就是</p><p>先分两组 组A-组B = X+Y</p><p>然后找到组A中部分 = Y的 移出来</p><p>但这个只是 充分条件不是必要条件</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>逆时针转45度坐标轴 长度再乘上 根号2</p><p>终点 原坐标系(a,b) -&gt; 新坐标系 (a-b,a+b)</p><p>操作 全变成了(+-di,+-di)的形式</p><p>什么好处呢, 两个轴单独考虑了</p><hr><p>对于一个轴, 要找</p><p>S = sum (1/-1) * di</p><p>的方案</p><p>可以同时加 所有di的和</p><p>S + sum di = sum (2/0) <em> di = 2 </em> (选一些di)</p><p>就是简单的01 背包,需要bitset搞一下 空间</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc221/submissions/33849395" target="_blank" rel="noopener">https://atcoder.jp/contests/abc221/submissions/33849395</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readbitset&lt;3600001&gt; dp[2001]; // bitset 压空间, dp[前i个][值] = 是否可达int d[2000];// 旋转矩阵: 逆时针 45度 * 根号2// (x y) ( 1  1) =&gt; (x-y, x+y)//       (-1  1)//                                     x y   y   x// L: (-1 0) =&gt; (-1 -1)  =&gt;  +1)/2 =&gt; (0,0)  0 + 0 =  0// D: (0 -1) =&gt; ( 1 -1)  =&gt;  +1)/2 =&gt; (1,0)  0 + 1 =  1// U: (0  1) =&gt; (-1  1)  =&gt;  +1)/2 =&gt; (0,1) 10 + 0 = 10// R: (1  0) =&gt; ( 1  1)  =&gt;  +1)/2 =&gt; (1,1) 10 + 1 = 11const char c[] = { &#39;L&#39;,&#39;D&#39;,&#39;U&#39;,&#39;R&#39;};char ans[2010];bool w(){  int n = read();  int x = read();  int y = read();  int m[2] = {x-y,x+y};  int s = 0;  rep(i,0, n) {    d[i] = read(); // [1,1800]    s += d[i];  }  rep(i,0,2) if(abs(m[i]) &gt; s) return false; // 过远  rep(i,0,2) if((m[i] + s) % 2 != 0) return false; // (m[i] + s )/2 = 选部分di  rep(i,0,2) m[i] = (m[i] + s) / 2;  dp[0][0] = true;  rep(i,0, 2000) dp[i + 1] = dp[i] | (dp[i] &lt;&lt; d[i]); // 哇  rep(j,0,2) if(!dp[n][m[j]]) return false; // 有值无法构成  per(i,0,n){ // 倒着找哪些用了哪些没用    int bit = 0;    rep(j,0,2) if (!dp[i][m[j]]) { // 表示可达, 直接贪心选取, 两个中必有一个可行,一个不可行另一个一定可行      m[j] -= d[i];      bit += (1 &lt;&lt; j);    }    ans[i] = c[bit];  }  return true;}int main() {  if(!w()) printf(&quot;No\n&quot;);  else {    printf(&quot;Yes\n&quot;);    printf(&quot;%s\n&quot;,ans);  }  return 0;}</code></pre><h1 id="H-Count-Multiset"><a href="#H-Count-Multiset" class="headerlink" title="H - Count Multiset"></a>H - Count Multiset</h1><p><a href="https://atcoder.jp/contests/abc221/tasks/abc221_h" target="_blank" rel="noopener">https://atcoder.jp/contests/abc221/tasks/abc221_h</a></p><p>输入正整数 N, M</p><p>找可重集合,k=1…N个正整数, 和=N, 同一个重复数量不超过M, 这样可重集合的个数</p><p>mod 998244353</p><p>对于k=1..N 分别输出答案</p><h2 id="范围-2"><a href="#范围-2" class="headerlink" title="范围"></a>范围</h2><p>M &lt;= N &lt;= 5000</p><p>2 s</p><p>1024 mb</p><h2 id="我的思路-2"><a href="#我的思路-2" class="headerlink" title="我的思路"></a>我的思路</h2><p>5000 很想平方</p><p>但是直接之想到3维dp</p><p><code>dp[v][x][c] =</code> 和 = v, 最大值不超过v, 一共用了c个数 的方案数</p><p>转移</p><p><code>dp[v][x][c] = sum dp[v-kx][x-1][c-k], k=0..m</code></p><p>这样$N^3$的状态, 转移还要枚举k(可以跳点双指针变成O1均摊), 虽然滚动可以吃掉一维解决空间,还是无法解决时间</p><p>但是从加和的角度可以看成二维卷积 一个稀疏的<code>[k][1] * 0..m</code></p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>显然 等于 非严格递增序列的方案数(其实上面dp就是按照这个来的</p><p>令B为其差分数组,其中B1=A1, Bi = Ai-A[i-1]</p><p>sum Ai = N</p><p>sum Bi * (k-1+i) = N</p><p>考虑翻转顺序</p><p>sum i Bi = N</p><p>然后限制是最多M个Ai, 也就是连续0的个数 &lt;= M-1 &lt; M</p><p>这里的好处就是把M限制变成了连续0的限制,不影响总和,而非0的内容是任意的数量,没有限制</p><p><code>f[i][j] =</code> B中前i个数和为j 且最后一个数不为0的方案数</p><p>$f_{i,j}=\sum\limits_{k=\max(0,i-m)}^{i-1}\sum\limits_{l = ik &lt; j} f_{k,j-l}$</p><p>初始状态<code>f[0][0] = 1, f[0][&gt;0] = 0</code></p><hr><p>滑窗和/前缀和优化一下就n^2了</p><p>注意到颠倒了i以后正好我们要的就是首个不为0,变成末尾不为零</p><p>因此<code>f[i][n]</code> 就是要求的k=i的答案</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc221/submissions/33848661" target="_blank" rel="noopener">https://atcoder.jp/contests/abc221/submissions/33848661</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 998244353#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readconst int N = 5000;ll f[N+10][N+10]; // f[i][j] = 前i个(第i个不为0), sum(i*Bi) = j 方案数ll sum[N+10][N+10]; // sum[i][j] = sum f[i-m+1..i][j], 对i维度的滑窗和(也可以前缀和)int main() {  int n = read();  int m = read();  f[0][0] = sum[0][0] = 1;  rep(i,1,n+1) rep(j,0,n+1) {    // f[i][j] = sum f[i-m ~ i-1][j - i * bi] ,  k = bi * i, O(log)    for(int k = i; k &lt;= j; k+=i) (f[i][j] += sum[i-1][j-k]) %= MOD;    sum[i][j] = (sum[i-1][j] + f[i][j] - (i-m&gt;=0?f[i-m][j]:0)) % MOD; // 长度m的滑窗  }  rep(i,1,n+1) printf(&quot;%lld\n&quot;, (f[i][n] + MOD) % MOD);  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>F</p><p>没啥难的</p><p>先知道基本的直径算法, 也是可以自己推的</p><p>G</p><p>分离相关性</p><p>坐标轴转化</p><p>据说有黑科技 能55ms Linear Time Algorithms for Knapsack Problems with Bounded Weights</p><p><a href="https://www.sciencedirect.com/science/article/abs/pii/S0196677499910349" target="_blank" rel="noopener">https://www.sciencedirect.com/science/article/abs/pii/S0196677499910349</a></p><p>H</p><p>差分转化!!!</p><p>这里的好处就是把M限制变成了连续0的限制,不影响总和,而非0的内容是任意的数量,没有个数限制</p><p>只有对于首个非零和连续0的个数的限制了</p><p>然后是bitset的熟练应用了, 甚至位运算做01背包转移</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://atcoder.jp/contests/abc221/editorial" target="_blank" rel="noopener">官方题解</a></p>]]></content>
      
      
      <categories>
          
          <category> Atcoder </category>
          
          <category> ABC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 树 </tag>
            
            <tag> 前缀和 </tag>
            
            <tag> 直径 </tag>
            
            <tag> 树的直径 </tag>
            
            <tag> 坐标转化 </tag>
            
            <tag> 笛卡尔系 </tag>
            
            <tag> 差分转化 </tag>
            
            <tag> 滑窗和 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atcoder abc220</title>
      <link href="/Blog/2022-08-06-ac_abc220/"/>
      <url>/Blog/2022-08-06-ac_abc220/</url>
      
        <content type="html"><![CDATA[<p>G(计算几何,排序,自定义排序)H(FWHT,FWT,meet-in-middle,bitmask)</p><h1 id="G-Isosceles-Trapezium"><a href="#G-Isosceles-Trapezium" class="headerlink" title="G - Isosceles Trapezium"></a>G - Isosceles Trapezium</h1><p>二维平面, N个点,坐标Xi,Yi, 权重Ci</p><p>选4个点, 形成 等腰梯形, 问选的4个点最大权重和</p><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>N 1000</p><p>Xi,Yi [-1e9,1e9]</p><p>Ci [1,1e9]</p><p>无重点</p><p>3s</p><p>1024</p><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>有点计算几何</p><p>N的样子,像是N^2的做法</p><p>如果是暴力找三个点, 确定平行边,那么剩下一个点就自然确定了, 这样的话是 <code>N^3 log(N)</code></p><hr><p>换个想法, 按对称轴来找</p><p>如果是垂于对称轴的一点,则找对称轴最远的两个点</p><p>这样 N^2 的对称轴, 其中相等的里面 按照垂点相同的最大的,找不同的两组就行了??</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc220/submissions/33799130" target="_blank" rel="noopener">https://atcoder.jp/contests/abc220/submissions/33799130</a></p><pre><code class="cpp">    #include &lt;bits/stdc++.h&gt;    using namespace std;    typedef long long ll;    #define MOD 1000000007    #define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)    #define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)    #define pb push_back    ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // read    ll gcd(ll a,ll b){      a = abs(a);      b = abs(b);      while(b!= 0) tie(a,b) = make_pair(b,a%b);      return a;    }    const ll INF = 0x3f3f3f3f3f3f3f3f;    array&lt;ll,3&gt; xyv[1010];    map&lt;tuple&lt;ll,ll,ll&gt;, vector&lt;pair&lt;int,int&gt; &gt; &gt; cx;    void addp(int i,int j){      auto [x0,y0,v0] = xyv[i];      auto [x1,y1,v1] = xyv[j];      // 对称轴, 标准化      ll ky = 2*(y1-y0);      ll kx = -2*(x1-x0);      ll k  = (x1-x0)*(x1+x0) + (y1-y0)*(y1+y0);      ll g = gcd(k,gcd(ky,kx));      ky /= g;      kx /= g;      k  /= g;      if(ky &lt; 0){        ky = -ky;        kx = -kx;        k  = -k;      }else if(ky == 0 &amp;&amp; kx &lt; 0){        kx = -kx;        k  = -k;      }      cx[{ky,kx,k}].push_back({i,j});    }    int main(){      int n = read();      rep(i,0,n){        int x = read();        int y = read();        int v = read();        xyv[i] = {x,y,v};      }      rep(i,0,n) rep(j,i+1,n) addp(i,j);      ll ans = -1;      for(auto [_,vec]:cx){        auto center = [=](const pair&lt;int,int&gt;&amp;ij){            auto [i0,j0] = ij;            auto [x0,y0,v0] = xyv[i0];            auto [x1,y1,v1] = xyv[j0];            return make_pair(x0+x1,y0+y1);        };        sort(vec.begin(),vec.end(), [=](const auto &amp;ij0,const auto &amp;ij1){            return center(ij0) &lt; center(ij1);        });        ll lastmax = -INF;        ll cur = -INF;        rep(i,0,vec.size()){          if(i == 0 || center(vec[i]) != center(vec[i-1])){            lastmax = max(lastmax,cur);            cur = 0;          }          auto [i0,j0] = vec[i];          cur = max(cur, xyv[i0][2] + xyv[j0][2]);          if(lastmax != -INF){            ans = max(ans, lastmax + cur);          }        }      }      printf(&quot;%lld\n&quot;,ans);      return 0;    }    // y = -(x1-x0)/(y1-y0) (x - (x0+x1)/2) + (y0+y1)/2    // 2(y1-y0) y = -2(x1-x0) x + (x1-x0)(x1+x0) + (y0+y1)(y1-y0)</code></pre><h1 id="H-Security-Camera"><a href="#H-Security-Camera" class="headerlink" title="H - Security Camera"></a>H - Security Camera</h1><p>N 点, M 边</p><p>选定一些点, 让边(至少一个点上有被选定的)的数量是偶数个</p><p>求合法方案数</p><h2 id="限制-1"><a href="#限制-1" class="headerlink" title="限制"></a>限制</h2><p>N 40</p><p>无重边,自环</p><p>2s</p><p>1024mb</p><h2 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h2><p>感觉题面就是个朴素的图论</p><p>40 呢, 对应边就是780</p><p>估计是个边平方~ 3次方 左右的算法, 或者点的5次方?</p><hr><p>思路正向就是考虑局部可行方案加上插头状态</p><p>逆向就是 所有减去存在未选择的 做容斥</p><p>点数量40, 2^40 = 1099511627776</p><hr><p>如果, 是一个一个安装的, 那么考虑对于个数的影响</p><p>增量是 相邻未安装的和</p><p>而对于这个连接出的点,相邻未安装的奇偶性发生颠倒</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>2^20 = 1048576</p><p>折半</p><p>把拆成两个点集合S,T</p><p><code>L1[S,s] =</code> 点集S的子集s 被选了, 覆盖的边数的奇偶性</p><p><code>L2[S,T,s] =</code> 点集T中, 连向S\s的数量是奇数的点集? (因为偶数的话,首先不被s选,其次不论在T中是否被选不影响奇偶性</p><p><code>R[T,t] =</code> 点集T的子集t被选了,覆盖的两端属于T的边的奇偶性</p><p>因为对于每个选中状态, 可以枚举剩下所有点, 所以 可以$O(|S|2^{|S|})$ 暴力算完</p><p>那么对于答案有贡献的</p><p>$L_1[s] \oplus  ((\text{popcount} (L_2[s]  \&amp;  t) ) \&amp;1) \oplus R[t] = 0$</p><p>意义 s得到的奇数偶,t内部奇偶,和t向S\s的奇偶 = 最终奇偶</p><hr><p>中间这玩意怪怪的,虽然很长意义也就是<code>L2[s] &amp; t</code> 的1的个数的奇偶性</p><p>像个办法把右侧合并一下</p><p>$F[S,T,s] = \sum_{t \subset T} ((\text{popcount} (L_2[s]  \&amp;  t) ) \&amp; 1) \oplus R[t] $</p><p>注意到 求和部分,奇数贡献1, 偶数贡献0, 所以这里是对于给定s,在T的子集中, 让上述表达式贡献1的个数</p><p>那么贡献0的个数就是 $2^{|T|} - F[S,T,s]$</p><p>如果能求出来, 那么对于每个$s$, 有$L1[s]$ 的奇偶性, 直接加上对应贡献即可</p><hr><p>问题变成是如何求出<code>F[S,T,s]</code></p><p>这里记$t’ = L2[s]$, 这样一个s唯一对应一个<code>t&#39;</code>, 但<code>t&#39;</code>可能有多个<code>s</code> 映射过来</p><p>记作$G[T,t’] = \sum_{t \subset T} ((\text{popcount} (t’ \&amp;  t) ) \&amp;1) \oplus R[t] $</p><p>这样有个好处是,不再关心<code>S</code>和<code>s</code>, 只用管<code>T</code>中的即可</p><hr><p>注意到 $FWHT$的变换公式是</p><p>$fwht[a]_ i = \sum_{(\text{popcount}(i \&amp; j) \bmod 2 = 0}a_j - \sum_{(\text{popcount}(i\&amp; j) \bmod 2  = 1}a_j$</p><p>对于给定 i</p><p>一个具体的j</p><p>左侧为0时, 原式子贡献是 R[j], 而fwht贡献是 a[j]</p><p>左侧为1时, 原式子贡献是 R[j]^1, 而fwht贡献是 -a[j]</p><p>如果让a[j] = R[j], 那么</p><p>左侧为0时, 原式子贡献是 0 , 而fwht贡献是 0</p><p>左侧为0时, 原式子贡献是 1 , 而fwht贡献是 1</p><p>左侧为1时, 原式子贡献是 0^1, 而fwht贡献是 -0</p><p>左侧为1时, 原式子贡献是 1^1, 而fwht贡献是 -1</p><p>左侧为0和为1各占一半, 总贡献会少掉$2^{|T|-1}$</p><p>加上即可?</p><h2 id="另一个做法"><a href="#另一个做法" class="headerlink" title="另一个做法"></a>另一个做法</h2><p>所有边变成”有向”, 小点连出到大点</p><p><code>f[i][j][k] =</code> 前i个点, 未覆盖的边的两端都在前i的边数为j(奇1/偶0), 一些未来不选的会影响未覆盖边的奇偶性的点的方案数</p><p><code>i+1</code>选 <code>f[i][j][k]</code> 贡献 <code>f[i+1][j][k高(i+2)位]</code></p><p><code>i+1</code>不选 <code>f[i][j][k]</code> 贡献 <code>f[i+1][j^(i+1是否在k中)][(k高(i+2)位) ^ (i+1 连出的边) ]</code></p><hr><p>很神奇的是, 这样每个点对于每个上个状态最多分支出两个状态</p><p>那么前一半最多<code>2^20</code>个状态</p><p>而状态低<code>i</code>位都是<code>0</code>, 所以后面的一半也是最多<code>2^20</code>个状态</p><p>所以复杂度也是</p><p><code>n 2^{n/2}</code></p><p>从一定程度上也有meet-in-middle 的感觉,而没有了fwt的需要</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc220/submissions/33847519" target="_blank" rel="noopener">https://atcoder.jp/contests/abc220/submissions/33847519</a></p><p>1.7s 快超时了, 为什么有人6ms 啊</p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readll g[50]; // g[小点] = 大点的bit mask// f[前i个点][两端均在前i个中的未覆盖的边的奇偶][mask中的点每不选一个奇偶性变化1]=方案数unordered_map&lt;ll,ll&gt;f[50][2];int main() {  int n = read(); // 点  int m = read(); // 边  rep(i,0,m){    int x = read() - 1;    int y = read() - 1;    if(x &gt; y) swap(x,y);    g[x] |= 1ll&lt;&lt;y; // 全是小 -&gt; 大  }  f[0][0][0]=1; // 选 点0，所有点因为不选 未覆盖 的边都为0，为偶数。  f[0][0][g[0]]++; // 不选 点0，0指向的点因为不选 未覆盖 的边+1.  rep(i,0,n-1) rep(j,0,2) { // 枚举当前的未覆盖的边数的奇偶。    for(auto [mask,cnt]:f[i][j]) { // 枚举上一层的所有状态，进行推磨式转移。      ll bit = (mask &gt;&gt; (i+1)) &amp; 1;// 确定 不选点i+1 未覆盖的边的 奇偶变化。      //选 点i+1，所有点(i+1之后的点) 因为不选而未覆盖的边数的就不变。且j的状态不变。      f[i+1][j][mask^(bit&lt;&lt;(i+1))]+=cnt;      //不选 点i+1，j的状态 根据当前j 和 因为i不选要未覆盖的边数的就确定      //并且改变之后的点因为不选而未覆盖的边的奇偶      f[i+1][j^bit][mask^(bit&lt;&lt;(i+1))^g[i+1]] += cnt;    }  }  ll ans=0;  for(auto [_,cnt]:f[n-1][m&amp;1]) ans += cnt; // m&amp;1 未覆盖的奇偶和总边一样,则覆盖了的为偶数  printf(&quot;%lld&quot;,ans);  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>G</p><p>没啥难的</p><p>简单的计算几何,排序,自定义排序</p><p>H</p><p>一个是40的一半是20, 2^20 是可以范围内的</p><p>另一个是拆的时候,可以按点拆分,一半是有点就包含,另一半是需要两端都属于集合</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://atcoder.jp/contests/abc220/editorial" target="_blank" rel="noopener">官方题解</a></p><p><a href="https://www.cnblogs.com/gcfer/p/15344079.html" target="_blank" rel="noopener">csdn 逆天峰 H</a></p>]]></content>
      
      
      <categories>
          
          <category> Atcoder </category>
          
          <category> ABC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算几何 </tag>
            
            <tag> 排序 </tag>
            
            <tag> bitmask </tag>
            
            <tag> FWT </tag>
            
            <tag> FWHT </tag>
            
            <tag> 自定义排序 </tag>
            
            <tag> meet-in-middle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atcoder abc219</title>
      <link href="/Blog/2022-08-05-ac_abc219/"/>
      <url>/Blog/2022-08-05-ac_abc219/</url>
      
        <content type="html"><![CDATA[<p>F(排序,分组)G(根号分类,分类)H(区间dp,问题转化)</p><h1 id="F-Cleaning-Robot"><a href="#F-Cleaning-Robot" class="headerlink" title="F - Cleaning Robot"></a>F - Cleaning Robot</h1><p><a href="https://atcoder.jp/contests/abc219/tasks/abc219_f" target="_blank" rel="noopener">https://atcoder.jp/contests/abc219/tasks/abc219_f</a></p><p>给序列 从点(0,0) 出发,上下左右走n个点,</p><p>重复序列k次, 问经过次数&gt;=1的点有几个</p><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>n 2e5</p><p>k 1e12</p><p>2s</p><p>1024mb</p><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>可以看成 一个图形, 每次平移固定向量, k次,问覆盖的图形面积</p><p>似乎脑补可得: 每次计算增量, 如果增量不变, 则往后都是这个增量</p><hr><p>但不知道如何判断 达到了最小增量</p><p>如果是这个形状, s -&gt; e</p><pre><code>xxxxxesxx</code></pre><p>那么下一次增量是5, 下下次增量也是5, 但是 这不是最小增量, 最小是3</p><hr><p>所以可能要变成去计算每个点首次不产生贡献的时刻, 而不产生贡献,也就是沿着 e -&gt; s 的向量方向如果存在点</p><p>所以考虑对点归类, 能够通过向量 e -&gt; s 到达的 归类</p><p>然后比较时刻和所有点的首次不产生贡献的时间即可</p><p>不产生时刻 = 同类别最近的方向向量 / 向量</p><p>好像就过了</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc219/submissions/33772772" target="_blank" rel="noopener">https://atcoder.jp/contests/abc219/submissions/33772772</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readchar s[200010];int ch[256];int di[] = {-1,1,0,0};int dj[] = {0,0,-1,1};vector&lt;pair&lt;pair&lt;ll,ll&gt;,ll&gt; &gt; pos;int main(){  ch[(int)&#39;L&#39;] = 0;  ch[(int)&#39;R&#39;] = 1;  ch[(int)&#39;U&#39;] = 2;  ch[(int)&#39;D&#39;] = 3;  scanf(&quot;%s&quot;,s);  int n = strlen(s);  ll k = read();  ll dx = 0;  ll dy = 0;  vector&lt;pair&lt;ll,ll&gt; &gt; vis = {{dx,dy}};  rep(i,0,n){    dx += di[ch[(int)s[i]]];    dy += dj[ch[(int)s[i]]];    vis.push_back({dx, dy});  }  if(dx &lt; 0){ // 保证在 (-pi/2,pi/2]    dx = -dx;    dy = -dy;  }else if(dx == 0 &amp;&amp; dy &lt; 0){ // &lt;- bug dx == 0    dy = -dy;  }  sort(vis.begin(),vis.end());  rep(i,0,vis.size()) if(i == 0 || vis[i] != vis[i-1]){    auto [x,y] = vis[i];    ll t = 0;    if(dx != 0){ // dx &gt;= 0      t = x/dx;      x -= t * dx;      y -= t * dy;      if(x &lt; 0){        t --;        x += dx;        y += dy;      }    }else if(dy != 0){ // dx == 0, dy &gt;= 0      t = y/dy;      y -= t * dy;      if(y &lt; 0){        t --;        y += dy;      }    }    pos.push_back({ { x , y } , t}); // 没空格 hexo 炸了  }  sort(pos.begin(),pos.end());  ll ans = 0;  if(dx == 0 &amp;&amp; dy == 0){    ans = pos.size();  }else{    rep(i,0,pos.size()){      if(i == 0 || pos[i].first != pos[i-1].first){        ans += k;      }else{        ans += min(k, pos[i].second - pos[i-1].second);      }    }  }  printf(&quot;%lld\n&quot;,ans);  return 0;}</code></pre><h1 id="G-Propagation"><a href="#G-Propagation" class="headerlink" title="G - Propagation"></a>G - Propagation</h1><p><a href="https://atcoder.jp/contests/abc219/tasks/abc219_g" target="_blank" rel="noopener">https://atcoder.jp/contests/abc219/tasks/abc219_g</a></p><p>n个点,m跳边的图, 点i上写的i</p><p>q次操作</p><p>每次让点xi 上的值扩散给它的所有相邻节点</p><p>输出最终每个点上的值</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>n 2e5</p><p>m 2e5</p><p>q 2e5</p><p>无重边 自环</p><p>2s</p><p>1024mb</p><h2 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h2><p>直接模拟? 如果出现2层菊花形状 每次一个外层染进来,中心扩散, 那么可能就是QN的量级</p><p>那么思路方向一个如何批量 或者 lazy的表示</p><p>另一个就是有没有可能倒着做</p><hr><p>如果把做为修改中心的, 作为点, 按时间顺序和依赖关系 可以建立树(森林), 但不太知道怎么去建</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>分度处理</p><p>对于度小于 $\sqrt{m}$, 直接修改周围的点, 而对于 $\ge \sqrt{m}$的度的点, 在点上标识</p><p>对于查询, 可以查询所有, 相当于边访问2次</p><p>而每次 处理前, 需要遍历一次周围度大于等于$\sqrt{m}$ 的</p><p>复杂度分析</p><p>修改就不用说了显然</p><p>而就每次获取最新状态时, 因为要遍历相邻的所有度$\sqrt{m}$</p><p>那么假设有$w$个, 那么即使边来自它们之间 $\frac{w \sqrt{m}}{2} leq m$, 即$w \leq {2\sqrt{m}}$, 说明也是$O(\sqrt{m})$ 级别的访问</p><p>中间复杂度$O(q\sqrt{m})$, 最后查询复杂度$O(n\sqrt{m})$</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc219/submissions/33773300" target="_blank" rel="noopener">https://atcoder.jp/contests/abc219/submissions/33773300</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readvector&lt;int&gt;p2[200010];vector&lt;int&gt;pl[200010]; // linked largebool large[200010]; // is largepair&lt;int,int&gt; distr[200010]; // [u] = {value, time}int a[200010]; // valueint t[200010]; // timeint getV(int u){  int val = a[u];  int ti = t[u];  for(auto v:pl[u]) if(distr[v].second &gt; ti) tie(val,ti) = distr[v];  return val;}int main(){  int n = read();  ll m = read();  int q = read();  rep(i,0,m){    int u = read();    int v = read();    p2[u].pb(v);    p2[v].pb(u);  }  iota(a+1,a+n+1,1);  rep(i,1,n+1) large[i] = (ll)p2[i].size() * (ll)p2[i].size() &gt; m;  rep(u,1,n+1){    for(auto v:p2[u]){      if(large[v]) pl[u].push_back(v);    }  }  rep(ti,1,q+1){    int u = read();    int val = getV(u);    a[u] = val;    t[u] = ti;    if(large[u]){      distr[u] = {val, ti};    }else{      for(auto v:p2[u]){        a[v] = val;        t[v] = ti;      }    }  }  rep(i,1,n+1) printf(&quot;%d &quot;,getV(i));  return 0;}</code></pre><h1 id="H-Candles"><a href="#H-Candles" class="headerlink" title="H - Candles"></a>H - Candles</h1><p><a href="https://atcoder.jp/contests/abc219/tasks/abc219_h" target="_blank" rel="noopener">https://atcoder.jp/contests/abc219/tasks/abc219_h</a></p><p>N 个蜡烛, 第i个在Xi, 长度Ai</p><p>每分钟, 点燃的蜡烛长度-1, 直到 = 0, 而没点燃的不变化</p><p>初始在0,每分钟可以移动+1/-1, 如果当前位置有任何蜡烛,可以扑灭(不耗时)</p><p>求所有蜡烛长度剩余和的最大值</p><h2 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h2><p>N 300</p><p>xi [-1e9,1e9]</p><p>Ai [1,1e9]</p><h2 id="我的思路-2"><a href="#我的思路-2" class="headerlink" title="我的思路"></a>我的思路</h2><p>第一感觉是, 向左走 然后一直向右, 或者向右然后一直向左, 找这个折反点</p><p>问题是,会不会出现 左右左的情况?</p><p>例如-1上有10个, 2上有10个, -4 上1个, 都足够的长</p><p>那么 0 -&gt; -1 -&gt; 2 -&gt; -4 的损失是21 <em> 1 + 11 </em> 3 + 1 * 6, 是最小的</p><hr><p>这样证否了贪心折返</p><p>注意到N很小</p><p>甚至能接受 n^3, 考虑dp</p><p><code>dp[i..j][0]</code> = <code>[i,j]</code> 区间内全部熄灭(烧完), 停在i 的 {最大长度, 时间} </p><p>问题是, 这种状态设计下, 最大长度和时间是有一致性吗?</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>也是说, 仅从访问来看</p><p>如果已经访问过的区间是<code>[X_i,X_j]</code> 那么下一次 一定是<code>[X_{i-1},X_j]</code> 或<code>[X_i,X_{j+1}]</code></p><hr><p>修改一下问题</p><ol><li>蜡烛可以负数长度</li><li>你可以在起始时移除一些蜡烛</li></ol><p>显然新答案不会比原答案更大,而如果有一个答案的方案你照着走,然后把是会是负数的在一开始就移除,那么也可以达到这个原答案的最大值</p><hr><p>那么</p><ol><li>初始 分 = 0</li><li>计数 C 去 [0,N] 之间的一个值, 相当于剩余的蜡烛个数,但是不知道具体是哪C个蜡烛</li><li>Hi等于对应蜡烛的高度</li><li>每次移动坐标变化1, 分数 -= C</li><li>对于走到一个未访问过的点, 且C &gt; 0, 可以选择 C-=1, 分 += Hi</li></ol><p>求最大分</p><p>显然最优解和答案是一样的</p><p>// 咦 我怎么看到上凸函数的影子</p><hr><p>然后就可以dp了</p><p><code>dp[i][j][flag][k] =</code> 已获的最大分数, $[X_i,X_j]$ 已经访问,$flag = 0$ 在$X_i$,$flag = 1$ 在$X_j$, $k$ 是剩余的要去熄灭的蜡烛个数</p><p>那么转移方程, 走到$X_i$</p><p><code>dp[i][j][0][k] = max(dp[i+1][j][0/1][k] - 距离 * k, dp[i+1][j][0/1][k+1] - 距离 * (k+1) + H[i])</code></p><p>转移方程, 走到$X_j$</p><p><code>dp[i][j][1][k] = max(dp[i][j-1][0/1][k] - 距离 * k, dp[i][j-1][0/1][k+1] - 距离 * (k+1) + H[i])</code></p><p>最后答案就是<code>dp[0][n-1][0/1][0]</code></p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc219/submissions/33780170" target="_blank" rel="noopener">https://atcoder.jp/contests/abc219/submissions/33780170</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readconst int N = 300;ll dp[N+10][N+10][2][N+10];pair&lt;int,int&gt; ph[N+10]; // pos height 起点 {0,0}const ll INF = 0x3f3f3f3f3f3f3f3f;void setMax(ll &amp;v0,ll v1){ if(v1 &gt; v0) v0 = v1; }int main(){  int n = read();  rep(i,1,n+1){    auto p = read();    auto h = read();    ph[i] = {p,h};  }  sort(ph,ph+n+1);  int ci = -1; // center i 起始点  rep(i,0,n+1){    if(ph[i] == make_pair(0,0)){      ci = i;      break;    }  }  rep(i,0,n+1) rep(j,0,n+1) rep(f,0,2) rep(c,0,n+1) dp[i][j][f][c] = -INF;  rep(f,0,2) rep(c,0,n+1) dp[ci][ci][f][c] = 0;  per(i,0,ci+1) rep(j,ci,n+1) {    //dp[i][j][0][k]=max(dp[i+1][j][0/1][k]-距离*k,dp[i+1][j][0/1][k+1]-距离*(k+1)+H[i])`    //dp[i][j][1][k]=max(dp[i][j-1][0/1][k]-距离*k,dp[i][j-1][0/1][k+1]-距离*(k+1)+H[i])`    if(i == j) continue;    rep(c,0,n+1) rep(f,0,2) {      if(i &lt; ci) {        auto [x,h] = ph[i];        const ll pos[] = {i+1, j};        ll &amp;res = dp[i][j][0][c];        setMax(res, dp[pos[0]][pos[1]][f][c] - (ph[pos[f]].first - x) * c);        if(c &lt; n) setMax(res, dp[pos[0]][pos[1]][f][c+1] - (ph[pos[f]].first - x) * (c+1) + h);      }      if(j &gt; ci){        auto [x,h] = ph[j];        const ll pos[] = {i, j-1};        ll &amp;res = dp[i][j][1][c];        setMax(res, dp[pos[0]][pos[1]][f][c] - (x - ph[pos[f]].first) * c);        if(c &lt; n) setMax(res, dp[pos[0]][pos[1]][f][c+1] - (x - ph[pos[f]].first) * (c+1) + h);      }    }  }  printf(&quot;%lld\n&quot;, max(dp[0][n][0][0], dp[0][n][1][0]));  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>F</p><p>一眼题</p><p>G</p><p>分类处理, 根号分治</p><p>做了不少分类的,又忘了分类</p><p>H</p><p>一个是题目转化去掉限制的技巧不会啊, 如果直接是转化后的题面, 那我还是会区间DP的, 但这个转化感觉遇到多了学一学转化</p><p>其实就是这里每分钟下降 燃烧着的个数, 会因为=0而难以维护, 通过支持负数 和可预先移除来让每分钟下降易于维护, 同时保持新的最大答案 = 原答案</p><p>n^3和dp的感知还是没有问题, 虽然在没有前面转化的情况下用处不大</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://atcoder.jp/contests/abc219/editorial" target="_blank" rel="noopener">官方题解</a></p>]]></content>
      
      
      <categories>
          
          <category> Atcoder </category>
          
          <category> ABC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 区间dp </tag>
            
            <tag> 分组 </tag>
            
            <tag> 根号分类 </tag>
            
            <tag> 分类 </tag>
            
            <tag> 问题转化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atcoder abc218</title>
      <link href="/Blog/2022-08-04-ac_abc218/"/>
      <url>/Blog/2022-08-04-ac_abc218/</url>
      
        <content type="html"><![CDATA[<p>G(dp,树,multiset)H(王钦石二分,Alien Trick)</p><h1 id="G-Game-on-Tree-2"><a href="#G-Game-on-Tree-2" class="headerlink" title="G - Game on Tree 2"></a>G - Game on Tree 2</h1><p><a href="https://atcoder.jp/contests/abc218/tasks/abc218_g" target="_blank" rel="noopener">https://atcoder.jp/contests/abc218/tasks/abc218_g</a></p><p>n点, 树, 点i上有数字Ai</p><p>初始 棋子在点1, 交替玩, 每次移动到未访问过的相邻点, 直到无法移动为止</p><p>先手 希望最大化访问过的中位数, 后手希望最小化中位数</p><p>如果他们都最优方案, 求这个中位数</p><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>N 1e5</p><p>Ai [2,1e9]</p><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>既然是树, 相当于1作为根, 走到叶节点结束, 路径上的中位数就是结果</p><p>换句话说, 每个叶节点 可以存储结果</p><p>如果能够算出每个从根到叶的结果, 那么简单的根据深度树上dp就完了(根 同的2倍深度 选最大, 根%2不同深度选最小)</p><p>想到的是相当于从中间剖开,那么dfs维护一个大根堆,一个小根堆,让它们元素个数差最多是1即可</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc218/submissions/33755229" target="_blank" rel="noopener">https://atcoder.jp/contests/abc218/submissions/33755229</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readint A[100010];vector&lt;int&gt; e[100010];template&lt;typename T&gt; using maxSet = multiset&lt;T, greater&lt;T&gt;&gt;;template&lt;typename T&gt; using minSet = multiset&lt;T&gt;;int mid[100010];template&lt;typename T&gt;void balance(maxSet&lt;T&gt; &amp;small,minSet&lt;T&gt; &amp;large){  while(large.size() &gt; small.size()){    small.insert(*large.begin());    large.erase(large.begin());  }  while(small.size() &gt;= large.size() + 2){    large.insert(*small.begin());    small.erase(small.begin());  }}template&lt;typename T&gt;int dfs(int u,int f,maxSet&lt;T&gt; &amp;small,minSet&lt;T&gt; &amp;large, int dep){  // 插入  if(small.size() == 0 || *small.begin() &gt;= A[u]){    small.insert(A[u]);  }else{    large.insert(A[u]);  }  balance(small,large);  int res = 0;  if(u != 1 &amp;&amp; e[u].size() == 1){ // leaf    res = (small.size() == large.size()) ? (*small.begin() + *large.begin())/2 : *small.begin();  }else{    vector&lt;int&gt; vals;    for(auto v:e[u]) if(v != f) vals.push_back(dfs(v,u,small,large,dep^1));    res = (dep==0)? *max_element(vals.begin(),vals.end()) : *min_element(vals.begin(),vals.end());  }  // 删除  auto sptr = small.find(A[u]);  if(sptr != small.end()){    small.erase(sptr);  }else{    auto lptr = large.find(A[u]);    assert(lptr != large.end());    large.erase(lptr);  }  balance(small,large);  return res;}int main(){  int n = read();  rep(i,1,n+1) A[i] = read();  rep(i,1,n){    int u = read();    int v = read();    e[u].pb(v);    e[v].pb(u);  }  maxSet&lt;int&gt; small ; // 前一半  minSet&lt;int&gt; large ;  printf(&quot;%d\n&quot;,dfs(1,1,small,large,0));  return 0;}</code></pre><h1 id="H-Red-and-Blue-Lamps"><a href="#H-Red-and-Blue-Lamps" class="headerlink" title="H - Red and Blue Lamps"></a>H - Red and Blue Lamps</h1><p><a href="https://atcoder.jp/contests/abc218/tasks/abc218_h" target="_blank" rel="noopener">https://atcoder.jp/contests/abc218/tasks/abc218_h</a></p><p>N个灯, 你需要让R个红色,N-R个蓝色</p><p>如果 i 和 i+1 不同色 则有Ai的贡献</p><p>求最大的贡献</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>N 2e5</p><p>R [1,N-1]</p><p>Ai [1,1e9]</p><p>2s</p><p>1024mb</p><h2 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h2><p>显然有个n^2的dp</p><p><code>dp[i][j][c] =</code> 前i个有j个红色,第i个颜色为c,的最大贡献</p><p><code>dp[i][j][red] = max(dp[i-1][j-1][red] , dp[i-1][j-1][blue] + A[i])</code></p><p><code>dp[i][j][blue] = max(dp[i-1][j][red] +A[i], dp[i-1][j][blue])</code></p><p>但肯定超时</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>如果红色比蓝色多, 则交换颜色数量</p><p>那么尽量多的两两不同,显然红色不相邻</p><p>那么把 A[i]+A[i+1] 看作整体</p><p>构造B[i] = A[i]+A[i+1] 数组</p><p>变成在B中选r个不相邻的元素使得总价值最大, 类似的<code>dp[i][j][0/1] =</code>前i个,选了j个,第i个是否选的最大值</p><p><code>dp[i][j][1] = dp[i-1][j-1][0] + B[i]</code></p><p><code>dp[i][j][0] = max(dp[i-1][j][1],dp[i-1][j][0])</code></p><p>复杂度依然不能接受</p><hr><p>但是有简单的性质: 可以王钦石二分</p><h2 id="王钦石二分"><a href="#王钦石二分" class="headerlink" title="王钦石二分"></a>王钦石二分</h2><ol><li>当可选的越多(虽然题目要你求具体的), 那么总收益越大(单增)</li><li>当选的越多, 增量非严格递减凹函数(上凸)</li><li>不限制个数,容器得到最优方案</li></ol><p>反过来, 如果我们指定一个最大收益, 那么可以快速算出需要可选的最少数量</p><p>如果变成二维图,是凹(上凸)函数,</p><p>方法是二分斜率, 对斜率找和凹函数的切点(切线)</p><p>而显然切线在y轴截距最大, <code>f(x) = g(x) - k x</code>, 原函数<code>g(x)</code>, 截距函数<code>f(x)</code></p><p>问题变成 给k, 找最大f(x), 而 g(x) - k x 从另一个角度看, 就是每个值-k 以后选x, 对于x没有限制时, 容易求的话,那就容易得到f(x) 和 x</p><p>求的话因为干掉了一个记录当前有多少个的限制, 从而可以简单dp</p><hr><p>然后…. 我被卡double /long double 了</p><p>现实是,本身斜率就是 每次增量, 答案不会有小数,而切点对切线斜率也是单调影响, 所以,全整数就行了</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc218/submissions/33768310" target="_blank" rel="noopener">https://atcoder.jp/contests/abc218/submissions/33768310</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readint n;ll a[200010];pair&lt;ll,int&gt; f(ll v){ // f(斜率) =&gt; {最大截距, 横坐标(选的个数)}  auto dp = vector(n,vector(2,pair&lt;ll,int&gt;{0,0})); // dp[i][第i个 选/不选] = {最大截距,个数}  rep(i,1,n){    auto [y0, c0] = dp[i-1][0];    dp[i][1] = {y0 + (a[i-1] - v), c0 + 1}; // 当前选, 则上一个不选    dp[i][0] = max(dp[i-1][0],dp[i-1][1]); // 当前不选, 则上一个可选可不选  }  return max(dp[n-1][0],dp[n-1][1]);}int main(){  n = read();  int x = read();  x = min(x, n-x);  rep(i,0,n-1) a[i] = read(); // [0..n-2]  rep(i,0,n-1) a[i] += a[i+1]; // [0..n-2], 看成多了末尾多了一个0, 对最大值无影响  ll L = 0, R = 3000&#39;000&#39;000; // 斜率  // 二分, 这里可能 有多个点 让同一个斜率最大, 保证 斜率R &lt; x &lt;= 斜率L 即可, 注意到这这里可能 f(R).pos &lt; f(L).pos &lt; x, 但f(L).pos 只是斜率L上的任意一点 但只要x 斜率不大于 L即可  while(L + 1 &lt; R) (f((L+R)/2).second &lt; x ? R : L) = mid;  printf(&quot;%lld\n&quot;, f(L).first + x * L);}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>G</p><p>没啥难的</p><p>H</p><p>感觉有的时候还是有点 PE的味道,偏数学一点</p><p>这里涉及 王钦石二分, 也是凸(凹)函数和二分相关的知识</p><p>然后这里double还不行,得long double</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://atcoder.jp/contests/abc218/editorial" target="_blank" rel="noopener">官方题解</a></p><p><a href="https://zhuanlan.zhihu.com/p/340514421" target="_blank" rel="noopener">王钦石二分</a></p>]]></content>
      
      
      <categories>
          
          <category> Atcoder </category>
          
          <category> ABC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> 二分 </tag>
            
            <tag> 树 </tag>
            
            <tag> multiset </tag>
            
            <tag> 王钦石二分 </tag>
            
            <tag> Alien Trick </tag>
            
            <tag> 凹函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atcoder abc217</title>
      <link href="/Blog/2022-08-03-ac_abc217/"/>
      <url>/Blog/2022-08-03-ac_abc217/</url>
      
        <content type="html"><![CDATA[<p>G(dp)H(凸函数)</p><h1 id="G-Groups"><a href="#G-Groups" class="headerlink" title="G - Groups"></a>G - Groups</h1><p><a href="https://atcoder.jp/contests/abc217/tasks/abc217_g" target="_blank" rel="noopener">https://atcoder.jp/contests/abc217/tasks/abc217_g</a></p><p>有数字1..N</p><p>把它们分成k组(每组至少一个数)</p><p>要求, 每组中没有两个数 mod M 是相等的</p><p>问对于k=1…n 分别有多少方案</p><p>答案 模 998244353</p><p>方案: 如果两方案不同,至少有一个(x,y) 在一个中同组,另一个是不同组</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>n 5000</p><p>2 &lt;= m &lt;= n</p><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>显然 (n - 1) / m + 1 个 mod m = 1 的</p><p>我们也容易计算mod m = r 的有多少个</p><p>然后 计算这个方案数无非是两个方向, 正向算和逆向算</p><p>正向算, 则需要对每个方案唯一标识, 那么考虑用每组中( (value - 1 )mod m, value) 最小的作为组标识</p><p>似乎相互依赖很多, 不知道怎么算</p><p>反向算, 则就是同 mod的放在同一个位置了</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>我感觉自己已经傻掉了, 看到n 5000 竟然没有想一下n方的算法</p><p><code>dp[i][j]</code> 表示前i个数,分成了j组方案</p><p>如果没有同余限制</p><p><code>dp[i][j] = dp[i-1][j-1](单独放在j) + j * dp[i-1][j] (前面i-1已经放了j)</code> 个</p><p>注意到同余的限制</p><p>那么j的放法就是 和它不同余的位置</p><p>已经有 ((i-1) / m)个和它同余了</p><p><code>dp[i][j] = dp[i-1][j-1](单独放在j) + (j-(i-1)/m)保证非负 * dp[i-1][j] (前面i-1已经放了j)</code> 个</p><hr><p>就没了</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc217/submissions/33750183" target="_blank" rel="noopener">https://atcoder.jp/contests/abc217/submissions/33750183</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;#include &lt;atcoder/modint&gt;using mint = atcoder::modint998244353;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;(int)n;i++)int read(){int r;scanf(&quot;%d&quot;,&amp;r);return r;} // readint main() {  int n = read();  int m = read();  vector&lt;vector&lt;mint&gt;&gt; dp(n + 1, vector&lt;mint&gt; (n + 1));  dp[0][0] = 1;  rep(i,1,n+1){    rep(j,1,i+1) { // j-(i-1)/m &gt;= 0      dp[i][j] = dp[i-1][j-1];      if(j-(i-1)/m &gt;= 0) dp[i][j] += dp[i-1][j] * (j-(i-1)/m);    }  }  rep(i,1,n+1) printf(&quot;%d\n&quot;,dp[n][i].val());  return 0;}</code></pre><h1 id="H-Snuketoon"><a href="#H-Snuketoon" class="headerlink" title="H - Snuketoon"></a>H - Snuketoon</h1><p><a href="https://atcoder.jp/contests/abc217/tasks/abc217_h" target="_blank" rel="noopener">https://atcoder.jp/contests/abc217/tasks/abc217_h</a></p><p>初始在点0, 每秒可以-1,0,+1</p><p>N次事件: 在ti时刻, 若在Xi左侧且Di = 0,受到和Xi距离的伤害, 若在Xi右侧, 且Di = 1,受到和Xi距离的伤害</p><p>想要受到伤害最小化, 求最小值</p><h2 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h2><p>N 2e5</p><p>ti [1,1e9]</p><p>di 0/1</p><p>Xi [-1e9,1e9]</p><h2 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h2><p>看起来像dp</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>$dp_{i,x} = $ 在Ti分钟 恰好在x 所需要受到的最小伤害, 为了方便认为T0 = 0</p><p>那么</p><p><code>dp[0][0] = 0</code></p><p><code>dp[0][!=0] = INF</code></p><p>若Di = 0, <code>dp[i][x] = min(dp[i-1][y]) + max(0,Xi - x)</code>, 且<code>|y-x| &lt;= T[i] - T[i-1]</code></p><p>若Di = 1, <code>dp[i][x] = min(dp[i-1][y]) + max(0,x - Xi)</code>, 且<code>|y-x| &lt;= T[i] - T[i-1]</code></p><p>很明显直接算会TLE</p><hr><p>对于一个具体的i, 在二维平面上画点$(x,dp_{i,x})$, 其中横坐标范围是$[-T_i,T_i]$, 然后用线段连起来, 发现是个凸函数(下凸)</p><p>证明: 若对于i-1是下凸函数, 注意到<code>min(dp[i-1][y])</code> 依然是凸函数, 而<code>max</code>部分也是凸函数,所以对于<code>i</code> 也是凸函数</p><hr><p>因此问题变成维护那些拐点</p><p>每次min的操作,相当于把最小值的区间 向两侧 平移<code>T[i]-T[i-1]</code></p><p>注意到 最初是[0,0], 其实就是把区间最左和最有移动到<code>-Ti</code>和正<code>Ti</code></p><p>然后每次+max, 相当于一段不变, 一段 斜率+1, 还可能产生新的节点</p><p>如何维护呢?</p><p>注意到每次 min的过程核心等于向两侧平移, 如果以 和<code>-Ti</code>,<code>Ti</code>的距离来看, 甚至是没有变化</p><p>每次 +max, 是区间内斜率增加1, 那不妨直接记录 斜率1的起始点,斜率2的起始点, 斜率3的起始点( 可能会有重合, 这些点和左侧的距离, 和右侧的距离</p><hr><p> -3 -2 -1 0 1 2 3 这样的斜率区间</p><p> 如果加上 0 1 的</p><p> 最终会变成  -3 -2 -1 0 1 2 3 4 这样的, 虽然可能有起点重合(斜率区间长度为0</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc217/submissions/33754555" target="_blank" rel="noopener">https://atcoder.jp/contests/abc217/submissions/33754555</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readpriority_queue&lt;ll&gt; ql; //大根堆,左侧, 记录斜率-1的起点,-2的起点,-3的起点,...到 -Ti的距离priority_queue&lt;ll&gt; qr; //大根堆,右侧, 记录斜率 1的起点, 2的起点, 3的起点,...到  Ti的距离int main() {  int n = read();  ll ans = 0;  rep(i, 1, n+1) {    ll t = read();    ll d = read();    ll x = read();    // 让下凸的最小值一直是0    if (d == 0) {      if (x &gt; t) { // 超出范围直接全部都加上        ans += x - t;        x = t;      }      if (qr.empty() || qr.top() &lt;= t-x) { // 不影响右侧的        ql.push(x + t);// 原来-1变-2, -2变-3,... , 新的-1的起点      } else { // ... -3 -2 -1  0 ... 0 1 2 3 ... 影响右侧的,        int pos = t - qr.top(); // 最小值的位置 右侧1斜率的起点        qr.pop();        ans += x - pos; // 让下凸的最小值 = 0        ql.push(pos-(-t)); // 成为左侧新的 -1 斜率的起点        qr.push(t - x); // 插入新的 斜率变化分割(距离右侧Ti      }    } else { // d = 1      if (x &lt; -t) { // 超出范围直接全部都加上        ans += -t - x;        x = -t;      }      if (ql.empty() || x - (-t) &gt;= ql.top()) { // 不影响左侧        qr.push(t - x); // 右侧最大点      } else {        int pos = ql.top() - t; // 最小值的位置, 左侧-1斜率的起点        ql.pop();        ans += pos-x;        qr.push(t-pos);        ql.push(x-(-t));      }    }  }  printf(&quot;%lld\n&quot;, ans);  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>G</p><p>干啊, n方dp都想不到了,我</p><p>据说有数学的 N log N 的方法</p><p>H</p><p>知识点就是凸函数, 但是变化点较少时, 只需要维护这些点即可</p><p>然后维护的时候, 想办法保持尽可能多的不变量, 让变化记录是常数级别</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://atcoder.jp/contests/abc217/editorial" target="_blank" rel="noopener">官方题解</a></p>]]></content>
      
      
      <categories>
          
          <category> Atcoder </category>
          
          <category> ABC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> 凸函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 3169</title>
      <link href="/Blog/2022-08-02-poj3169/"/>
      <url>/Blog/2022-08-02-poj3169/</url>
      
        <content type="html"><![CDATA[<p>cow game, 差分约束</p><h1 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h1><p><a href="http://poj.org/problem?id=3169" target="_blank" rel="noopener">http://poj.org/problem?id=3169</a></p><p>数轴上放N个点(按照i的顺序坐标非严格单调递增</p><p>10000 个大于限制, 点i和点j距离不超过 di (1e6)</p><p>10000 个小于限制, 点i和点j距离不小于 di (1e6)</p><p>1s</p><p>64MB</p><p>求点1 和 点N的最大距离</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>传说中日本众所周知的的cow game</p><p>也就是 全部小于号, (大于号同乘-1)</p><p>注意到上面要保证i的顺序( 所以 大-小 &lt;= Di 或者 大减小 &gt;= Di</p><p>然后说 差分约束本质上还是 最短路 只是需要建图</p><p>b-a &lt;= d</p><p>转化成 a + d &gt;= b, 所以 a -&gt; b如果有边长d的话, 那么b的距离最小就是 a+d 还可能更小</p><p>b-a &gt;= d的话</p><p>转化成 b-d &gt;= a, 也就是 b -&gt; a 如果有边长 (-d), 那么a的距离最小是 b-d, 还可能更小</p><p>总而言之转化成</p><p>点0 + ? &gt;= 点1 的形式, 然后从点0 发一条长? 的边</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="过不了编译版本"><a href="#过不了编译版本" class="headerlink" title="过不了编译版本"></a>过不了编译版本</h3><p>这poj g++版本太老了</p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (int i=a;i&lt;n;i++)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readconst int INF = 0x3f3f3f3f; // 1e9vector&lt;array&lt;int,3&gt; &gt; e; // 有向边 [u,v,weight/length]int main(){  int N = read();  int ML = read();  int MD = read();  // 建图  rep(i,1,N) e.push_back({i+1, i, 0}); // 从i+1-&gt;i权值为0的边 保证顺序i的距离不大于i+1  rep(i,0,ML){ //&#39;喜欢&#39;关系约束 &lt;= DL    int a = read();    int b = read(); // 保证 b&gt;a    int d = read(); // |距离| &lt;= DL[i]    /* b-a&lt;=d, 即 a+d&gt;=b 从a到b权值为d的边 */    e.push_back({a,b,d});  }  rep(i,0,MD){ //&#39;不喜欢&#39;关系约束 &gt;= DD    int a = read();    int b = read(); // 保证 b&gt;a    int d = read(); // |距离| &gt;= DD[i]    /* BD - AD &gt;= DD 即 BD - DD &gt;= AD,  从BD到AD权值-DD的边*/    e.push_back({b,a,-d});  }  // Bellman_Ford  vector&lt;int&gt;dist(N+1,INF);// 最短距离  dist[1] = 0;  //循环N-1次 对所有边进行松弛操作  rep(i,0,N-1) for(auto [u,v,w]: e) if(dist[u] != INF) dist[v] = min(dist[v], dist[u] + w);  //再遍历一次所有边（第N次循环）如果本次有更新，则存在负环  bool ngloop = false;  for(auto [u,v,w]: e) if(dist[u] != INF &amp;&amp; dist[u] + w &lt; dist[v] ) ngloop = true;  int ans = dist[N];  if (ngloop) ans = -1;  else if(ans == INF) ans = -2;  printf(&quot;%d\n&quot;, ans);  return 0;}</code></pre><h3 id="AC-版本"><a href="#AC-版本" class="headerlink" title="AC 版本"></a>AC 版本</h3><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define mt make_tuplell read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readconst int INF = 0x3f3f3f3f; // 1e9// 没有tuplestruct edge{  int u;  int v;  int w;  // 结构体直接赋值也没有  edge(int _u,int _v,int _w){    u = _u;    v = _v;    w = _w;  }};vector&lt;edge&gt; e; // 有向边 [u,v,weight/length]int main(){  int N = read();  int ML = read();  int MD = read();  // 建图  rep(i,1,N) e.push_back(edge(i+1, i, 0)); // 从i+1-&gt;i权值为0的边 保证顺序i的距离不大于i+1  rep(i,0,ML){ //&#39;喜欢&#39;关系约束 &lt;= DL    int a = read();    int b = read(); // 保证 b&gt;a    int d = read(); // |距离| &lt;= DL[i]    /* b-a&lt;=d, 即 a+d&gt;=b 从a到b权值为d的边 */    e.push_back(edge(a,b,d));  }  rep(i,0,MD){ //&#39;不喜欢&#39;关系约束 &gt;= DD    int a = read();    int b = read(); // 保证 b&gt;a    int d = read(); // |距离| &gt;= DD[i]    /* BD - AD &gt;= DD 即 BD - DD &gt;= AD,  从BD到AD权值-DD的边*/    e.push_back(edge(b,a,-d));  }  // Bellman_Ford  vector&lt;int&gt;dist(N+1,INF);// 最短距离  dist[1] = 0;  //循环N-1次 对所有边进行松弛操作  rep(t,0,N-1) rep(i,0,e.size()){    edge &amp;uvw = e[i]; // 不支持auto    int u = uvw.u;    int v = uvw.v;    int w = uvw.w;    if(dist[u] != INF) dist[v] = min(dist[v], dist[u] + w);  }  //再遍历一次所有边（第N次循环）如果本次有更新，则存在负环  bool ngloop = false;  rep(i,0,e.size()){    edge &amp;uvw = e[i]; // 不支持auto    int u = uvw.u;    int v = uvw.v;    int w = uvw.w;    if(dist[u] != INF &amp;&amp; dist[u] + w &lt; dist[v] ) ngloop = true;  }  int ans = dist[N];  if (ngloop) ans = -1;  else if(ans == INF) ans = -2;  printf(&quot;%d\n&quot;, ans);  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>就是如何对差分变成图</p>]]></content>
      
      
      <categories>
          
          <category> poj </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 差分约束 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atcoder abc216</title>
      <link href="/Blog/2022-08-01-ac_abc216/"/>
      <url>/Blog/2022-08-01-ac_abc216/</url>
      
        <content type="html"><![CDATA[<p>G(贪心,差分约束,最短路)H(LGV引理,状压dp)</p><h1 id="G-01Sequence"><a href="#G-01Sequence" class="headerlink" title="G - 01Sequence"></a>G - 01Sequence</h1><p><a href="https://atcoder.jp/contests/abc216/tasks/abc216_g" target="_blank" rel="noopener">https://atcoder.jp/contests/abc216/tasks/abc216_g</a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc216/submissions/33727628" target="_blank" rel="noopener">https://atcoder.jp/contests/abc216/submissions/33727628</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;(int)n;i++)int read(){int r;scanf(&quot;%d&quot;,&amp;r);return r;} // readconst int N=200000;int a[N+10]; // a[空白个数] = 到右侧点, 之间全是1int r[N+10]; // 读入int y[N+10]; // 左侧0个数vector&lt;int&gt; l2i[N+10]; // 左端点到第i个区间int main() {  int n = read();  int m = read();  rep(i,1,m+1){    int l = read();    r[i] = read();    y[i] = (r[i]-l+1) - read(); // 左侧0个数 [[....yi],1,1,1,1,1,1]    l2i[l].push_back(i);  }  int cnt = 0; // 遍历过程中 (&lt;l) 0 的个数  rep(pos,1,n+1){ // 下标    for(auto i:l2i[pos]) a[y[i]+cnt] = max(a[y[i]+cnt],r[i]);// [pos.....r[i]]    printf(&quot;%d &quot;, a[cnt] &gt;= pos); // 这一段全是1, 1尽量向右,贪心塞0    cnt += (a[cnt] &lt; pos); // 计数+1  }  return 0;}</code></pre><h1 id="H-Random-Robots"><a href="#H-Random-Robots" class="headerlink" title="H - Random Robots"></a>H - Random Robots</h1><p>数轴上k个机器人, 初始位置分别在xi</p><p>每次 每个机器人独立选择 移动(正向+1)或不动 1/2 概率</p><p>问经过N次,过程中没有任何两个robot 同时在同位置的概率</p><p>mod 998244353</p><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>k [2,10]</p><p>n 1000</p><p>xi [0,1000], 严格单增提供</p><p>2s</p><p>1024mb</p><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>一般来说 概率 = 次/总次数 可以互相转化</p><p>不相遇 可以 和相遇的容斥互相转化</p><p>k 10 的话可能和k的bitmask有关系</p><p>如果进行一次</p><p>而碰撞比不碰撞似乎好算一些</p><p>而且一般是相邻碰撞</p><p>pi 和pi+1 在t次时刻碰撞</p><p>意味着 t-1 次时距离1, t时 1/4 概率</p><p>0~t-1 时刻每次 1/4 +1, 1/4 -1, 1/2 不变</p><p>设原来距离 为d</p><p>那么 -1 次数 减去 +1 次数 = d-1, 且中间不能有负数情况</p><p>变成后缀个数统计问题</p><p>似乎可以强行算出t时刻 的概率, 实在组合排列不行, <code>dp[时刻1000][距离2000]</code> 来算也可以</p><hr><p>那么无碰撞 = 所有 - 碰撞</p><p>所以想办法容斥掉碰撞</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>用一下LGV引理相关的思路: 相交的路径 总有转化方法,成对的出现互为相反数的贡献,从而有相交的内容贡献和为0</p><p>每一个路径组方案贡献1 乘上-1的最终位置的逆序列数量次方, 其实就像当于LGV中所有边权为1 的特殊情况</p><p>$\sum_{Q} (-1)^{\sigma(Q)}\cdot(\frac{1}{2})^{NK}\cdot\prod_{i=1}^K {\rm C}(N,Q_i-x_i)$</p><p>也就是 方案 * (-1) 的幂次权, 再除以总方案数</p><p>Qi 为初始第i个机器人最终的下标</p><p>$\sigma(Q)$ 为逆序对个数</p><p>那么对于一条具体的有交的路径, 找其编号最小交点, 其中最小的起始位置,做后置路径交换(和LGV一样), 那么将得到一个新的路径组,有同样的交点,最小交点的最小起始位置依然相同, 但逆序对数变化为1, 所以总贡献为0</p><hr><p><code>f[S][j] =</code> 选起点集合在S中, 最终节点最大值 &lt;= j 的 带权 方案数和</p><p><code>ans = f[{1,...,k}][x[k] + n]</code></p><p>考虑状态转移</p><p>最终最大节点 &lt; j, <code>f[S][j] += f[S][j-1]</code></p><p>最终最大节点 = j, <code>f[S][j] += lgv中的行列式值 展开最后一列</code></p><p>所以有</p><p>$f(S, j) = f(S, j-1) + \sum_{i=1}^{|S|} (-1)^{|S|+i} e(x_{s_i}, j) f(S\setminus{s_i}, j-1).$</p><p>$f(S, j) = f(S, j-1) + \sum_{i=1}^{|S|} (-1)^{|S|+i} \binom{n}{j-x_{s_i}} f(S\setminus{s_i}, j-1).$</p><p>状态$2^k(n + x_k - x_1)$, 转移倍数$k$</p><p>总时间复杂度 $2^kk(n + x_k - x_1)$</p><hr><p>注意到j仅依赖于j-1, 所以可以滚动数组降低空间</p><p>而S依赖于的都是S子集, 所以保证顺序即可</p><p>$for(j) \\ f(S) = f(S) + \sum_{i=1}^{|S|} (-1)^{|S|+i} \binom{n}{j-x_{s_i}} f(S\setminus{s_i}).$</p><p>注意到这里的i不是X数组的i而是X选出的x按照顺序组成的S中的i, 且是1-index</p><p>也可以表示成$d(S,i) = S$中比$i$大的的个数</p><p>$for(j) \\ f(S) = f(S) + \sum_{i=1}^{|S|} (-1)^{d(S,i)} \binom{n}{j-x_{s_i}} f(S\setminus{s_i}).$</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc216/submissions/33737388" target="_blank" rel="noopener">https://atcoder.jp/contests/abc216/submissions/33737388</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;#include &lt;atcoder/modint&gt;using mint = atcoder::modint998244353;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readint x[2010]; // 初始位置mint f[2010] = {1}; // f[i] = binom(n,i)int p[(1&lt;&lt;10)+10]; // p[mask] = (-1)^(mask中1的个数)mint dp[(1&lt;&lt;10)+10] = {1}; // 第二维滚动 f(S,pos) = f(S, pos-1) + \sum_{i=1}^{|S|} (-1)^{count(S,&gt; i)} \binom{n}{pos-x_{s_i}} f(S\setminus\{s_i\}, pos-1).$int main() {  int k=read();  int n=read();  rep(i,0,k) x[i]=read();  rep(i,1,n+1) f[i]=f[i-1]*(n-i+1)/i; // binom(n,i-1) -&gt; binom(n,i)  rep(mask,0,1&lt;&lt;k) p[mask] = p[mask&gt;&gt;1] * (mask&amp;1?-1:1);  rep(pos,x[0],x[k-1]+n+1){ // 第二维滚动    per(mask,0,1&lt;&lt;k) { // 第一维 bitmask 注意顺序      rep(i,0,k) if(mask&amp;(1&lt;&lt;i)) { // 变成递推贡献, 要增加的bit位        if(x[i]&lt;=pos &amp;&amp; pos&lt;=x[i]+n) { // 保证 binom 不为0          // f(S) += f(S\i) * binom(n, pos - x[S_i]) * (-1)^count(S,&gt;i)          dp[mask] += dp[mask^(1&lt;&lt;i)] * f[pos-x[i]] * p[mask&gt;&gt;(i+1)];        }      }    }  }  printf(&quot;%d\n&quot;,(dp[(1&lt;&lt;k)-1] / ((mint)2).pow(k*n)).val()); // 频次/总次数 = 概率  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>G</p><p>贪心完全不会</p><p>题解说有个cow game</p><p>有一些 dj-di &lt;= wij 的限制</p><p>寻找最大的 dT-dS, 可以变成最短路问题</p><p><a href="http://poj.org/problem?id=3169" target="_blank" rel="noopener">http://poj.org/problem?id=3169</a></p><p>H</p><p>学了一下LGV引理, 和其思路细节</p><p>路径不相交问题首选逆序对容斥，那么可以套用 LGV 引理</p><p>相关练习: <a href="https://www.luogu.com.cn/problem/P7736" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P7736</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://atcoder.jp/contests/abc216/editorial" target="_blank" rel="noopener">官方题解</a></p><p><a href="https://yexiaorain.github.io/Blog/2022-07-22-LGVlemma/">LGV引理</a></p>]]></content>
      
      
      <categories>
          
          <category> Atcoder </category>
          
          <category> ABC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
            <tag> 差分约束 </tag>
            
            <tag> 最短路 </tag>
            
            <tag> LGV引理 </tag>
            
            <tag> 状压dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atcoder abc215</title>
      <link href="/Blog/2022-07-31-ac_abc215/"/>
      <url>/Blog/2022-07-31-ac_abc215/</url>
      
        <content type="html"><![CDATA[<p>G(概率论,组合数,期望,贡献统计)H(二分图,霍尔定理,SOSDP,子集反演)</p><h1 id="G-Colorful-Candies-2"><a href="#G-Colorful-Candies-2" class="headerlink" title="G - Colorful Candies 2"></a>G - Colorful Candies 2</h1><p>N 个 有色糖果,第i个颜色c[i]</p><p>从中选K个有 binom(N,K)种方案</p><p>等概率选一种方案</p><p>价值=所选的颜色的不同的数量</p><p>对于每个 k= 1…N 求期望价值</p><p>mod 998244353</p><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>N 5e4</p><p>c[i]  [1,1e9]</p><p>4s</p><p>1024mb</p><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>首先只关心不同值,显然c[i]可以离散化到[1..N]</p><p>答案 = sum{价值} / binom(N,K)</p><p>不同颜色互不影响</p><p>所以 选了j种颜色, 一共k个, 如果能算方案出来 f(j), 那么答案 = sum j * f(j)</p><p>指定的 c[…] 中选的话</p><p>似乎可以卷积</p><p>去表示每个颜色 选t个的方案数, 然后卷积意义是前 j 种颜色(可能有的不选) 选k个的方案数</p><p>好像无法获得选了几个颜色</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>反过来, 也就是每个颜色出现一次的概率 的贡献和</p><p>P(出现一次) = 1-P(一次都不出现)</p><p>binom(n-x,k) / binom(n,k) , 也就是x 是这个颜色的个数</p><p>其中 n-x &lt; k 的话, 必定出现p = 1</p><p>(binom(n,k) - binom(n-x,k))/binom(n,k) , 也就是x 是这个颜色的个数</p><p>可以减少计算</p><p>注意到 可以统计个数为x的有多少个, 这样最多 $\sqrt(N)$个统计</p><p>因此对于k来讲,是$O(\sqrt{N})$的</p><p>总的便是$O(N^{\frac{3}{2}})$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc215/submissions/33712411" target="_blank" rel="noopener">https://atcoder.jp/contests/abc215/submissions/33712411</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;#include &lt;atcoder/all&gt;using mint = atcoder::modint998244353;using namespace std;typedef long long ll;const int MOD = 998244353;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readint c[50010];mint fac[50010] = {1};mint invv[50010] = {0,1};mint invfac[50010] = {1};mint binom(int n,int m){  if(m &gt; n) return 0;  return fac[n] * invfac[m] * invfac[n-m];}int main(){  int n = read();  rep(i,0,n) c[i] = read();  rep(i,1,n+1) fac[i] = fac[i-1] * i;  invv[1] = 1;  rep(i,2,n+1) invv[i] = (MOD - MOD/i) * invv[MOD%i];  rep(i,1,n+1) invfac[i] = invfac[i-1] * invv[i];  sort(c,c+n);  vector&lt;int&gt; sz = {1};  rep(i,1,n){    if(c[i] != c[i-1]){      sz.push_back(1);    }else{      sz.back()++;    }  }  sort(sz.begin(),sz.end());  vector&lt;pair&lt;int,int&gt;&gt; sc; // size count  int cnt = 0;  rep(i,0,sz.size()){    cnt++;    if(i+1 == (int)sz.size() || sz[i] != sz[i+1]){      sc.push_back({sz[i],cnt});      cnt = 0;    }  }  rep(k,1,n+1){    mint bnk = binom(n,k);    mint ans = bnk * sz.size() ;    for(auto [s,t]:sc) {      if(n-s &lt; k) break; // n-s &lt; k 的话, 必定出现p = 1      ans -= binom(n-s,k) * t; // * 次数    }    ans /= bnk;    printf(&quot;%d\n&quot;,ans.val());  }  return 0;}</code></pre><h1 id="G-Cabbage-Master"><a href="#G-Cabbage-Master" class="headerlink" title="G - Cabbage Master"></a>G - Cabbage Master</h1><p>N种菜,每种 A[i] 个</p><p>M个需求, 每个需求B[i] 个, 但是限制<code>c[i][j] = 0/1</code> 表示第i个需求 是否允许得到 第j种菜</p><p>如果 能满足所有需求则 成功</p><p>现在要尽量少的删除一些菜的个数, 让它无法成功</p><p>并且求, 删除同样数量的方案数  mod 998244353</p><h2 id="限制-1"><a href="#限制-1" class="headerlink" title="限制"></a>限制</h2><p>n 20</p><p>m 1e4</p><p>a[i] 1e5</p><p>b[i] 1e5</p><p>3s</p><p>1024mb</p><h2 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h2><p>一眼感觉网络流, 但是看着这n这么少</p><p>又觉得说 会不会是 maskdp</p><p>2^20 = 1048576, 大概1e6</p><hr><p>网络流思路</p><p>就是 S -&gt; Ini 流量 A[i]</p><p>Ini -&gt; Outj 流量无限 如果<code>c[i][j] == 1</code></p><p>Outj -&gt; T 流量B[i]</p><p>那么目标是让最小割(最大流) &lt;= sum B[i] 即可</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>二分图</p><p>左侧N个颜色, 右侧M个需求</p><p>注意到 这里成功对应的是 匹配 = sum 右侧</p><p>所以是枚举右侧的的点集,看对应左侧的点集是否大于等于右侧</p><p>左侧L, 右侧R</p><p>要能完美匹配 $\forall S \subset R $</p><p>左侧对应集合并的和 $\ge S$对应需求的和</p><p>即 min (左侧对应集合并的和 - S对应需求的和) &gt;= 0</p><hr><p>n=20, 考虑枚举左侧的并,来找右侧的max</p><p>但似乎通过枚举子集可能有m 2^n 复杂度</p><p>但实际上我们要的是</p><p>min {f(L0) - g(L0)} &gt;= 0, 其中f 算的集合里左侧的和, g 算的映射到左侧包含于集合的右侧的值的和 (既然B[i] 都是正的,那就是所有的加起来让g达到最大</p><p>g中计算 子集和可以sosdp 高维前缀和</p><p>那么删除数量X = min( f(L0) - g(L0)) + 1</p><hr><p>然后问题变成如何计算方案数</p><p>ans = 0 , 不操作1种</p><p>对于ans &gt; 0</p><p>设 左侧移除的X的值 来自的点集合恰好为S</p><p>当存在 S1 满足 S 是 S1 的子集, 且 f(L0) - g(S1) + 1 == X, 这时 S移除X的方案数h(S) 会有贡献</p><p>binom(S的个数,X) = sum h(T), T 是S的子集</p><p>这就是 子集反演问题</p><p>$h(S) = \sum (-1)^{|S|-|T|} binom(T的个数,X)$, T是S的子集</p><p>又是求子集的函数和, 那么这里把和原集合有关的移动一下</p><p>$(-1)^{|S|} {h(S)} = \sum (-1)^{|T|} \binom{f(T)}{X}$, T是S的子集</p><p>同样FWT, SOSDP可以处理</p><h2 id="霍尔-Hall-定理"><a href="#霍尔-Hall-定理" class="headerlink" title="霍尔(Hall)定理"></a>霍尔(Hall)定理</h2><p>二分图 左侧n点 右侧 m 点, n&lt;= m</p><p>二分图的最大匹配个数=|n| 的充要条件, 左侧点n的任意大小(=k)的子集连到右图的点的个数都满足&gt;=k</p><p>必要性, 因为最大匹配=|n|,所以存在一个方案, 任意左侧子集(=k)的方案对应右侧的点都是k, 所以连接的一定 &gt;= k</p><p>充分性, 归纳法, 显然 n = 1时 成立</p><p>如果n时成立</p><p>对于n+1个点</p><p>假设存在k(&lt;=n)个左侧点对应可达右侧刚好是k个, 那么存在一组匹配</p><p>注意到左侧 n+1对应 右侧&gt;=n+1, 那么从左右分别去掉上面的k个</p><p>那么左侧n+1-k, 右侧 &gt;=n+1-k, 归纳有方案</p><hr><p>如果上述不存在, 则所有k(&lt;=n)个左侧 对应的是 &gt;= k+1个右侧</p><p>那么 任意取一个匹配, 那么剩下的n个左点对应的右点 &gt;= k 个, 所以归纳成立</p><h2 id="子集反演"><a href="#子集反演" class="headerlink" title="子集反演"></a>子集反演</h2><p>$g(S) = \sum f(T)$, T是S的子集合</p><p>$f(S) = \sum (-1)^{|S| - |T|} g(T)$ , T是S的子集合</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc215/submissions/33719233" target="_blank" rel="noopener">https://atcoder.jp/contests/abc215/submissions/33719233</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;#include &lt;atcoder/all&gt;using mint = atcoder::modint998244353;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readconst ll INF = 0x3f3f3f3f; // &gt; 1e9const int N = 20;const int MASK = ( 1 &lt;&lt; N ) ;const int M = N * 100000;mint fac[M+10] = {1}; // 阶乘mint ifac[M+10] ={1}; // 阶乘的逆向int f[MASK+10]; // f[1 &lt;&lt; i] = A[i], f[mask] = sum Aint g[MASK+10]; // g[左侧mask] = sum B , 通过sosdp 变成子集和mint h[MASK+10]; // h(S=bitmask) S中移除 X 个的方案数,(每个恰好一个)int cnt[MASK+10]; // mask 中1的个数int cont[MASK+10]; // cont[mask] = 多少个父集合 是满足 最小代价为X的 在mask中移除让Hall定理触发不满足int B[M+10]; // 读入int adj[M+10]; // adj[右侧] = 左侧的bitmaskmint binom( int n, int m ) { return n &lt; m ? 0 : fac[n] * ifac[m] * ifac[n - m]; }int main() {  rep(i,1,M+1) fac[i] = fac[i - 1]*i;  ifac[M] = fac[M].inv();  per(i,0,M) ifac[i] = ifac[i + 1]*(i + 1);  int n = read();  int m = read();  rep(i,0,n)f[1 &lt;&lt; i]=read();//f[1 &lt;&lt; i]=A[i]  rep(j,0,m)B[j]=read();  rep(i,0,n)rep(j,0,m) if(read())adj[j]|=1 &lt;&lt; i; // 转换成mask  rep(j,0,m)g[adj[j]] += B[j]; // g[对应左侧mask] += B[j]  rep(mask,1,1 &lt;&lt; n) cnt[mask] = cnt[mask &gt;&gt; 1] + ( mask &amp; 1 ); // 计算1个数  rep(mask,1,1 &lt;&lt; n) f[mask] = f[mask&amp;(-mask)] + f[mask&amp;(mask-1)]; // 去掉最后一个1 和最后一个1的mask之和  rep(pwr,0,n) rep(mask,1,1 &lt;&lt; n) if(mask &amp; (1 &lt;&lt; pwr)) g[mask] += g[mask ^ (1 &lt;&lt; pwr)]; // sosdp 高维前缀和  rep(mask,0,1 &lt;&lt; n) if(!g[mask]) g[mask] = -INF; // 右侧没有集合对应左侧集合是mask的子集合  int X = INF; // 答案第一部分 删除个数  rep(mask,1,1 &lt;&lt; n) X = min(X,f[mask]-g[mask]+1 ); // Hall定理, min(左子集值和 - 右侧来源子集和)  if(max(X,0) == 0) { // 本来就不合法    printf( &quot;0 1\n&quot; );    return 0;  }  // h&#39;(S) = (-1)^|S| h(S) = sum (-1)^|T| binom(f[t], X) SOSDP  rep(mask,1,1 &lt;&lt; n) h[mask] = binom(f[mask], X) * (cnt[mask] &amp; 1 ? -1 : 1);  rep(pwr,0,n) rep(mask,0,1 &lt;&lt; n) if(mask &amp; (1 &lt;&lt; pwr)) h[mask] += h[mask ^ (1 &lt;&lt; pwr)];  rep(mask,0,1 &lt;&lt; n) h[mask] = h[mask] * ((cnt[mask] &amp; 1)?-1:1);  // SOSDP 父集合反演(本质上还是 子集反演, 你只是把每个mask 看成mask的取反即可, 最外层是pwr顺序, mask每次之间没有链式依赖,都是两两依赖, 所以mask不需要换顺序  rep(mask,1,1 &lt;&lt; n) if( f[mask] - g[mask] + 1 == X ) cont[mask] = 1;  rep(pwr,0,n) rep(mask,0,1 &lt;&lt; n) if(mask &amp; (1 &lt;&lt; pwr)) cont[mask ^ (1 &lt;&lt; pwr)] += cont[mask]; // 统计父集合可行的次数  mint ans = 0;  rep(mask,0,1 &lt;&lt; n) if(cont[mask]) ans += h[mask];  printf(&quot;%d %d\n&quot;,X, ans.val());  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>G</p><p>其实还算基础知识点, 如何批量算模拟元,批量阶乘和阶乘模逆元,如何基于它们快速bionom</p><p>然后就是概率统计变形状和相同次数统计变成$\sqrt{N}$</p><p>评分 2267 也差不多</p><p>H</p><p>二分图,霍尔(Hall)定理</p><p>二分图一定程度上, 就不在意初始设计的方向了,  因为是匹配, 内部是没有关系的</p><p>霍尔定理对于这种大于1流量的也适用(因为从本质上看 左/右侧最多k个, 无非是k个点, 有无穷大边, 无非是这些拆开后的左右侧按照原来的关系两两有边, 而这个思路是不是特殊题型还能反过来思考)</p><p>这种”任意”的条件，可以考虑是在哪个部分将它破坏的</p><p>还涉及到 子集反演(以及用子集反演完成父集合反演)</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://atcoder.jp/contests/abc215/editorial" target="_blank" rel="noopener">官方题解</a></p>]]></content>
      
      
      <categories>
          
          <category> Atcoder </category>
          
          <category> ABC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图 </tag>
            
            <tag> dp </tag>
            
            <tag> scc </tag>
            
            <tag> 网络流 </tag>
            
            <tag> 二分图 </tag>
            
            <tag> 排列 </tag>
            
            <tag> 容斥 </tag>
            
            <tag> 环 </tag>
            
            <tag> 费用流 </tag>
            
            <tag> 霍尔定理 </tag>
            
            <tag> SOSDP </tag>
            
            <tag> 子集反演 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atcoder abc214</title>
      <link href="/Blog/2022-07-30-ac_abc214/"/>
      <url>/Blog/2022-07-30-ac_abc214/</url>
      
        <content type="html"><![CDATA[<p>G(排列,图,容斥,dp,环)H(scc,网络流,费用流)</p><h1 id="G-Three-Permutations"><a href="#G-Three-Permutations" class="headerlink" title="G - Three Permutations"></a>G - Three Permutations</h1><p><a href="https://atcoder.jp/contests/abc214/tasks/abc214_g" target="_blank" rel="noopener">https://atcoder.jp/contests/abc214/tasks/abc214_g</a></p><p>给[1..N]的排列p和q</p><p>求多少个排列r 满足 r[i] != p[i] , r[i] != q[i], i = [0..N]</p><p>mod 1e9+7</p><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>n 3000</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h3><p>如果只是给一个排列p</p><p>要找另一个排列r让每个位置对应不等(r[i] != p[i])</p><p>一个想法是, 把它直接按照p[i]的1到n重新排序</p><p>问题变成了 找r[i] != i的排列方案数</p><p>考虑长度n的和n-1之间变化</p><p>如果i放的n,而n放的i ,那么 去掉i和n, 方案数 为f(n-2)</p><p>n 有 n-1中交替放的方案, (n-1) f(n-2)</p><p>如果i放的n,而n放的不是i, 那么,交换i和n放的, 前n-1也合法, f(n-1)</p><p>f(n-1) 每个方案每个位置和n换, 贡献(n-1)f(n-1)</p><p>f(n) = (n-1)(f(n-1) + f(n-2))</p><p>f(1) = 0</p><p>f(2) = 1</p><p>f(3) = 2(1+0) = 2</p><hr><p>那么对于两个序列</p><p>首先一样的思路按照p 来排序</p><p>那么变成 r[i] != q[i], r[i] != i</p><p>但因为q[i]的限制并不能 像上面那样转移</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>如果对于每个位置,计算ri=pi或ri=qi的排列方案数,可以考虑容斥</p><p>假设 i1,i2,…ik, 对应的下标满足, ri=pi 或 ri=qi, 那么要计算所有r[i1],r[i2]..r[ik]的值方案</p><p>对于每个 i in i[1..k],在图中,我们增加一个(pi,qi)的边, 只需计算每条边分配给其一个端点的总数，以便没有两条不同的边共享一个分配给它的顶点。(意思就是边即是i, 而给边分配的点,即是r[i]的值, 不能共享点,意味着值不重复</p><p>(注意到 如果(pi,qi)链接的话, 只可能是 链 或 环,不可能出现分叉</p><p>对于每个联通分量考虑(除去孤立点和自环)</p><p>因为环之间两两不相关, 所以每一组i的选择答案 = 不同环的方案的乘积</p><p>我们对于一个K个点的环内, 选了k条边, 的方案数</p><p>当所有边被选(所有的i都有相等关系), 那么有2种方案</p><p>不是全部都选, 考虑把环剖成链讨论首尾是否选择</p><hr><p><code>dp[i][j][s0=0/1/2][si=0/1/2]</code> 表示前i条边,选择了j条, 且第一条是s0 状态,第i条是si状态的方案数</p><p>0: 未选择</p><p>1: 该边分配了左点</p><p>2: 该边分配了右点</p><p>状态转移</p><p>不选 <code>dp[i][j][s0][0] = sum dp[i-1][j][s0][0..2]</code></p><p>向左 <code>dp[i][j][s0][1] = sum dp[i-1][j-1][s0][0..1]</code></p><p>向右 <code>dp[i][j][s0][2] = sum dp[i-1][j-1][s0][0..2]</code></p><p>这样最后长n的环选了k条链的总方案数 就是<code>sum dp[n][k][s0][s1], 且 (s0 != 1 || s1 != 2)</code></p><p>记为<code>circle[n][k]</code></p><hr><p>如果gi 表示 指定了i个不合法的选择, 剩余的n-i个任意选(可以合法也可以不合法,但始终满足是排列)</p><p>那么 $ans = \sum_{i=0}^n (-1)^i(n-i)! g_i$</p><hr><p>而gi也可以通过上面环的结果, 去做dp</p><p><code>f[i][k] =</code> 前i个环指定了k个边 的方案数</p><p><code>f[i][k] = sum{f[i-1][k-t] * circle[sz[i]][t]}</code> 前i个环指定了k个边 的方案数</p><hr><p>于是把所有环剖成链连续放在数组上</p><p><code>g[i][j][s0][s1]</code> = 前i边,指定分配了j条, i所在环的起始是s0,结束是s1的方案数, 这里也是把s0也与i做相关意义了</p><p>转移类似, 分别是跨环转移 和 环内转移</p><hr><p>感觉这题还可以改控制最大环长, 但增大总长度, 变成矩阵乘法</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc214/submissions/33643608" target="_blank" rel="noopener">https://atcoder.jp/contests/abc214/submissions/33643608</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;#include &lt;atcoder/all&gt;using namespace std;using mint = atcoder::modint1000000007;#define rep(i,a,n) for (int i=a;i&lt;(int)n;i++)int read(){int r;scanf(&quot;%d&quot;,&amp;r);return r;} // readconst int N = 3000;int p[N+10];int q[N+10];int e[N+10]; // 单向边int vis2[N+10]; // 每个环的结束位置 = 1, 例如环为 2 3 5, 那么 [2]=1,[2+3=5]=1,[5+5=10]=1, 自环结束位置=2// 0 不分配, 1 分配左点, 2分配右点mint g[N+10][N+10][3][3]; // [i][j][s0][si] 每个环剖成链以后,长度i的链 分配了j条, 当前环 首个点state 0, 最后一个点stateimint fac[N+10]; // n!int main() {  int n=read();  fac[0]=1;  rep(i,1,n+1) fac[i]=fac[i-1]*i;  rep(i,0,n) p[i] = read();  rep(i,0,n) e[p[i]] = q[i] = read(); // 建立边 p,q =&gt; e  { // e =&gt; vis2    vector&lt;bool&gt; vis(n+1,false); // 点是否被访问    int m = 0;    rep(i,1,n+1) if(!vis[i]){      if(e[i]==i) { // 自环        vis2[++m]=2;        continue;      }      for(int j=i;!vis[j];j=e[j]) {        vis[j]=1;        m++;      }      vis2[m]=1;    }  }  g[0][0][0][0] = 1; // 初始状态  vis2[0] = 1;       // 初始状态  rep(i,0,n+1) rep(j,0,i+1){ // 剖成链, 前i个边, 指定j个不合法, 第i个点所在环首个点s0,第i个点s1状态    if(vis2[i]) { // 环结束位置      g[i][j][1][2] = 0; // 环首为向左环尾向右      if(vis2[i]==2) g[i][j][1][1]=0; // 自环, 不选是一种, 选左和选右相同, 去掉一个      rep(k,0,3) rep(l,0,3) { // i+1 是新的环        auto v = g[i][j][k][l];        g[i+1][j  ][0][0] += v; // 新环 本身与i 无关, 应该是1,这里相当于全部乘上前面的倍数        g[i+1][j+1][1][1] += v;        g[i+1][j+1][2][2] += v;      }    } else { // 环内      rep(k,0,3) rep(l,0,3){        auto v = g[i][j][k][l];        g[i+1][j  ][k][0] += v;        g[i+1][j+1][k][1] += ((l == 2) ? 0 : v); // 不能下一个向左 这一个向右        g[i+1][j+1][k][2] += v;      }    }  }  mint res = 0;  rep(i,0,n+1) {    mint cnt = 0; // 方案数    rep(j,0,3) rep(k,0,3) cnt += g[n][i][j][k];    res += fac[n-i]*cnt*(i%2?-1:1); // 容斥  }  printf(&quot;%d&quot;,res.val());  return 0;}</code></pre><h1 id="H-Collecting"><a href="#H-Collecting" class="headerlink" title="H - Collecting"></a>H - Collecting</h1><p><a href="https://atcoder.jp/contests/abc214/tasks/abc214_h" target="_blank" rel="noopener">https://atcoder.jp/contests/abc214/tasks/abc214_h</a></p><p>有向图 N点, M边</p><p>xi个东西在点i上</p><p>k个人一个一个遍历graph</p><p>1开始, 遍历有限长度, 找最大可被收集的东西个数</p><h2 id="限制-1"><a href="#限制-1" class="headerlink" title="限制"></a>限制</h2><p>n2e5, m 2e5</p><p>k 10</p><p>xi [1..1e9]</p><p>4s</p><p>1024mb</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h3><p>显然 可以scc缩点, 然后问题变成 一个有向无环图</p><p>找k(&lt;=10)条路径, 被经过的点的和最大</p><p>这没啥想法了</p><p>例如</p><p>a-&gt;b-&gt;c</p><p>a-&gt;b-&gt;d</p><p>a-&gt;e-&gt;d</p><p>a-&gt;e-&gt;f</p><p>一次选择的贪心 是否对全局也是最好的?</p><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>果然也是先scc变成DAG</p><p>然后这里是最小费用流问题</p><ol><li>DAG每个点拆成out,in, 增加源S和汇T</li><li>DAG中每个u, 增加 in[u] -&gt; out[u], 流量1, 费用-val<a href="首次经过点">u</a>, 以及无限(K)流量费用0</li><li>DAG中(u,v)变成 out[u] -&gt; in[v] , 流量无限(K), 费用0</li><li>S -&gt; in[1] 容量k, 费用0 ( 这里可以简化成去掉S, 1 作为S, 通过 in[1] -&gt; out[1] 总容量k 来保证最大流 = K</li><li>out[u] -&gt; T 容量无限(k), 费用0</li></ol><p>求min cost max flow , 答案乘上 -1</p><p>我看atcoder的库是可以限制最大流的求 mincost</p><hr><p>然后这样做的话 代价有些是负的</p><p>办法是</p><ol><li>DAG中每个u, in[u] -&gt; out[u], 流量1费用0, 流量无限(费用val[u])</li><li>DAG中(u,v), out[u] -&gt; in[v], 无限流量, 费用sum X[u+1..v-1]</li><li>out[u] -&gt; T, 无限流量, 代价sum X[u+1..N]</li></ol><p>ans = s-&gt;t 流=K 的最小代价 - K * sum X</p><hr><p>原理</p><p>本质上希望每个流的代价增加 sum X</p><p>那么整体形式就是 从 in[u0] -&gt; out[u0] -&gt; in[v1] -&gt; out[v1] -&gt; T</p><p>希望  每次到out[u] 的时候, 费用和的增量是 前缀和X[0..u], 这样每个 out[u] -&gt; T, 只需要是X[0..n] - X[0..u] 即可</p><p>那么自然 out[u]-&gt; in[v] -&gt; out[v]</p><p>这一整段增加为 X[0..v] - X[0..u] // 保证拓扑序 来让它非负? atcoder的scc返回保证了逆向拓扑序!!</p><p>那么, 这里设计 in[v] -&gt; out[v] 增加X[v]</p><p>所以 out[u] -&gt; in[v] 增加 X[0..v] - X[0..u] - X[v]</p><hr><p>它这个没有拓扑似乎也保证不了 cost非负?</p><p>保证的是没有负环!?</p><p>注意因为没有S所以 链增加的是 X[0..n] - X[0..start]</p><h3 id="费用流-mcmf"><a href="#费用流-mcmf" class="headerlink" title="费用流 mcmf"></a>费用流 mcmf</h3><p>费用流, 每个边有流量限制和每单位费用</p><p>最大流最小费 = 最短路</p><p>最大流最大费 = 最长路</p><p>满足正向单位费用的相反数 = 逆向单位费用</p><p>最小费用以流量的单价作为边权值跑最短路，注意因为不会有负环（否则费用是负无限大）所以用SPFA就可以了</p><p>如果增广路中出现了负环，那么在上一次选择中一定有一条更短的路径。(如果开始就有负环呢？ 那么它说明你图建错了</p><p>最小费用流, 就是在做最大流的时候, 把dfs改成 spfa, 而距离= 路径上单位cost代价之和</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p><a href="https://atcoder.jp/contests/abc214/submissions/33655383" target="_blank" rel="noopener">https://atcoder.jp/contests/abc214/submissions/33655383</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;#include &lt;atcoder/scc&gt;#include &lt;atcoder/mincostflow&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readint main() {  int N = read();  int M = read();  int K = read();  vector&lt;int&gt; A(M), B(M);  atcoder::scc_graph graph(N); // 0-index 点  rep(i,0,M){    A[i] = read() - 1; // 0-index    B[i] = read() - 1;    graph.add_edge(A[i], B[i]);  }  const vector&lt;vector&lt;int&gt;&gt; scc = graph.scc(); // 连通块 atcoder的scc返回还保证了逆拓扑序  const int V = scc.size(); // DAG节点个数  vector&lt;int&gt; belongs(N); // [节点] = 所在块  rep(i,0,V) for(int u : scc[i]) belongs[u] = i;  vector&lt;ll&gt; X(V); // 新图每个点上的值  rep(i,0,N) X[belongs[i]] += read();  vector&lt;ll&gt; accum(V + 1, 0); // 前缀和  rep(i,0,V) accum[i + 1] = accum[i] + X[i];  atcoder::mcf_graph&lt;int, ll&gt; network(2 * V + 1); // in[1]变成 S, T = 2*V  int S = 2*belongs[0];  int T = 2*V;  rep(i,0,V) {    network.add_edge(2 * i, 2 * i + 1, 1, 0); // in[i] -&gt; out[i], 容量1, 费用 -X[i] + X[i]    network.add_edge(2 * i, 2 * i + 1, K, X[i]); // in[i] -&gt; out[i], 容量K(无穷), 费用 0 + X[i]    network.add_edge(2 * i + 1, 2 * V, K, accum[V] - accum[i + 1]); // out[i] -&gt; T 费用 0 + All - X[0..i]  }  rep(i,0,M) {    int u = belongs[A[i]];    int v = belongs[B[i]];    if (u != v) network.add_edge(2 * u + 1, 2 * v, K, accum[v] - accum[u + 1]); // out[u] -&gt; in[v] , 容量k, 费用 0 + X[0..v] - X[0..u]  }  auto [maxflow, mincost] = network.flow(S,T,K/* 限流 */);  printf(&quot;%lld\n&quot;,(accum[V] - accum[belongs[0]]) * K - mincost);}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>G</p><p>容斥还是不熟 感觉这个式子需要记忆 $ans = \sum_{i=0}^n (-1)^i c_i$</p><p>然后这个排列会构成多个环感觉很常用虽然知道, 但是这里通过边表示i, 分配点表示取值还是没有想到, 感觉也是一种转化思路</p><p>然后环拆成链+两头也是很经典的方法了</p><p>实现上把 环变成链 再在数组上连续性, 去做dp的方法, 比多重再算g更神奇</p><p>另外这里递推贡献更新时没有保证正确性, 有的在处理时才修复正确性 比如<code>[1][2]</code> 和自环</p><p>H</p><p>网络流完全不会, 学了一手费用流, 看起来就是正常最大流 变了spfa和 路径cost和</p><p>atcoder 内置的scc 和mincostflow</p><pre><code class="cpp">#include &lt;atcoder/scc&gt;#include &lt;atcoder/mincostflow&gt;</code></pre><p>然后这个神奇的让 所有费用变正的 前缀和变化法 , 感觉其它地方似乎也能用</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://atcoder.jp/contests/abc214/editorial" target="_blank" rel="noopener">官方题解</a></p><p><a href="https://oi-wiki.org/graph/flow/min-cost/" target="_blank" rel="noopener">oi wiki 费用流</a></p>]]></content>
      
      
      <categories>
          
          <category> Atcoder </category>
          
          <category> ABC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图 </tag>
            
            <tag> dp </tag>
            
            <tag> scc </tag>
            
            <tag> 网络流 </tag>
            
            <tag> 排列 </tag>
            
            <tag> 容斥 </tag>
            
            <tag> 环 </tag>
            
            <tag> 费用流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atcoder abc261</title>
      <link href="/Blog/2022-07-29-ac_abc261/"/>
      <url>/Blog/2022-07-29-ac_abc261/</url>
      
        <content type="html"><![CDATA[<p>G(dp, 字符串),H/Ex(图,dp,拓扑排序,dij,拆点)</p><h1 id="G-Replace"><a href="#G-Replace" class="headerlink" title="G - Replace"></a>G - Replace</h1><p>字符串S,T包含小写英文</p><p>可以执行k种 操作, 任意次 任意顺序</p><p>第i种 操作: 1代价, 把一个字符Ci 换成 字符串Ai</p><p>问S变成T 的最小代价 或不可能</p><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>|S|&lt;=|T| &lt;= 50</p><p>k &lt;= 50</p><p>|Ai| &lt;= 50</p><p>2s</p><p>1024mb</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h3><p>既然是字符(离散)换成字符串</p><p>那么岂不是 <code>dp[i][j]</code> 表示 S前i 个换成 T前j个</p><p><code>dp[i][j]</code> = <code>dp[i-1][j-k]</code>, <code>s[i] -&gt; T[j-k+1..j]</code> 可行</p><p>那么问题是如何判断可行</p><p>换句话说, 如果我们能算出 <code>T[j-k+1..j]</code> 能否逆向变成<code>s[i]</code> 也是办法</p><p>但是感觉这个会分叉很多</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p><code>dp[i][j][c]</code> = 最小代价<code>T[i..j] =&gt; 字符 c</code></p><p><code>f[i][j][k][l]</code> = 最小代价<code>T[i..j]</code> =&gt; 字符串 <code>A[k][1..l]</code> (这个很关键, 是把字符中前缀设置成状态)</p><pre><code>for i = N -&gt; 1:  for j = i -&gt; N:    计算 f[i][j][k][l], f[i][j][c], f[i][j][k][1]</code></pre><hr><p>计算<code>f[i][j][k][l]</code> 时 (<code>T[i..j] =&gt; A[k][1..l]</code>)</p><p>注意到替换时顺序不会变相当于</p><p>时 (<code>T[i.m][m+1.j] =&gt; A[k][1..l-1] A[k][l]</code>)</p><p>$f[i][j][k][l] = min(f[i][m][k][l-1] + dp[m+1][j][A[k][l]])$</p><hr><p>计算<code>dp[i][j][c] / f[i][j][k][1]</code></p><ol><li>本身就是c字符, i==j, Ti = c, 0</li><li>一步到位 <code>T[i..j] = A[k], C[k] = c</code></li><li>先转换到某个<code>A[k]</code> 再转一步, <code>min(f[i][j][k][|A[k]|]+1),C[k] = c</code></li></ol><p><code>f[i][j][k][1]</code> 从<code>dp[i][j][A[k][1]]</code> 中读即可</p><hr><p>这大概是O(n^4)的状态</p><p><code>O(n^5)</code> 的转移复杂度</p><hr><p>这其中还有一个问题是, 对于A和C都是单个字符的, 你会出现<code>T[i...j] -&gt; c0 -&gt; c1 -&gt; c2</code></p><p>你需要求最短路dij/spfa松弛 即可</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc261/submissions/33608140" target="_blank" rel="noopener">https://atcoder.jp/contests/abc261/submissions/33608140</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;(int)n;i++)#define per(i,a,n) for (int i=n;i--&gt;(int)a;)int read(){int r;scanf(&quot;%d&quot;,&amp;r);return r;} // readconst int INF = 0x3f3f3f3f; // 无穷大const int maxc = &#39;z&#39; - &#39;a&#39;; // 最大字符对应数字vector&lt;int&gt; t;int f[60][60][60][60]; // [l..r] =&gt; a[k][0...i] (prefix(a[k][i]))int dp[60][60][30]; // [l..r] =&gt; char cint c[60] = {maxc + 1}; // 不存在的字符vector&lt;int&gt; a[60]; // c[i] -&gt; a[i];vector&lt;pair&lt;int,int&gt; &gt; c2c; // 单字符映射char tmp[60];int lcStr2VecInt(vector&lt;int&gt; &amp; res){ // lower case string to vector&lt;int&gt;  scanf(&quot;%s&quot;, tmp);  int sz = strlen(tmp);  res.resize(sz);  rep(i,0,sz) res[i] = tmp[i] - &#39;a&#39;; // s 放在 c[0],a[0]  return sz;}void setMin(int &amp;v0,int v1){v0 = min(v0,v1);}int main(){  int ns = lcStr2VecInt(a[0]); // s 放在 c[0],a[0]  int nt = lcStr2VecInt(t); // t  int K = read() + 1; // 包含s  rep(i,1,K){    scanf(&quot;%s&quot;, tmp);    c[i] = tmp[0] - &#39;a&#39;;    if(lcStr2VecInt(a[i]) == 1) c2c.push_back({c[i], a[i][0]});  }  rep(l,0,nt) {    rep(r,l,nt) { // 全部设置为无穷大      rep(k,0,K) rep(i,0,50) f[l][r][k][i] = INF;      rep(c,0,maxc+1) dp[l][r][c] = INF;    }    dp[l][l][t[l]] = 0; // 本身就是字符  }  // --- init ---  per(l,0,nt) rep(r,l,nt){ // T[l..r], 各种顺序都行 保证依赖关系先被运算    rep(k,0,K){      int sz = a[k].size();      rep(i,1,sz){ // T[l..j][j+1..r] = &gt; a[k][0..i-1],a[k][i]        int &amp;v = f[l][r][k][i];        rep(j,l,r) setMin(v, f[l][j][k][i-1] + dp[j+1][r][a[k][i]]);        if(i == sz - 1) setMin(dp[l][r][c[k]], v + 1); // T[i..j] =&gt; a[k] =&gt; c[k]      }    }    // dp[l][r][c]=min(dp[l][r][k][|a[k]|]) + 1 = min(len &gt; 1(上面算了), len = 1) + 1, len = |a[k]|    rep(c,0,maxc+1) for(auto [c0, c1]: c2c) setMin(dp[l][r][c0], dp[l][r][c1] + 1); // 26 次 松弛    rep(k,0,K) setMin(f[l][r][k][0], dp[l][r][a[k][0]]); // 更新 f 中首字母  }  int &amp; ans = f[0][nt-1][0][ns-1];  printf(&quot;%d\n&quot;, ans == INF? -1: ans);  return 0;}</code></pre><h1 id="H-Ex-Game-on-Graph"><a href="#H-Ex-Game-on-Graph" class="headerlink" title="H/Ex - Game on Graph"></a>H/Ex - Game on Graph</h1><p>N点, M边</p><p>有向边 [ui,vi,weight i], 无重边 无自环</p><p>初始,点v上有个棋子</p><p>T和A交替游戏</p><ul><li>如果棋子所在点 没有向外路径 则结束游戏</li><li>如果有路径,任选一个走路径</li></ul><p>T 让weight和尽量小, A让和尽量大</p><p>T(结束游戏优先级 &gt; 和尽量小)</p><p>A(让游戏无限循环优先级 &gt; 和尽量大)</p><h2 id="限制-1"><a href="#限制-1" class="headerlink" title="限制"></a>限制</h2><p>N 2e5</p><p>M 2e5</p><p>Wi [0,1e9]</p><p>2s</p><p>1024mb</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h3><p>并不是有环就一定无限, 例如 <code>a-&gt;b-&gt;c-&gt;d-&gt;a</code></p><p>a连了个有限的, c也连了个更短的有限的</p><p>那么虽然你可以走到b,让对手走到c,这样在走到有限的 会比a直接去到有限的更短</p><p>考虑从叶子反过来, 判断是否有限,感觉bfs或者spfa/dij的感觉</p><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>图上环状dp</p><p><code>dp[x][0]</code> 从x出发 尽量小</p><p><code>dp[x][1]</code> 从x出发 尽量大</p><p><code>dp[x][0] = min (f[y][1] + weight[x][y])</code>, 相当于 反向图的最短路</p><p><code>dp[x][1] = max (f[y][0] + weight[x][y])</code>, 需要所有<code>f[y][0]</code> 被计算后才有意义</p><hr><p>然后就反图+拓扑+dij 就没了???</p><p>我感觉这个条件必要, 但总觉得没有证明到充分</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc261/submissions/33603896" target="_blank" rel="noopener">https://atcoder.jp/contests/abc261/submissions/33603896</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readll dp[2][200010];ll mx[200010]; // 只记录1的, 因为0的直接记录在pq和dp中, 而1的在子节点未完全计算时pq和dp都不会记录int deg[200010]; // 正向图出度, 反向图入度vector&lt;pair&lt;int,int&gt; &gt; g[200010]; // 反向图 v = {u, weight}template &lt;typename T&gt; using minPQ = priority_queue&lt;T,vector&lt;T&gt;, greater&lt;T&gt;&gt;; // 小根堆int main(){  int n = read();  int m = read();  int v = read();// 起点  rep(i,0,2) fill(dp[i],dp[i]+n+1,-1); // 未访问  rep(i,0,m) {    int u = read();    int v = read();    int w = read();    g[v].push_back({u, w});    deg[u] ++;  }  minPQ&lt;array&lt;ll,3&gt;&gt; q; // 小根堆, dij 每次找最小的未达点变为可达 {距离, 0/1, 点}  rep(i,1,n+1) if(deg[i] == 0) rep(j,0,2) q.push({0, j, i}); // dp[0/1][i] 反向入度为0 的节点  while(q.size()) {    auto [d, i, u] = q.top(); q.pop();    if(dp[i][u] != -1) continue; // 计算过    dp[i][u] = d; // 更新值    if(!i) { // dp[0][u] -&gt; dp[1][v]      for(auto [v, w] : g[u]) { // 更新反向边 并更新 deg[v] --        mx[v] = max(mx[v], d + w); // 更新值但是 不一定进入pq dp[x][1] = max (f[y][0] + weight[x][y])        if(--deg[v] == 0) q.push({mx[v], 1, v}); // dp[1][v] 只能所有计算都计算后才有意义      }    } else for(auto [v, w] : g[u]) q.push({d + w, 0, v}); // dp[1][u] -&gt; dp[0][v] dij  }  if(dp[0][v] == -1) printf(&quot;INFINITY\n&quot;);  else printf(&quot;%lld\n&quot;, dp[0][v]);  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>G</p><p>大小只有50的情况, <strong>对字符串中的前缀设计状态</strong>, 从而有dp的状态</p><p>第二就是 小的情况 多次松弛简单也效率满足, 不需要上dij</p><p>H/Ex</p><p>我感觉这个条件必要, 但总觉得没有证明到充分???</p><p>可能关键在于,虽然点上有 0/1两个状态,但实际上这两个状态不相关, 所以其实每个点可以拆点</p><p>这样就变成了路径的逆向dp了, 有环一定不行, 所以关键在这个拆点 -&gt; 变成dij</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://atcoder.jp/contests/abc261/editorial" target="_blank" rel="noopener">官方题解</a></p>]]></content>
      
      
      <categories>
          
          <category> Atcoder </category>
          
          <category> ABC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图 </tag>
            
            <tag> dp </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 拓扑排序 </tag>
            
            <tag> dij </tag>
            
            <tag> 拆点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atcoder abc213</title>
      <link href="/Blog/2022-07-28-ac_abc213/"/>
      <url>/Blog/2022-07-28-ac_abc213/</url>
      
        <content type="html"><![CDATA[<p>F(SA,后缀数组,单调栈)G(bitmask, 集合论, 图, dp, 子集遍历),H/Ex(dp, 卷积, fft, NTT, 分治NTT)</p><h1 id="F-Common-Prefixes"><a href="#F-Common-Prefixes" class="headerlink" title="F - Common Prefixes"></a>F - Common Prefixes</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://atcoder.jp/contests/abc213/tasks/abc213_f" target="_blank" rel="noopener">https://atcoder.jp/contests/abc213/tasks/abc213_f</a></p><p>给长n字符串S</p><p>求其每个位置开始的后缀字符串, 和所有其它后缀字符串的 公共前缀和</p><h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h3><p>n 1e6</p><p>3s</p><p>1024mb</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="官方"><a href="#官方" class="headerlink" title="官方"></a>官方</h3><p>知识点 <a href="http://yexiaorain.github.io/Blog/2022-07-27-sa/">后缀数组 SA</a></p><p>那么对于 后缀i</p><p>它在SA中的位置是 rank[i]</p><p>有高度数组表示 rank[i] 和 rank[i-1]的最长公共前缀</p><p>那么就是 min(height[0..i]]) + min(height[1..i]) +… + min(height[i..i]) + (n-i) + min(height[i+1..i+1]) + .. + min(height[i+1..n])</p><p>直接枚举依然不行</p><p>考虑 可以单调栈维护计算其中一半</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc213/submissions/33587517" target="_blank" rel="noopener">https://atcoder.jp/contests/abc213/submissions/33587517</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 1000000007#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_back#define mp make_pairll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readconst int N = 1000000;char s[N+10]; // readint rk[N+10]; // rankint rk0[N+10]; // 临时int h[N+10]; // heightint sa[N+10]; // SAll pre[N+10]; // 前缀和ll suf[N+10]; // 后缀和int main(){  int n = read();  scanf(&quot;%s&quot;, s);  // sa &amp; rank  iota(sa,sa+n,0);  sort(sa,sa+n,[=](int i,int j){return s[i] &lt; s[j];});  rk[sa[0]] = 0;  rep(i,1,n) rk[sa[i]] = rk[sa[i-1]] + (s[sa[i]] != s[sa[i-1]]);  rep(pwr,0,22){    int w = 1&lt;&lt;pwr;    if(w &gt; n) break;    rep(i,0,n) rk0[i] = rk[i];    auto f = [=](int i){return i &lt; n?rk0[i]:-1;};    sort(sa,sa+n,[=](int i,int j){ return mp(f(i),f(i+w)) &lt; mp(f(j),f(j+w));});    rk[sa[0]] = 0;    rep(i,1,n) rk[sa[i]] = rk[sa[i-1]] + (mp(f(sa[i]),f(sa[i]+w)) != mp(f(sa[i-1]),f(sa[i-1]+w)));  }  // height  int hei = 0;  rep(i,0,n){    if(!rk[i]) continue;    if(hei) hei--;    while(s[i + hei] == s[sa[rk[i]-1] + hei]) hei++;    h[rk[i]] = hei;  }  // 单调栈  {    vector&lt;int&gt; stk = {};    rep(i,1,n) {      while(stk.size() &amp;&amp; h[i] &lt; h[stk.back()]) stk.pop_back();      // h[i] * length + stk[]      int last = stk.size() ? stk.back() : 0;      pre[i] = pre[last] + h[i] * (i - last);      stk.push_back(i);    }  }  {    vector&lt;int&gt; stk = {};    per(i,1,n) {      while(stk.size() &amp;&amp; h[i] &lt; h[stk.back()]) stk.pop_back();      // h[i] * length + stk[]      int last = stk.size() ? stk.back() : n;      suf[i] = suf[last] + h[i] * (last - i);      stk.push_back(i);    }  }  rep(i,0,n) printf(&quot;%lld\n&quot;,(n-i) + pre[rk[i]] + suf[rk[i]+1]);  return 0;}</code></pre><h1 id="G-Connectivity-2"><a href="#G-Connectivity-2" class="headerlink" title="G - Connectivity 2"></a>G - Connectivity 2</h1><p><a href="https://atcoder.jp/contests/abc213/tasks/abc213_g" target="_blank" rel="noopener">https://atcoder.jp/contests/abc213/tasks/abc213_g</a></p><p>无向图</p><p>n 点, m 边</p><p>考虑移除任意条边得到新图G, 有 2^M 种新图G</p><p>对于每个点, 计算在所有新图中, 和1属于同一连通块的个数</p><p>mod 9098244353</p><h2 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h2><p>n 17</p><p>无重边,无自环</p><p>3s</p><p>1024mb</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>显然, n&lt;=17 是个bitmask的题</p><p>2^17 = 131072</p><p>定义mask 为点1所在的联通块, 那么其实状态只有2^16 了</p><p>c[mask] = 包含mask的联通块个数</p><p>cnt[mask] = 边的两个端点都属于mask 的数量</p><p>对于剩下m - cnt[Mask] 条边</p><ul><li>如果端点均不在mask中, 则是否选边对mask没有影响,</li><li>如果端点一个在一个不在不在mask中, 则不可选,否则mask会变化</li></ul><p>导出子图(induced subgraph)是指，由该图顶点的一个子集和该图中两端均在该子集的所有边的集合组成的图。</p><hr><p>dp[S] = S构成连通块时, 内部的选的边端点均属于S的方案数</p><p>$dp[S] = 2^{cnt(S)} - \sum_{1\in T, T\subset S} dp[T] \cdot 2^{cnt(S-T)}$</p><p>所有方案 - 非所有点连通的方案(即是一个包含1的非所有点连通块,以及不包含1的连通块内的点的剩余边随便连)</p><hr><p>那么$ans(x) = \sum_{1\in S,x\in S} dp[S] \cdot 2^{cnt(全集 - S)}$</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc213/submissions/33590273" target="_blank" rel="noopener">https://atcoder.jp/contests/abc213/submissions/33590273</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 998244353#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // read// 2^17 =      65&#39;536// 2^17 =     131&#39;072// 3^16 =  43&#39;046&#39;721// 3^17 = 129&#39;140&#39;163const int N = 1&lt;&lt;17;int f[N+10];int c[N+10]; // 边两端 都属于mask 的数量ll p2[150]={1}; // 2**power , 17 * (17-1)/2 = 136ll ans[20];int main(){  rep(i,1,140) p2[i]=2*p2[i-1]%MOD;  int n = read();  int m = read();  // O(m 2^n)  rep(i,0,m){    int u = read() - 1; // 0-index    int v = read() - 1;    rep(mask,0,p2[n]) if((mask &amp; p2[u]) &amp;&amp; (mask &amp; p2[v])) c[mask]++; // 直接统计mask数量  }  rep(S0,0,p2[n-1]){    int S = 2*S0+1; // S一定要选0    f[S] = p2[c[S]]; // f[S] = 2^c[S] - sum{1\in T,T\subset S} f[T] 2^c[S-T]    for(int T0=S0&amp;(S0-1);S0/* 只有点0 没有真子集*/;T0=(T0-1)&amp;S0){// 真子集遍历 记住复杂度是O(3^n)      int T = 2*T0 + 1; // T一定选0      (f[S] -= f[T] * p2[c[S-T]] % MOD) %= MOD;      if(!T0)break;    }    // S包含0,i ; 时间复杂度 O(n 2^n)    rep(i,1,n) if(S &amp; p2[i]) (ans[i] += f[S]*p2[c[p2[n]-1-S]] % MOD) %= MOD;  }  rep(i,1,n) printf(&quot;%lld\n&quot;, (ans[i]+MOD) % MOD);}</code></pre><h1 id="H-Ex-Stroll"><a href="#H-Ex-Stroll" class="headerlink" title="H/Ex - Stroll"></a>H/Ex - Stroll</h1><p><a href="https://atcoder.jp/contests/abc213/tasks/abc213_h" target="_blank" rel="noopener">https://atcoder.jp/contests/abc213/tasks/abc213_h</a></p><p>N个点</p><p>M 个点对, 连接ui,vi, <code>p[i][d]</code>条路 长度d的路, (d [1,T])</p><p>找从点1开始,点1结束,长度等于T的路径方案数</p><h2 id="范围-2"><a href="#范围-2" class="headerlink" title="范围"></a>范围</h2><p>n 10</p><p>m min(10,n(n-1)/2)</p><p>t 4e4</p><p><code>p[1..m][1..T]</code> \in [0,998244353]</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h3><p>一眼递推</p><p><code>f[u][d] =</code>到u步数为T的方案数</p><p>那么每次找未贡献的最小的<code>d</code></p><p><code>f[v][d+step] += p[边[u &lt;-&gt; v]][step] * f[u][d]</code></p><p>但这样$NT$个状态, 每个状态会更新$MT$个点</p><p>看起来有$O(MNT^2)$</p><h3 id="官方-1"><a href="#官方-1" class="headerlink" title="官方"></a>官方</h3><p><code>dp[u][i]=</code> 1 出发, 长度i, 走到u 方案数</p><p>考虑最后一次转移 从v到u, 走t步</p><p>$dp[u][i] = \sum_{(u,v)\in E} \sum_{t=1}^i dp[v][i-t] * p[e_{u,v}][t]$</p><p>直接NTT依然不行</p><p>因为它们相互依赖</p><p>于是来到了分治NTT</p><hr><p>cdq 分治 + NTT/fft 框架</p><pre><code class="cpp">solve(l..r):  solve(l..mid)  // 计算(l..mid) 对(mid+1..r) 的贡献 , 这一部分将是dp[l..mid] 卷积 g[1..(r-l+1)], fft/ntt nlogn  solve(mid+1..r)</code></pre><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc213/submissions/me" target="_blank" rel="noopener">https://atcoder.jp/contests/abc213/submissions/me</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;#include &lt;atcoder/all&gt;using namespace std;using mint=atcoder::modint998244353;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readll n;ll p[20][40010]; // 系数矩阵mint dp[20][40010];vector&lt;pair&lt;int,int&gt;&gt; e[20];// cdq 分治 [l..r],// 每次分治 [l..mid], 计算[l..mid] 对 [mid+1..r]的贡献, 分治[mid+1..r]// 所以卷积代价 convolution([l..mid] x g[1..(r-l+1)]), ntt n log n, 总 =&gt; logn// 意味着每次分治solve(l..r)结束后,(l..r)的内部的贡献计算完了,(r+1...)的贡献完全没有统计void solve(ll l,ll r) {  if(l==r) return;  ll mid=(l+r)/2;  solve(l, mid);  rep(u,1,n+1) for(auto [v,eid]:e[u]) { // 枚举所有点和边    vector &lt;mint&gt; A = {};    vector &lt;mint&gt; B = {0};    // A[l..mid] , T[1..(r-l+1)], dp[i+1] = dp[i-j] * p[j] = A[i-j-l] * B[j] = C[i-l]    rep(i,l,mid+1) A.pb(dp[u][i]);    rep(i,1,(r-l+1)+1) B.pb(p[eid][i]);    auto C = atcoder::convolution(A,B); // 内部小的暴力 大的 fft    rep(i,mid+1,r+1) dp[v][i]+=C[i-l].val();  }  solve(mid+1,r);}int main() {  n = read();  ll m = read();  ll t = read();  rep(i,0,m) {    ll u = read();    ll v = read();    e[u].pb({v,i});    e[v].pb({u,i});    rep(j,1,t+1) p[i][j] = read();  }  dp[1][0] = 1;  solve(0,t);  printf(&quot;%d\n&quot;,dp[1][t].val());  return 0;}// dp[u][i] = sum{(u,v)\in E} sum{t=1..i} dp[v][i-t] * p[e_{u,v}][t]$</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>F</p><p>知识点 后缀数组 与高度数组</p><p>G</p><p>感觉有点集合论转移的思路,没有类似的练习</p><p>然后就是如何做分类和贡献统计, 这里是按照和1连通的作为一个分类的依据</p><p>分别记录内部方案数, 和 外部方案倍数, 外部倍数相对好算, 而内部方案数 需要dp推导</p><p>所有子集遍历的复杂度是$3^n$ 不是$4^n$</p><p>H</p><p>除了dp还可以数学直接表示到目标点, 从而引申出求和 有卷积</p><p>这里新知识点是分治NTT</p><p>atcoder 提供 atcoder::modint998244353, 以及卷积 atcoder::convolution</p><hr><p>关于Ubuntu 使用, 最简单就是, 克隆下来做个软链接</p><pre><code class="bash">git clone git@github.com:atcoder/ac-library.gitcd /usr/local/include/ # 切换到目录sudo ln -s 克隆路径/atcoder</code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://atcoder.jp/contests/abc213/editorial" target="_blank" rel="noopener">官方题解</a></p><p><a href="https://atcoder.jp/contests/abc213/editorial/2410" target="_blank" rel="noopener">https://atcoder.jp/contests/abc213/editorial/2410</a></p>]]></content>
      
      
      <categories>
          
          <category> Atcoder </category>
          
          <category> ABC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图 </tag>
            
            <tag> fft </tag>
            
            <tag> dp </tag>
            
            <tag> 后缀数组 </tag>
            
            <tag> 单调栈 </tag>
            
            <tag> bitmask </tag>
            
            <tag> NTT </tag>
            
            <tag> SA </tag>
            
            <tag> 集合论 </tag>
            
            <tag> 子集遍历 </tag>
            
            <tag> 卷积 </tag>
            
            <tag> 分治NTT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>后缀数组 SA</title>
      <link href="/Blog/2022-07-27-sa/"/>
      <url>/Blog/2022-07-27-sa/</url>
      
        <content type="html"><![CDATA[<h1 id="相关内容"><a href="#相关内容" class="headerlink" title="相关内容"></a>相关内容</h1><p>后缀自动机</p><h1 id="最终产物"><a href="#最终产物" class="headerlink" title="最终产物"></a>最终产物</h1><p>一个数组sa 记录下标, 按照后缀字典序排序</p><p>以及需要的话一个记录rank的数组(和sa相反)</p><p><img src="https://oi-wiki.org/string/images/sa1.png" alt="后缀数组"></p><p>h[i] 表示排名为i的和排名为i-1的最长公共前缀长度</p><h1 id="SA"><a href="#SA" class="headerlink" title="SA"></a>SA</h1><p>就是字符串所有后缀, 按照字典序排序</p><p>就是先按照每个位置开始长度为1排序, 变成数值顺序</p><p>再按照长度2的前缀顺序排, 但是此时 不需要原字符串,而直接用算出的数值顺序拼接</p><p>再按照长度4的前缀顺序排, 同上 相当于两个 长度2 的拼接</p><pre><code>for step =&gt; 2 * step:  rank = sort(pair&lt; rank[i],rank[i+step] &gt;)</code></pre><h2 id="例如代码"><a href="#例如代码" class="headerlink" title="例如代码"></a>例如代码</h2><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 1000000007#define rep(i,a,n) for (ll i=a;i&lt;n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backconst int N = 1000000;bool eq(vector&lt;int&gt;&amp; rk, int x,int y,int w){  return rk[x] == rk[y] &amp;&amp; rk[x+w] == rk[y+w];}// 0-index + 基数排序void calcsa(char *s,int n, vector&lt;int&gt; &amp;sa,vector&lt;int&gt; &amp;rk){  const int SIZE = max(512, n+1); // 字符集大小  vector&lt;int&gt;cnt(SIZE, 0); // char 2 count  rk.resize(2*n); // rank: 相等的前缀rank相等, 结束符rank = 0, 所以rank从1开始  sa.resize(n); // 后缀 index  rep(i,0,n) ++cnt[rk[i] = s[i]]; // 计数统计  rep(i,1,SIZE) cnt[i] += cnt[i - 1]; // 计数统计前缀  per(i,0,n) sa[--cnt[rk[i]]] = i; // 当前排序  { // n == 1    auto oldrk = rk;    int p = 0;    rep(i,0,n) {      if (i == 0 || oldrk[sa[i]] != oldrk[sa[i-1]]) p++;      rk[sa[i]] = p;    }  }  // rk = sort({rk[i],rk[i+w]}  for(int w = 1; w &lt; n; w *= 2) {    // 从低位到高位排序, 先排低位 rank[i+w], 再排 rank[i+0]    for(auto d:{w, 0}){      cnt = vector(SIZE,0);      rep(i,0,n) ++cnt[rk[i + d]]; // 所有 i+d 开始的计数统计      rep(i,1,SIZE) cnt[i] += cnt[i - 1];// 前缀和(基数排序      auto idx = sa;      per(i,0,n) sa[--cnt[rk[idx[i] + d]]] = idx[i]; // 保序    }    auto oldrk = rk;    int p = 0;    rep(i,0,n) {      if (i == 0 || oldrk[sa[i]] != oldrk[sa[i-1]] || oldrk[sa[i]+w] != oldrk[sa[i - 1] + w]) p++;      rk[sa[i]] = p;    }  }  rk.resize(n+1);}int main() {  char s[N+10] = &quot;aabaaaab&quot;;  int n = strlen(s) ;  printf(&quot;%d\n&quot;,n);  printf(&quot;%s\n&quot;,s);  vector&lt;int&gt; sa;  vector&lt;int&gt; rank;  calcsa(s, n, sa, rank);  rep(i,0,n) printf(&quot;%d &quot;, sa[i]);  return 0;}</code></pre><h2 id="height-数组"><a href="#height-数组" class="headerlink" title="height 数组"></a>height 数组</h2><p>而h数组, 首次相等的则 = 1</p><p>h[i] = lcp(sa[i],sa[i-1])</p><p>性质</p><p>h[rk[i]] &gt;= h[rk[i-1]] - 1</p><p>设后缀i-1 = “aAB”, a字符,A是h[i-1]对应字符串剩余部分,B是后缀的剩余部分</p><p>那么后缀i = “AB”</p><p>因为后缀i-1 = “aAB” 其实存在 “aAC”, “C &lt; B”, 且”C,B”公共前缀为空字符串</p><p>那么也就说明”AC”也存在</p><p>“AC”, “AB” 之间 如果还有其他的字符串,只能是”AD”形式 “C &lt; D &lt; B”, 那么长度至少为”|A|”, 得证</p><p>所以 可以按照i的顺序暴力算</p><pre><code class="cpp">int k = 0;rep(i,0,n) {  if (rk[i] == 0) continue;  if (k) --k;  while (s[i + k] == s[sa[rk[i] - 1] + k]) ++k;  h[rk[i]] = k;}</code></pre><h2 id="vector-sort-pair版本"><a href="#vector-sort-pair版本" class="headerlink" title="vector + sort + pair版本"></a>vector + sort + pair版本</h2><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 1000000007#define rep(i,a,n) for (ll i=a;i&lt;n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_back// 0-index + vector + sort// sa 下标按照顺序排列// rank 下标对应顺序index// h sa 中相邻后缀 最长公共前缀 h[0] = 0;template&lt;class T&gt;void calc_sa_rank(vector&lt;T&gt;&amp; arr, vector&lt;int&gt; &amp;sa,vector&lt;int&gt; &amp;rank, vector&lt;int&gt;&amp;h){  int n = arr.size();  rank = vector&lt;int&gt;(n,0);  sa = vector&lt;int&gt;(n,0);  iota(sa.begin(),sa.end(), 0);  sort(sa.begin(),sa.end(), [=](int i,int j){return arr[i] &lt; arr[j];});  rep(i,1,n) rank[sa[i]] = rank[sa[i-1]] + !(arr[sa[i]] == arr[sa[i-1]]);  for(int w = 1; w &lt; n; w *= 2) {    auto rank0 = rank;    auto rk = [=](int i){return i &lt; n ? rank0[i] : -1;};    sort(sa.begin(),sa.end(), [=](int i,int j){        return rk(i) != rk(j) ? rk(i) &lt; rk(j) : rk(i+w) &lt; rk(j+w);    });    rank[sa[0]] = 0;    rep(i,1,n) rank[sa[i]] = rank[sa[i-1]] + !(rk(sa[i]) == rk(sa[i-1]) &amp;&amp; rk(sa[i]+w) == rk(sa[i-1]+w));  }  // height  h = vector&lt;int&gt;(n,0);  int k = 0;  rep(i,0,n) {    if (rank[i] == 0) continue;    if (k) --k;    while (arr[i + k] == arr[sa[rank[i] - 1] + k]) ++k;    h[rank[i]] = k;  }}int main() {  char s[100] = &quot;aabaaaab&quot;;  int n = strlen(s) ;  printf(&quot;s:%s\n&quot;,s);  vector&lt;char&gt; arr ;  rep(i,0,n) arr.pb(s[i]);  vector&lt;int&gt; sa;  vector&lt;int&gt; rank;  vector&lt;int&gt; h;  calc_sa_rank(arr, sa, rank, h);  printf(&quot;sa:\n&quot;);  rep(i,0,n) printf(&quot;%d %s\n&quot;, sa[i], s + sa[i]);  printf(&quot;\nrk:\n&quot;);  rep(i,0,n) printf(&quot;%d %s\n&quot;, rank[i], s + i);  printf(&quot;\nhei:&quot;);  rep(i,0,n) printf(&quot;%d &quot;, h[i]);  printf(&quot;\n&quot;);  return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SAM </tag>
            
            <tag> SA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从FFT 到 FWHT 快速沃尔什-阿达玛转换(Walsh Hadamard transform)</title>
      <link href="/Blog/2022-07-26-FWT/"/>
      <url>/Blog/2022-07-26-FWT/</url>
      
        <content type="html"><![CDATA[<h1 id="FWHT"><a href="#FWHT" class="headerlink" title="FWHT"></a>FWHT</h1><p>快速沃尔什-阿达玛转换(Fast Walsh-Hadamard transform), 一种广义傅立叶变换(FWHT)</p><h2 id="解决什么问题"><a href="#解决什么问题" class="headerlink" title="解决什么问题"></a>解决什么问题</h2><p>FWHT 是用于解决对下标进行位运算卷积问题的方法</p><p>$c_{i} = \sum_{i=j \bigoplus k}a_{j} b_{k}$</p><p>并且没有fft中会涉及到double</p><hr><p>前置知识 FFT(DFT)</p><p>DFT:</p><p>${\displaystyle {\begin{bmatrix}f_{0}\\f_{1}\\\vdots \\f_{n-1}\end{bmatrix}}={\begin{bmatrix}1&amp;1&amp;1&amp;\cdots &amp;1\\1&amp;\alpha &amp;\alpha ^{2}&amp;\cdots &amp;\alpha ^{n-1}\\1&amp;\alpha ^{2}&amp;\alpha ^{4}&amp;\cdots &amp;\alpha ^{2(n-1)}\\\vdots &amp;\vdots &amp;\vdots &amp;&amp;\vdots \\1&amp;\alpha ^{n-1}&amp;\alpha ^{2(n-1)}&amp;\cdots &amp;\alpha ^{(n-1)(n-1)}\\\end{bmatrix}}{\begin{bmatrix}v_{0}\\v_{1}\\\vdots \\v_{n-1}\end{bmatrix}}.}$</p><h2 id="回顾离散傅立叶与卷积"><a href="#回顾离散傅立叶与卷积" class="headerlink" title="回顾离散傅立叶与卷积"></a>回顾离散傅立叶与卷积</h2><p>核心等式</p><p>$\operatorname{FFT}(a * b) = \operatorname{FFT}(a) \cdot \operatorname{FFT}(b)$</p><p>快速变换, $x$原向量,$N$大小, $idx$ 下标</p><p>$idx \le \frac{N}{2}$</p><p>$f(x,N,idx) = f(even(x),\frac{N}{2},idx) + w^k \cdot f(odd(x),\frac{N}{2},idx)$</p><p>$f(x,N,idx+\frac{N}{2}) = f(even(x),\frac{N}{2},idx) - w^k \cdot f(odd(x),\frac{N}{2},idx)$</p><h2 id="Or-版本-FORT-Fast-or-transform"><a href="#Or-版本-FORT-Fast-or-transform" class="headerlink" title="Or 版本 FORT(Fast or transform)"></a>Or 版本 FORT(Fast or transform)</h2><h3 id="Or卷积-与-ForT"><a href="#Or卷积-与-ForT" class="headerlink" title="Or卷积 与 ForT"></a>Or卷积 与 ForT</h3><p>$c_{i} = \sum_{i = j | k}a_{j} b_{k}$, 这里$|$ 是按位或不是整除</p><p>令$fort[C]_ i = \sum_{i = j|i} A_j$</p><p>$\begin{aligned}<br>fort[a]_ i \cdot fort[b]_ i &amp;= (\sum_{j|i=i} a_j) \cdot (\sum_{k|i=i} b_k) \\<br>&amp;= \sum_{j|i=i} \sum_{k|i=i} a_jb_k \\<br>&amp;= \sum_{(j|k)|i = i} a_jb_k \\<br>&amp;= fort[c]_ i<br>\end{aligned}$</p><p>这证明了 $\operatorname{ForT}(\left(\sum_{i=j | k}a_{j} b_{k}\right)) = \operatorname{ForT}(a) \cdot \operatorname{ForT}(b)$</p><h3 id="快速变换"><a href="#快速变换" class="headerlink" title="快速变换"></a>快速变换</h3><p>下面问题就是如何fast, 如何让快速计算fort和它的逆变换ifort</p><p>快速变换, $x$原向量,$N$大小, $idx$ 下标</p><p>$idx &lt; \frac{N}{2}$</p><p>$f(x,N,idx) = f(x, \frac{N}{2},idx)$</p><p>$f(x,N,idx+\frac{N}{2}) = f(x[0\cdots \frac{N}{2}-1]),\frac{N}{2},idx) + f(x[\frac{N}{2}\cdots N-1],\frac{N}{2},idx)$</p><p>因为本身$fort$的第$i$位就是所有$i$的二进制子集位置的和</p><p>那么对于$idx$ 它的子集一定也是在前半数组中</p><p>那么对于$idx + \frac{N}{2}$ 它的 其实就是最高位多了一个bit, 除了这个bit, 剩余部分和$idx$一样, 所以前半后半都按照$idx$来计算求和即可</p><p>至此完成fast</p><pre><code class="cpp">void ForT(modint *f) {  for (int k = 1; k &lt; n; k *=2){    for (int i = 0; i &lt; n; i += 2*k){      for (int j = 0; j &lt; k; j++){        // f[i+j] = f[i+j];        f[i+j+k] += f[i+j];      }    }  }}</code></pre><h3 id="逆变换"><a href="#逆变换" class="headerlink" title="逆变换"></a>逆变换</h3><p>可以直接参考fast的过程, 每个位置表示它所有bit子集的和, 那么按照反过来, 可以先减去未包含最低的其它子集和bit的值,未包含了低2位bit的其她子集和,…</p><p>显然对于的向量的$v$首个值有 $fort(v)_ 0 = v_0$</p><p>所以 $a_0 = fort(a)_ 0$</p><p>因为 $fort(a)_ 1 = fort(a_0) + fort(a_1)$</p><p>所以 $a_1 = fort(a_1) = fort(a)_ 1 - fort(a_0)$</p><p>同理$idx &lt; \frac{N}{2}$</p><p>$f(x,N,idx) = f(x, \frac{N}{2},idx)$</p><p>$f(x,N,idx+\frac{N}{2}) = f(x[0\cdots \frac{N}{2}-1]),\frac{N}{2},idx) - f(x[\frac{N}{2}\cdots N-1],\frac{N}{2},idx)$</p><pre><code class="cpp">void IForT(modint *f) {  for (int k = 1; k &lt; n; k *=2){    for (int i = 0; i &lt; n; i += 2*k){      for (int j = 0; j &lt; k; j++){        f[i+j+k] -= f[i+j];      }    }  }}</code></pre><hr><p>合并</p><pre><code class="cpp">// Or卷积void ForT(vector&lt;modint&gt; &amp;f,int flag = 1/* 1:正变换,-1:逆变换 */) {  int n = f.size();  for (int k = 1; k &lt; n; k *=2){    for (int i = 0; i &lt; n; i += 2*k){      for (int j = 0; j &lt; k; j++){        f[i+j+k] += flag * f[i+j];      }    }  }}</code></pre><h2 id="And-卷积-Fast-and-transform"><a href="#And-卷积-Fast-and-transform" class="headerlink" title="And 卷积(Fast and transform)"></a>And 卷积(Fast and transform)</h2><p>$c_{i} = \sum_{i = j \&amp; k}a_{j} b_{k}$</p><p>和Or的部分同理</p><ol><li>定义变换$fandt(a)_ i = \sum_{i|j = j} a_j$</li><li>证明 $fandt(a) \odot fandt(b) = fandt(\left(\sum_{i = j \&amp; k}a_{j} b_{k}\right))$</li><li>利用分块关系,实现fast</li></ol><p>最终代码</p><pre><code class="cpp">void FandT(vector&lt;modint&gt; &amp;f, int flag = 1/* 1:正变换,-1:逆变换 */) {  int n = f.size();  for (int k = 1; k &lt; n; k *=2){    for (int i = 0; i &lt; n; i += 2*k){      for (int j = 0; j &lt; k; j++){        f[i+j] += f[i+j+k] * flag;      }    }  }}</code></pre><h2 id="Xor卷积-与-FWHT-Fast-Walsh-Hadamard-transform"><a href="#Xor卷积-与-FWHT-Fast-Walsh-Hadamard-transform" class="headerlink" title="Xor卷积 与 FWHT(Fast Walsh-Hadamard transform)"></a>Xor卷积 与 FWHT(Fast Walsh-Hadamard transform)</h2><p>$\operatorname{FWHT}(\left(\sum_{i=j \bigoplus k}a_{j} b_{k}\right)) = \operatorname{FWHT}(a) \cdot \operatorname{FWHT}(b)$</p><h3 id="定义FWHT"><a href="#定义FWHT" class="headerlink" title="定义FWHT"></a>定义FWHT</h3><p>其实和上面一样,依然是三步,定义转换,证明等式,实现fast</p><p>定义符号 $x\otimes y=\text{popcount}(x \&amp; y) \bmod 2$, 即 $x$位与$y$后的二进制表示的$1$的个数再$\bmod 2$</p><p>有性质$(i \otimes j) \oplus (i \otimes k) = i \otimes (j \oplus k)$</p><p>证明: 对于给定的一位, 如果i中0, 则都贡献0, 如果i中是1, $j,k$对应的是1 则贡献是0 则不贡献, 得证</p><p>定义: $fwht[a]_ i = \sum_{i\otimes j = 0}a_j - \sum_{i\otimes j = 1}a_j$</p><p>那么有:</p><p>$fwht[a]_ i \cdot fwht[b]_ i$</p><p>$\begin{aligned}<br>&amp;= (\sum_{i\otimes j = 0} a_j - \sum_{i\otimes j = 1} a_j)\cdot (\sum_{i\otimes k = 0} b_k - \sum_{i\otimes k = 1} b_k) \\<br>&amp;=\left((\sum_{i\otimes j=0}a_j)(\sum_{i\otimes k=0}b_k)+(\sum_{i\otimes j=1}a_j)(\sum_{i\otimes k=1}b_k) \right)-\left((\sum_{i\otimes j=0}a_j)(\sum_{i\otimes k=1}b_k)-(\sum_{i\otimes j=1}a_j)(\sum_{i\otimes kj=0}b_k)\right)\\<br>&amp;=\sum_{i\otimes(j \oplus k)=0}a_jb_k-\sum_{i\otimes(j\oplus k)=1}a_jb_k \\<br>&amp;=\sum_{i\otimes l = 0}\sum_{l = j \oplus k}a_jb_k-\sum_{i\otimes l = 1}\sum_{l = j\oplus k}a_jb_k \\<br>&amp;= fwht[\left(\sum_{i=j \bigoplus k}a_{j} b_{k}\right)]_ i<br>\end{aligned}$</p><h3 id="Walsh-matrix-and-Hadamard-transform"><a href="#Walsh-matrix-and-Hadamard-transform" class="headerlink" title="Walsh matrix and Hadamard transform"></a>Walsh matrix and Hadamard transform</h3><p>可以看看Walsh矩阵的样子</p><p>${\displaystyle H_{m}={\frac {1}{\sqrt {2}}}{\begin{pmatrix}H_{m-1}&amp;H_{m-1}\\H_{m-1}&amp;-H_{m-1}\end{pmatrix}}}$</p><p>${\begin{aligned}H_{0}&amp;=+{\begin{pmatrix}1\end{pmatrix}}\\H_{1}&amp;={\frac {1}{\sqrt {2}}}\left({\begin{array}{rr}1&amp;1\\1&amp;-1\end{array}}\right)\\H_{2}&amp;={\frac {1}{2}}\left({\begin{array}{rrrr}1&amp;1&amp;1&amp;1\\1&amp;-1&amp;1&amp;-1\\1&amp;1&amp;-1&amp;-1\\1&amp;-1&amp;-1&amp;1\end{array}}\right)\\H_{3}&amp;={\frac {1}{2^{3/2}}}\left({\begin{array}{rrrrrrrr}1&amp;1&amp;1&amp;1&amp;1&amp;1&amp;1&amp;1\\1&amp;-1&amp;1&amp;-1&amp;1&amp;-1&amp;1&amp;-1\\1&amp;1&amp;-1&amp;-1&amp;1&amp;1&amp;-1&amp;-1\\1&amp;-1&amp;-1&amp;1&amp;1&amp;-1&amp;-1&amp;1\\1&amp;1&amp;1&amp;1&amp;-1&amp;-1&amp;-1&amp;-1\\1&amp;-1&amp;1&amp;-1&amp;-1&amp;1&amp;-1&amp;1\\1&amp;1&amp;-1&amp;-1&amp;-1&amp;-1&amp;1&amp;1\\1&amp;-1&amp;-1&amp;1&amp;-1&amp;1&amp;1&amp;-1\end{array}}\right)\\(H_{n})_{i,j}&amp;={\frac {1}{2^{n/2}}}(-1)^{i\cdot j}\end{aligned}}$</p><p>对于 $(1,0,1,0,0,1,1,0)$</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/aa/1010_0110_Walsh_spectrum_%28single_row%29.svg/300px-1010_0110_Walsh_spectrum_%28single_row%29.svg.png" alt="The product of a Boolean function and a Walsh matrix"></p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/58/1010_0110_Walsh_spectrum_%28fast_WHT%29.svg/300px-1010_0110_Walsh_spectrum_%28fast_WHT%29.svg.png" alt="Fast Walsh–Hadamard transform, a faster way to calculate the Walsh spectrum"></p><h3 id="快速变换-1"><a href="#快速变换-1" class="headerlink" title="快速变换"></a>快速变换</h3><p>其实看到了矩阵之间的递推关系 这个表达式就很显然了</p><p>$idx &lt; \frac{N}{2}$</p><p>$f(x,N,idx) = f(x[0,\frac{N}{2}), \frac{N}{2},idx) + f(x[\frac{N}{2},N), \frac{N}{2}, idx)$</p><p>$f(x,N,idx+\frac{N}{2}) = f(x[0,\frac{N}{2}), \frac{N}{2},idx) - f(x[\frac{N}{2},N), \frac{N}{2}, idx)$</p><pre><code class="cpp">void FWHT(vector&lt;modint&gt; &amp;f, int flag = 1 /* 1: 正变换, 1/2: 逆变换*/) {  int n = f.size();  for (int k = 1; k &lt; n; k *=2){    for (int i = 0; i &lt; n; i += 2*k){      for (int j = 0; j &lt; k; j++){        auto U = f[i+j];        auto T = f[i+j+k];        f[i+j]   = U + T;        f[i+j+k] = U - T;        f[i+j] *= flag;        f[i+j+k] *= flag;      }    }  }}</code></pre><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;#include &quot;./modint.cpp&quot;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backusing MODINT::modint;namespace FWT{  void ForT(vector&lt;modint&gt; &amp;f,int flag = 1/* 1:正变换,-1:逆变换 */) {    int n = f.size();    for (int k = 1; k &lt; n; k *=2){      for (int i = 0; i &lt; n; i += 2*k){        for (int j = 0; j &lt; k; j++){          f[i+j+k] += f[i+j] * flag;        }      }    }  }  void IForT(vector&lt;modint&gt; &amp;f) {ForT(f, -1);}  vector&lt;modint&gt; or_convolution(vector&lt;modint&gt; &amp;v0, vector&lt;modint&gt; &amp;v1){    const int sz = v0.size();    ForT(v0);    ForT(v1);    vector&lt;modint&gt; v2(sz,0);    rep(i,0,sz) v2[i] = v0[i] * v1[i];    IForT(v2);    return v2;  }  void FandT(vector&lt;modint&gt; &amp;f, int flag = 1/* 1:正变换,-1:逆变换 */) {    int n = f.size();    for (int k = 1; k &lt; n; k *=2){      for (int i = 0; i &lt; n; i += 2*k){        for (int j = 0; j &lt; k; j++){          f[i+j] += f[i+j+k] * flag;        }      }    }  }  void IFandT(vector&lt;modint&gt; &amp;f) {FandT(f, -1);}  vector&lt;modint&gt; and_convolution(vector&lt;modint&gt; &amp;v0, vector&lt;modint&gt; &amp;v1){    const int sz = v0.size();    FandT(v0);    FandT(v1);    vector&lt;modint&gt; v2(sz,0);    rep(i,0,sz) v2[i] = v0[i] * v1[i];    IFandT(v2);    return v2;  }  modint inv2 = modint(2).inv();  void FWHT(vector&lt;modint&gt; &amp;f, modint flag = 1 /* 1: 正变换, 1/2: 逆变换*/) {    int n = f.size();    for (int k = 1; k &lt; n; k *=2){      for (int i = 0; i &lt; n; i += 2*k){        for (int j = 0; j &lt; k; j++){          auto U = f[i+j];          auto T = f[i+j+k];          f[i+j]   = U + T;          f[i+j+k] = U - T;          f[i+j] *= flag;          f[i+j+k] *= flag;        }      }    }  }  void IFWHT(vector&lt;modint&gt; &amp;f) {FWHT(f, inv2);}  void FxorT(vector&lt;modint&gt; &amp;f,int flag = 1) {FWHT(f, flag);}  void IFxorT(vector&lt;modint&gt; &amp;f) {IFWHT(f);}  vector&lt;modint&gt; xor_convolution(vector&lt;modint&gt; &amp;v0, vector&lt;modint&gt; &amp;v1){    const int sz = v0.size();    FxorT(v0);    FxorT(v1);    vector&lt;modint&gt; v2(sz,0);    rep(i,0,sz) v2[i] = v0[i] * v1[i];    IFxorT(v2);    return v2;  }};void print(vector&lt;modint&gt; &amp;arr){  for(auto &amp;v:arr) printf(&quot;%d &quot;, v.val());  printf(&quot;\n&quot;);}int main(){  // 长度2的幂次  const vector&lt;modint&gt; A0 = {1,2,3,0};  const vector&lt;modint&gt; B0 = {4,5,6,0};  // --- or ---  {    auto A = A0;    auto B = B0;    auto C = FWT::or_convolution(A,B);    print(C);  }  // --- and ---  {    auto A = A0;    auto B = B0;    auto C = FWT::and_convolution(A,B);    print(C);  }  // --- xor ---  {    auto A = A0;    auto B = B0;    auto C = FWT::xor_convolution(A,B);    print(C);  }  return 0;}</code></pre><h2 id="洛谷P4717"><a href="#洛谷P4717" class="headerlink" title="洛谷P4717"></a>洛谷P4717</h2><p><a href="https://www.luogu.com.cn/record/81332363" target="_blank" rel="noopener">https://www.luogu.com.cn/record/81332363</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;n;i++)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // read// ----------- modint -----------namespace MODINT{  const int _mod = 998244353;  class modint{    private:      ll _v;    public:      modint() :_v(0) {  }      modint(ll _a) {        _v = (_a &lt; 0)? _mod - ((-_a) % _mod) : (_a % _mod);      }      int val()const { return _v; }      modint operator+()const { return *this; }      modint operator-()const { return { _mod - _v }; }      modint operator+(const modint&amp; rhs) const { return modint(*this) += rhs; }      modint operator-(const modint&amp; rhs) const { return modint(*this) -= rhs; }      modint operator*(const modint&amp; rhs) const { return modint(*this) *= rhs; }      modint operator/(const modint&amp; rhs) const { return modint(*this) /= rhs; }      bool operator==(const modint&amp; rhs)const { return _v == rhs._v; }      bool operator!=(const modint&amp; rhs)const { return _v != rhs._v; }      bool operator&gt; (const modint&amp; rhs)const { return _v &gt;  rhs._v; }      bool operator&gt;=(const modint&amp; rhs)const { return _v &gt;= rhs._v; }      bool operator&lt;=(const modint&amp; rhs)const { return _v &lt;= rhs._v; }      bool operator&lt; (const modint&amp; rhs)const { return _v &lt;  rhs._v; }      modint&amp; operator+=(const modint&amp; rhs) {        (_v += rhs._v) %= _mod;        return *this;      }      modint&amp; operator-=(const modint&amp; rhs) {        (_v += _mod - rhs._v) %= _mod;        return *this;      }      modint&amp; operator*=(const modint&amp; rhs) {        _v = _v * rhs.val() % _mod;        return *this;      }      modint&amp; operator/=(const modint&amp; rhs) { // 费马小定理        _v = _v * rhs.inv().val() % _mod ;        return *this;      }      modint pow(ll pwr) const {        ll res(1);        ll _b(_v);        while (pwr) {          if (pwr &amp; 1) (res *= _b) %= _mod;          (_b *= _b) %= _mod;          pwr /= 2;        }        return res;      }      modint inv() const {        assert(_v != 0);        return pow(_mod - 2);      }  };};// ----------- modint -----------// ----------- fwt -----------using MODINT::modint;namespace FWT{  void ForT(vector&lt;modint&gt; &amp;f,int flag = 1/* 1:正变换,-1:逆变换 */) {    int n = f.size();    for (int k = 1; k &lt; n; k *=2){      for (int i = 0; i &lt; n; i += 2*k){        for (int j = 0; j &lt; k; j++){          f[i+j+k] += f[i+j] * flag;        }      }    }  }  void IForT(vector&lt;modint&gt; &amp;f) {ForT(f, -1);}  vector&lt;modint&gt; or_convolution(vector&lt;modint&gt; &amp;v0, vector&lt;modint&gt; &amp;v1){    const int sz = v0.size();    ForT(v0);    ForT(v1);    vector&lt;modint&gt; v2(sz,0);    rep(i,0,sz) v2[i] = v0[i] * v1[i];    IForT(v2);    return v2;  }  void FandT(vector&lt;modint&gt; &amp;f, int flag = 1/* 1:正变换,-1:逆变换 */) {    int n = f.size();    for (int k = 1; k &lt; n; k *=2){      for (int i = 0; i &lt; n; i += 2*k){        for (int j = 0; j &lt; k; j++){          f[i+j] += f[i+j+k] * flag;        }      }    }  }  void IFandT(vector&lt;modint&gt; &amp;f) {FandT(f, -1);}  vector&lt;modint&gt; and_convolution(vector&lt;modint&gt; &amp;v0, vector&lt;modint&gt; &amp;v1){    const int sz = v0.size();    FandT(v0);    FandT(v1);    vector&lt;modint&gt; v2(sz,0);    rep(i,0,sz) v2[i] = v0[i] * v1[i];    IFandT(v2);    return v2;  }  modint inv2 = modint(2).inv();  void FWHT(vector&lt;modint&gt; &amp;f, modint flag = 1 /* 1: 正变换, 1/2: 逆变换*/) {    int n = f.size();    for (int k = 1; k &lt; n; k *=2){      for (int i = 0; i &lt; n; i += 2*k){        for (int j = 0; j &lt; k; j++){          auto U = f[i+j];          auto T = f[i+j+k];          f[i+j]   = U + T;          f[i+j+k] = U - T;          f[i+j] *= flag;          f[i+j+k] *= flag;        }      }    }  }  void IFWHT(vector&lt;modint&gt; &amp;f) {FWHT(f, inv2);}  void FxorT(vector&lt;modint&gt; &amp;f,int flag = 1) {FWHT(f, flag);}  void IFxorT(vector&lt;modint&gt; &amp;f) {IFWHT(f);}  vector&lt;modint&gt; xor_convolution(vector&lt;modint&gt; &amp;v0, vector&lt;modint&gt; &amp;v1){    const int sz = v0.size();    FxorT(v0);    FxorT(v1);    vector&lt;modint&gt; v2(sz,0);    rep(i,0,sz) v2[i] = v0[i] * v1[i];    IFxorT(v2);    return v2;  }};// ----------- fwt -----------void print(vector&lt;modint&gt; &amp;arr){  for(auto &amp;v:arr) printf(&quot;%d &quot;, v.val());  printf(&quot;\n&quot;);}int main(){  const int n = read();  const int SIZE = 1&lt;&lt;n;  // 长度2的幂次  auto A0 = vector&lt;modint&gt;(SIZE,0);  auto B0 = vector&lt;modint&gt;(SIZE,0);  rep(i,0,SIZE) A0[i] = read();  rep(i,0,SIZE) B0[i] = read();  // --- or ---  {    auto A = A0;    auto B = B0;    auto C = FWT::or_convolution(A,B);    print(C);  }  // --- and ---  {    auto A = A0;    auto B = B0;    auto C = FWT::and_convolution(A,B);    print(C);  }  // --- xor ---  {    auto A = A0;    auto B = B0;    auto C = FWT::xor_convolution(A,B);    print(C);  }  return 0;}</code></pre><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="http://yexiaorain.github.io/Blog/2019-01-02-fftmul/">我的FFT笔记</a></p><p><a href="https://en.wikipedia.org/wiki/Fast_Walsh%E2%80%93Hadamard_transform" target="_blank" rel="noopener">wikipedia Fast Walsh-Hadamard transform</a></p><p><a href="https://en.wikipedia.org/wiki/Hadamard_transform" target="_blank" rel="noopener">Hadamard transform</a></p><p><a href="https://en.wikipedia.org/wiki/Walsh_matrix" target="_blank" rel="noopener">Walsh matrix</a></p><p><a href="https://codeforces.com/blog/entry/71899" target="_blank" rel="noopener">Codeforces FWHT inner working</a></p><p><a href="https://blog.csdn.net/a_forever_dream/article/details/105110089" target="_blank" rel="noopener">CSDN 快速沃尔什变换（FWT）详详详解</a></p><p><a href="https://www.luogu.com.cn/problem/solution/P4717" target="_blank" rel="noopener">luogu 模板练习</a></p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fft </tag>
            
            <tag> FWHT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atcoder abc212</title>
      <link href="/Blog/2022-07-25-ac_abc212/"/>
      <url>/Blog/2022-07-25-ac_abc212/</url>
      
        <content type="html"><![CDATA[<p>G(数学,数论,原根)H/Ex(沃尔什-阿达玛转换,FWT/FWHT)</p><h1 id="G-Power-Pair"><a href="#G-Power-Pair" class="headerlink" title="G - Power Pair"></a>G - Power Pair</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://atcoder.jp/contests/abc212/tasks/abc212_g" target="_blank" rel="noopener">https://atcoder.jp/contests/abc212/tasks/abc212_g</a></p><p>给定 质数$p$ </p><p>问 $x,y\in[0,p-1]$  中有多少对$(x,y)$满足</p><p>存在$n$, 使得$x^n = y \pmod p$</p><h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h3><p>p $10^{12}$</p><p>2s</p><p>1024mb</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h3><p>显然x=0 只有y = 0, y=0也只有x=0</p><p>然后如果x是原根 那么 方案数$p-1$</p><p>如果$r|(p-1)$ 那么 $x^r \pmod p$的方案数为$\frac{p-1}{r}$</p><p>或者$x$的最小幂次$t$让$x^t = 1 \pmod p$, 则答案为$t$</p><p>但是即使这样, 如果每个去枚举依然是$O(p log(p))$</p><p>反过来考虑说有没有办法求$x^t = 1$ 的方案数,</p><p>如果能快速计算出,那么 方案数减去它的t因子对应的方案数 就恰好是 = t的方案数</p><p>而$t$的取值只会是 $p-1$的因数</p><p>$t = 1$ $x = 1$</p><p>$t = 2$ $x = 1,-1$</p><p>$t = 4$</p><p>$t = 7$</p><p>$t = 8$</p><hr><p>t = 2k时, $x^{2k} - 1 = 0 \pmod p$</p><p>$(x^k+1)(x^k-1) = 0 \pmod p$, 相当于$x^k = 1 \pmod p, x^k = -1 \pmod p $的解的并</p><p>并不会</p><h3 id="官方"><a href="#官方" class="headerlink" title="官方"></a>官方</h3><p>原根的想法没问题, 然后就变成了我们指定原根</p><p>$x^i = j$, $(i,j)$ 是一一对应, 且取$[1,p-1]$范围内的所有值</p><p>这样的话</p><p>要求 $x^i$ 的最小让 幂次等于1的t</p><p>注意到 和我思路一样的 $x^i$当$i | (p-1)$时, 方案数 $=\frac{p-1}{i}$</p><p>而这里$i$可能不是$p-1$的因子, 而易证明 方案数为 $\frac{p-1}{gcd(p-1,i)}$</p><p>这里问题变成了, 统计不同 $gcd(p-1,i) = k$ 的数量即可</p><hr><p>$g | (p-1)$</p><p>$\sum_{g|(p-1)} count(g 倍数 且非(p-1)因子) $</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc212/submissions/33524525" target="_blank" rel="noopener">https://atcoder.jp/contests/abc212/submissions/33524525</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 998244353#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // read// 转质数和幂次vector&lt;pair&lt;ll,int&gt; &gt; v2ppwr(ll v){  vector&lt;pair&lt;ll,int&gt; &gt; res = {};  rep(t,2,v+1){    if(t*t &gt; v) break;    int c = 0;    while(v % t == 0){      v /= t;      c ++;    }    if(c) res.pb({t,c});  }  if(v != 1) res.pb({v, 1});  return res;}// gcd = xll dfs(ll idx, ll y, vector&lt;ll&gt; primes, const vector&lt;pair&lt;ll,int&gt; &gt; &amp; ppwr1){  if(idx == (int)ppwr1.size()) {    ll rc = y; // 容斥    for(auto p:primes) rc = rc / p * (p-1);    return y % MOD * (rc % MOD) % MOD;  }  auto [p,mi] = ppwr1[idx];  ll mul = 1; // p ** pwr  primes.push_back(p);  ll res = 0;  rep(pwr,0,mi+1){    if(pwr == mi) primes.pop_back();    (res += dfs(idx+1, y / mul, primes, ppwr1)) %= MOD;    mul *= p;  }  return res;}int main(){  ll p = read();  auto ppwr = v2ppwr(p-1);  printf(&quot;%lld\n&quot;, (1 /* (0,0) */ + dfs(0, p-1, {}, ppwr)) % MOD);  return 0;}</code></pre><h1 id="H-Ex-Nim-Counting"><a href="#H-Ex-Nim-Counting" class="headerlink" title="H/Ex - Nim Counting"></a>H/Ex - Nim Counting</h1><p><a href="https://atcoder.jp/contests/abc212/tasks/abc212_h" target="_blank" rel="noopener">https://atcoder.jp/contests/abc212/tasks/abc212_h</a></p><p>给正整数 长度k的 数组A, 值两两不同</p><p>T和A轮流游戏, T先</p><p>选一个 &gt;= 1 的石堆, 移除任意正整数个</p><p>谁取了最后一个胜利</p><hr><p>问题是</p><p>对于长度[1,N] 每个元素属于A中的一个的 初始状态, 有多少种状态是 T 胜利</p><p>模 998244353</p><h2 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h2><p>n 2e5</p><p>k 65536</p><p>$a_i$ [1, 65536]</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h3><p>首先nim游戏作为博弈的常见基础, 很明显 就是 xor 和 != 0 时 T胜利</p><p>那么无非是求 所有 !=0 的方案数, 或者 是 == 0 的方案数, 去总方案减去 ==0的方案数</p><p>那么对于一个选择来说因为Ai两两不同, 偶数次被选的Ai 不影响xor,奇数次被选的Ai影响一次</p><p>问题变成了说</p><p>选x个Ai,让它们 xor = 0, 那么</p><p>对于长度x 贡献是 x!</p><p>对长度x+2 贡献是 ?? 还是x, 但是剩余两个是一样的, 这两个一样的如果属于x个值内注意不要重复统计,不属于x个数内,则穿插即可</p><h3 id="官方-1"><a href="#官方-1" class="headerlink" title="官方"></a>官方</h3><p>对于给定的数组长度M</p><p>$C=(C_0,C_1,…C_{2^{16}-1})$ 表示 下标的值 是否存在, 相当于选择了一次</p><p>定义xor的卷积 $Z_k = \sum_{i\oplus j=k} X_i Y_j$</p><p>那么$C$的M次卷积的结果$R$中的$R_0$, 就是期望值</p><hr><p>快速沃尔什-阿达玛转换(Fast Walsh Hadamard transform), 一种广义傅立叶变换</p><p>FWT/FWHT 是用于解决对下标进行位运算卷积问题的方法, 见下面我的博客链接</p><p>$C_{i} = \sum_{i=j \bigoplus k}A_{j} B_{k}$</p><hr><p>因为 xor 的卷积满足结合率, 所以可以考虑快速幂来算</p><p>注意到$C * C = ifwt(fwt(C)\odot fwt(C))$</p><p>而$C * C * C= ifwt(fwt(C * C) \odot fwt(C))$</p><p>$= ifwt(fwt(ifwt(fwt(C)\odot fwt(C))) \odot fwt(C))$</p><p>$= ifwt(fwt(C)\odot fwt(C) \odot fwt(C))$</p><p>即是 $C^n = ifwt(\left( fwt(C)_ i^n\right))$</p><p>所以 $C$的$n$次+/xor/or/and卷积等于 正变换每个位置的$n$次方后的逆变换, <strong>这个在dft(fft)/ntt/fwt 同理</strong></p><hr><p>令 $I = C^0 = (1,0,0,0,0,0,\cdots)$</p><p>答案 $R = C + C * C + \cdots + C^n$</p><p>$R * C = C^2 + C^3 + \cdots + C^{n+1}$</p><p>$R * (C-I) = C^{n+1} - C$</p><p>$fwt(R) \odot fwt(C-I) = fwt(C^{n+1} - C)$</p><p>$fwt(R) = fwt(C^{n+1} - C) \oslash fwt(C-I)$</p><p>$R = ifwt(fwt(C^{n+1} - C) \oslash fwt(C-I))$</p><p>注意到$fwt$ 实际是线性变换, 所以也有$fwt(a+b) = fwt(a) + fwt(b),fwt(a-b) = fwt(a) - fwt(b),$</p><p>$R = ifwt( (fwt(C^{n+1}) - fwt(C)) \oslash (fwt(C)-fwt(I)))$</p><p>注意到 $fwt(I) = (1,1,1,1,1,\cdots)$</p><p>$R = ifwt(\left(\frac{fwt(C)_ i^{n+1} - fwt(C)_ i}{fwt(C)_ i - 1}\right))$</p><hr><p>至此就很好写了</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc212/submissions/33545657" target="_blank" rel="noopener">https://atcoder.jp/contests/abc212/submissions/33545657</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // read// -------------- modint ---------------namespace MODINT{  const int _mod = 998244353;  class modint{    private:      ll _v;    public:      modint() :_v(0) {  }      modint(ll _a) {        _v = (_a &lt; 0)? _mod - ((-_a) % _mod) : (_a % _mod);      }      int val()const { return _v; }      modint operator+()const { return *this; }      modint operator-()const { return { _mod - _v }; }      modint operator+(const modint&amp; rhs) const { return modint(*this) += rhs; }      modint operator-(const modint&amp; rhs) const { return modint(*this) -= rhs; }      modint operator*(const modint&amp; rhs) const { return modint(*this) *= rhs; }      modint operator/(const modint&amp; rhs) const { return modint(*this) /= rhs; }      bool operator==(const modint&amp; rhs)const { return _v == rhs._v; }      bool operator!=(const modint&amp; rhs)const { return _v != rhs._v; }      bool operator&gt; (const modint&amp; rhs)const { return _v &gt;  rhs._v; }      bool operator&gt;=(const modint&amp; rhs)const { return _v &gt;= rhs._v; }      bool operator&lt;=(const modint&amp; rhs)const { return _v &lt;= rhs._v; }      bool operator&lt; (const modint&amp; rhs)const { return _v &lt;  rhs._v; }      modint&amp; operator+=(const modint&amp; rhs) {        (_v += rhs._v) %= _mod;        return *this;      }      modint&amp; operator-=(const modint&amp; rhs) {        (_v += _mod - rhs._v) %= _mod;        return *this;      }      modint&amp; operator*=(const modint&amp; rhs) {        _v = _v * rhs.val() % _mod;        return *this;      }      modint&amp; operator/=(const modint&amp; rhs) { // 费马小定理        _v = _v * rhs.inv().val() % _mod ;        return *this;      }      modint pow(ll pwr) const {        ll res(1);        ll _b(_v);        while (pwr) {          if (pwr &amp; 1) (res *= _b) %= _mod;          (_b *= _b) %= _mod;          pwr /= 2;        }        return res;      }      modint inv() const {        assert(_v != 0);        return pow(_mod - 2);      }  };};// -------------- modint ---------------// ---------- fwt ----------using MODINT::modint;namespace FWT{  void ForT(vector&lt;modint&gt; &amp;f,int flag = 1/* 1:正变换,-1:逆变换 */) {    int n = f.size();    for (int k = 1; k &lt; n; k *=2){      for (int i = 0; i &lt; n; i += 2*k){        for (int j = 0; j &lt; k; j++){          f[i+j+k] += f[i+j] * flag;        }      }    }  }  void IForT(vector&lt;modint&gt; &amp;f) {ForT(f, -1);}  vector&lt;modint&gt; or_convolution(vector&lt;modint&gt; &amp;v0, vector&lt;modint&gt; &amp;v1){    const int sz = v0.size();    ForT(v0);    ForT(v1);    vector&lt;modint&gt; v2(sz,0);    rep(i,0,sz) v2[i] = v0[i] * v1[i];    IForT(v2);    return v2;  }  void FandT(vector&lt;modint&gt; &amp;f, int flag = 1/* 1:正变换,-1:逆变换 */) {    int n = f.size();    for (int k = 1; k &lt; n; k *=2){      for (int i = 0; i &lt; n; i += 2*k){        for (int j = 0; j &lt; k; j++){          f[i+j] += f[i+j+k] * flag;        }      }    }  }  void IFandT(vector&lt;modint&gt; &amp;f) {FandT(f, -1);}  vector&lt;modint&gt; and_convolution(vector&lt;modint&gt; &amp;v0, vector&lt;modint&gt; &amp;v1){    const int sz = v0.size();    FandT(v0);    FandT(v1);    vector&lt;modint&gt; v2(sz,0);    rep(i,0,sz) v2[i] = v0[i] * v1[i];    IFandT(v2);    return v2;  }  modint inv2 = modint(2).inv();  void FWHT(vector&lt;modint&gt; &amp;f, modint flag = 1 /* 1: 正变换, 1/2: 逆变换*/) {    int n = f.size();    for (int k = 1; k &lt; n; k *=2){      for (int i = 0; i &lt; n; i += 2*k){        for (int j = 0; j &lt; k; j++){          auto U = f[i+j];          auto T = f[i+j+k];          f[i+j]   = U + T;          f[i+j+k] = U - T;          f[i+j] *= flag;          f[i+j+k] *= flag;        }      }    }  }  void IFWHT(vector&lt;modint&gt; &amp;f) {FWHT(f, inv2);}  void FxorT(vector&lt;modint&gt; &amp;f,int flag = 1) {FWHT(f, flag);}  void IFxorT(vector&lt;modint&gt; &amp;f) {IFWHT(f);}  vector&lt;modint&gt; xor_convolution(vector&lt;modint&gt; &amp;v0, vector&lt;modint&gt; &amp;v1){    const int sz = v0.size();    FxorT(v0);    FxorT(v1);    vector&lt;modint&gt; v2(sz,0);    rep(i,0,sz) v2[i] = v0[i] * v1[i];    IFxorT(v2);    return v2;  }};// ---------- fwt ----------const int SIZE = 1 &lt;&lt; 16; // 16;vector&lt;modint&gt; C(SIZE,0);int main(){  int n = read();  int k = read();  rep(i,0,k) { C[read()] = 1; }  auto ans = k == 1? n : ((modint(k).pow(n+1)- 1)/(k-1) - 1); // 总方案数  FWT::FWHT(C);  rep(i,0,SIZE) C[i] = (C[i] == 1) ? n : ((C[i].pow(n+1) - C[i])/(C[i] - 1)); // 等比数列求和  FWT::IFWHT(C);  printf(&quot;%d\n&quot;,(ans-C[0]).val());  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>G</p><p>没观察到选了一个原根以后 整个范围 都有幂次和值的一一映射</p><p>H(Ex)</p><p>首先这个C和这个卷积 就很神奇, 完全没有向这个方向的思路</p><p>学了一手FWT/FWHT</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://atcoder.jp/contests/abc212/editorial" target="_blank" rel="noopener">官方题解</a></p><p><a href="http://yexiaorain.github.io/Blog/2022-07-26-FWT/">FWHT/FWT</a></p>]]></content>
      
      
      <categories>
          
          <category> Atcoder </category>
          
          <category> ABC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 数论 </tag>
            
            <tag> 原根 </tag>
            
            <tag> 沃尔什-阿达玛转换 </tag>
            
            <tag> FWT </tag>
            
            <tag> FWHT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从FFT 到 NTT(快速数论变换)</title>
      <link href="/Blog/2022-07-24-NTT/"/>
      <url>/Blog/2022-07-24-NTT/</url>
      
        <content type="html"><![CDATA[<h1 id="NTT"><a href="#NTT" class="headerlink" title="NTT"></a>NTT</h1><p>竟然Div2能出现NTT 虽然是在最后一题, 还是得学一学</p><h2 id="解决什么问题"><a href="#解决什么问题" class="headerlink" title="解决什么问题"></a>解决什么问题</h2><p>是多项式乘法带模数的情况计算卷积</p><p>并且没有fft中会涉及到double,</p><p>NTT 也就是关于任意 环(数学术语) 上的离散傅立叶变化(DFT), 有限域的情况下,通常成为数论变换</p><h2 id="离散傅立叶变换"><a href="#离散傅立叶变换" class="headerlink" title="离散傅立叶变换"></a>离散傅立叶变换</h2><p>回顾离散傅立叶变换, 就是</p><p>原函数(原向量) $\to$ DFT(离散傅立叶) $\to$ 点乘 $\to$ IDFT(逆傅立叶) $\to$ 结果函数(结果向量)</p><p>DFT:</p><p>$\hat{x}[k]=\sum_{n=0}^{N-1} e^{-i\frac{2\pi}{N}nk}x[n] \qquad k = 0,1,\ldots,N-1.$</p><p>IDFT:</p><p>$x\left[n\right]={1 \over N}\sum_{k=0}^{N-1} e^{ i\frac{2\pi}{N}nk}\hat{x}[k] \qquad n = 0,1,\ldots,N-1.$</p><p>有时系数可以是两个$\frac{1}{\sqrt{N}}$</p><p>矩阵表示的DFT, 是一个线性算子</p><p>${\displaystyle {\begin{bmatrix}f_{0}\\f_{1}\\\vdots \\f_{n-1}\end{bmatrix}}={\begin{bmatrix}1&amp;1&amp;1&amp;\cdots &amp;1\\1&amp;\alpha &amp;\alpha ^{2}&amp;\cdots &amp;\alpha ^{n-1}\\1&amp;\alpha ^{2}&amp;\alpha ^{4}&amp;\cdots &amp;\alpha ^{2(n-1)}\\\vdots &amp;\vdots &amp;\vdots &amp;&amp;\vdots \\1&amp;\alpha ^{n-1}&amp;\alpha ^{2(n-1)}&amp;\cdots &amp;\alpha ^{(n-1)(n-1)}\\\end{bmatrix}}{\begin{bmatrix}v_{0}\\v_{1}\\\vdots \\v_{n-1}\end{bmatrix}}.}$</p><h2 id="阶"><a href="#阶" class="headerlink" title="阶"></a>阶</h2><p>若 $gcd(a,p) = 1, p &gt; 1$</p><p>最小的$n &gt; 0$ 使得 $a^n \equiv 1 \pmod{p}$, 则$\delta_p(a) = n$ 称作$a$模$p$的阶</p><p>显然, 对于$i\in [0,\delta_p(a))$, $a^i \pmod p$ 两两不同</p><h2 id="原根"><a href="#原根" class="headerlink" title="原根"></a>原根</h2><p>$p &gt; 0, a$ 是整数, $\delta_p(a) = \varphi(a), gcd(p,a) = 1$, 则$a$为$p$的一个原根</p><p>其中$\varphi(n)$ 为欧拉函数, 表示$1$到$n$中与$n$互质的数的个数</p><p>若$gcd(a,p) = 1, p &gt; 0$ 则$a$为$p$的一个原根的充要条件 ${a^1,a^2,a^3,\cdots,a^{\varphi(p)}}$ 是p的简化剩余系</p><p>必要: $a$是$p$的原根, 根据阶中结论模n两两不同</p><p>充分: 因为是简化剩余系, 所以两两不同, 所以说明 $ &lt; \varphi(p)$ 的都不为1, 也说明$\delta_p(a) = \varphi(a)$</p><p>完全剩余系: n的完全剩余系, 在模n的剩余类中各取一个元素，则这n个数就构成了模n的一个完全剩余系。例如{0,1,2,3,…,n-1} 是n的一个完全剩余系</p><p>简化剩余系: 完全剩余系中 与n互质 构成的</p><h2 id="回到NTT"><a href="#回到NTT" class="headerlink" title="回到NTT"></a>回到NTT</h2><p>$p$为素数,$a$为$p$的一个原根, 有$\varphi(p) = p-1$</p><p>$n = 2^k, n | (p-1), k &gt; 0$</p><p>令 $g_n = a^{\frac{p-1}{n}}$</p><p>$g_n^n = (a^{\frac{p-1}{n}})^n = a^{p-1} = 1 \pmod p$</p><p>$g_n^{\frac{n}{2}} = a^{\frac{p-1}{2}} = -1 \pmod p$</p><p>$g_{tn}^{tk} = a^{\frac{tk(p-1)}{tn}}=a^{\frac{k(p-1)}{n}}=g_n^k$</p><p>这里想用 $g_n^k$ 来替代$w_n^k$ </p><p>(然后就直接可以替换了??? 不严格的语言证明是, 可以看成w为未知数, 那么$a * b = c$ 不过是变成了c = IFFT(FFT(a) FFT(b)) = a * b</p><p>也就是 最终的只和$w$的$n$和$\frac{n}{2}$有关,否则 会有复平面的偏移</p><p>所以$w_n^k = e^{- i \frac{2 \pi}{N} nk}$ 也好</p><p>所以$w_n^k = g_n^k \pmod p$ 也好, 只要满足了$n$和$\frac{n}{2}$次方的性质即可</p><hr><p>注意的是 $g_n^k \neq 1 \pmod p , k &lt; \varphi_p(g)$</p><p>例如</p><p>$p=998244353=7 \times 17 \times 2^{23}+1$</p><p>有$g_{2^{23}} = 3^{\frac{p-1}{2^{23}}}$</p><hr><p>据说$g$都挺小, 可以枚举$g$</p><hr><p>然后INTT, 和IFFT对应, IFFT 相当于乘上了$e^{i \frac{2 \pi}{N} nk} = \frac{1}{w_n^k}$</p><p>所以这里就是$g$的逆元,</p><h2 id="代码-模板"><a href="#代码-模板" class="headerlink" title="代码, 模板"></a>代码, 模板</h2><p><a href="https://github.com/CroMarmot/OICode/blob/master/functions/ntt998244353.cpp" target="_blank" rel="noopener">https://github.com/CroMarmot/OICode/blob/master/functions/ntt998244353.cpp</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (int i=a;i&lt;n;i++)const int MOD = 998244353; // 7*17*2^23 + 1const int MAXPWR = 22; // 随着MOD改变, 2的幂次, 对应复平面单位向量的N = 2 &amp;&amp; MAXPWR;const int g = 3;// 原根 随着MOD改变const int invg = 332748118;// 原根模逆元 随着MOD 和 g 改变// bit 翻转int rev(int x, int len) {  int ans = 0;  while(len -- ){    ans &lt;&lt;= 1;    ans |= x &amp; 1;    x &gt;&gt;= 1;  }  return ans;}inline int getlog2(int n){ return 31 - __builtin_clz(n);}ll mypow(ll a, ll k) { //快速幂，a**k  ll res = 1;  while (k) {    if (k &amp; 1) (res *= a) %= MOD;    (a *= a) %= MOD;    k &gt;&gt;= 1;  }  return res;}void NTT(vector&lt;ll&gt; &amp;A, int flag = 1 /* 1: NTT, -1: INTT*/ ) {  int n = A.size();  if(n == 1) return ;  // assert((n &amp; (n-1)) == 0); // 2 的幂次  int lgn = getlog2(n);  // assert(lgn &lt;= MAXPWR);  rep(i, 0, n) { // 同FFT    int j = rev(i, lgn);    if (j &gt; i) swap(A[i], A[j]);  }  rep(pwr,0,lgn){    int m = 1 &lt;&lt; pwr;    // assert((MOD - 1) % (m&lt;&lt;1) == 0);    ll gn = mypow(flag == 1 ? g : invg, (MOD - 1) / (m &lt;&lt; 1)); // 单位原根g_n    for (int k = 0; k &lt; n; k += (m&lt;&lt;1)) {      ll gi = 1;      rep(j,0,m) {        auto U = A[k + j];        auto T = gi * A[k + j + m] % MOD;        A[k + j] = (U + T) % MOD;        A[k + j + m] = (U - T + MOD) % MOD;        (gi *= gn) %= MOD;      }    }  }  if(flag == -1){ // 内置 / N    const ll INVSIZE = mypow(n, MOD-2);    rep(i,0,n) (A[i] *= INVSIZE) %= MOD;  }}void INTT(vector&lt;ll&gt; &amp;A){ NTT(A,-1);}int main(){  // 123*456 = 56088  const int SIZE = 8; // 一定要是2的幂次  auto a = vector&lt;ll&gt;{3,2,1,0,0,0,0,0};  auto b = vector&lt;ll&gt;{6,5,4,0,0,0,0,0};  // 计算  NTT(a);  NTT(b);  auto c = vector&lt;ll&gt;(SIZE,0);  rep(i,0,SIZE) c[i] = a[i] * b[i];  INTT(c);  // 输出  rep(i,0,SIZE) printf(&quot;(%lld)&quot;, c[i]);  printf(&quot;\n&quot;);  rep(i,0,SIZE-1) {// 进位    c[i+1] += c[i] / 10;    c[i] -= (c[i] / 10) * 10;  }  rep(i,0,SIZE) printf(&quot;(%lld)&quot;, c[i]);  printf(&quot;\n&quot;);  return 0;}</code></pre><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="http://yexiaorain.github.io/Blog/2019-01-02-fftmul/">我的FFT笔记</a></p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fft </tag>
            
            <tag> ntt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces 1709</title>
      <link href="/Blog/2022-07-23-CF1709/"/>
      <url>/Blog/2022-07-23-CF1709/</url>
      
        <content type="html"><![CDATA[<p>E(树,xor,贪心,树上启发式合并)F(dp,NTT,前缀和)</p><h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><p><a href="https://codeforces.com/contest/1709/problem/E" target="_blank" rel="noopener">https://codeforces.com/contest/1709/problem/E</a></p><p>给你个一个树, 每个点上有值, 修改尽量少的点为任意值</p><p>让任何简单路径的 xor都不为零</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>n 2e5</p><p>ai [1,2^30]</p><p>3s</p><p>256MB</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h3><p>显然啊, 类似树上差分的思想,  a…b xor = 0</p><p>意味着 a…root ^ root …b = 0</p><p>所以直接变成 计算每个数到根的xor</p><p>然后问题变成, 任意两个相同值之间的连线, 需要至少选一个点</p><p>或者说, 需要xor树最终两两不等 </p><p>不知道往后怎么搞</p><hr><p>一个思路是dp</p><p>但是 遇到同值点不是 祖先关系,而是分叉的关系 ,也不知打怎么记录</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>虽然的确有前缀意义,但其实 我想的总思路没问题, 但是细节有问题</p><p>并不是简单路径 = 到根的 路径 xor</p><p>因为它们的lca 被算了两次 </p><p>所以其实是 path[u]^path[v] = a[lca[u,v]]</p><hr><p>那么 对于一个点x  = lca(u,v) , 且 u..v 的xor = 0</p><p>那么 (x,y) 上至少有一点需要改变</p><p>然后 我们对所有的有这种情况的x 按深度从深到浅考虑</p><p>找深度最深的x, 那么修改 x的方案不会比修改 u…v 的更差</p><p>因为是最深的, 所以其它满足的链 如果经过它的子树 则必定经过它,因为它需要修改, 所以而至少一个, 而对于其它经过它的链来说是至多一个</p><hr><p>dfs(u){<br> 对于u的所有子树 dfs(v)</p><p> 每个点获取 从根到它的子节点 能得到的 xor 集合</p><p> 一旦有来自两个子树 中有值 xor == u 那么u就必然被选<br> 而被选的u对于它的父节点的返回是 空集合<br> 未被选的u对于它的父节点的返回是它所有子集合可达值 xor 它自身<br>}</p><hr><p>怎么看都是n^2 啊 , 为啥 O(nlog^2 n)</p><p>因为虽然dfs一次就可以把所有点到根的xor 算完</p><p>但是每次做 set 的合并时, 一个点就是会在它的 父节点 中被运算</p><p>那每个点被参与比较的次数可以达到 链的长度 不就是 n^2 吗</p><hr><p>然后神奇的是 这个启发式合并的复杂度不是n方</p><h3 id="启发式合并-DSU-on-Tree"><a href="#启发式合并-DSU-on-Tree" class="headerlink" title="启发式合并(DSU on Tree)"></a>启发式合并(DSU on Tree)</h3><p><a href="https://oi-wiki.org/graph/dsu-on-tree/#_3" target="_blank" rel="noopener">oi-wiki 树上启发式合并</a></p><p>重儿子, 儿子节点子节点个数最多的</p><p>重边, 当前点连向其中一个重儿子的边</p><p>轻边 非重边</p><hr><p>根到任意点 轻边不超过log n 条</p><p>反证法, 如果大于log n 条,</p><p>则最深的轻边的根至少还额外连了一个点大小为1的子树</p><p>第二深的轻边的根至少还额外连了一个点大小为3的子树</p><p>第三深的轻边的根至少还额外连了一个点大小为7的子树</p><p>…</p><p>第m深的轻边的根至少还额外连了一个点大小为2^m-1的子树</p><p>显然 m &gt; log n , 则 2^m - 1 &gt; n - 1 &gt;= n</p><p>性质得证</p><hr><p>那么每个节点 只有在它的某个祖先u的视角, 它是u的轻边的那一部分时, 才会作为被遍历的</p><p>所以每个节点的被遍历次数 = 它到根的 轻边数</p><p>所以 O(n log n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://codeforces.com/contest/1709/submission/165472602" target="_blank" rel="noopener">https://codeforces.com/contest/1709/submission/165472602</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readconst int N = 200000;int ans=0;int a[N+10]; // readint p[N+10]; // 当前每个节点对应st节点下标 pos[u]vector&lt;int&gt; e[N+10]; // edgeset&lt;int&gt; st[N+10]; // st[顶点] = {链到根的xor集合}void dfs(int u,int f, int x) {  int &amp;iu = p[u]; // 真的u  int bu = x^a[u]; // 从根下来的xor 链  st[iu].insert(bu);  bool delu = false; // delete u  for(auto v:e[u]) if(v != f){    dfs(v,u,bu);    int &amp;iv = p[v];    // 把小的向大的合并, 结果存在st[iu] 中    if(st[iu].size() &lt; st[iv].size()) swap(iu, iv);    for(auto val:st[iv]){      if(delu) break;      if(st[iu].count(val ^ a[u])) delu = true;    }    if(!delu) for(auto val:st[iv]) st[iu].insert(val);    st[iv] = {};  }  if(delu){    st[iu] = {};    ans++;  }}int main() {  int n = read();  rep(i,1,n+1) {    a[i] = read();    p[i] = i;  }  rep(i,1,n){    int u = read();    int v = read();    e[u].pb(v);    e[v].pb(u);  }  dfs(1,0,0);  printf(&quot;%d\n&quot;,ans);}</code></pre><h1 id="F"><a href="#F" class="headerlink" title="F"></a>F</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://codeforces.com/contest/1709/problem/F" target="_blank" rel="noopener">https://codeforces.com/contest/1709/problem/F</a></p><p>读入 n, k ,f</p><p>包含长度等于n的字符串 的可重集合 beautiful 定义为</p><p>对于长度 [1,n] 之间任意字符串s, c[s] &gt;= 集合中以s为前缀的字符串个数</p><p>任务 对于[1,n] 的所有字符串s, 你需要计算有多少 中映射c[s] 的选择方式</p><p>max(beautiful的集合的元素个数 )= f</p><p>其中 0 &lt;= c[s] &lt;= k</p><h3 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h3><p>n 15</p><p>k,f 2e5</p><p>6s</p><p>512ms</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h3><p>显然关于前缀</p><p>如果 s0 是 s1的前缀</p><p>那么显然 s0 出现的次数 &gt;= s1 出现的次数</p><p>那么 如果 c[s0] &lt;= c[s1] , c[s1] 就没什么作用</p><p>反过来, 如果 c[s0] &gt;= sum c[s0的所有下一级后缀], 那么c[s0] 也不是紧限制</p><p>因此 真正有效的内容是</p><p>c[s1] &lt;= c[s0] ,c[s0] &lt;= sum c[s0的所有下一级后缀], </p><hr><p>而这样约束以后, 方案数 就 = c[0] + c[1], 因为每个都表示<strong>能达到</strong>的最大个数</p><p>问题来了, 这样如何 算原始的c呢</p><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>转化一下题目</p><p>高度n的满二叉树</p><p>你需要对每个父子之间做最大流量限制,[0,k] 之间整数</p><p>让根源, 所有叶子汇, 的最大流恰好 = f</p><p>求方案数 % 998244353</p><hr><p>对于给定k</p><p>a(n,f) = 高度n, 最大恰好f的方案数</p><p>考虑状态转移</p><p>那么也就是 左边的n-1高度 最大流为v的时候,右边为f-v</p><p>但是这个 左边的最大流 可能是被根到左边这个边限制的, 也可能是本身n-1,v 的方案</p><p>定义 b(n,f) 等于 高度n 且根上多一个[0,k] 的限制的最大流 = k,方案数</p><p>如果是下面子树最大f, 那么对于根上可以选择 f~k, 所以有(k-f+1)a(n,f) 种</p><p>如果是下面子树最大 &gt; f, 那么对于根上仅可选择f, 所以有 $\sum_{i=f+1}^{2k} a(n,i) 种</p><p>综上$b(n,f) = (k-f+1)a(n,f) + \sum_{i=f+1}^{2k} a(n,i)$ , 前缀和每个状态 均摊O(1) 可算</p><p>那么对于a就是最开始的转移</p><p>$a(n,f) = \sum_{i=0}^f b(n-1,i)\cdot b(n-1,f-i)$, 卷积, 需要FFT或者NTT就可以搞</p><hr><p>那么答案 = $a(n,f)$, 也说明 $f &gt; 2k$ 无解</p><hr><p>最后边界处理, $b(n,f) = 0, f &gt; k$</p><hr><p>关于实现, 似乎直接NTT c++17会被卡, 可能要c++20</p><p>因为这里 相当于 是$a[n] = b[n-1]^2$, 所以平方可以少算一次NTT</p><p>然后 注意计算前把 末尾0删了, 不然可能长度倍增</p><p>以及我本地测 带了<code>-fsanitize</code>的编译, c++17/20 都4.5s, 而不带的都是1s</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p><a href="https://codeforces.com/contest/1709/submission/165613575" target="_blank" rel="noopener">https://codeforces.com/contest/1709/submission/165613575</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // read// ------------------------------- NTT --------------------------------namespace NTT998{  const int MOD = 998244353; // 7*17*2^23 + 1  const int MAXPWR = 22; // 随着MOD改变, 2的幂次, 对应复平面单位向量的N = 2 &amp;&amp; MAXPWR;  const int g = 3;// 原根 随着MOD改变  const int invg = 332748118;// 原根模逆元 随着MOD 和 g 改变  // bit 翻转  int rev(int x, int len) {    int ans = 0;    while(len -- ){      ans &lt;&lt;= 1;      ans |= x &amp; 1;      x &gt;&gt;= 1;    }    return ans;  }  inline int getlog2(int n){ return 31 - __builtin_clz(n);}  ll mypow(ll a, ll k) { //快速幂，a**k    ll res = 1;    while (k) {      if (k &amp; 1) (res *= a) %= MOD;      (a *= a) %= MOD;      k &gt;&gt;= 1;    }    return res;  }  void NTT(vector&lt;ll&gt; &amp;A, int flag = 1 /* 1: NTT, -1: INTT*/ ) {    int n = A.size();    if(n == 1) return ;    // assert((n &amp; (n-1)) == 0); // 2 的幂次    int lgn = getlog2(n);    // assert(lgn &lt;= MAXPWR);    rep(i, 0, n) { // 同FFT      int j = rev(i, lgn);      if (j &gt; i) swap(A[i], A[j]);    }    rep(pwr,0,lgn){      int m = 1 &lt;&lt; pwr;      // assert((MOD - 1) % (m&lt;&lt;1) == 0);      ll gn = mypow(flag == 1 ? g : invg, (MOD - 1) / (m &lt;&lt; 1)); // 单位原根g_n      for (int k = 0; k &lt; n; k += (m&lt;&lt;1)) {        ll gi = 1;        rep(j,0,m) {          auto U = A[k + j];          auto T = gi * A[k + j + m] % MOD;          A[k + j] = (U + T) % MOD;          A[k + j + m] = (U - T + MOD) % MOD;          (gi *= gn) %= MOD;        }      }    }    if(flag == -1){ // 内置 / N      const ll INVSIZE = mypow(n, MOD-2);      rep(i,0,n) (A[i] *= INVSIZE) %= MOD;    }  }  void INTT(vector&lt;ll&gt; &amp;A){ NTT(A,-1);}  // 平方 少一次 NTT  vector&lt;ll&gt; poly_sq(vector&lt;ll&gt; &amp;v0) {    int sz = v0.size() * 2;    if(sz == 0)return {};    sz = 1 &lt;&lt; (getlog2(sz) + !!(sz &amp; (sz-1))); // 非2的幂次    v0.resize(sz,0);    NTT(v0);    vector&lt;ll&gt; a2(sz,0);    rep(i,0,sz) a2[i] = v0[i] * v0[i] % MOD;    INTT(a2);    return a2;  }}// ------------------------------- NTT --------------------------------int n;vector&lt;ll&gt; a;vector&lt;ll&gt; b; // 滚动int main(){  const int MOD = NTT998::MOD;  int n = read(); // 15  int k = read(); // 2e5  int f = read(); // 2e5  if(f &gt; 2 * k){    printf(&quot;0\n&quot;);    return 0;  }  b = vector&lt;ll&gt;(k+1,1);  rep(i,1,n+1){    // a    a = NTT998::poly_sq(b); // 非平方也会TLE    if(a.size() &lt;= 2*k+1) a.resize(2*k+1,0);    vector&lt;ll&gt; prea(2*k+2, 0); // prefix sum of a    rep(j,0,2*k+1) prea[j+1] = (prea[j] + a[j]) % MOD;    b = vector&lt;ll&gt;(k+1,0);    rep(j,0,k+1) b[j] = (k-j+1) * a[j] % MOD + (prea[2*k+1] - prea[j+1]);    while(!b.empty() &amp;&amp; b.back() == 0) b.pop_back(); // 重要, 否则多出来的0 会导致 长度倍增 TLE  }  printf(&quot;%lld\n&quot;, a[f]);  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>E</p><p>一个是细节想错, lca多算一次 没想到</p><p>另一个是 考虑最深的lca的根 ,而不是考虑端点</p><p>这两点都是能想到没想到</p><p>然后关键的来了, 就是启发式合并的知识点, 这下学会了又</p><p>F</p><p>一个是变成树的 “流计算”, 很神奇 我好想 竖着觉得是树 ,横着就没发现了,</p><p>一个是学一下NTT, 以及NTT中的平方</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://codeforces.com/blog/entry/105164" target="_blank" rel="noopener">官方</a></p><p><a href="http://yexiaorain.github.io/Blog/2022-07-24-NTT/">NTT</a></p>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> 贪心 </tag>
            
            <tag> 树 </tag>
            
            <tag> 前缀和 </tag>
            
            <tag> xor </tag>
            
            <tag> 树上启发式合并 </tag>
            
            <tag> NTT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LGV 引理</title>
      <link href="/Blog/2022-07-22-LGVlemma/"/>
      <url>/Blog/2022-07-22-LGVlemma/</url>
      
        <content type="html"><![CDATA[<p>Lindström–Gessel–Viennot lemma</p><p><a href="https://oi-wiki.org/graph/lgv/" target="_blank" rel="noopener">https://oi-wiki.org/graph/lgv/</a></p><p>前置知识, 图论基础,矩阵,行列式,高斯消元</p><p>适用于DAG上(有向无环图)</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>$P$ 路径</p><p>$\omega(P) = $ 路径$P$上边权之积</p><p>点$u,v$</p><p>$e(u,v) = \sum_{P:u\to v} \omega(P)$每一条 $u$到 $v$ 的路径$S$,的$\omega(P)$之和</p><p>大小为n的 起点集合A,终点集合B, (点集内也可能有边, 满足DAG, 以及还有一些不是起点也不是终点的其它中间的点</p><p>$S$ 一组不相交的路径组(路径集合,包含所有起点终点): 任意两个路径$S_i,S_j$没有公共顶点</p><p>$\sigma(S)$ 表示一个具体的路径集合$S$中,$A$按照顺序($S_i$的起点是$A_i$)时, $B$的下标序列</p><p>$N(\sigma) = \sigma$的逆序对个数</p><p>系数矩阵</p><p>$M = \begin{bmatrix}e(A_1,B_1)&amp;e(A_1,B_2)&amp;\cdots&amp;e(A_1,B_n)\\<br>e(A_2,B_1)&amp;e(A_2,B_2)&amp;\cdots&amp;e(A_2,B_n)\\<br>\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\<br>e(A_n,B_1)&amp;e(A_n,B_2)&amp;\cdots&amp;e(A_n,B_n)\end{bmatrix}<br>$</p><h2 id="引理"><a href="#引理" class="headerlink" title="引理"></a>引理</h2><p>其中$S$是不相交路径组</p><p>$\det(M)=\sum\limits_{S:A\rightarrow B}(-1)^{N(\sigma(S))}\prod\limits_{i=1}^n \omega(S_i)$</p><p>M的行列式的值是所有不相交路径的边权乘积的带符号数量和</p><hr><p>证明:</p><p>由行列式定义</p><p>$\begin{aligned}<br>\det(M)&amp;=\sum_{\sigma}(-1)^{N(\sigma)}\prod_{i=1}^ne(A_i,B_{\sigma_i})\\<br>&amp;=\sum_{\sigma}(-1)^{N(\sigma)}\prod_{i=1}^n\left(\sum_{P:A_i\rightarrow B_{\sigma_i}}\omega(P)\right)\\<br>&amp;=\sum_\sigma(-1)^{N(\sigma)}\sum_{\sigma=\sigma(S)}\prod_{i=1}^n \omega(S_i)\\<br>&amp;=\sum_{S:A\rightarrow B} (-1)^{N(\sigma(S))} \prod_{i=1}^n \omega(S_i)<br>\end{aligned}$</p><p>第一步是行列式展开</p><p>第二步是,e等价替换</p><p>第三步是,神奇的分配率, $(\omega(A_1\to B_{\sigma_1}方案0) + \omega(A_1\to B_{\sigma_1}方案1) + \cdots) \cdot (\omega(A_2\to B_{\sigma_2}方案0) + \omega(A_2\to B_{\sigma_2}方案1) + \cdots) \cdot (\cdots)$</p><p>这个使用分配率乘开了就是 方案之间的$\omega$之乘积, 再求和</p><p>再换句话说,原来内部的求和的是针对指定的起始点$A_i$结束点$B_{\sigma_i}$, 而拆开以后,把一个路径组看作单位,对路径组中第$i$条路径($A_i$)开头的进行统计</p><p>第四步就是, 把上面按照一个行列式的$\sigma$作为贡献的单位来计算,变成一个具体的$S$来计算,也是求和分配</p><hr><p>注意到上面仅证明了行列式能转换, 也保证了路径之间起点和终点互异, 但是<strong>没有证明是不相交路径</strong></p><p>但注意到对于所有(起点终点两两不同)的路径组,这个表达式也成立</p><p>对路径集合划分,$U$为不相交路径组,$V$为相交路径组</p><p>$\begin{aligned}<br>&amp;\sum_{S:A\rightarrow B} (-1)^{N(\sigma(S))} \prod_{i=1}^n \omega(S_i)\\<br>=&amp;\sum_{U:A\rightarrow B} (-1)^{N(\sigma(U))} \prod_{i=1}^n \omega(U_i)+\sum_{V:A\rightarrow B} (-1)^{N(\sigma(V))} \prod_{i=1}^n \omega(V_i)<br>\end{aligned}$</p><p>要证明右侧$\sum_{V:A\rightarrow B} (-1)^{N(\sigma(V))} \prod_{i=1}^n \omega(V_i) = 0$ 即可</p><p>对于$V$中一个具体的路径组$S$,取最小的相交路径的二元组$(i,j)$</p><p>有路径$S_i: A_i \to u \to B_{\sigma(S)_ i}$, $S_j: A_j \to u \to B_{\sigma(S)_ j}$, 其中$u$是路径上首次相交的点(注意到是DAG,所以两条路径中都是首次</p><p>修改得到路径$S_i: A_i \to u \to B_{\sigma(S)_ j}$, $S_j: A_j \to u \to B_{\sigma(S)_ i}$</p><p>这样得到$S’$</p><p>首先乘积的部分一致$\prod_{i=1}^n \omega(S_i) = \prod_{i=1}^n \omega(S’_ i)$, 而逆序对变化为$1 = |N(\sigma(S)) - N(\sigma(S’))|$, 所以 $S$与$S’$的贡献互为相反数, 总贡献和为$0$</p><p>并且根据这个交换产生规则,$S$唯一映射到$S’$,$S’$也唯一映射到$S$, 且$S \neq S’$ ??????? ( 感觉有点没对, 这样构造并不能保证交换后 最小二元组还是$(i,j)$, 因为被交换的路径和$i$ 有交,变成$(i,k)$</p><p>但是整体思路还是可以用的, 就是找标识去构建对称,总贡献为0.</p><p>这里需要改变的是, 把S中所有相交路径的交点中取编号最小的u, 在u处相交的取最小的二元组$(i,j)$ 并交换u以后的部分, 这样 交换以后能保证, 所有交点不变, 所以u依然最小,而在u处相交的也不变,依然是$(i,j)$, 这才有一一对应的关系</p><p>综上, 所有V中的两两成对,贡献和为$0$, 因此$V$的总贡献为$0$</p><p>证毕</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这又是行列式知识, 每个乘积的正负号 = (-1)的逆序对次方 乘对应位置的积</p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lgv lemma </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces 1707</title>
      <link href="/Blog/2022-07-18-CF1707/"/>
      <url>/Blog/2022-07-18-CF1707/</url>
      
        <content type="html"><![CDATA[<p>C(最小生成树,LCA,树上差分)D(组合数,树上DP,DP,前缀和)E(数学,倍增)</p><h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><p><a href="https://codeforces.com/contest/1707/problem/C" target="_blank" rel="noopener">https://codeforces.com/contest/1707/problem/C</a></p><p>给你个n点,m边的连通图,边两两不等</p><p>有个错误的dfs算法, 每次找未选择的点中最短边进行dfs</p><p>问,从哪些点开始dfs,能得到正确的最小生成树</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>n 1e5</p><p>m [n-1,2e5]</p><p>2s</p><p>256MB</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>首先边两两不等,说明正确的最小生成树唯一</p><p>第二以一个点作为根, 按正确的最小生成树建树, 那么树边以外的其它边都是回边,没有跨边,则这个点做dfs合法</p><p>但这样每次枚举就是 O(n^2), TLE</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>先找到最小生成树</p><p>如果有连接 u v的非树边</p><p>那么 通过树边的简单路径 u—–v 通过树边的中间的点, 不可能, 且沿着树边扩展的点也不可能</p><hr><p>变成了树上染色问题</p><p>然后剩下就LCA,树上差分了</p><hr><p>LCA + 树上差分 思想就是</p><p>初始是对不可能的+1</p><p>然后因为批量+1 复杂度大</p><p>变成了记录每个数和它父节点的差(根节点表示自身的值), 就是树上差分了</p><p>那么对于 u,v 是非祖先关系, c[根]+=1,c[u]-=1,c[v]-=1</p><p>u和v是祖先关系, 假设u是v的祖先</p><p>c[u向v的子节点]+=1, c[v]-=1</p><p>最后还原差分成真实树即可, 判断 &gt; 0?</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://codeforces.com/contest/1707/submission/164711832" target="_blank" rel="noopener">https://codeforces.com/contest/1707/submission/164711832</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backconst int POWER = 20;const int N = 100000;const int M = 200000;ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readint n;int m;vector&lt;int&gt;p2[N+10]; // MSTpair&lt;int,int&gt; e[M+10]; // 边bool treee[M+10]; // tree edgeint f[N+10]; // 并查集int find(int v) {return f[v]==v?v:(f[v] = find(f[v]));}void link(int u,int v){ f[find(v)] = find(u);}ll x[N+10]; // 差分 和最终值int fa[N+10][POWER]; // 树上倍增int d[N+10]; // 深度// 一级父节点 和 深度void build(int u,int p = 1,int dep = 1){  fa[u][0] = p;  d[u] = dep;  for(auto v:p2[u]) if(v != p) build(v,u,dep+1);}// 还原差分void dfs(int u, int p = 1, int s = 0){  x[u] += s;  for(auto v:p2[u]) if(v != p) dfs(v,u,x[u]);}// 最近公共祖先int lca(int u,int v){  if(d[u] &lt; d[v])swap(u,v); // d[u] &gt; d[v]  per(i,0,POWER) if(d[u] - d[v] &gt;= (1 &lt;&lt; i)) u = fa[u][i];  if(u == v) return u;  per(i,0,POWER) {    if(fa[u][i] != fa[v][i]){      u = fa[u][i];      v = fa[v][i];    }  }  return fa[u][0];}// u 向上走d步int fa_d(int u,int d){  per(i,0,POWER) if(d &gt;= (1 &lt;&lt; i)) {    d -= (1&lt;&lt;i);    u = fa[u][i];  }  return u;}int main(){  // read  n = read();  m = read();  rep(i,0,m){    int u = read();    int v = read();    e[i] = {u,v};  }  // MST  iota(f+1,f+n+1,1);  rep(i,0,m){    auto [u,v] = e[i];    if(find(u) != find(v)) {      treee[i] = true;      link(u,v);      p2[u].pb(v);      p2[v].pb(u);    }  }  // 建立倍增  build(1); // 深度 和 1级父节点  rep(pwr,1,POWER) rep(i,1,n+1) fa[i][pwr] = fa[fa[i][pwr-1]][pwr-1];  // 树上差分  rep(i,0,m) if(!treee[i]){    auto [u,v] = e[i];    if(d[u] &gt; d[v]) swap(u,v); // d[u] &lt; d[v];    int r = lca(u,v);    if(u == r){      int w = fa_d(v, d[v] - d[u] - 1);      x[w]++;      x[v]--;    } else {      x[1]++;      x[u]--;      x[v]--;    }  }  // 差分还原成值  dfs(1);  // 输出答案  rep(i,1,n+1) printf(&quot;%d&quot;, (int)(x[i] == 0));  return 0;}</code></pre><h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><p><a href="https://codeforces.com/contest/1707/problem/D" target="_blank" rel="noopener">https://codeforces.com/contest/1707/problem/D</a></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>n 点 根为1树</p><p>初始 U = 1..n 点集合</p><p>一次操作, 取点集T, T 是U的部分虚树(T是U的真子集, 且T中任意两点的LCA也属于T), 令U=T</p><p>求 恰好k次操作后 集合只有根节点的操作路径有多少种</p><p>方案数 mod p </p><p>要求 k=1,2,…,n-1 所有的结果</p><h3 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h3><p>n 2000</p><p>p [1e8+7 ~ 1e9+9] 是 质数</p><p>2s</p><p>256mb</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h3><p>可能可以倒过来</p><p>初始只有根,每次增加至少一个点, 增加后要满足LCA的在集合中的关系, 一共k次</p><p>考虑一个叶子节点, 它可以任意时候被加入</p><p>一个非叶子只有一个分支的节点, 它也是任意时刻被加入</p><p>一个非叶子,多分支节点那么它加入的时机 需要 早于或等于 它的第二个被加入的子树</p><p>换句话说, 假设点i为多叉点,在t时刻被加入,那么 1..t-1 中至多只能存在点i 的其中一个子树中的点</p><p>f(t..k, all子树)</p><ul><li><p>f(1..k, 子树1, 至少一个在[1..t-1]) * f(t..k, all子树-子树1) + </p></li><li><p>f(1..k, 子树2, 至少一个在[1..t-1]) * f(t..k, all子树-子树2) + </p></li><li><p>…</p></li></ul><p>但似乎 注意到一个子树放在区间至于区间长度有关, 这样至少后面一半状态上是nk的</p><p>前面一节, 可以变成f(1..k,子树1) - f(t..k, 子树1) 这样剩下的至少一个不属于(t..k)</p><p>f(根u, 长度l) = for t = 1..l</p><p>转移还要n, 这样n^3, 而且还有k, 一眼TLE</p><p>考虑到本来状态就是 f(根u, 长度l) 也就是对于不同k可以复用, 那么问题来到了如何把转移优化到 log或者常数级别, 或者均摊常数级别</p><p>f(u,l) = f(v0, k - t + 1) * f(v1)</p><p>如果干掉这个t就好了</p><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>如果每次点数不严格下降结果为f,原答案为ans</p><p>有 $f_i=\sum_{j=0}^i\binom{i}{j}ans_j$, 因为j步意味着j+1个不同的集合, 要用这j+1个不同的集合按原顺序,可重复的产生i+1个集合, 那么其实就是选择每个开始的位置</p><p>既然是带系数前缀和,那也可以从 f反向推ans, 所以问题怎么球不严格下降的结果</p><hr><p>然后又是来到和我讨论类似的对删除时间的讨论</p><p>当一个节点u有分叉时</p><p>那么它的删除时间就会受到 子树的限制</p><ol><li><p>子树里所有节点 早于等于 u</p></li><li><p>u的某个子树以外的子树都删完了 早于等于 u, 早于剩下的子树最后一个节点</p></li></ol><p>状态 <code>dp[u][t]</code> , u以及它的子树,恰好第i次操作后删除完的方案数</p><hr><p>转移 $dp_{u,t}$</p><p>$C_u$ 是 $u$ 的子节点集合</p><p>前缀 $S_{u,t} = \sum_{i\le t} dp_{u,i}$</p><p>$u$子集前缀关于$t$的乘积 $M_{u,t} = \prod_{v \in C_u} S_{v,t}$</p><ol><li>$u$在$t$时刻删, 则 剩下的都在$[1,t]$时刻删</li></ol><p>$M_{u,t}$</p><ol start="2"><li>$u$在$t_0 &lt; t$ 时刻删, 因为要恰好, 则至少有个在$t$时刻删, 其它在$[1,t_0]$时刻删</li></ol><p>$ \sum_{v\in C_u} (dp_{v,t} \cdot \prod_{w \in C_u, w \neq v}^N S_{w,t_0})$</p><p>$ = \sum_{v\in C_u} (dp_{v,t} \cdot \frac{\prod_{w\in C_u} S_{w,t_0}}{S_{v,t_0}})$</p><p>$ = \sum_{v\in C_u} dp_{v,t} \cdot \frac{M_{u,t_0}}{S_{v,t_0}}$</p><p>对于所有$t_0 \in [1..t-1]$ 加和</p><p>$ = \sum_{t_0 = 1}^{t-1} (\sum_{v\in C_u} dp_{v,t} \cdot \frac{M_{u,t_0}}{S_{v,t_0}})$</p><p>$ = \sum_{v\in C_u} (dp_{v,t} \cdot (\sum_{t_0 = 1}^{t-1} \cdot \frac{M_{u,t_0}}{S_{v,t_0}}))$</p><hr><p>综上</p><p>$ dp_{u,t} = M_{u,t} + \sum_{v\in C_u} (dp_{v,t} \cdot (\sum_{t_0 = 1}^{t-1} \cdot \frac{M_{u,t_0}}{S_{v,t_0}}))$</p><p>每个$S_{u,t}$, 均摊只需要O(1), $S$总状态$O(n^2)$, 所以时间复杂度$O(n^2)$</p><p>然后每个$M_{u,t}$ 均摊需要$O(|C_u|)$, 对于所有$u$的$|C_u|$和为 节点数,所以时间复杂度也是$O(n^2)$</p><p>再看 $\sum_{t_0 = 1}^{t-1} \cdot \frac{M_{u,t_0}}{S_{v,t_0}}$</p><p>注意和$u,v,t$ 有关,但v只能是u的子节点集, 所以状态数为$O(|C_u|n)$, 总状态数依然是$O(n^2)$, 同样通过t的前缀和, 均摊$O(1)$, 所以总时间复杂度也是$O(n^2k)$</p><p>最后$dp_{u,t}$, 状态显然$O(n^2)$, 时间复杂度$O(|C_u|)$, 所以总时间复杂度$O(n^2)$;</p><p>可做……….</p><hr><p>咦,看起来和我的很像啊, 是不是我的那个t也可以干掉</p><p>可能不一定,别人通过恰好来简化了转移方便了前缀和实现</p><hr><p>最后的最后, 通过$ans_i = f_i - \sum_{j=0}^{i-1} \binom{i}{j} ans_j $反推即可</p><hr><p>实际写起来有几点坑,</p><ol><li><p>时间卡得紧, 不要频繁的用费马小定理 计算inv, TLE11</p></li><li><p>Wa31 第31个点 会出现S是MOD的倍数…..</p></li></ol><p>然后Wa31需要小学数学, 因为本身是乘法, 变成除法只是为了简化运算, 所以本身不会有除0, 但 变化后 加上mod 就可能除以0</p><p>注意到这里其实就是M和S之间,所以统计一下M中少乘一个零的结果, 当S=0时取那个结果即可</p><p>然后 因为量级很大, 不能去 大量做mod除法, 所以一个办法是记录 分子分母, 另一个办法是</p><p>M/S也变成前缀+后缀的形式来算, 当然前缀+后缀形式会常数更小</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>分数+除法 857ms 158MB</p><p><a href="https://codeforces.com/contest/1707/submission/164894672" target="_blank" rel="noopener">https://codeforces.com/contest/1707/submission/164894672</a></p><p>前后缀 + longlong 733ms 81MB</p><p><a href="https://codeforces.com/contest/1707/submission/164900140" target="_blank" rel="noopener">https://codeforces.com/contest/1707/submission/164900140</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backint MOD = -1;ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readll mpow(ll v,ll mi){ll r = 1;while(mi){if(mi%2)(r*=v)%=MOD;(v*=v)%=MOD;mi&gt;&gt;=1;};return r;} // quick power with MODint n;vector&lt;int&gt; e[2010];void dfs(int u,int fa){  vector&lt;int&gt; arr = {};  for(auto v: e[u]) if(v != fa) arr.pb(v);  e[u] = arr;  for(auto v: e[u]) dfs(v, u);}struct ModInt{  int v;  ModInt(ll val = 0) :v(val) { }};ll real(const ModInt &amp; v0){  return (v0.v + MOD) % MOD;}ModInt operator+(const ModInt &amp; v0, const ModInt &amp;v1){  return (v0.v + v1.v) % MOD;}ModInt operator-(const ModInt &amp; v0, const ModInt &amp;v1){  return (v0.v - v1.v) % MOD;}ModInt operator*(const ModInt &amp; v0, const ModInt &amp;v1){  return ((ll)v0.v * (ll)v1.v) % MOD;}ModInt dp[2010][2010];vector&lt;ModInt&gt; preMu[2010]; // 每次只会具体 u 可以复用vector&lt;ModInt&gt; sufMu[2010];ModInt S[2010][2010];ModInt W[2010][2010];ModInt fac[2010] = {1};ModInt invv[2010] = {1};ModInt invfac[2010] = {1};ModInt C(int n,int m) { return fac[n] * invfac[m] * invfac[n-m]; }ModInt ans[2010];int main(){  n = read();  MOD = read();  rep(i,1,n){    int u = read();    int v = read();    e[u].pb(v);    e[v].pb(u);  }  // 30 ms  rep(i,1,n+1) fac[i] = fac[i-1] * i;  invv[1] = 1;  rep(i,2,n+1) invv[i] = (MOD-MOD/i) * invv[MOD % i];  rep(i,1,n+1) invfac[i] = invfac[i-1] * invv[i];  dfs(1, 1);  // 61ms  // bfs on tree  vector&lt;int&gt; vorder = {1};  rep(i, 0, vorder.size()) {    int u = vorder[i];    for(auto v: e[u]) vorder.pb(v);  }  reverse(vorder.begin(), vorder.end());  for(auto u: vorder) {    rep(t,1,n) {      ModInt &amp;dput = dp[u][t] = 1; // 叶子      if(!e[u].empty()) {        // 优化成 前后缀        preMu[t] = vector&lt;ModInt&gt; (e[u].size() + 1, 1);        sufMu[t] = vector&lt;ModInt&gt; (e[u].size() + 1, 1);        rep(i,0,e[u].size()){          auto v = e[u][i];          preMu[t][i+1] = preMu[t][i] * S[v][t];        }        per(i,0,e[u].size()){          auto v = e[u][i];          sufMu[t][i] = sufMu[t][i+1] * S[v][t];        }        dput = preMu[t][e[u].size()];        if(t &gt; 1) rep(i,0,e[u].size()) {          auto v = e[u][i];          ModInt &amp;Wvt = W[v][t-1] = ((t-1 &gt; 1) ? W[v][t-2] : 0) + (preMu[t-1][i] * sufMu[t-1][i+1]);          dput = dput + dp[v][t] * Wvt;        }      }      S[u][t] = ((t &gt; 1) ? S[u][t-1] : 0) + dput;    }  }  rep(t,1,n) ans[t] = preMu[t][e[1].size()];  rep(t,1,n) rep(t0,1,t) ans[t] = ans[t] - ans[t0] * C(t,t0) ;  rep(t,1,n) printf(&quot;%lld &quot;, real(ans[t]));  return 0;}</code></pre><h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><p><a href="https://codeforces.com/contest/1707/problem/E" target="_blank" rel="noopener">https://codeforces.com/contest/1707/problem/E</a></p><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>长度n数组 a</p><p>$ai \in [1,n]$</p><p>f((l,r)) = (min(a[l..r]) , max(a[l..r])), 传入区间范围, 返回最小值和最大值</p><p>每次调用 (l,r) = f((l,r))</p><p>q个询问</p><p>每次问如果初始 li,ri, 需要反复调用 多少次 让l和r 最终变成(1,n) 或不可能</p><h3 id="范围-2"><a href="#范围-2" class="headerlink" title="范围"></a>范围</h3><p>q 1e5</p><p>n 1e5</p><h2 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路-2"><a href="#我的思路-2" class="headerlink" title="我的思路"></a>我的思路</h3><p>显然对于给定l,r 输出的f是一定的</p><p>所以对于所有的输入, 全部成环</p><p>那么f( (1,n) ) 一定要等于 (1,n), 否则 只有直接传入1,n 才会满足</p><p>想倒着找, 但是显然有最坏情况, 2 3 4 5 6, 这样一共有$O(n^2)$种不同输入和结果</p><h3 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h3><p>如果 区间A 包含于区间B</p><p>那么 f(A) 包含于 f(B)</p><p>证明, min(B) &lt;= min(A) &lt;= max(A) &lt;= max(B)</p><p>并且高阶f也有这个包含关系</p><hr><p>因此如果 [l,r] = ([l,r0] 并 [l0,r]), 其中 (l0 &lt;= r0) </p><p>那么 f(l,r) 包含 (f(l,r0) 并 f(l0,r)), </p><p>注意到 f(l,r0) 包含 f(l0,r0), f(l0,r) 也包含 f(l0,r0)</p><p>所以 f(l,r0) 和 f(l0,r) 本身就重叠, 所以 f(l,r0) 并 f(l0,r) = 连续的区间</p><p>那么 f(l,r) 的最小值 至少包含于 f(l,r0) 和 f(l0,r) 的其中一个, 最大值也是, 所以最小值最大值都存在,且连续, 包含于 f(l,r)</p><p>综上 f(l,r0) 并 f(l0,r) = f(l,r)</p><p>同样高阶也满足</p><p>例如2阶段, f(f(l,r)) = f(f(l,r0)) 并 f(f(l0,r)) , 思路同上, 包含于关系, 最小 最大值, 连续 推出相等</p><hr><p>注意到 一旦能到整个长度,那么一定 f(1,n) = (1,n)</p><p>如果链很长, 根据状态数 可能达到n^2</p><p>那么 办法就是倍增, 倍增到&gt; n^2 如果还不行那就真不行了</p><p>可以的话就二分倍增的倍数</p><p>为了效率, 用倍增记录每个位置开始的长度的 多少轮跳跃的结果</p><hr><p>然后实现上几点注意, 别二分, 每次二分会导致 长度不是幂次 依然需要log, 多层log过不了</p><p>找结果依然是倍增的找</p><p>然后就是cpu缓存和tlb机制, 注意循环顺序访问顺序和数组定义顺序</p><p>这导致常数影响非常明显, tle的代码和600+ms过的代码 就是把顺序换了换</p><hr><p>然后我看有人 长度开的2^18 也过了!!!, 不知道数学上是否有办法证明或者找反例</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><p><a href="https://codeforces.com/contest/1707/submission/164951002" target="_blank" rel="noopener">https://codeforces.com/contest/1707/submission/164951002</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readconst int N = 100000;const int PLEN = 19; // power length math.log(100000) / math.log(2) 16.609640474436812const int POP = 35; // power operation math.log(4999950000) / math.log(2) 32.219266521851075ll n;int L[POP][PLEN][N+10]; // 次数不用记录零次int R[POP][PLEN][N+10];int LG2[N+10]; // 0 和 1 都对应0次方, 需要减的 1&lt;&lt;LG2[r-l]的偏移量int a[N+10];inline pii f(int l,int r,int p1){  if(l == r) return {    L[p1][0][l],    R[p1][0][r]  };  int sz = LG2[r-l];  return {    min(L[p1][sz+1][l],L[p1][sz+1][r-(1&lt;&lt;sz)]),    max(R[p1][sz+1][l],R[p1][sz+1][r-(1&lt;&lt;sz)])  };}inline int query(int l,int r){  if(l == 1 &amp;&amp; r == n) return 0;  if(l == r) return -1;  // 不要二分, 二分是 log(n^2) = 2 log(n) * log(n)  // 直接binary 倍增做, log(r-l+1)*O(1) &lt; log(n)  ll ret = 0;  per(i, 0, POP){    // printf(&quot;%d = %d\n&quot;,r-l,p0);    int l0, r0;    tie(l0, r0) = f(l, r, i);    if(l0 != 1 || r0 != n){      // checklrk(l, r, 1ll &lt;&lt; i, l0, r0);      l = l0;      r = r0;      ret += (1ll &lt;&lt; i);      if(l == r) return -1;    }  }  tie(l,r) = f(l, r, 0);  return (l == 1 &amp;&amp; r == n) ? (ret + 1) : -1;}int main(){  n = read();  rep(i,2,N) LG2[i] = LG2[i/2] + 1;  int q = read();  rep(i,1,n+1) L[0][0][i] = R[0][0][i] = a[i] = read();  {    const int p1 = 0;    rep(p0,1,PLEN) rep(i,1,n+1) {      L[p1][p0][i] = min(L[p1][p0-1][i],L[p1][p0-1][min(n,i+(1ll &lt;&lt; max(0ll, p0-2)))]);      R[p1][p0][i] = max(R[p1][p0-1][i],R[p1][p0-1][min(n,i+(1ll &lt;&lt; max(0ll, p0-2)))]);      // check(i,p0,p1);    }  }  rep(p1, 1, POP) rep(p0, 0, PLEN) rep(i,1,n+1){    tie(        L[p1][p0][i] ,        R[p1][p0][i]       ) = f(         L[p1 - 1][p0][i],         R[p1 - 1][p0][i],         p1 - 1         );  }  while(q--){    int l = read();    int r = read();    printf(&quot;%d\n&quot;, query(l,r));  }  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>C</p><p>有想到, 环的最大边的 两点以外的点不可能,但是有反例, 就是没有把最小生成树 和 这个合在一起考虑</p><p>后面LCA和树上差分倒是没啥问题掌握了</p><p>D</p><p>感觉真有可能能做出来, 多习惯在dp时 分别恰好,和 小于等于 ,以及 前缀和方程与逆方程之间的联系</p><p>被小学数学教育了$a \neq \frac{a\cdot b}{b}$</p><p>然后就是 大量的inv还是不要, 一个办法就是 分数表示, 一个办法是想办法消除掉除法</p><p>E</p><p>数学推出性质以后 就是倍增倍增倍增了</p><p>实现上也有一些坑</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://codeforces.com/blog/entry/104930" target="_blank" rel="noopener">官方</a></p>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LCA </tag>
            
            <tag> DP </tag>
            
            <tag> 数学 </tag>
            
            <tag> 组合数 </tag>
            
            <tag> 前缀和 </tag>
            
            <tag> 树上差分 </tag>
            
            <tag> 倍增 </tag>
            
            <tag> 最小生成树 </tag>
            
            <tag> 树上DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atcoder arc144</title>
      <link href="/Blog/2022-07-17-ac_arc144/"/>
      <url>/Blog/2022-07-17-ac_arc144/</url>
      
        <content type="html"><![CDATA[<p>D(数学,组合数),E(有向图,并查集,gcd,所有环,树回边)</p><h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://atcoder.jp/contests/arc144/tasks/arc144_d" target="_blank" rel="noopener">https://atcoder.jp/contests/arc144/tasks/arc144_d</a></p><p>有多少个映射f满足</p><p>定义域[0..2^n-1]</p><p>值域[0..k]</p><p>且值域内任意值x,y满足</p><p>f(x) + f(y) = f(x &amp; y) + f(x | y)</p><h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h3><p>n 3e5</p><p>k 1e18</p><p>2s</p><p>1024mb</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h3><p>f(…0) + f(1) = f(…1) + f(0)</p><p>f(…0.) + f(10) = f(…1.) + f(0)</p><p>因此 自由元素 f(0) f(1) f(2) f(4) …</p><p>把 f(0..2^{n-1}-1)看作整体, 那么 f(2^{n-1}..2^{n}-1) 可以看作它的平移</p><p>显然有</p><p><code>dp[i][min][max] = sum{dp[i-1][min][min..max]} + sum{dp[i-1][min..max][max]} - dp[i-1][min][max]</code></p><p>然而这 $O(nk^2)$ 显然时间空间都接受不了</p><p>不知道怎么化简</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>跟着上面思路 如果 f(0) = 0 , 那么 f(x) = 按二进制拆开x的 sum f(bit)</p><p>相当于 f(1) + f(2) + f(4) + f(8) … &lt;= k 插板组合数</p><p>如果f(0) != 0, 令 f(0) = V</p><p>那么令 g(x) = f(x) - V</p><p>那么g(x) 也满足条件,  -V &lt;= g(x) &lt;= K - V</p><p>0 &lt;= sum g(任意2幂)  + V &lt;= k</p><p>sum 正g(2幂) + V &lt;= k</p><p>sum 负g(2幂) + V &gt;= 0</p><hr><p>然后就是</p><p>枚举<code>f(0)</code> 的值V</p><p>枚举正数个数i, i个正的和 $\le k-V$, 因为小于等于 所以不妨把<code>k-V-和+1</code> 看作一个新的正数,相当于 i+1个正数 和 = k-V+1, 那就是k-V空隙插i个板子</p><p>枚举负数个数j,同理</p><p>$\sum_{V=0}^k \sum_{i=0}^n \sum_{j=0}^{n-i} \binom{n}{i} \binom{n-i}{j} \binom{k-V}{i} \binom{V}{j}$</p><p>$\sum_{i=0}^n \sum_{j=0}^{n-i} \binom{n}{i} \binom{n-i}{j} (\sum_{V=0}^k  \binom{k-V}{i} \binom{V}{j})$</p><p>$\sum_{i=0}^n \sum_{j=0}^{n-i} \binom{n}{i} \binom{n-i}{j} (\sum_{V=j}^{k-i}  \binom{k-V}{i} \binom{V}{j})$</p><p>右侧括号里,可以想成$k+1$个球, 选出$i+j+1$个球的组合方案数</p><p>我们去枚举被选的第$i+1$个球的位置$p$, $p \in [i+1,k+1-j]$</p><p>那么左侧有$p-1$个, 需要选出$i$个, 右侧有$k + 1 - p$个需要选出$j$个</p><p>令$V = k + 1 - p$即和现在表达式一致了</p><p>所以</p><p>$\sum_{i=0}^n \sum_{j=0}^{n-i} \binom{n}{i} \binom{n-i}{j} \binom{k+1}{i+j+1}$</p><p>$\sum_{i=0}^n \sum_{j=0}^{n-i} \binom{i+j}{i} \binom{n}{i+j} \binom{k+1}{i+j+1}$</p><p>$\sum_{i+j \le n} \binom{i+j}{i} \binom{n}{i+j} \binom{k+1}{i+j+1}$</p><p>二项式和</p><p>$\sum_{s = 0}^n 2^s \binom{n}{s} \binom{k+1}{s+1}$</p><p>就可以做了</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/arc144/submissions/33279666" target="_blank" rel="noopener">https://atcoder.jp/contests/arc144/submissions/33279666</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 998244353#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readll mul(ll a,ll b){  a %= MOD;  b %= MOD;  return a * b % MOD;}ll add(ll a,ll b){  a %= MOD;  b %= MOD;  return (a + b) % MOD;}ll normal(ll a){  return (a%MOD + MOD)%MOD;}ll mypow(ll v,ll pwr){  v%=MOD;  ll r = 1;  while(pwr){    if(pwr%2) (r*=v)%=MOD;    (v*=v)%=MOD;    pwr/=2;  }  return r;}ll fac[300010] = {1};ll binom(ll n,ll m){  if(m &gt; n) return 0;  return fac[n] * mypow(fac[m],MOD-2) % MOD * mypow(fac[n-m],MOD-2) % MOD;}int main(){  rep(i,1,300005) fac[i] = mul(fac[i-1],i);  int n = read();  ll k = read();  ll ans = 0;  ll binomk1s1 = 1; // k 很大  rep(s,0,n+1){    if(s &gt; k) break;    binomk1s1 = mul(binomk1s1,mul(k+1-s,mypow(s+1,MOD-2)));    ans = add(ans,mul(mul(mypow(2,s),binom(n,s)),binomk1s1) );  }  printf(&quot;%lld\n&quot;, normal(ans));  return 0;}</code></pre><h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>N点,M边有向图</p><p>有向边 都是从小节点指向大节点的(无自环,无重边)</p><p>输入一个初始W[1..N],其中如果是Wi=-1,就可以取任何值,否则按给定的来</p><p>点i 权重 Wi</p><p>求最大从1到N的所有路径的权重和的gcd</p><p>如果gcd可能无限大则输出-1</p><p>不需要输出W的方案</p><h3 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h3><p>N 3e5</p><p>M 3e5</p><p>至少存在一条路径</p><p>初始Wi [1…10e12]</p><p>2s</p><p>1024MB</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h3><p>首先 如果存在一条完全给定的 <code>1-&gt;N</code>的权重和则有限大,否则可能无限大(<code>A-&gt;B, B-&gt;C-&gt;D, B-&gt;D</code>, 其中<code>B</code>任意,而后面指定两条路径不等, 那么gcd也是有限大)</p><p>对于有限大, 因为有向边全是从小指向大, 所以不成环只有拓扑关系</p><p>在没有具体值的情况, 并不能对求和的表达式计算gcd</p><p>所以考虑有没有可能反过来</p><p>反过来指定gcd, 1个问题是并没有二分性质, 每条边的可能性是考虑mod gcd,也是gcd个, 量级也不会太小</p><p>对于直接有指定W路径的相对好一些, 其中gcd一定是它的约数,这样情况会少一些,但是Ai和M都很大,即使给定的路径W和也可以达到3e17</p><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>首先干掉 1不能到达, 和 不能到达N的点(无效的点), 防止无效的点影响找环的结果</p><p>如果k是答案,那么也就是所有路径 和 %k == 0</p><p>那么假设 到点u, <code>(1 -&gt; u)%k = p[u]</code> 是唯一的</p><p>那么所有直接相邻的 <code>vi-&gt;u</code>, 有 <code>p[vi] + w[u] = p[u] (mod k)</code></p><p>说明<code>p[vi]</code> 全部一样</p><p>这样, 就并查集了!</p><p>然后<code>p[n] = 0</code>, 所以可以加0号点 <code>W[0] = 0</code>, 路径<code>0-&gt;1</code></p><hr><p>有直接相邻<code>u-&gt;v</code>,且<code>w[v]</code>给定,</p><p>说明 两个并查集里的 的<code>union[u] + 3 = union[v]</code></p><hr><p>变成了 一些点, 和一些有权有向边</p><p>找所有环, 求gcd, 并不能找所有环,但是gcd性质上, 所有环gcd = 所有(树+回边) gcd</p><p>所以就可以搞了</p><p>环即可能由0产生, 也会有形如<code>A-&gt;B-&gt;C-&gt;D, A-&gt;D</code>, 这样产生</p><hr><p>无环 就任意都可以, -1</p><hr><p>然后有向图找环 我真不会写</p><p>学了一下apiad巨佬的代码, 发现是所有边建立正向和负向, 保证任何简单复杂路径 = 端点简单路径和即 全部像是无向图的有向图, 这样任何一个点可以作为根</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/arc144/submissions/33329393" target="_blank" rel="noopener">https://atcoder.jp/contests/arc144/submissions/33329393</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (int i=a;i&lt;(int)n;i++)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readll gcd(ll a,ll b){return b == 0?a:gcd(b,a%b);}const int N = 300000;int n,m;vector&lt;int&gt; u2v[N+10]; // 正向边vector&lt;int&gt; v2u[N+10]; // 反向边ll w[N+10];int invalid[N+10]; // 1 无效, 0 有效, -1 未访问int fa[N+10]; // 并查集// 并查集int getfa(int v){ return v == fa[v]?v:(fa[v] = getfa(fa[v]));}void link(int u,int v){ fa[getfa(u)] = getfa(v);}// 计算不可达bool dfs1n(int u){  int &amp;r = invalid[u];  if(r != -1) return r;  if(u == n) return r = 0;  r = 1;  for(auto v:u2v[u]) if(!dfs1n(v)) r = 0;  return r;}// 移除不合法vector&lt;int&gt; rminvalid(const vector&lt;int&gt; &amp;arr){  vector&lt;int&gt; ret = {};  for(auto u: arr) if(!invalid[u]) ret.pb(u);  return ret;}vector&lt;pair&lt;int,ll&gt; &gt; p2[N+10];int vis[N+10];ll dis[N+10]; // 和根的距离, root distancevoid dfs(int idx,ll d,ll &amp; ans) {  if(vis[idx]) {    // (环长 = 多树边 + 1回边), (重边), 多回边的环 gcd = 拆分的多个单回边环的gcd的gcd    ans = gcd(ans, abs(d - dis[idx]) );    return ;  }  vis[idx] = true;  dis[idx] = d;  for(auto [v,s]:p2[idx]) dfs(v, d + s, ans);}int main(){  n = read();  m = read();  iota(fa,fa+n+1,0); // fa[i] = i  fill(invalid+1,invalid+n+1,-1); // invalid[i] = -1  rep(i,1,m+1) { // u -&gt; v    int u = read();    int v = read();    u2v[u].push_back(v);    v2u[v].push_back(u);  }  rep(i,1,n+1) w[i] = read();  // 筛无效点  dfs1n(1);  rep(u,1,n+1) if(!invalid[u]) u2v[u] = rminvalid(u2v[u]);  rep(v,1,n+1) if(!invalid[v]) v2u[v] = rminvalid(v2u[v]);  // n -&gt; 1  u2v[n].pb(1);  v2u[1].pb(n);  // 找所有点的源点, 计算并查集  rep(v,1,n+1) if(!invalid[v]) rep(i,1,v2u[v].size()) link(v2u[v][i-1], v2u[v][i]);  // 根据给定w 建立新的图  rep(v,1,n+1) if(!invalid[v] &amp;&amp; w[v] != -1){    int tov = getfa(v); // 并查集中的点    int fromv = getfa(v2u[v][0]); // assert(v2u[tov].size()); 因为都可达所以每个点一定有前置点    // 全部双向边 辅助在有向图中找所有环的gcd    p2[fromv].pb({tov, w[v]}); // 正向    p2[tov].pb({fromv, -w[v]}); // 负向  }  // 找环  ll ans = 0;  rep(i,1,n+1) if(!invalid[i] &amp;&amp; !vis[i]) dfs(i,0,ans);  printf(&quot;%lld\n&quot;,ans == 0? -1: abs(ans));  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>D</p><p>这个对f(0) = 0特殊讨论 ,在 讨论f(0) 不为零的转化, 就是 一个特殊边界讨论 + 向特殊转移的问题</p><p>然后什么神奇的范德蒙恒等式(这里并不是, 但有一点思路相近的感觉</p><p>$\binom{n+m}{k} = \sum_{i=0}^k \binom{m}{i} \binom{n}{k-i}$</p><p>其实就是考虑$(1+x)^{m+n}$的$x^k$系数和 $(1+x)^m\cdot (1+x)^n$的$x^k$的系数</p><p>总之还有一些组合数的技巧,不是光有了初始表达式就可以的</p><p>E</p><p>讨论满足目标条件的 相邻转移</p><p>然后这个有向找所有环的gcd 也是学了一手, 改成正负双向</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://atcoder.jp/contests/arc144/editorial" target="_blank" rel="noopener">官方题解</a></p><p><a href="https://www.bilibili.com/video/BV1aB4y1a74j" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1aB4y1a74j</a></p>]]></content>
      
      
      <categories>
          
          <category> Atcoder </category>
          
          <category> ARC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
            <tag> gcd </tag>
            
            <tag> 数学 </tag>
            
            <tag> 组合数 </tag>
            
            <tag> 有向图 </tag>
            
            <tag> 所有环 </tag>
            
            <tag> 树回边 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atcoder abc259</title>
      <link href="/Blog/2022-07-11-ac_abc259/"/>
      <url>/Blog/2022-07-11-ac_abc259/</url>
      
        <content type="html"><![CDATA[<p>G(网络流)H/Ex(分块,讨论)</p><h1 id="G"><a href="#G" class="headerlink" title="G"></a>G</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://atcoder.jp/contests/abc259/tasks/abc259_g" target="_blank" rel="noopener">https://atcoder.jp/contests/abc259/tasks/abc259_g</a></p><p>HxW的数阵</p><p>选择任意的一些行和一些列, 让被选到的所有格子的和最大(同时被行和列选只统计一次)</p><p>且 限制条件,如果格子上的值为负那么 不能同时选它的行和列</p><h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h3><p>H,W [1,100]</p><p>Aij [-1e9,+1e9]</p><p>2s</p><p>1024mb</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h3><p>显然 纯非负的行和列一定被选,</p><p>所以可以预处理让剩下的所有行列至少包含一个负数</p><p>然后考虑说纯选行或选列</p><p>但是显然有反例</p><pre><code>  1     -1    100 -1      1 -10000100 -10000      1</code></pre><p>这种情况 最优的是选1行和1列</p><hr><p>然后另一个性质是, 显然 和为非正的行和列不会被选, 因为 如果即选了行又选了列,重叠部分非负 两个都选的和是 小于 两个分别的和的</p><p>然后没思路了</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>首先我们令 结果 = 全部正值 都被选了, 考虑变化对结果的影响</p><ol><li>如果一个正的没有被选, 那么它的行列没有直接被选, -Aij</li><li>如果一个负值被选了, 那么它的行和列有一个被选, Aij</li></ol><p>如果 Aij &lt; 0 被选了, </p><ul><li><p>如果是行被选, 那么 影响的是 加上 i行的所有负数</p></li><li><p>如果是列被选, 那么 影响的是 加上 j列的所有负数</p></li></ul><hr><p>于是改变题目</p><p>初始分 = 正数和</p><p>那么如果 选了i行, 则 损失 i行的所有负值的和</p><p>那么如果 选了j列, 则 损失 j列的所有负值的和</p><p>对于正的单元没被选的 损失上面值的代价</p><p>对于负的单元, 不恩那个同时选行和列</p><p>答案 = 正数和 减去 下面网络流的最小割</p><p>点:</p><p>R[1..H]</p><p>C[1..W]</p><p>源S,汇T</p><p>边:</p><p><code>S-&gt;R[i]</code>, 容量 行i的所有负值和的绝对值</p><p><code>C[j]-&gt;T</code>, 容量 行j的所有负值和的绝对值</p><p><code>R[i] -&gt; C[j]</code> 如果是 Aij &gt; 0, 则 权重 Aij</p><p><code>C[j] -&gt; R[i]</code> 如果是 Aij &lt; 0, 则 权重 无限大</p><p>这样考虑</p><p>对于 Aij &gt; 0</p><p><code>S-&gt;R[i]-&gt;C[j]-&gt;T</code> 在最小割中, 至少有一条边被割(说至少是因为, 可能 R和T一个集合,S和C一个集合)</p><p>对 Aij &lt; 0</p><p>也就是最小割一定不会同时割<code>S-&gt;R[i]</code>,和<code>C[j]-&gt;T</code>, 因为如果这样割了</p><p>意味着, <code>S,C[j]</code> 是一个集合,<code>R[i],T</code>是一个集合, 就有 <code>C[j] -&gt; R[i]</code> 的无限大, 就不会是最小割了</p><p>对于<code>Aij &lt; 0</code> 一定是 <code>S-&gt;R[i]</code> 或 <code>C[j]-&gt;T</code>, 表示</p><p>也就是对于Aij &lt; 0, 至多一个成为割边</p><hr><p>然后最小割 = 最大流 Dinic, 或者直接调用官方的maxflow</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc259/submissions/33171094" target="_blank" rel="noopener">https://atcoder.jp/contests/abc259/submissions/33171094</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;#include &lt;atcoder/maxflow&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readint n;int m;const int N = 100;const ll inf = 0x3f3f3f3f3f3f3f3f;int h, w; // 输入ll a[N+10][N+10]; // 输入ll rsum[N+10], csum[N+10]; // 行列负数绝对值和int main() {  h = read();  w = read();  rep(i,1,h+1){    rep(j,1,w+1) a[i][j] = read();  }  atcoder::mf_graph&lt;ll&gt; g(h+w+2); // 传入点数  int S = 0; // 源  int T = h+w+1; // 汇  ll ans = 0;  rep(i,1,h+1){    rep(j,1,w+1){      if(a[i][j] &gt;= 0){        ans += a[i][j];        g.add_edge(i, h+j, a[i][j]); // R[i] -&gt; C[j], a[i][j]      } else {        g.add_edge(h+j, i, inf); // C[j] -&gt; R[i], inf        rsum[i] += -a[i][j];        csum[j] += -a[i][j];      }    }  }  rep(i,1,h+1) g.add_edge(S, i, rsum[i]); // S -&gt; R[i], 行负数和的绝对值  rep(j,1,w+1) g.add_edge(h+j, T, csum[j]); // C[j] -&gt; T, 列负数和的绝对值  printf(&quot;%lld\n&quot;, ans - g.flow(S, T));  return 0;}</code></pre><h1 id="H-Ex"><a href="#H-Ex" class="headerlink" title="H/Ex"></a>H/Ex</h1><p><a href="https://atcoder.jp/contests/abc259/tasks/abc259_h" target="_blank" rel="noopener">https://atcoder.jp/contests/abc259/tasks/abc259_h</a></p><p>NxN的矩阵</p><p>每次向右或向下走</p><p>问有多少种路径,头和尾所在位置的数字相同</p><h2 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h2><p>n 400</p><p>aij [1,N^2]</p><p>2s</p><p>1024 MB</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h3><p>最朴素就是 对不同值分开处理,直接变成 每个值=&gt; 所有位置</p><p>然后 (i0,j0) =&gt; (i1,j1) 就是组合数</p><p>问题是, 如果一个一算,是(N^4)的样子会TLE</p><p>考虑是否有办法把结果变成统计合并</p><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>分块</p><p>更朴素的纯色+dp是, O(n^2)的</p><p>所以对于每个颜色根据个数来做不同处理</p><p>如果当前颜色点个数 &lt;= n</p><p>显然用我的思路里两两去算, 复杂度不超过O(个数^2),这一类的总复杂度小于O(sum{个数^2}) &lt;= O(sum{n <em> 个数})&lt;= O(n </em> sum{个数}) &lt;= O(n^3)</p><p>如果当前颜色个数 &gt; n , 那就直接dp,也不超过O(n^2), 而这种最多n种颜色最多O(n^3)</p><p>综上</p><p>都在n^3内</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>无</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>G</p><p>感觉 完全对网络流类型不熟,即使看了答案也仅是证明, 感觉没有系统的练习相关的建图, 还是不知道从何而起</p><p>这里相当于网络流求的是尽可能删除得小的, 利用了 最小割 = 最大流 , 这也是一个点,要求最小值的时候可以考虑让图能含义到最小割</p><p>然后就是atcoder内置的maxflow真香啊</p><p>Ex</p><p>有一说一感觉比G简单</p><p>这个分类的第一个复杂度上限推导还是很有意思,有点像之前树上左右部分平方的dp总复杂度是n3不是n4的感觉</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://atcoder.jp/contests/abc259/editorial" target="_blank" rel="noopener">官方题解</a></p><p><a href="https://www.bilibili.com/video/BV1KW4y1S7NA" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1KW4y1S7NA</a></p>]]></content>
      
      
      <categories>
          
          <category> Atcoder </category>
          
          <category> ABC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络流 </tag>
            
            <tag> 分块 </tag>
            
            <tag> 讨论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces 1699</title>
      <link href="/Blog/2022-07-05-CF1699/"/>
      <url>/Blog/2022-07-05-CF1699/</url>
      
        <content type="html"><![CDATA[<p>D(dp)E(双指针,部分更新,1/2+1/3+1/4+…)</p><p>这次Div2的D,E都不会了</p><h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><p><a href="https://codeforces.com/contest/1699/problem/D" target="_blank" rel="noopener">https://codeforces.com/contest/1699/problem/D</a></p><p>长度n数组A</p><p>每次操作可以删除相邻且不同的两个值, 剩下的拼在一起, 多次操作</p><p>要让最终的数组值全部相同,求最大长度</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>n 5000</p><p>2s</p><p>256MB</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>如果我们指定哪个值留下来</p><p>假设是v</p><p>那么 考虑两个v之间的其它值 v …. v</p><p>如果其中有值x出现次数超过一半, 那么剩下的必然是x - 非x</p><p>否则,如果是奇数个剩下任意一个, 偶数个则全部清除</p><p>最后可以得到一个 v 非v v 非v v …</p><p>的多段结果</p><p>然后我并没有什么办法 处理这个</p><p>如果有办法就是n^2 的总复杂度了</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>首先如果一个数出现次数超过一半,那最终剩下的一定是它,所以这种情况不用猜留哪个</p><p>如果整个长度是偶, 且没有数出现次数超过一半,那么可以被完全删除</p><p>然后通过O(n^2) 计算所有区间 最多出现的数字,或者全部可消除</p><p>啊 我知道啊</p><hr><p>dp[i] 表示a[0…i]删除以后 结果包含a[i] 的最大长度</p><p>初始化 如果[0..i-1] 能完全删除 dp[i] = 1, 否则 dp[i] = -INF</p><p>如果<code>j &lt; i, a[i] == a[j]</code> 且 <code>[j+1..i-1]</code> 能完全删除</p><p><code>dp[i] = max(dp[j]+1)</code></p><p>所以最后就是求所有中的最大的且后缀可删除<code>rm[j..end] == true</code>, 相当于找结果的末尾位置</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://codeforces.com/contest/1699/submission/162852461" target="_blank" rel="noopener">https://codeforces.com/contest/1699/submission/162852461</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readint n;int a[5010];  // 5000 n^2bool rm[5010][5010]; // rm[i][j] = [i..j] 完全删除int dp[5010]; // 前[0..i] 删完剩下 a[i] 的个数const int INF = 0x3f3f3f3f;void w(){  n = read();  rep(i,0,n) a[i] = read();  rep(i,0,n){    fill(rm[i],rm[i]+n,false);    vector&lt;int&gt;cnt(n+1,0); // 次数统计    int maxc = -1; // 出现最多的    rep(j,i,n){      cnt[a[j]]++;      if(maxc == -1 || cnt[maxc] &lt; cnt[a[j]]) maxc = a[j];      if((j-i)%2 == 0)continue;      if(cnt[maxc] &lt;= (j-i+1)/2) rm[i][j] = true;    }  }  rep(i,0,n) dp[i] = (i == 0 || rm[0][i-1]) ? 1: -INF; // 初始化  int ans = 0;  rep(i,0,n){    rep(j,0,i){      if((i-j)%2==0)continue;      if(a[i] != a[j]) continue;      if(j == i-1 || rm[j+1][i-1]) dp[i] = max(dp[i], dp[j]+1);    }    if(i == n-1 || rm[i+1][n-1]) ans = max(ans,dp[i]); // 后续可删  }  printf(&quot;%d\n&quot;,ans);}int main(){  int t = read();  while(t--) w();  return 0;}</code></pre><h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><p>给你长度n数组a</p><p>每次你可以把任意一个值v=a乘b,拆成a,b,</p><p>求 min(max(数组) - min(数组))</p><h2 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h2><p>n 1e6</p><p>ai [1..5e6]</p><p>4s</p><p>256MB</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h3><p>直接想 有点像是说, 能否把每个数拆分进[l..r] 之间</p><p>变个方向就是 给定l,求最小的r</p><p>那么考虑l的变化</p><p>因为任意两个ai,aj的拆分方案互不影响, 考虑单个 v 拆成最小&gt;=l时,最大r的最小值的</p><p>显然l增大时,r 非严格单增, 且l &lt;= min(ai)的</p><p>而问题是让区间尽量小</p><p>区间长度并没有单调性或凹凸性, 想法方向GG</p><hr><p>第二个想法是</p><p>我直接拆每个数, 去计算每个数的<code>map[间隔] = vector&lt; pair&lt;最小,最大&gt; &gt;</code></p><p>比如 <code>4: [0] = { { 2 , 2 } , { 4 , 4 } }</code></p><p>但不知道怎么拆, dfs暴力?</p><p>以及拆分后怎么在不同ai之间组合</p><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>和我第一个想法类似但是倒着for最小的因子</p><p>因为不同v的拆法互不影响,考虑一个具体的原数组中出现过的 v</p><p>若当前最小因子恰好为i, 那么</p><p>如果 v不是i的倍数, 则,之前v怎么拆分就怎么拆分</p><p>如果 <code>v &lt; i^2</code>, 显然不能拆,如果拆了 另一个因子就会小于i</p><p><code>v &gt;= i^2</code> 且<code>v = ik</code> , 那么会拆成<code>i 和 k</code>, 而对于<code>k</code>可能也有拆的方案</p><p>我们直接记录<code>dp[k] =</code>当前拆分方案中, 最大的因子</p><p>有<code>dp[ik] = min(old dp[ik], dp[k])</code>, 其中<code>k &gt;= i</code></p><p>这里要注意的是当一个数<code>v=ik</code>是i的倍数,它按i拆开仅是可能让最大因子更小,而不是一定, 所以要和之前的<code>dp[v]</code> 比较</p><hr><p>而最大值, 显然是非严格单调递减, 我们只需要 统计每个值拆分后的最大因子(也是非严格单调递减)出现次数, 就能知道最大值</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p><a href="https://codeforces.com/contest/1699/submission/162860620" target="_blank" rel="noopener">https://codeforces.com/contest/1699/submission/162860620</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readconst int N = 5000000;bool appear[N+10]; // 在数列中出现过int mxval[N+10]; // [v] = v当前被拆分出来的更大的因子 , 运算过程中每个值的变化是非严格单调递减int cnt[N+10]; // 遍历过程中 每个ai拆分后对应最大因子 的 次数统计int n;int m;void w(){  // clear  fill(appear,appear+m+1,false);  fill(cnt,cnt+m+1,0);  fill(mxval,mxval+m+1,0);  n = read();  m = read();  int mn = m; // 最小  int mx = 0; // 最大  rep(i,0,n){    int x = read();    appear[x] = true;    cnt[x] = 1;    mn = min(mn, x);    mx = max(mx, x);  }  iota(mxval,mxval+mx+1,0); // mxval[i] = i; 默认都未被拆分  int ptr = mx; // 最大值  ll ans = mx - mn;  per(i,1,mx+1){    for (ll j = i * i; j &lt;= mx; j += i) { // j = i * (k&gt;=i) , j 拆分成 i 和 k, k可能继续能拆      // 移除原有拆分方案      if (appear[j]) cnt[mxval[j]]--; // 从真的统计上讲 应该是 [i]--, [mxval[j]]--, 但i &lt;= mxval[j] 所以 这里 中间一段不影响结果      // 计算新的最优方案      mxval[j] = min(mxval[j], mxval[j / i]); // i 不一定是最小的, 所以吆喝之前的比较      // 加入新的拆分方案      if (appear[j]) cnt[mxval[j]]++;    }    while (cnt[ptr] == 0) ptr--;    if (i &lt;= mn) ans = min(ans, ptr - i); // 最小值为i, 最大值为ptr  }  printf(&quot;%lld\n&quot;,ans);}int main() {  int t = read();  while (t--) w();}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>D</p><p>核心其实还是dpi可以和ai挂钩,因为其它什么区间可删除都想到了, 感觉应该还很常见的</p><p>E</p><p>倒着处理</p><p>只更新会影响的部分内容</p><p>因为遍历的i就是最小, 所以拆分统计, 不需要统计非最大因子以外的内容, 优化统计</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://codeforces.com/blog/entry/104088" target="_blank" rel="noopener">官方</a></p>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
            <tag> 双指针 </tag>
            
            <tag> 部分更新 </tag>
            
            <tag> 1/2+1/3+1/4+... </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atcoder abc258</title>
      <link href="/Blog/2022-07-03-ac_abc258/"/>
      <url>/Blog/2022-07-03-ac_abc258/</url>
      
        <content type="html"><![CDATA[<p>F(暴力)G(bitset)H/Ex(dp,矩阵快速幂)</p><h1 id="F"><a href="#F" class="headerlink" title="F"></a>F</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://atcoder.jp/contests/abc258/tasks/abc258_f" target="_blank" rel="noopener">https://atcoder.jp/contests/abc258/tasks/abc258_f</a></p><p>网格,4临移动</p><p>如果 x=Bn的线上移动或者y=Bn的线上移动,(B的倍数), 单位距离代价1</p><p>其它情况单位距离代价k</p><p>求(sx,sy) -&gt; (gx,gy) 的最小代价</p><h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h3><p>t 2e5 测试点</p><p>b,k [1,1e9]</p><p>sx,sy,gx,gy [0,1e9]</p><p>3s</p><p>1024mb</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h3><p>显然是个数学处理一下, 就做的题</p><p>两个点分开考虑</p><p>一个点计算它本身, 四个方向到x=bn or y=bn , 的点,再到四个角的点</p><p>点类型 (普通0,边点1,十字交点2)</p><p>(0-任何) 直接距离乘k</p><p>(边点 - 边/十字) = 在方向上同bn, 则x1, 否则直接距离乘k</p><p>(十字-十字) = 距离x1</p><p>写了二十多分钟</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc258/submissions/32973579" target="_blank" rel="noopener">https://atcoder.jp/contests/abc258/submissions/32973579</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 1000000007#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readll b;ll k;const int T_NORMAL = 0; // 普通const int T_SIDE = 1; // 边const int T_CROSS = 2; // 角int calctype(ll i,ll j){  return (int)(i%b == 0) + (int)(j%b == 0);}vector&lt;array&lt;ll,3&gt; &gt; calc(ll i,ll j){  // i , j , dis  vector&lt;ll&gt; ai = {i};  vector&lt;ll&gt; aj = {j};  if(i%b) {    ai.pb((i/b)*b);    ai.pb((i/b+1)*b);  }  if(j%b) {    aj.pb((j/b)*b);    aj.pb((j/b+1)*b);  }  vector&lt;array&lt;ll,3&gt; &gt; res;  for(auto ni:ai){    for(auto nj:aj){      if(ni != i &amp;&amp; nj != j){        res.pb({ni,nj, (abs(ni-i) + abs(nj-j) - max(abs(ni-i), abs(nj-j)))*k + max(abs(ni-i), abs(nj-j)) });      }else{        if(i % b != 0 &amp;&amp; j%b != 0){          res.pb({ni,nj, (abs(ni-i) + abs(nj-j))*k});        }else{          res.pb({ni,nj, (abs(ni-i) + abs(nj-j))});        }      }    }  }  return res;}void w(){  b = read();  k = read();  ll si = read();  ll sj = read();  ll gi = read();  ll gj = read();  auto ijds = calc(si,sj);  auto ijdg = calc(gi,gj);  ll ans = 0x3f3f3f3f3f3f3f3f;  for(auto [i0,j0,d0]:ijds){    int t0 = calctype(i0,j0);    for(auto [i1,j1,d1]:ijdg){      int t1 = calctype(i1,j1);      if(t0 == T_NORMAL || t1 == T_NORMAL){        ans = min(ans,d0+d1+ (abs(i1-i0) + abs(j1-j0))*k);      }else if(t0 == T_SIDE || t1 == T_SIDE){        if(i0 == i1 &amp;&amp; i0 % b == 0){          ans = min(ans,d0+d1+abs(j1-j0));        }else if(j0 == j1 &amp;&amp; j0 % b == 0){          ans = min(ans,d0+d1+abs(i1-i0));        }else{          ans = min(ans,d0+d1+(abs(i1-i0)+abs(j1-j0))*k);        }      }else{ // == CROSS        ans = min(ans,d0+d1+abs(i1-i0)+abs(j1-j0));      }    }  }  printf(&quot;%lld\n&quot;,ans);}int main(){  int t = read();  while(t--) w();  return 0;}</code></pre><h1 id="H-Ex"><a href="#H-Ex" class="headerlink" title="H/Ex"></a>H/Ex</h1><p><a href="https://atcoder.jp/contests/abc258/tasks/abc258_h" target="_blank" rel="noopener">https://atcoder.jp/contests/abc258/tasks/abc258_h</a></p><p>序列X满足</p><ol><li>所有元素正奇数</li><li>和为s</li><li>X前缀和的值不在集合A中, 集合A大小为N</li></ol><p>求满足的要求的序列X的个数</p><h2 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h2><p>n 1e5</p><p>ai [1,1e18]</p><p>s [1,1e18]</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h3><p>果然读错题, 读成了需要序列X长度也是N</p><p>实际上对序列长度无要求</p><hr><p>不考虑X而是直接考虑X的前缀和</p><p><code>dp[v] =</code> 构成v的方案数</p><p><code>dp[Aj] = 0</code></p><p><code>dp[0] = 1</code></p><p>递推关系</p><p><code>dp[v] = sum{dp[v-1]+dp[v-3]+ dp[v-5]+...}</code></p><p>令<code>f[i] = dp[i] + dp[i-2] + dp[i-4]</code></p><p>有<code>dp[v] = f[v-1]</code> <code>f[v] = dp[v] + f[v-2] = (v in A ? 0 :f[v-1]) + f[v-2]</code></p><p>所以可以直接算f 矩阵快速幂</p><p>然后问题是要处理掉v 在 A中的情况, 并且注意到v在A中是<code>dp[v] == 0</code> 并不意味<code>f[v-1] == 0</code></p><pre><code>(f[v-1] f[v-2]) (f[v] f[v-1])                (1/0    1   )                ( 1     0   )</code></pre><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/abc258/submissions/32981204" target="_blank" rel="noopener">https://atcoder.jp/contests/abc258/submissions/32981204</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 998244353#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readint n;ll s ;ll a[100010];// Wi = (f[i]  f[i-1])// (f[v] f[v-1]) = (f[v-1] f[v-2]) *//                                (1/0    1   )//                                ( 1     0   )vector&lt;vector&lt;ll&gt; &gt; mul(vector&lt;vector&lt;ll&gt; &gt;m0,vector&lt;vector&lt;ll&gt; &gt;m1){  vector&lt;vector&lt;ll&gt; &gt; r = vector&lt;vector&lt;ll&gt; &gt;(m0.size(), vector&lt;ll&gt;(m1[0].size(),0));  assert(m0[0].size() == m1.size());  rep(i,0,m0.size()){    rep(j,0,m1[0].size()){      rep(k,0,m0[0].size()){        (r[i][j] += m0[i][k] * m1[k][j] % MOD) %= MOD;      }    }  }  return r;}vector&lt;vector&lt;ll&gt; &gt; mypow(vector&lt;vector&lt;ll&gt; &gt;m0,ll pwr){  vector&lt;vector&lt;ll&gt; &gt; r = {    {1,0},    {0,1}  };  while(pwr){    if(pwr%2) r = mul(r,m0);    m0 = mul(m0,m0);    pwr/=2;  }  return r;}int main(){  n = read();  s = read();  rep(i,0,n) a[i] = read();  a[n] = s; // dp[s] = f[s-1] =&gt;  w[s][1]  n++;  vector&lt;vector&lt;ll&gt; &gt; w; // w[iw] = {f[iw], f[iw-1]}  ll iw = 1;  if(a[0] == 1) w = { {0,1} };  else w = { {1,1} };  rep(i,0,n){    ll ai = a[i];    if(iw == ai)continue;    if(iw == ai-1){      w = mul(w,{          {0,1},          {1,0}          });      iw = ai;    }else{      w = mul(          mul(w,mypow({              {1,1},              {1,0}              }, ai-iw-1)),{          {0,1},          {1,0}          });      iw = ai;    }    // printf(&quot;w[%lld] = {%lld %lld}\n&quot;,iw, w[0][0],w[0][1]);  }  printf(&quot;%lld\n&quot;,w[0][1]);  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>F</p><p>没啥难的</p><p>G</p><p>内置 bitset 优化一下效率就行了</p><p>Ex</p><p>也没啥难的</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://atcoder.jp/contests/abc258/editorial" target="_blank" rel="noopener">官方题解</a></p>]]></content>
      
      
      <categories>
          
          <category> Atcoder </category>
          
          <category> ABC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 暴力 </tag>
            
            <tag> bitset </tag>
            
            <tag> 矩阵快速幂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces 1698</title>
      <link href="/Blog/2022-07-02-CF1698/"/>
      <url>/Blog/2022-07-02-CF1698/</url>
      
        <content type="html"><![CDATA[<p>F(数学,数组,相邻无序对)G(GF(2),meet in middle,不懂证明)</p><h1 id="F"><a href="#F" class="headerlink" title="F"></a>F</h1><p><a href="https://codeforces.com/contest/1698/problem/F" target="_blank" rel="noopener">https://codeforces.com/contest/1698/problem/F</a></p><p>给长度n的数组A和B</p><p>每次可以选择A数组中值相等两个数,把它们中间的区间颠倒顺序</p><p>求$n^2$次数内的方案得到B</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>n 500</p><p>1s</p><p>256MB</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>没有思路</p><p>只知道首个和末个 有重复的数字的一定位置不会变,且它们两侧的也不会变</p><p>但如何记录翻转并不知道</p><p>可行的话, 首先每个值个数要一样</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>数组不变量</p><p>首先a1和an是不会变的</p><p>然后是相邻元素构成无序对不变, 因为 区间 v…v颠倒,那么 中间和v连接的依然和v连接</p><p>必要显然</p><p>充分性, 我们具体构造</p><p>假设 前缀 a[..i] 和 b[..i] 相同, a[i] = x</p><p>a[i+1] = y</p><p>b[i+1] = z</p><p>如果存在 <code>a[i..] = [x,y,...,z,x,...]</code> 那么直接翻转 做1次</p><p>如果 <code>a[i...] = [x,y,...,x,z,...]</code>, 如果 <code>x,z</code> 右侧还有<code>x</code> 则翻转2次</p><p>否则 <code>x,z</code> 的<code>x</code>是最后出现的<code>x</code>, 所以, x至少2个</p><p>如果x恰好2个, 且是连着 <code>a[i..]= [x,y,x,z,...]</code>, <code>b[i..] = [x,z,....y,x,y,...]</code> , 这样转b</p><p>否则<code>a[i..]</code> 中 x相邻至少3对相邻</p><p>那么根据上面的,只有最后的那一个x的右侧不能通过,x本身交换 完成, 而a和b的操作是对称的</p><p>所以 <code>3对</code>中 最多<code>2对</code>无法交换,所以总存在一个相邻,可以0~2次 完成换到<code>a[i..] = [x,?,...]</code></p><p>即只要满足,无序对的性质</p><p>那么<code>a[0..i]</code> 一致了 就有办法让<code>b[0..i]</code> 一致</p><hr><p>直接暴力找 <code>O(n^2)</code></p><p>注意到的是算法实际的次数是不超过4n的</p><p>而需要的是小于$n^2$的次数,所以考察 <code>n=[1..4]</code>的合法的数组的操作次数时候</p><p>n=1 0次</p><p>n=2 0次</p><p>n=3 0次</p><p>n=4 0次/1次</p><p>所以也满足次数要求</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><a href="https://codeforces.com/contest/1698/submission/162605498" target="_blank" rel="noopener">https://codeforces.com/contest/1698/submission/162605498</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;#define MOD 1000000007#define rep(i,a,n) for (int i=a;i&lt;(int)n;i++)#define per(i,a,n) for (int i=n;i--&gt;(int)a;)int read(){int r;scanf(&quot;%d&quot;,&amp;r);return r;} // readint n;int a[510];int b[510];// 翻转区间void rev(int *arr,int i,int j){  rep(k,i,j+1){    int rk = j-(k-i);    if(rk &lt; k)break;    swap(arr[k],arr[rk]);  }}// 找arr[sti...]中 找 [x,y,...,z,x,...], 翻转成[x,z...]bool op(int *arr,int sti,int z,vector&lt;pair&lt;int,int&gt;&gt; &amp; ans){  int x = arr[sti];  rep(i,sti+1,n){    // [x,y........z,x]    // [sti............i]    if(arr[i] == x &amp;&amp; arr[i-1] == z){      rev(arr, sti+1,i-1);      ans.push_back({sti+1,i+1});      return true;    }  }  return false;}// 找arr[sti...]中 找 [x,y,...,x,z,...,x,...], 翻转成[x,z...]bool oprev(int *arr,int sti,int z,vector&lt;pair&lt;int,int&gt;&gt; &amp; ans){  int x = arr[sti];  rep(i,sti+1,n){    // [x,y........x,z,.....x]    // [sti..........i      j]    if(arr[i] == z &amp;&amp; arr[i-1] == x){      rep(j,i+1,n){        if(arr[j] == x){          rev(arr, sti+1,j-1);          ans.push_back({sti+1,j+1});          return op(arr,sti,z,ans);        }      }      return false;    }  }  return false;}void w(){  n = read();  rep(i,0,n) a[i] = read();  rep(i,0,n) b[i] = read();  if(a[0] != b[0]) {    printf(&quot;NO\n&quot;);    return ;  }  if(a[n-1] != b[n-1]){    printf(&quot;NO\n&quot;);    return ;  }  vector&lt;pair&lt;int,int&gt;&gt; pa;  rep(i,1,n){    int u = a[i-1];    int v = a[i];    if(u &gt; v) swap(u,v);    pa.push_back({u,v});  }  vector&lt;pair&lt;int,int&gt;&gt; pb;  rep(i,1,n){    int u = b[i-1];    int v = b[i];    if(u &gt; v) swap(u,v);    pb.push_back({u,v});  }  sort(pa.begin(),pa.end());  sort(pb.begin(),pb.end());  if(pa != pb){    printf(&quot;NO\n&quot;);    return ;  }  printf(&quot;YES\n&quot;);  // 一定可以  // -------------  vector&lt; pair&lt;int,int&gt; &gt;ans; // 正向  vector&lt; pair&lt;int,int&gt; &gt;revans; // 反向  rep(i,0,n){    if(a[i] != b[i]){      int x = a[i-1];      //      if(op(   a,i-1,b[i],ans))continue;      if(oprev(a,i-1,b[i],ans))continue;      if(op(   b,i-1,a[i],revans))continue;      if(oprev(b,i-1,a[i],revans))continue;      int w = -1; // 找既不等于 b[i] 也不等于a[i]的 x相邻的, 至少存在一个      rep(j,i+1,n){        if(a[j] == x){          if(a[j-1] != a[i] &amp;&amp; a[j-1] != b[i]){            w = a[j-1];          }else if(a[j+1] != a[i] &amp;&amp; a[j+1] != b[i]){            w = a[j+1];          }          assert(w!=-1);          break;        }      }      assert(w!=-1);      if(!op(a,i-1,w,ans)){        assert(oprev(a,i-1,w,ans));      }      if(!op(b,i-1,w,revans)){        assert(oprev(b,i-1,w,revans));      }    }  }  per(i,0,revans.size()) ans.push_back(revans[i]);  printf(&quot;%d\n&quot;,(int)ans.size());  for(auto [u,v]:ans){    printf(&quot;%d %d\n&quot;,u,v);  }}int main(){  int t = read();  while(t--) w();  return 0;}</code></pre><h1 id="G"><a href="#G" class="headerlink" title="G"></a>G</h1><p>S 是长度n的0/1串</p><p>让S与任意个S的任意正位移 做xor</p><p>求 结果中1的个数恰好2个,且字符串表示下字典序最大的串中, 这两个1的位置</p><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>n 35</p><p>2s</p><p>256MB</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h3><p>显然 第一次取S</p><p>然后把首个1以后的内容 的 首个1与S的首个1对齐 做xor, 直到后续剩余的只有1个1</p><p>这样的话,S的首个1和末个1各贡献一次, 位置就可以算了</p><p>为了简化运算,可以预处理掉S的前后缀0记录下来</p><hr><p>然而n有35, 虽然无法估计精确复杂度,但这样做上限是2的35次方会超时,写出来也果然tle 6 了</p><h3 id="官方"><a href="#官方" class="headerlink" title="官方"></a>官方</h3><p>多项式问题</p><p>首先 忽略S前后缀0, 这些零在最后的结果中会加回来</p><p>那么把S看作在GF(2)域中多项式P(x)</p><p>Galois Field, 只有0,1二元及+（异或运算）×（与运算）</p><p>那么要求的是$P(x)Q(x) = x^k+1$ 的最小k</p><p>P(x)的常数项是1, Q是任意的, 所以一定存在</p><p>证明, 显然 $x^k$ 随着k增大$x^k \mod P(x)$ 成周期,且始终不为0, 那么周期的就是一个$x^k \mod P(x) = 1$的解</p><p>所以$k \le 2^{35}$ 依然很大</p><p>要用的方法是meet in middle?</p><hr><p>emmmmm 就是直接除 然后meet in middle?</p><p>我没懂 这个prod 为何一定是 mod 为1, 以及GF(2)域上的相关性质</p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_back#define all(x) (x).begin(), (x).end()int n;char s0[100];ll mod;// (i*j)%mod in GF(2)ll mul(ll i, ll j) {  ll res = 0;  rep(x, 0, n-1) {    if (i &amp; (1LL &lt;&lt; x)) res ^= j;    j &lt;&lt;= 1;    if (j &amp; (1LL &lt;&lt; (n - 1))) j ^= mod; // 取mod in GF(2)  }  return res;}// (2**i)%mod in GF(2)ll pow2(ll pwr) {  ll res = 1; // result  ll b = 2; // base  while (pwr) { // pwr    if (pwr &amp; 1) res = mul(res, b);    b = mul(b, b);    pwr &gt;&gt;= 1;  }  return res;}// v的二进制最高位1在2的多少幂次, high1(3) = 1int high1(ll v){  int leadz = __builtin_clzll(v); // x 前缀0个数  return 63 - leadz;}int main() {  char *s = s0;  scanf(&quot;%s&quot;,s);  n = strlen(s);  vector&lt;int&gt; pos; // 只用来判断 &lt;= 2的1  rep(i,0,n){    if (s[i] == &#39;1&#39;) pos.push_back(i+1);  }  per(i,0,n) { // remove trailing zero    if(s[i] != &#39;0&#39;) break;    s[i] = 0;  }  rep(i,0,n) { // remove prefix zero    if(s[0] != &#39;0&#39;) break;    s++;  }  int offset = s - s0; // 前导0  n = strlen(s);  if (pos.size() == 0) { // all zero    printf(&quot;-1\n&quot;);    return 0;  }  if (pos.size() == 1) { // only 1 of 1    printf(&quot;%d %d\n&quot;,pos[0],pos[0]+1);    return 0;  }  if (pos.size() == 2) { // 恰好2个    printf(&quot;%d %d\n&quot;,pos[0],pos[1]);    return 0;  }  rep(i, 0, n) { // 正向和逆向结果一样的    if (s[i] == &#39;1&#39;) mod |= (1LL &lt;&lt; i); // s.trim().tobinary()  }  printf(&quot;s: %lld\n&quot;,mod);  int h = (n + 1) / 2; // 半长  ll val = mod;  ll prod = 1; // (2**h(x)-1)(2**h(x))**(pwr-1)  rep(x, 3LL, 1 &lt;&lt; h) { // GF(2)乘法还满足结合率    if (!(x &amp; 1)) continue; // x 末位是1    int pwr = 0; // val = x^pwr * ... 相当于 计算GF(2) 中 val的因子和幂次    while (true) {      ll curr = val;      ll other = 0;      rep(bit, 0, n) {        if (!(curr &amp; (1LL &lt;&lt; bit))) continue;        curr ^= x &lt;&lt; bit;        other ^= 1LL &lt;&lt; bit;      }      if (curr)  break;      // val = x * other in GF(2)      printf(&quot;%lld = %lld * %lld\n&quot;, val, x, other);      val = other;      pwr++;    }    if (pwr) { // x的pwr次方      printf(&quot;=&gt; %lld ** %d\n&quot;,x,pwr);      printf(&quot;high1[%lld] =  %d\n&quot;,x,high1(x));      // prod *= (10-1) * 10 * 10 ,        3**3      prod *= (1LL &lt;&lt; high1(x)) - 1;      rep(y, 1, pwr) prod *= 1LL &lt;&lt; high1(x);    }  }  // val 的 一次方  if (val &gt; 1) prod *= (1LL &lt;&lt; high1(val)) - 1;  // mod =&gt; GF(2) =&gt; 基的幂次 乘积 =&gt; (2的幂次)的幂次和2的(幂次-1) 的 积  ll ans = 1LL &lt;&lt; 60;  // printf(&quot;prod:%lld\n&quot;,prod);  assert(pow2(prod) == 1); // 2**prod ???????????????????????????????????????????  for (ll x = 1; x * x &lt;= prod; x++) { // 长度一定是prod的因子 ????????????????????????????????    if (prod % x ) continue;    if (pow2(x) == 1) ans = min(ans, x);    if (pow2(prod / x) == 1) ans = min(ans, prod / x);  }  printf(&quot;%d %lld\n&quot;,offset+1,offset+ans+1);}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>F</p><p>这个交换性质 厉害了,之前并不了解,也没有自己推出</p><p>相等的位置的交换,必定让相邻无序对是不变的,而且是充要条件</p><p>还是不变量的思考</p><p>G</p><p>GF(2) 真的没有系统学过</p><p>通过这个题看起来 乘法还 满足 结合率</p><p>加减也是对称的 A+B= C, A-B=C</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://codeforces.com/blog/entry/104310" target="_blank" rel="noopener">官方</a></p><p><a href="https://www.luogu.com.cn/paste/1z5pai9x" target="_blank" rel="noopener">洛谷 GF(2)</a></p>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 相邻无序对 </tag>
            
            <tag> GF(2) </tag>
            
            <tag> meet in middle </tag>
            
            <tag> 不懂证明 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atcoder arc143</title>
      <link href="/Blog/2022-06-27-ac_arc143/"/>
      <url>/Blog/2022-06-27-ac_arc143/</url>
      
        <content type="html"><![CDATA[<p>D(dfs,无向图无桥联通块,强连通分量)</p><p>哎 超时8min过了E,但这个D我还是不会</p><h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><p>评分2229</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://atcoder.jp/contests/arc143/tasks/arc143_d" target="_blank" rel="noopener">https://atcoder.jp/contests/arc143/tasks/arc143_d</a></p><p>左边1-n的点</p><p>右边1-n的点</p><p>左i-右i有边</p><p>给你m对数 (ai,bi), 你需要输出长度为m的0/1字符串</p><p>如果你要(左ai-右bi) 则第i个字符为0, 如果你要(左bi-右ai)则第i个字符是1</p><p>最终让图里的桥最少, 求一个字符串方案</p><h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h3><p>n 2e5</p><p>m 2e5</p><p>2s</p><p>1024mb</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h3><p>只想着贪心</p><p>首先如果一个边在任意环里那它就不是桥, 所以希望能贪心尽量让边进入环</p><p>统计给的m对数中, 每个值出现的次数</p><p>对于只出现一次的无药可救,先不管它</p><p>对于出现2次的,那就安排让它左右各连出一个</p><p>如果运算过程中某个点一侧被连了,另一侧没有连,还有关于这个点的数对,那么就去连另一测</p><p>已经两侧都连了的就不管</p><hr><p>但就写的来看似乎有问题, 还蛮多人过了这个题</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><blockquote><p>一句话 把它当成一个未定向的有向图， 然后在图上找环， 并定向即可</p></blockquote><p>首先考虑一个n个点, m边的无向图, 按照ai-bi的连接</p><p>如果有边在无向图中也是桥, 那么在题目问题中它只能是桥</p><p>对于无向图来说,移除了所有桥以后, 每个连通块可以单独独立处理</p><p>所以假设 拿到一个无向连通 无桥图</p><p>总有办法给所有边一个方向,让连通图变成强联通图</p><p>一个办法就是 直接做dfs树</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/arc143/submissions/32806181" target="_blank" rel="noopener">https://atcoder.jp/contests/arc143/submissions/32806181</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define pb push_backint read(){int r;scanf(&quot;%intd&quot;,&amp;r);return r;} // readint n;int m;char s[200010]; // answerpair&lt;int,int&gt; ab[200010];vector&lt;array&lt;int,3&gt;&gt; u2[200010]; // {v, ab idx, &#39;0&#39;,&#39;1&#39;}bool vis[200010];void dfs(int u){  vis[u] = true;  for(auto [v,i,o]:u2[u]){    if(s[i]) continue; // 边处理过    s[i] = (char)o;    if(!vis[v]) dfs(v);  }}int main(){  n = read();  m = read();  rep(i,0,m) ab[i].first = read();  rep(i,0,m){    int a = ab[i].first;    int b = ab[i].second = read();    u2[a].pb({b,i,(int)&#39;0&#39;});    u2[b].pb({a,i,(int)&#39;1&#39;});  }  rep(i,1,n+1){    if(vis[i])continue;    dfs(i);  }  rep(i,0,m){    if(!s[i]) s[i] = &#39;0&#39;;  }  printf(&quot;%s\n&quot;,s);  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>D</p><p>知道逻辑以后 10min 随便写了QAQ</p><p>我不知道应该怎么归类,信息提取,还是有向图无向图连通性质</p><p>我觉得有一点 算是 无向图的无桥联通块 能通过指定所有边 变成有向图的强连通分量这一点吧,但好像又是一个提炼性质</p><p>哎</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://atcoder.jp/contests/arc143/editorial/4210" target="_blank" rel="noopener">官方题解</a></p>]]></content>
      
      
      <categories>
          
          <category> Atcoder </category>
          
          <category> ARC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dfs </tag>
            
            <tag> 无向图无桥联通块 </tag>
            
            <tag> 强连通分量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces 1696</title>
      <link href="/Blog/2022-06-26-CF1696/"/>
      <url>/Blog/2022-06-26-CF1696/</url>
      
        <content type="html"><![CDATA[<p>G(线性规划,对偶,dp,矩阵乘法,segtree)H(TODO)</p><h1 id="G"><a href="#G" class="headerlink" title="G"></a>G</h1><p><a href="https://codeforces.com/contest/1696/problem/G" target="_blank" rel="noopener">https://codeforces.com/contest/1696/problem/G</a></p><p>给一个长n数列</p><p>q个操作或询问</p><ol><li>操作修改 a[i] = v</li><li>询问[l,r] 区间上, 最小处理代价(不真实的修改区间)</li></ol><p>f(l,r) = 每次可以对 相邻元素,分别 (-xt,-yt) 或(-yt,-xt) 代价为t</p><p>问最小代价和让 a[l..r] 全部小于等于0</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>n 2e5</p><p>q 2e5</p><p>x,y [1,1e6]</p><p>ai, v [1,1e6]</p><p>6s</p><p>1024MB</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>因为对称,不妨设 ( x &lt; y)</p><p>开始没看到相邻以为任意,那么不就是维护区间和与区间最大值 = max(和/(x+y),最大值/y)</p><p>但是要相邻这样肯定不对了, 比如样例1, 不相邻可以3,相邻最少要3.5</p><hr><p>单次询问怎么做?</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><h3 id="线性规划对偶"><a href="#线性规划对偶" class="headerlink" title="线性规划对偶"></a>线性规划对偶</h3><p><a href="https://pic1.zhimg.com/80/v2-b780de4a3bd814944026ad22f51518f8_720w.jpg" target="_blank" rel="noopener">https://pic1.zhimg.com/80/v2-b780de4a3bd814944026ad22f51518f8_720w.jpg</a></p><p>$max \sum c_j x_j$</p><p>限制</p><p>$a_{ij} x_{j} \le b_i$</p><p>$x_j \ge 0$</p><p>$i=1\cdots m,j=1\cdots n$</p><p>它的对偶问题</p><p>$min \sum b_i y_i$</p><p>限制</p><p>$a_{ij} y_{i} \ge c_i$</p><p>$y_i \ge 0$</p><p>$i=1\cdots m,j=1\cdots n$</p><hr><p>我看了很多直觉的举例,反而没有理解,通过公式倒是理解了大流程, 下面youtube链接 感觉很清晰</p><p>小写字母表示列向量,大写字母表示矩阵</p><p>$max (c^Tx)$</p><p>$Ax \le b$</p><p>$x \ge 0$</p><p>对于任意$y \ge 0$满足</p><p>$c^Tx \le y^TAx$</p><p>有 $c^Tx \le y^TAx \le y^Tb$, 所以所有都满足,那么它的最大 = 右边的最小</p><p>所以对于所有$c^T \le y^TA$, $max(c^Tx) = min(y^Tb)$</p><p>$c^T \le y^TA$ 即是$Ay \ge c$</p><hr><p>更一般的转化</p><ol><li><p>min max 对换</p></li><li><p>列个数x 变成行个数y</p></li><li><p>右侧约束 和 表达式系数 兑换</p></li><li><p>偏序关系</p></li></ol><p>同偏序: max 变量(xi) 与 0关系 和 min 约束(不等式组xi) 左与右 关系</p><p>反偏序: min 变量(xi) 与 0关系 和 max 约束(不等式组xi) 左与右 关系</p><p>约束等于 对应 变量无约束</p><h2 id="回到题目"><a href="#回到题目" class="headerlink" title="回到题目"></a>回到题目</h2><p>线性规划 问题</p><p>原数组A</p><p>最小化  $\sum_{1\le i &lt; n} a_i+b_i $</p><p>限制</p><p>$Xa_1+Yb_1\ge A_1$</p><p>$Xa_i+Yb_i+Ya_{i-1}+Xb_{i-1}\ge A_i (2\le i &lt; n) $</p><p>$Ya_{n-1}+Xb_{n-1}\ge A_n $</p><p>$a_i,b_i\ge 0$</p><hr><p>那么对偶</p><p>最大化 $\sum_{1\le i \le n} A_iz_i $</p><p>限制</p><p>$xz_i + yz_{i+1} \le 1 (1 \le z &lt; n)$</p><p>$yz_i + xz_{i+1} \le 1 (1 \le z &lt; n)$</p><p>$z_i \ge 0$</p><p>很好的把上面要求的所有系数1变成了右侧的限制</p><hr><p>所以$z_i$ 可能取值$0,\frac{1}{y},\frac{1}{x+y}$</p><p>如果只有两个, 线性规划很明显 <a href="https://www.wolframalpha.com/input?i=2x%2B3y+%3C%3D+1%2C+2y%2B3x+%3C%3D+1" target="_blank" rel="noopener">https://www.wolframalpha.com/input?i=2x%2B3y+%3C%3D+1%2C+2y%2B3x+%3C%3D+1</a></p><p>去画3个的3d情况,你会发现,和2d一样虽然有些棱,但如果这个棱上最优,那么棱上的顶点也最优,但这些凸点的坐标都是这三个可能值中</p><hr><p>然后就可以dp了</p><p><code>dp[i][0/1/2]</code>, 即是算 $max \sum_{j \le i} A_jz_j$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>jiangly 的, 他整个G只花了15min??????</p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_back#define SEG_ROOT 1,0,n#define mid (l+r)/2#define SEG_L 2*p#define SEG_R 2*p+1#define SEG_L_CHILD SEG_L,l,mid#define SEG_R_CHILD SEG_R,mid,rll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readint n;int a[200010];template&lt;class Info,  class Merge = plus&lt;Info&gt; // 合并方法  &gt;  struct SegmentTree {    const int n;    const Merge merge;    vector&lt;Info&gt; info;    SegmentTree(int n) : n(n), merge(Merge()), info(4*n) {}    SegmentTree(vector&lt;Info&gt; init) : SegmentTree(init.size()) {      function&lt;void(int, int, int)&gt; build = [&amp;](int p, int l, int r) { // [l,r) 左闭右开        if (r - l == 1) { // 线段树叶子节点          info[p] = init[l];          return;        }        build(SEG_L_CHILD);        build(SEG_R_CHILD);        pull(p);      };      build(SEG_ROOT);    }    void pull(int p) {      info[p] = merge(info[SEG_L], info[SEG_R]);    }    void modify(int p, int l, int r, int x, const Info &amp;v) {      if (r - l == 1) {        info[p] = v;        return;      }      if (x &lt; mid) {        modify(SEG_L_CHILD, x, v);      } else {        modify(SEG_R_CHILD, x, v);      }      pull(p);    }    void modify(int p, const Info &amp;v) {      modify(SEG_ROOT, p, v);    }    Info rangeQuery(int p, int l, int r, int x, int y) {      if (l &gt;= y || r &lt;= x) return Info(); // 直接省去范围判断, 超过范围提前 返回可参与计算的空状态      if (l &gt;= x &amp;&amp; r &lt;= y) return info[p];      return merge(rangeQuery(SEG_L_CHILD, x, y), rangeQuery(SEG_R_CHILD, x, y));    }    Info rangeQuery(int l, int r) {      return rangeQuery(SEG_ROOT, l, r);    }  };int x, y;// 0: 0// 1: 1/(x+y)// 2: 1/y// 线段树每个节点struct Info {  double f[3][3];  Info(ll v = 0) {    rep(i,0,3){      rep(j,0,3){        if (i + j &gt; 2) {          f[i][j] = -1E18; // 不合法        } else { // 这里直接 值 * z_i(0,1/(x+y),1/y), 因为转移方程里始终要乘 值          f[i][j] = (j == 0 ? 0.0 : 1.0 * v / (j == 1 ? x + y : y));        }      }    }  }};// 实现合并方法Info operator+(const Info &amp;a, const Info &amp;b) {  Info c;  rep(i,0,3){    rep(j,0,3){      c.f[i][j] = -1E18; // 不合法      rep(k,0,3){        // max 矩阵乘法        c.f[i][j] = max(c.f[i][j], a.f[i][k] + b.f[k][j]);      }    }  }  return c;}int main() {  int n = read();  int q = read();  x = read();  y = read();  if (x &gt; y) swap(x, y); // 保证 x&lt;=y  vector&lt;int&gt; b(n);  rep(i,0,n) b[i] = read();  SegmentTree seg(vector&lt;Info&gt;(b.begin(), b.end())); // v =&gt; Info(v) =&gt; segtree(vector&lt;info()&gt;)  while(q--) {    int t = read();    if (t == 1) {      int k = read() - 1;      int v = read();      seg.modify(k, v);    } else {      int l = read() - 1;      int r = read();      auto info = seg.rangeQuery(l, r) + Info(); // + Info() 整合最大值,否则需要手动for 去取max      printf(&quot;%.15lf\n&quot;,info.f[0][0]);    }  }  return 0;}</code></pre><h1 id="H"><a href="#H" class="headerlink" title="H"></a>H</h1><p><a href="https://codeforces.com/contest/1696/problem/H" target="_blank" rel="noopener">https://codeforces.com/contest/1696/problem/H</a></p><p>给一个正整数k</p><p>大小为n,元素可重复的集合A</p><p>f(集合S) = S中恰好选出k个元素能得到的最大乘积</p><p>求 A所有元素个数不小于k的子集B,的f(B)的和</p><p>mod 1e9+7</p><h2 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h2><p>n 600</p><p>ai [-1e9,1e9</p><p>1.5s</p><p>512 MB</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h3><p>如果全非负, 则最大k个的乘积</p><p>如果全负</p><p>k为偶数, 则最小k个的乘积</p><p>k为奇数, 则最大k个的乘积</p><p>如果有负有非负</p><p>k为偶数, 则负 和 非负 分两组, 每组按照绝对值 从大到小,两两成对 构成新的乘积, 一对一对选</p><p>如果k 为奇数, 取一个最大非负, 剩下的 和偶数方案一样处理</p><p>所以肯定要对原来的集合拍个序</p><p>但贡献怎么统计没有思路</p><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>选k个指定它们最大? 计算会出现在多少个集合中??</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>G</p><p>低分题做多了, 太久没遇到线性规划了,很久以前学过, 但好像也是系数多限制多变量少的,</p><p>然后这个对偶学了一下, 希望下次能有用到的地方???</p><p>最后转化可以描述为矩阵max乘法,可以用segtree维护</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://codeforces.com/blog/entry/103479" target="_blank" rel="noopener">官方</a></p><p><a href="https://sites.math.washington.edu/~burke/crs/407/notes/section3.pdf" target="_blank" rel="noopener">https://sites.math.washington.edu/~burke/crs/407/notes/section3.pdf</a></p><p><a href="https://www.youtube.com/watch?v=yU8updOR87c" target="_blank" rel="noopener">https://www.youtube.com/watch?v=yU8updOR87c</a></p><p><a href="https://blog.csdn.net/qq_43539633/article/details/109150749" target="_blank" rel="noopener">https://blog.csdn.net/qq_43539633/article/details/109150749</a></p>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> 线性规划 </tag>
            
            <tag> 对偶 </tag>
            
            <tag> 矩阵乘法 </tag>
            
            <tag> segtree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atcoder abc257</title>
      <link href="/Blog/2022-06-25-ac_abc257/"/>
      <url>/Blog/2022-06-25-ac_abc257/</url>
      
        <content type="html"><![CDATA[<p>D(正确读题就能做)G(kmp+DP)Ex(TODO)</p><h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><p>天天卡D我服了,EF都过了就是卡D</p><p>题解这次出得好慢</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://atcoder.jp/contests/abc257/tasks/abc257_d" target="_blank" rel="noopener">https://atcoder.jp/contests/abc257/tasks/abc257_d</a></p><p>平面n个点</p><p>每个点一个倍率Pi</p><p>每个点可到达 PiS 曼哈顿距离以内的点</p><p>问最小的整数S让 可以选择某一点, 让其它点都可从此点跳跃到达,(不需要一次路径)</p><h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h3><p>n 200</p><p>坐标 x,y [-1e9,1e9]</p><p>p [1..1e9]</p><p>3s</p><p>1024mb</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h3><p>一眼 二分答案+tarjan+拓扑排序</p><p>关键这是abc的D题不应该,而且N也就200</p><p>不会这么难, 想不出啊,接近2k人比赛里过了,心态有点炸,还好跳了去做了EF,而且本来abc我也不算分了</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>不要读错题,</p><p>我读成选点 跳跃经过所有点</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>无</p><h1 id="G"><a href="#G" class="headerlink" title="G"></a>G</h1><p><a href="https://atcoder.jp/contests/abc257/tasks/abc257_g" target="_blank" rel="noopener">https://atcoder.jp/contests/abc257/tasks/abc257_g</a></p><p>两个只有小写字母的字符串S,T</p><p>让T 为 S的k个前缀的拼接</p><p>求最小的k 或报不可能</p><h2 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h2><p>|S| 5e5</p><p>|T| 5e5</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><h3 id="我的想法"><a href="#我的想法" class="headerlink" title="我的想法"></a>我的想法</h3><p>一眼像是kmp,但kmp写得真的少,</p><p>而且不确定kmp 怎么具体做,去计算t每个位置作为起始的最大长度</p><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>dp[i] = T[0..i] 和S匹配的答案</p><p>如果 T[i-p…i] == S[1..p], 那么有 dp[i] = min(dp[i-p]+1), p 可能有多种, 没有答案就INF</p><p>单调性</p><p>dp[i] &lt;= dp[i+1]</p><p>否则你把 dp[i+1]的方案中最后一个字符去掉,dp[i] 就能变小</p><p>因此你只需要关心最长的前缀匹配</p><hr><p>终究还是来到了kmp</p><p>经典的# 拼接</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p><a href="https://atcoder.jp/contests/abc257/submissions/32786655" target="_blank" rel="noopener">https://atcoder.jp/contests/abc257/submissions/32786655</a></p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 1000000007#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readclass KMP {  private :    vector&lt;int&gt; f; // 比它小的最长前缀的长度    char *s;    int sz;  public:    KMP(char *s,int sz):s(s),sz(sz){      f = vector&lt;int&gt;(sz,0);      int fa = 0;      rep(i,1,sz){        while (fa &amp;&amp; s[i] != s[fa]) fa = f[fa-1];        if (s[i] == s[fa]) fa++;        f[i] = fa;      }    }    vector&lt;int&gt; getPrefixLen(){      return f;    }    int posIn(char *t,int szt) {      int fa = 0;      rep(i,0,szt) {        while (fa &amp;&amp; t[i] != s[fa]) fa = f[fa-1];        if (t[i] == s[fa]) fa++;        if (fa == sz) return i-fa+1;      }      return -1;    }};char s[1000010];int ns;int nt;const int INF = 0x3f3f3f3f;int main(){  scanf(&quot;%s&quot;,s);  int ns = strlen(s);  s[ns] = &#39;#&#39;;  scanf(&quot;%s&quot;,s+ns+1);  int nt = strlen(s+ns+1);  int n = ns+1+nt;  vector&lt;int&gt; dp(nt+1,INF);  dp[0] = 0;  KMP kmp(s, n);  auto pl = kmp.getPrefixLen();  // rep(i,0,nt){  //   printf(&quot;%lld: %d\n&quot;,i,pl[i+ns+1]);  // }  rep(i,1,nt+1){    dp[i] = dp[i-pl[i+ns]]+1;    // printf(&quot;dp[%lld] = %d\n&quot;,i,dp[i]);  }  printf(&quot;%d\n&quot;, dp[nt] &gt;= INF?-1:dp[nt]);  return 0;}// k 个S前缀拼成 T// KMP?</code></pre><h1 id="Ex"><a href="#Ex" class="headerlink" title="Ex"></a>Ex</h1><p><a href="https://atcoder.jp/contests/abc257/tasks/abc257_h" target="_blank" rel="noopener">https://atcoder.jp/contests/abc257/tasks/abc257_h</a></p><p>n个6面dice,每个上面6个给定数字, 每个价格Ci</p><p>恰好买k个,</p><p>求期望sum(扔的数字)^2 - sum(价格) 最大</p><p>输出 mod 998244353</p><h2 id="范围-2"><a href="#范围-2" class="headerlink" title="范围"></a>范围</h2><p>n 1e3</p><p>k [1..N]</p><p>ci [1,1e5]</p><p>aij [1,1e5]</p><h2 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h3><p>先期望转化</p><p>E((?+xi)^2 - Ci) - E(?^2)</p><p>= E(?^2+2?xi+xi^2) - Ci - E(?^2)</p><p>= E(xi^2) - Ci + 2?E(xi)</p><p>看起来是?的线性函数, 不知道这个是否有局部性可以贪心, 或者<code>dp[前i][用了k] = {E(ans),E?}</code></p><h3 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h3><p>只有一个日文的 <a href="https://atcoder.jp/contests/abc257/editorial/4168" target="_blank" rel="noopener">https://atcoder.jp/contests/abc257/editorial/4168</a></p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>D</p><p>读错题好难受啊</p><p>G</p><p>然后我也更新了一下我的kmp板子多加了个外置函数</p><p>Ex</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://cp-algorithms.com/string/prefix-function.html" target="_blank" rel="noopener">KMP</a></p>]]></content>
      
      
      <categories>
          
          <category> Atcoder </category>
          
          <category> ABC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> kmp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atcoder arc142</title>
      <link href="/Blog/2022-06-24-ac_arc142/"/>
      <url>/Blog/2022-06-24-ac_arc142/</url>
      
        <content type="html"><![CDATA[<p>D(树,dp)</p><h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><p>评分2900,远高于C的难度</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://atcoder.jp/contests/arc142/tasks/arc142_d" target="_blank" rel="noopener">https://atcoder.jp/contests/arc142/tasks/arc142_d</a></p><p>给你一个树,要上面放一些棋子</p><p>每个时间周期,所有棋子要向它相邻的任意一个点移动,确保移动时每条边最大负债1,移动后每个点最多棋子1个</p><p>且保证任意个时间周期的结果唯一</p><p>问所有合法放置方案数</p><h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h3><p>n 2e5</p><p>2s</p><p>1024mb</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h3><p>要唯一,考虑做树上dp</p><p><code>dp[from][to][tofa]</code> 每个点2x2x2=8 最多8个状态</p><p>from表示根原来有或没, to表示移动一次后有或没, tofa表示移动一次以后对父节点是否有贡献</p><p>但转移感觉只有手动推一推, 不知道自动怎么算</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>注意到是唯一的反复跳 <code>u-&gt;v-&gt;u-&gt;v</code></p><p>那么实际上树是由多个不相交的链组成的</p><p>如果分叉角度说</p><p>a-b a-c a-d</p><p>a总有一轮是1, 两轮都是0是不可能的(这样有多个摆放方案</p><p>那么移动一次后一是到b,c,d中的一个</p><p>而下一次会移动回来</p><p>说明a至多和两个位置跳来跳去剩下的就是和a不相关的链了</p><hr><p>那么<code>1110110</code>, 这样的看作两条链</p><p>问题就是如何划分链</p><p>potato167 的blog上画了很多方便理解的图</p><p>注意到每个独立的链都是 <code>111110</code> 的形式, 而不相交的相邻链是 1和0 相临的, 且独立的链最小长度为2</p><p>然后一条链的端点也不能和另一条链的中间点相邻, 但两条链的中点可以相邻</p><p>所以对于一个点来讲,它可以是头0,头1或者中间的1,</p><p>dp上 就考虑根的状态了</p><hr><p>0 端点 ( 另一个端点是这个端点的后代</p><p>1 端点 ( 另一个端点不是这个端点的后代</p><p>2 非端点, 且连接父节点</p><p>3 非端点, 且连接两个子节点</p><p>这里的状态划分也不再关心是端点是0还是1,因为你只需要保证端点之和端点相邻(相邻的端点相互决定),这样只用关心有多少自由端点的个数n即可, $2^n$</p><hr><p>手推4种状态</p><p>0: 1个子节点1/2, 剩余都是0</p><p>1: 所有子节点都是0</p><p>2: 1个子节点1/2, 剩余都是3</p><p>3: 2个子节点1/2, 剩余都是3</p><p>除了状态转移, 还需要统计自由度</p><p>中间的3 和 根的0 会让自由度+1</p><p>自由度+1, 相当于答案乘2, 所以直接统计答案比记录自由度更方便</p><hr><p>计算</p><p>0: </p><p>一种方案是</p><p><code>sum (dp[v][1]+dp[v][2]) * ((sum dp[..][0]) - dp[v][0])</code></p><p><code>sum (dp[v][1]+dp[v][2]) * (sum dp[..][0]) - sum (dp[v][1]+dp[v][2]) *  dp[v][0])</code></p><p><code>(sum1+sum2)*sum0 - sum( (v1+v2)(v0))</code></p><p>另一种按照循环增加的算法是</p><p><code>res = (res * dp[v][0]) + (dp[v][1] + dp[v][2])*(before all 0)</code></p><p>1: all0</p><p>2: 类似0的计算方法 采取循环子节点 的方法</p><p><code>res = (res * dp[v][3]) + (dp[v][1] + dp[v][2])*(before all 3)</code></p><p>3: 相当于双状态转移</p><p><code>res[2个满足子节点] = res[2] * dp3 + (dp1+dp2)*(before res[1])</code></p><p><code>res[1个满足子节点] = res[1] * dp3 + (dp1+dp2)*(before res[0] = before all 3)</code></p><p>最后记得3还要再乘2</p><p>当然注意到 1和2只有过程中的计算才是分开的, 父子之间处理是一起使用的, 还可以降低一个状态,虽然意义不大</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/arc142/submissions/32681890" target="_blank" rel="noopener">https://atcoder.jp/contests/arc142/submissions/32681890</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 998244353#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readvector&lt;int&gt; G[200010];int main() {  int n = read();  rep(i,1,n){    int u = read() - 1;    int v = read() - 1;    G[u].push_back(v);    G[v].push_back(u);  }  vector&lt;int&gt; fa(n,-1); // 父节点?  vector&lt;int&gt; order={0}; // 树上bfs 顺序, 反序就是树上dp  rep(i,0,n) {    int u = order[i];    for(auto v:G[u]){      if(v == fa[u]) continue;      fa[v] = u;      order.push_back(v);    }  }  vector&lt;vector&lt;ll&gt;&gt; dp(n,vector&lt;ll&gt;(4));  per(i,0,n){    int u = order[i];    ll all0 = 1;    ll all3 = 1;    ll pre1 = 0;    for(auto v:G[u]){      if(fa[v]!=u) continue;      ll s12 = (dp[v][1]+dp[v][2])%MOD;      // 0      dp[u][0] = (dp[u][0] * dp[v][0] % MOD + all0 * s12 % MOD)%MOD;      // 2      dp[u][2] = (dp[u][2] * dp[v][3] % MOD + all3 * s12 % MOD)%MOD;      // 3      dp[u][3] = (dp[u][3] * dp[v][3] % MOD + pre1 * s12 % MOD)%MOD;      pre1     = (pre1     * dp[v][3] % MOD + all3 * s12 % MOD)%MOD;      (all0 *= dp[v][0]) %= MOD;      (all3 *= dp[v][3]) %= MOD;    }    // 1    dp[u][1] = all0;    (dp[u][3] *= 2) %= MOD;  }  printf(&quot;%lld\n&quot;,(dp[0][0] * 2 % MOD + dp[0][3])%MOD);}</code></pre><p>如果再压缩1和2的状态</p><pre><code class="cpp">vector&lt;vector&lt;ll&gt;&gt; dp(n,vector&lt;ll&gt;(3)); // 0:0, 1:1&amp;2, 2:3per(i,0,n){  int u = order[i];  ll all0 = 1;  ll all3 = 1;  ll pre1 = 0;  for(auto v:G[u]){    if(fa[v]!=u) continue;    dp[u][0] = (dp[u][0] * dp[v][0] % MOD + all0 * dp[v][1] % MOD)%MOD; // 0    dp[u][1] = (dp[u][1] * dp[v][2] % MOD + all3 * dp[v][1] % MOD)%MOD; // 2    dp[u][2] = (dp[u][2] * dp[v][2] % MOD + pre1 * dp[v][1] % MOD)%MOD; // 3    pre1     = (pre1     * dp[v][2] % MOD + all3 * dp[v][1] % MOD)%MOD;    (all0 *= dp[v][0]) %= MOD;    (all3 *= dp[v][2]) %= MOD;  }  (dp[u][1] += all0) %= MOD; // 1 &amp; 2  (dp[u][2] *= 2) %= MOD;}printf(&quot;%lld\n&quot;,(dp[0][0] * 2 % MOD + dp[0][2])%MOD);</code></pre><h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><p>n 个巫师,</p><p>ai 能力</p><p>打败 bi 怪物</p><p>对任意巫师增加任意次1能力</p><p>(i,j) is good when (a[i] &gt;= bi and a[j] &gt;= bj) or (a[i] &gt;= b[j] and a[j] &gt;= b[i])</p><p>相当于直接打败或交叉打败</p><p>给你m 个 (x,y)</p><p>要最小增加能力, 让所有(x,y) 是good</p><h2 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h2><p>n 100</p><p>ai bi [1,100]</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>如果自己打败自己,那很好算,但是不一定是答案,但是答案上界至少是</p><p>考虑结果总有个每个巫师的大小顺序</p><p>如果<code>(a[i] - a[j])*(b[i]-b[j]) &gt;= 0</code> , 且存在限制 (x,y) = (i,j)</p><p>那么 必然<code>a[i] &gt;= b[i]</code> <code>a[j] &gt;= b[j]</code> , 如果</p><p>因为如果(i,j) good ,也就是 min(a[i],a[j]) &gt;= min(b[i],b[j]) , max(a[i],a[j]) &gt;= max(b[i],b[j]) </p><p>但是n是100 不可能去枚举顺序</p><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>首先, a[x],a[y] &gt;= min(a[x],a[y]) 这是必要的, 所以可以预处理掉这个</p><p>X 为 能力 小于 monter的 集合, 且在(x,y)中出现了的巫师</p><p>Y 是 其它的巫师</p><p>对于(x,y) 且 x属于X, y属于Y, 结果上期望 a[y] &gt;= b[x] 或 a[x] &gt;= b[x]</p><p>因为有预处理, 所以b[x] &gt; b[y], 因为如果 b[x] &lt;= b[y] 那么必然有 a[x] &gt;= min(b[x],b[y]) = b[x],  x不会属于X,</p><p>也就是X-Y的连接, 一定y中的b更小</p><p><code>b[x] &gt; a[x] &gt;= b[y]</code> 的顺序, <code>a[y] &gt;= b[y]</code></p><p>对于Y-Y的连接,不需要考虑,因为a只会增大,原来满足增加后还是满足</p><p>对于X-X的链接,不会存在,因为有了预处理, 这两个a大于min(b), 所以一定有一个属于Y</p><hr><p>回到X-Y</p><p><code>a[y] &gt;= b[x] &gt; a[x] &gt;= b[y]</code> 直接合法</p><p><code>b[x] &gt; (a[x],a[y]) &gt;= b[y]</code> 考虑上面是让<code>a[y] &gt;= b[x]</code> 还是 <code>a[x] &gt;= b[x]</code></p><hr><p>建图</p><p>点:</p><p>S源,T汇</p><p>X每个x一个点</p><p>Y每个y,100个点(y,i = 1..100)</p><p>边</p><p><code>S -&gt; x</code> 权重<code>b[x] - a[x]</code></p><p><code>(y,i) -&gt; T</code> 权重1</p><p><code>(y,i) -&gt; (y,i-1)</code> 权重无限大</p><p><code>x -&gt; (y,b[x] - a[y])</code> 权重无限大</p><hr><p>意义</p><p>先看假设只有一对</p><p><code>S-(bx-ax)-&gt;x-(无限)-&gt; (y, b[x]-a[y])-(1)-&gt; T</code>, 然后还有些<code>(y,i)-&gt;(y,i-1)</code>的边</p><p><code>S-&gt;X</code>这边限制了不会大于<code>bx-ax</code>, 右边限制了不会大于<code>bx-ay</code></p><p>最小割一定是 <code>S-&gt;x</code>和<code>(y,i)-&gt;T</code> 中的边,不会是那些无限的边</p><p>而如果<code>S-&gt;x</code> 不在最小割里,说明右侧对应的<code>(y,b[x]-a[y]) -&gt; T</code>, 以及更小的i的<code>(y,i)</code> 全部填满, 否则可至少可以再+1, 填满也就说明选择满足</p><hr><p>这个最小割的建图,我也是真不会啊(最大流,最小割还是会写)</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p><a href="https://atcoder.jp/contests/arc142/submissions/32759166" target="_blank" rel="noopener">https://atcoder.jp/contests/arc142/submissions/32759166</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // read#define N 100#define INF 0x3f3f3f3fint n,m;int a[N+10];int b[N+10];vector&lt;int&gt; p2[110]; // 双向关系int S = 0;int T = 1;// S,T,[2..101],[102...201][202..301][302..401]//int nodex(int x) {  assert(x &gt;=0 &amp;&amp; x&lt; 100);  return 2+x;}int nodey(int y,int value) {  assert(y &gt;=0 &amp;&amp; y&lt; 100);  assert(value &gt;=1 &amp;&amp; value &lt;= 100);  return 101 + y*100 + value;}class MinCut{  int sz ;  // TODO 优化成正反边下标  vector&lt;unordered_map&lt;int,ll&gt; &gt; G; // {idx,weight}  vector&lt;int&gt; d; // bfs 距离public:  MinCut(int n):sz(n){    G = vector&lt;unordered_map&lt;int,ll&gt; &gt;(sz);  }  void path(int u,int v,ll w){    assert(u != v);    G[u][v] += w;  }  int dfs(int u,int en, ll s){    if (u == en)return s;    for(auto [v,w]:G[u]){      if(w == 0) continue;      if(d[v] != d[u]+1) continue;      int r = dfs(v,en,min(s,w));      if(r){        G[u][v] -= r;        G[v][u] += r;        return r;      }    }    d[u] = 0; // 标记无效 替代vis    return 0;  }  bool bfs(int st,int en){    d = vector&lt;int&gt;(sz+10,-1);    vector&lt;int&gt; q = {st};    d[st] = 0;    rep(i,0,q.size()){      int u = q[i];      for(auto [v,w]: G[u]){ // u -&gt; v, weight =w        if(d[v] != -1) continue;        if(w == 0) continue;        d[v] = d[u] +1;        q.pb(v);      }    }    return d[en] &gt;= 0;  }  // 一次性计算  ll calc(int st,int en){    int ans = 0;    while (bfs(st, en)) ans += dfs(st, en, INF);    return ans;  }};int main(){  n = read();  S = 0;  T = 1;  rep(i,0,n){    a[i] = read();    b[i] = read();  }  m = read();  int ans = 0;  // 预处理 和 建边  rep(i,0,m){    int x = read() - 1;    int y = read() - 1;    int minv = min(b[x],b[y]);    ans += max(0,minv - a[x]);    a[x] = max(a[x],minv);    ans += max(0,minv - a[y]);    a[y] = max(a[y],minv);    p2[x].pb(y);    p2[y].pb(x);  }  MinCut mc(20000);  rep(i,0,n) {    if(a[i] &lt; b[i]){ // i in X      mc.path(S,nodex(i),b[i] - a[i]);      for(auto u:p2[i]){ // u in Y        if(a[u] &gt;= b[i]) continue;        mc.path(nodex(i),nodey(u,b[i]-a[u]),INF);      }    }else{ // i in Y      rep(j,1,101){        mc.path(nodey(i,j),T,1);        if(j &gt; 1){          mc.path(nodey(i,j),nodey(i,j-1),INF);        }      }    }  }  printf(&quot;%lld\n&quot;,ans + mc.calc(S,T) );  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>D</p><p>我突然觉得我的<code>dp[from][to][tofa]</code> 是不是也可能可以做?? 看起来是完全不同的思路</p><p>虽然想到反复横跳,但拆成链以及链的链接合法方式完全没想过</p><p>而且即使是拆成链,看了积分代码, 所做的树上dp也不相同, 能拆成这样四个也是很需要功力的</p><p>看potato167的代码学了一手非递归的树上dp, 通过先建立order,再逆序做</p><p>E</p><p>光是这个预处理就很厉害,解决了分类的问题, 能证明但完全没能自己挖掘出这个性质</p><p>然后这个建图我也是不会, 虽然学过最大流最小割,但是为啥这样想,没做过这种, 顺便整两个mincut板子</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://atcoder.jp/contests/arc142/editorial" target="_blank" rel="noopener">官方题解</a></p><p><a href="https://potato167.hatenablog.com/entry/2022/06/21/005732" target="_blank" rel="noopener">potato167 D</a></p>]]></content>
      
      
      <categories>
          
          <category> Atcoder </category>
          
          <category> ARC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>June Lunchtime 2022 Division 1</title>
      <link href="/Blog/2022-06-22-LTIME109A/"/>
      <url>/Blog/2022-06-22-LTIME109A/</url>
      
        <content type="html"><![CDATA[<p>P5.MINXORSEG(XOR,fenwick)</p><h1 id="MINXORSEG"><a href="#MINXORSEG" class="headerlink" title="MINXORSEG"></a>MINXORSEG</h1><p>评分 3087, tourist 也没做出</p><p>给你长度n数组, q个询问,每次问区间[l,r]中任意两个数的异或的最小值</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>n 2e5</p><p>q 2e5</p><p>ai 2^30</p><p>3s</p><p>400MB</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>离线, 按查询的右端点排序</p><p>简单的扫描加入 是n方?</p><p>x=a[l]^a[r]</p><p>假设x最高位1在p位,那么高于p的bit,a[l]和a[r]一样</p><p>如果[l..r] 之间有同样的高于p的bit和它们一样的t,那么(l,r)这一对一定不是最小值,因为 (l,t) 或 (t,r) 比它小</p><p>如果区间有3个高w位一样,那么答案至少是高w位为0, 所以答案最小的只存两个高w一样,或者存在两个相等的数</p><p>这个观察很神奇,也就是说如果ai和aj高w位相同,那么要让它们可能是答案的必要条件是,它们中间没有高w位和它们相同的</p><p>换句话说, a[i]如果和它前面某个a[j]高w相同,贡献了最小xor,那么a[i]的w相同的前面最近的就是a[j]</p><p>所以直接记录每个数前面和它高0,1,2,3..位相同的最近的下标即可, 这可以简单的排序记录</p><hr><p>最后扫描+fenwick一下</p><p>其中把每对的左点为index,异或和为值,做后缀min fenwick 就可以了, 这样每次询问就是[l…  中的最小值</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://www.codechef.com/viewsolution/67421139" target="_blank" rel="noopener">https://www.codechef.com/viewsolution/67421139</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backconst ll INF = 0x3f3f3f3f3f3f;ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readll a[200010];int idxs[200010];struct fenwick_tree {  vector&lt;ll&gt; bit;  int n;  fenwick_tree(int n) : n(n) {    bit = vector&lt;ll&gt; (n + 1, INF); // 后缀min fenwick  }  void update(int u, ll v) {    for (u++; u &gt; 0; u -= u &amp; -u) bit[u] = min(bit[u], v);  }  int query(int u) {    ll r = INF;    for (u++; u &lt;= n; u += u &amp; -u) r = min(r, bit[u]);    return r;  }};int main() {  int n = read();  int q = read();  vector&lt;vector&lt;int&gt;&gt; lst(n);  vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; que(n);  rep(i,0,n) a[i] = read();  rep(b,0,30+1) { // 低位到高位    // 按高 30-p 位排序    iota(idxs,idxs+n,0);    sort(idxs,idxs+n,[=](int i,int j){return make_pair((a[i] &gt;&gt; b),i) &lt; make_pair((a[j] &gt;&gt; b),j); });    rep(i,1,n) {      if ((a[idxs[i]] &gt;&gt; b) == (a[idxs[i-1]] &gt;&gt; b)) { // 高位相同,建立可能对最小值贡献的关系        lst[idxs[i]].push_back(idxs[i-1]);      }    }  }  vector&lt;int&gt; ans(q);  rep(i,0,q) {    int l = read() - 1;    int r = read() - 1;    que[r].push_back({l, i});  }  fenwick_tree fen(n);  rep(i, 0, n) {    for (int v : lst[i]) fen.update(v, a[v] ^ a[i]);    for (auto [l, ind] : que[i]) ans[ind] = fen.query(l);  }  for(auto v:ans) printf(&quot;%d\n&quot;, v);}// n 2e5 个数// q询问,2e5// 查区间内 最小的两个值的 xor</code></pre><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote><p>MINXORSEG</p></blockquote><p>这个观察最小的可能贡献很厉害啊, 应该属于xor的一个神奇的知识点了?</p><p>另一个就是, 这种非统计的, 最大最小也是可以从”可能贡献”的角度去思考,这个我没有思路过,学到了</p><p>fenwick这个还有后缀写法,不需要做颠倒原数组的动作</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://discuss.codechef.com/search?q=tags%3Aeditorial%2BLTIME109" target="_blank" rel="noopener">官方</a></p>]]></content>
      
      
      <categories>
          
          <category> CodeChef </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 异或 </tag>
            
            <tag> fenwick </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces 1700</title>
      <link href="/Blog/2022-06-21-CF1700/"/>
      <url>/Blog/2022-06-21-CF1700/</url>
      
        <content type="html"><![CDATA[<p>E(总体观察,数学),F(贪心)</p><h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><p><a href="https://codeforces.com/contest/1700/problem/E" target="_blank" rel="noopener">https://codeforces.com/contest/1700/problem/E</a></p><p>给你一个矩阵,每个数字都不相同</p><p>然后让你依次取1,2,3,4,… 取完所有</p><p>取的块需要和之前取过的至少一个4临</p><p>直接可取输出0</p><p>需要还是交换两个位置(可以不相邻)后可取,输出<code>1 方案数</code></p><p>还是都不行输出2</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>矩阵大小4e5</p><p>2s</p><p>256MB</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>0很好判断,vis染色+bfs</p><p>其实就是1的时候怎么算个数</p><p>不妨设按找上述方法最开始失败的是x</p><p>意味着, 小于x的连在一起了,</p><p>那么有两种方案</p><ol><li>交换x和小于x的外边界,这样小于等于x就连在一起了,</li><li>交换小于x的某一个和x的四临</li></ol><p>但是这两种如果一个一个检验是时间复杂度会炸掉的</p><hr><p>考虑可交换的,对于第一种没有什么思路</p><p>对于第二种,你可以考察每个依赖于它的是否仅依赖于它, 但也不一定</p><pre><code>1452.63?7.8.</code></pre><p>比如上面这样,7仅依赖于6,而6也可以移动</p><p>不知道怎么搞了</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>不要看一步一步,看总览性质</p><p>如果一个位置，它的四个邻居有比他小的，那么它就能连到小于它的数。矩阵为可遍历当且仅当所有点（除了1）的四个邻居都有比他小的。</p><p>这归纳法可证明</p><hr><p>所以判断可行,也不再需要vis+bfs, 而直接判断count(badpos)== 0</p><p>所以badpos 需要交换它或者它的邻居</p><p>两两不相同,显然badpos不相邻, 因为badpos需要小于4临, 说明4临都不是badpos</p><p>两两不同,说明交换以后的两个位置,一个比原来大,一个比原来小,</p><p>比原来大的位置4邻之前一定不是badpos, </p><p>比原来小的本身一定不是badpos</p><p>综上, badpos最多5个, 一个中心一个4临</p><p>5x5x4, 种</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>无</p><h1 id="F"><a href="#F" class="headerlink" title="F"></a>F</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://codeforces.com/contest/1700/problem/F" target="_blank" rel="noopener">https://codeforces.com/contest/1700/problem/F</a></p><p>2 * n 的01矩阵,两个</p><p>每次交换第一个中相邻位置的01,求最小次数得到第二个矩阵</p><h3 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h3><p>n 2e5</p><p>1s</p><p>256mb</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h3><p>写了个假的</p><p>两个变量记录未匹配的,然后进入则+,退出则-</p><p>发生 一正一负则消耗1抵消</p><p>竟然官方数据弱还过了system test</p><p>然后有错误样例</p><pre><code>0 1 01 0 00 1 00 0 1</code></pre><p>我的匹配会</p><pre><code>0 b 0a 0 00 a 00 0 b</code></pre><p>代价为4, 最小的是2</p><h3 id="官方"><a href="#官方" class="headerlink" title="官方"></a>官方</h3><p>直接可配消耗掉即可…….</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>无</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>E</p><p>这个总体观察没想到, 一直在想细节的步, 总体只想到vis+bfs 而不是这个充分性质</p><p>jiangly 也TLE了好像</p><p>F</p><p>贪心细节还是没想到啊</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://codeforces.com/blog/entry/103978" target="_blank" rel="noopener">官方</a></p>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 总体观察 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nowcoder 牛客挑战赛61 D</title>
      <link href="/Blog/2022-06-18-nowcoder-11201/"/>
      <url>/Blog/2022-06-18-nowcoder-11201/</url>
      
        <content type="html"><![CDATA[<p>D <a href="https://ac.nowcoder.com/acm/contest/11201/D" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/contest/11201/D</a></p><p>总思路没问题, dijkstra不能带log, 2s时间卡时限了</p><p>没有log的也800ms, 稍微一个3倍都过不了</p><p>所以需要的是点的值要么是初始的要么是推导(当前最大值-定值k)生成的, 双队列+指针实现</p><p>没过这题也能+3</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (int i=a;i&lt;(int)n;i++)#define per(i,a,n) for (int i=n;i--&gt;(int)a;)#define pb push_back#define c(a,b) ((a)*(m)+(b))int read(){int r; scanf(&quot;%d&quot;, &amp;r);return r;} // readint a[500010];int n,m,k;bool vis[500010];const int di[] = {-1,1,0,0,-1,1};const int dj[] = {0,0,-1,1,1,-1};vector&lt; array&lt;int,3&gt; &gt; startvij;ll cost(int diff){  fill(vis,vis + n*m,false);  vector&lt; array&lt;int,3&gt; &gt; vp = {}; // 优先队列等含有log的会TLE  ll sk = 0 ;  vp = {};  int i0 = 0;  int i1 = 0;  while(i0 &lt; startvij.size() || i1 &lt; vp.size()){    int v = 0;    int i = -1;    int j = -1;    if(i0 &lt; startvij.size() &amp;&amp; i1 &lt; vp.size()){      if(startvij[i0][0] &gt;= vp[i1][0]){        v = startvij[i0][0];        i = startvij[i0][1];        j = startvij[i0][2];        i0++;      }else{        v = vp[i1][0];        i = vp[i1][1];        j = vp[i1][2];        i1++;      }    }else if(i0 &lt; startvij.size()){      v = startvij[i0][0];      i = startvij[i0][1];      j = startvij[i0][2];      i0++;    }else {      v = vp[i1][0];      i = vp[i1][1];      j = vp[i1][2];      i1++;    }    if(vis[c(i,j)])continue;    vis[c(i,j)] = true;    sk += v - a[c(i,j)];    rep(w,0,6){      int ni = i + di[w];      int nj = j + dj[w];      if(ni &lt; 0 || ni &gt;= n || nj &lt; 0 || nj &gt;= m) continue;      if(a[c(ni,nj)] == -1) continue;      if(vis[c(ni,nj)]) continue;      if(v - diff &gt; a[c(ni,nj)]){        vp.pb({v - diff,ni,nj});      }    }  }  return sk;}int main(){  n = read();  m = read();  k = read();  rep(i,0,n){    rep(j,0,m){      a[c(i,j)] = read();      if(a[c(i,j)] != -1) startvij.pb({a[c(i,j)],i,j});    }  }  sort(startvij.begin(), startvij.end(), greater&lt;array&lt;int,3&gt;&gt;());  int l = 0;  int r = 1000;  int ans = 1000;  while(l &lt;= r){    int mid = (l+r)/2;    if(cost(mid) &lt;= k){      ans = mid;      r = mid - 1;    }else{      l = mid + 1;    }  }  cout&lt;&lt;ans&lt;&lt;endl;  return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> NowCoder </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dijkstra </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces 1693 C D E F</title>
      <link href="/Blog/2022-06-17-CF1693/"/>
      <url>/Blog/2022-06-17-CF1693/</url>
      
        <content type="html"><![CDATA[<p>C(反向dijkstra)D(DP,数学,贡献)E(标记,延后,贪心,树状数组)F(0/1串,数学)</p><h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><p><a href="https://codeforces.com/contest/1693/problem/D" target="_blank" rel="noopener">https://codeforces.com/contest/1693/problem/D</a></p><p>给你一个排列</p><p>问多少个子区间 可以表示成 增序列和减序列合成的, 称作Decinc</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>n 2e5</p><p>2s</p><p>512MB</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>如果是判断一个是否合法</p><p>考虑</p><p>inc[i] 表示i在增序列, 减序列的最大值</p><p>dec[i] 表示i在减序列, 增序列的最小值</p><p>然后dp一下O(n) 就做了</p><p>然后这里考虑有没有办法转移</p><p>因为如果[i..j] 是decinc的,那么它的所有子区间也是</p><p>考虑有没有办法dp然后做转移, 发现并没有办法转移</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><h3 id="AmShZ"><a href="#AmShZ" class="headerlink" title="AmShZ"></a>AmShZ</h3><p>一样的, 但是说是可以证明均摊更新是常数倍?</p><p>对于给定i, 找最大的j, 使得 j &lt; i, a[j] &gt; a[j+1]</p><p>注意到<code>a[j],a[j+1]</code> 不会都在增序列里,必定一个在减序列里</p><p>情况1 <code>a[j+1]</code> 在增序列的话 =&gt; <code>a[j]</code> 在减序列</p><p>情况2 <code>a[j+1]</code> 在减序列</p><p>且因为它是最大的j, 所以<code>a[j] &gt; a[j+1]</code>, 且<code>a[j+1] &lt; a[j+2] &lt; a[j+3] &lt; ... &lt; a[i]</code></p><p><code>inc[i] = a[j](情况1) or a[j+1](情况2) or 0</code></p><p>而对于<code>inc[i]</code>初始化是是<code>inf</code>, 而对于<code>a[j+1]..a[i]</code>这一段都是<code>inf</code></p><p>所以每个位置的值只会有4种情况</p><p>dec对称关系同理</p><hr><p>换句话说</p><p>l从大到小,</p><p>每轮从小到大, 如果更新才会去算下一个位置, 否则提前退出</p><p>这里还有一点是就是 运算时,当给定l的时候, dp[i]仅依赖于dp[i-1]和a[i], 所以说如果dp[i]没有更新,则i以后的也不会更新, 所以更新的一定是连续的区间</p><p>所以sum 遍历 = sum 更新次数 = sum变化次数 = O(n)</p><h3 id="Koosha-Mv"><a href="#Koosha-Mv" class="headerlink" title="Koosha_Mv"></a>Koosha_Mv</h3><p>一个由升序和降序列合成的序列,当且仅当它不含 3412 也不含 2143</p><p>显然包含则不满足</p><p>怎么证明不满足一定包含这样的呢</p><p>回到dp的过程, 如果刚好在i不满足, </p><p>那么, 如果 a[i-1] &lt; a[i], (a[i-1] &gt; a[i] 对称同理</p><p>显然a[i-1] 在增序列不合法, (如果a[i-1] 在增序列有合法方案,那么把a[i]放到增序列即可</p><p>a[i-1]在减序列, 且 增序列最小值 &gt; a[i]</p><p>所以 存在a[j] &gt; a[i] &gt; a[i-1], j &lt; i-1</p><p>所以原序列是由</p><p>增序列 <code>..... a[j]</code> 和 减序列<code>.... a[i-1]</code>合成的</p><p>因为a[j] 是满足的最小的a[j]</p><p>也就是, a[j] 不能放进减序列里(如果可以则能得到更小的增序列值</p><p>那么 不妨设下标 w(可能不存在) &lt; j &lt; k ,且 a[k] 在减序列中, a[w] 在减数列中</p><p>那么<code>a[j] &lt; a[k] (j k i-1 i =&gt; 3 4 1 2)</code> 或 <code>a[j] &gt; a[w]</code>(a[j] 左侧至少一个</p><p>考虑把a[j]左侧分成三部分讨论, 大于a[j]的, a[i]到a[j]之间的, 小于a[i]的</p><p>如果a[i]到a[j]之间存在(3 4 1 2)`, 否则完全不存在, 且 小于a[i] 至少一个</p><p>如果大于a[j]的存在,则一定全属于减序列</p><p>如果小于a[i]的有不只1个, 那么一旦有其中两个递减 <code>=&gt; (? ? j i) =&gt; (2 1 4 3)</code> 即它的对称状态</p><p>小于a[i]的一定是升序列</p><p>总上可以重组 升序列<code>a[j] 左侧,小于a[i], 包含a[w] .... a[j]</code>, 降序列<code>a[j]左侧大于a[j]...a[j]右侧原减序列</code></p><p>注意到这样重组以后, <code>a[j]</code> 可以被放入减序列, 而增序列最小值将不再是a[j]</p><p>性质充要得证</p><hr><p>如何实现</p><p>注意到3412和2143是对称的,所以a[i] = n+1-a[i] ,再跑一次3412就行</p><p>那么如何计算3412</p><p>考虑计算的结果是对于当前位置i作为3,<code>min_r[i]</code>表示最近的<code>2</code>让<code>3412</code>出现</p><p>给定3以后,4要是最近的,如果有2,那么1是离2最近的</p><p>所以先预处理每个位置后面和它最近的比它大的,以及每个位置前面最近的比它小的的位置</p><p>但是记录并不是<code>[3]-&gt;4</code>, <code>[2] -&gt; 1</code></p><p>考虑反着来<code>4-&gt; array{3}</code>, <code>1-&gt;array{2}</code></p><p>为什么要这么样做呢,因为除了大小关系还有顺序,<code>1</code> 需要在<code>4</code>的右侧</p><p>那么我们倒着遍历4的位置</p><p>我们可以用fenwick记录i右侧, (1,2) 存在的<code>[值]-&gt;2的坐标</code></p><p>这样我们对于每个3, 去fenwick上查, 值 &lt; 3的值中存在的最大坐标, 就算出答案了</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><a href="https://codeforces.com/contest/1693/submission/160996027" target="_blank" rel="noopener">https://codeforces.com/contest/1693/submission/160996027</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readconst int N = 2e5 + 10;int n;int a[N]; // 数组int inc0[N]; // a[i] 在增数组时, 减数组的最大值int dec0[N]; // a[i] 在减数组时, 增数组的最小值int f[N]; // f[i] = 该轮次的计算中,当前点i到 以l为起点的终点 的距离ll ans;void udec0(int i){  if (n &gt;= i){    // 就硬算    int inc1 = max( (dec0[i - 1] &lt; a[i]?a[i - 1]:0), (a[i - 1] &lt; a[i] ? inc0[i - 1]: 0));    int dec1 = min( (a[i] &lt; inc0[i - 1]?a[i - 1]:n+1), (a[i] &lt; a[i - 1] ? dec0[i - 1]: n+1));    if (!(inc1 == inc0[i] &amp;&amp; dec1 == dec0[i])){ // 更新的一定是连续的区间, sum(遍历) = sum(更新) = sum(变化)      inc0[i] = inc1;      dec0[i] = dec1;      f[i] = 0; // 结束点 距离为0      if (dec1 &lt;= n || inc1) udec0(i+1);    }  }  f[i - 1] = f[i] + 1; // 到结束点距离+1}int main(){  n = read();  rep(i,1,n+1) a[i] = read();  per(i,1,n+1) { // 倒序l    inc0[i] = n + 1;    dec0[i] = 0;    udec0(i + 1);    ans += f[i];  }  printf(&quot;%lld\n&quot;, ans);  return 0;}</code></pre><p>3412,2143的</p><p><a href="https://codeforces.com/contest/1693/submission/161132167" target="_blank" rel="noopener">https://codeforces.com/contest/1693/submission/161132167</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readconst int N = 2e5 + 10;int INF = 0x3f3f3f3f;// 前缀最小值fenwickstruct Fenwick {  const int n;  vector&lt;int&gt; a;  Fenwick(int n) : n(n), a(n, INF) {}  // 支持 [0..n) 更新最大值  void setMin(int x, int v) {    for (int i = x + 1; i &lt;= n; i += i &amp; -i) a[i - 1] = min(a[i - 1], v);  }  // 获得 [0,x) 最大值  int get(int x) {    int ans = INF;    for (int i = x; i &gt; 0; i -= i &amp; -i) ans = min(ans, a[i - 1]);    return ans;  }};int n;int a[N]; // 数组int min_r[N];ll ans;stack &lt;int&gt; sk;vector &lt;int&gt; vec[2][N];// 如果指定3和2的位置,所以你需要的是3后面最近的4, 和2前面最近的1void find_3412(){  Fenwick f(n+10); // 下标是值, 前缀表示小于某个值的出现的最小坐标  rep(i,0,2) fill(vec[i]+1,vec[i]+n+1,vector&lt;int&gt;());  // vec[0][i] = vector&lt;int&gt; {j,...}, 表示 j 前面最近的比j小的是i, sk中保留单增的值对应的下标  sk = {};  rep(i,1,n+1) {    while (!sk.empty() &amp;&amp; a[i] &lt; a[sk.top()]) sk.pop();    if (!sk.empty()) vec[0][sk.top()].push_back(i);    sk.push(i);  }  // 倒着做一边, sk中保持值单调递减, vec[1][i] = {j...} , j后面最近的比a[j]大的是a[i]  sk = {};  per(i,1,n+1) {    while (!sk.empty() &amp;&amp; a[sk.top()] &lt; a[i]) sk.pop();    if (!sk.empty()) vec[1][sk.top()].push_back(i);    sk.push(i);  }  // 倒着做  per(i,1,n+1){    // f在遍历过程中,存的是(1,2) 的下标都&gt;=i, 然后[2的值] = 位置    // i=&gt;1, ind=&gt;2    for (auto ind : vec[0][i]) f.setMin(a[ind], ind); // (i,ind) 构成增序列    // 这次就是 i=&gt;4, ind =&gt; 3, 因为如果确定了3,那么4就最近最好, 所以查询的是(1,2)位置在(以后,且值小于3的,结束位置的最小值),    // 这里遍历过程之所以i=&gt;4 而不是3,主要因为 保证(1,2)在当前位置右侧    for (auto ind : vec[1][i]) min_r[ind] = min(min_r[ind], f.get(a[ind]));    // 得到的是min_r[3的位置] = 最近的2的位置能构成3 4 1 2    // 在反转过程中 min_r 直接取min,而f是清空  }}int main(){  n = read();  INF = n+1;  rep(i,1,n+1) a[i] = read();  fill(min_r, min_r + n + 2, INF);  find_3412();  rep(i,1,n+1) a[i] = n + 1 - a[i]; // 做对称, 因为对称不影响答案, 而3412和2143是对称的  find_3412();  per(i,1,n+1) {    min_r[i] = min(min_r[i], min_r[i + 1]);    ans += min_r[i] - i;  }  printf(&quot;%lld\n&quot;, ans);  return 0;}</code></pre><h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://codeforces.com/contest/1693/problem/E" target="_blank" rel="noopener">https://codeforces.com/contest/1693/problem/E</a></p><p>n+2 长度数组a</p><p>首尾元素值为0</p><p>最小操作次数让 所有值 = 0</p><p>每次操作可以任选以下一种</p><ol><li>最左的最大值=它的左侧的最大值</li><li>最右的最大值=它的右侧的最大值</li></ol><h3 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h3><p>n 2e5</p><p>2s</p><p>256mb</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h3><p>值挺友好,给你的是[0,n]的范围,(就算很大也可以手动离散</p><p>没思路了</p><h3 id="ecnerwala"><a href="#ecnerwala" class="headerlink" title="ecnerwala"></a>ecnerwala</h3><p>官方的代码实在太长了</p><p>ecnerwala 有个超短的代码</p><p><a href="https://codeforces.com/contest/1693/submission/160890042" target="_blank" rel="noopener">https://codeforces.com/contest/1693/submission/160890042</a></p><p>有点延后判断, 贪心选最小值的意味</p><pre><code>0 1 4 2 4 0 2 0. . . . . . . . // 初始. . ? . ? . . . // 最大的标记为?, 贡献 +2, 意义是第一轮处理2个. . . x x x x . // 准备处理2的也就是x覆盖区间的, 把区间左侧问号标成 &lt;(表示这个?位置的值比当前小,和左侧的最值相等, 右侧标成 &gt; (同理. . &lt; . ? . . . // 标记. . &lt; ? ? . ? . // 对2处理, 贡献 +3. . ? &gt; &gt; . &gt; . // 同理对于1, 但注意到 1右侧的 &lt; 会变成? 因为. ? ? &gt; &gt; . &gt; . // 贡献+2// 0 不需要处理</code></pre><p>总贡献是2+3+2 = 7</p><hr><p>样例2</p><pre><code>0 1 3 5 4 2 0. . . . . . .. . . ? . . . // +1. . . &lt; . . . // . . . &lt; ? . . // +1. . . ? &gt; . . //. . ? ? &gt; . . // +2. . &lt; &lt; ? . . //. . &lt; &lt; ? ? . // +2. . ? ? &gt; &gt; . //. ? ? ? . . . // +3</code></pre><p>1+1+2+2+3 = 9</p><p>再补充一个例子 <code>1 2 3</code></p><pre><code>0 1 2 3 0. . . . .. . . ? . // +1. . . &gt; . // . . ? &gt; . // +1. . &gt; &gt; . // . ? &gt; &gt; . // +1</code></pre><p>1+1+1 = 3</p><hr><p>总的来说, 每轮最大值,确定覆盖区间</p><p>区间左侧:</p><pre><code>? 变 &lt;&gt; 变?</code></pre><p>区间内部</p><pre><code>&lt; 变 ?&gt; 变 ?</code></pre><p>区间右侧</p><pre><code>? 变 &gt;&lt; 变 ?</code></pre><p>最后最大值的所有点都是? , 统计?个数即可</p><hr><p>实现</p><p>并不需要真的像上面思路那样维护4种 . , ? , &gt; , &lt;的状态</p><p>发现其实只需要统计?的个数</p><p>那么?个数有多少呢</p><p>区间内,所有大于它的都变成了问号, 所以区间内就是大于它的个数</p><p>区间左侧, 可能有 &gt;,?,&lt;</p><p>但 注意到一旦出现 &gt; ,说明上一轮 &gt; 的左侧有?, 如果出现 &lt; 说明上一轮右侧有 ?</p><p>引理, 每轮结束后 除开.的情况,剩下的一定是 &lt; ? &gt; 形状的</p><p>归纳法可证明</p><p>因此, 你需要统计的是</p><ol><li>相交关系</li></ol><pre><code>    ?   ?      // 上一轮结果&lt;  [l...r] &gt;   // 上一轮结果     [l...r]   // 本轮      ?   ?    // 本轮   &lt; [l...r]&gt;  // 结果</code></pre><ol start="2"><li>非相交关系</li></ol><pre><code>    ?   ?                 // 上一轮结果&lt;  [l...r] &gt;              // 上一轮结果                [l...r]   // 本轮                 ?   ?    // 本轮        &lt; [l      ...r]&gt;  // 结果</code></pre><p>有</p><pre><code>newl = min(l, lastr)newr = max(r, lastl)</code></pre><p>区间统计点 = 前缀差 = 树状数组维护</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>ecnerwaia <a href="https://codeforces.com/contest/1693/submission/160890042" target="_blank" rel="noopener">https://codeforces.com/contest/1693/submission/160890042</a></p><p>基于修改+注释+自己格式+bit改为fenwick: <a href="https://codeforces.com/contest/1693/submission/161139663" target="_blank" rel="noopener">https://codeforces.com/contest/1693/submission/161139663</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readint main() {  int n = read();  vector&lt;vector&lt;int&gt; &gt; idxs(n+1); // [值] = 下标数组  rep(i,1,n+1) idxs[read()].push_back(i);  vector&lt;int&gt; fenwick(n); // 树状数组, 大于等于当前的点记为1  ll ans = 0;  int lo = 1, hi = n + 1; // 左闭右开, [lo,hi)  per(v, 1, n+1) { // 从大到小    if (idxs[v].empty()) continue; // 忽略不存在的值    // 本轮全为问号的范围    std::tie(lo, hi) = make_pair(        min(idxs[v].front(), hi),        max(idxs[v].back()+1, lo)    );    // 本轮点 树状数组上标记为1,    for (int a : idxs[v]) {      for (; a &lt;= n; a += (a&amp;-a)) fenwick[a-1]++;    }    // 区间 [lo, hi) = pre[hi-1] - pre[lo-1]    for (int a = hi-1; a; a -= (a&amp;-a)) ans += fenwick[a-1];    for (int a = lo-1; a; a -= (a&amp;-a)) ans -= fenwick[a-1];  }  printf(&quot;%lld\n&quot;, ans);  return 0;}</code></pre><h1 id="F"><a href="#F" class="headerlink" title="F"></a>F</h1><p><a href="https://codeforces.com/contest/1693/problem/F" target="_blank" rel="noopener">https://codeforces.com/contest/1693/problem/F</a></p><p>0/1 字符串 S</p><p>每次选择一段 sort, 代价 |cnt(1) - cnt(0)| + 1</p><p>求最小总代价,让整个S有序</p><h2 id="范围-2"><a href="#范围-2" class="headerlink" title="范围"></a>范围</h2><p>n 2e5</p><h2 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h2><h3 id="我的想法"><a href="#我的想法" class="headerlink" title="我的想法"></a>我的想法</h3><p>假设最后一次操作了 [l..r]</p><p>那么说明 操作之前, [0..l-1] 和目标一样[r+1..n-1] 和目标一样</p><p>并且[l..r]中的1和0的个数尽可能的靠近</p><h3 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h3><p>结论: 只对0和1个数相等的进行排序</p><p>证明:</p><p>若最优方案中, 对[l,r]排序,且区间中,0比1多d个(d &gt; 0), 代价d+1</p><p>如果l上是0, 只需要对[l+1,r]排序,代价为d, 且效果相同, 所以l上一定是1</p><p>确定区间左端点,右端点增加时,0和1的差的变化为+1/-1</p><p>因此必然存在k &lt; r, 区间 [l,k] 的0和1的个数相等</p><p>排序[l,k],代价1, 再排序 [l+1,r] 代价 = d, 总代价 = d+1</p><p>所以任何一个0比1多排序, 可以拆成 (0和1相等的排序,代价1) + (0和1的差更小,更短,比原来代价更小的排序)</p><p>对于1比0多的情况, 对称关系同理可证</p><p>得证</p><p>问题变成如何选尽量少的0和1相等区间排序</p><hr><p>把0换为-1</p><p>又变成经典的,前缀和2维图形化了, 每次选择的是等高的点, 让等高点之间变成 V字形</p><p>假设1比-1多,那么也就是结束点比起点高, 如果最后一段是从一个和起点相等的值 一直+1达到 结束点的,那么 把起点和这个值的区间处理即可</p><p>所以就是让最后一个连续+1 到的结束点 的那一串尽量长</p><p>我们记录达到每个值的首先出现的点, 只考虑(&gt;=0的部分) 显然随着值越大,下标大,( 因为是从0涨过来的</p><p>而我们对末端的操作不会改变这个首次出现的位置</p><p>贪就完了</p><p>-1 比 1多 对称处理即可, 这里只要方案数不要操作细节,(所以还可以把 1变-1,0变1,并旋转字符串)</p><hr><p>样例输入1的最后一个数据</p><p><img src="/Blog/img/CF_1693F.jpeg" alt></p><p>这个和上面假设相反, 那就是 把头部可达的值的最小值的最后出现位置之间做区间处理</p><p>当然也可以双指针, (总代价移动是线性的</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><p><a href="https://codeforces.com/contest/1693/submission/162002156" target="_blank" rel="noopener">https://codeforces.com/contest/1693/submission/162002156</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;(int)n;i++)#define per(i,a,n) for (int i=n;i--&gt;(int)a;)int read(){int r;scanf(&quot;%d&quot;,&amp;r);return r;} // readchar s[200010];int pre[200010]; // 前缀和int pos[200010]; // 首次出现的位置int w(){  int n = read();  fill(pos,pos+n+1,-1);  scanf(&quot;%s&quot;,s);  int cnt[] = {0,0};  rep(i,0,n) cnt[s[i] == &#39;1&#39;] ++;  if(cnt[0] &gt; cnt[1]) { // 保证 个数1 &gt; 个数0    swap(cnt[0],cnt[1]);    rep(i,0,n) s[i] = (1 - (s[i] - &#39;0&#39;)) + &#39;0&#39;;    rep(i,0,n/2) swap(s[i],s[n-1-i]);  }  int d = cnt[1] - cnt[0];  rep(i,0,n) pre[i+1] = pre[i] + (s[i] == &#39;0&#39;? -1 : 1);  rep(i,0,n+1){    if(pre[i] &lt; 0) continue;    if(pos[pre[i]] != -1) continue;    pos[pre[i]] = i;  }  int minv = d; // 倒着最小能连续到达的值  per(i,-cnt[0],d+1){    if(pre[n - (d-i)] != i) break;    minv = i;  }  int ans = 0;  while(minv + cnt[0] &gt; 0){ // 已经完成排序    if(minv &lt; 0) return ans + 1; // 和l=0配    ans ++ ;    minv -= ((n-(d-minv))/*r*/-pos[minv]/*l*/)/2; // [l..r]  }  return ans;}int main(){  int t = read();  while(t--) printf(&quot;%d\n&quot;,w());  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>C</p><p>Dijkstra 性质还是不够熟啊</p><p>D</p><p>直接的dp能想到,也在想转移,倒是转移也可以倒着做, 而且需要推导这个变化的条件,从而得到必定是区间变化,有遍历次数=变化次数=可能次数</p><p>另一个方案, 我有大的方向, 说看能不能找不成立的,但是没有得到3412/2143, 一个是这个充要真不知道比赛能不能快速证明,</p><p>再就是3412, 就算我知道了, 也不知道怎么去算, 这个按中间位置做遍历, 预处理 两头算是又学了一手</p><p>E</p><p>总觉得好像见过类似的标记处理, 这里是标记+延后+贪心</p><p>哦 像python里的 a,b= b,a+b 可以写成 std::tie(a,b) = make_pair(b,a+b)</p><p>原来树状数组还有bit和fenwick写法区别</p><p>bit版本的是 a|=a+1</p><p>fenwick的是 a+=(a&amp;-a)</p><p>逻辑上 bit版本,统计的是末尾连续1的所有子集或上高位1的信息</p><p>而fenwick是当前结束向前(a&amp;-a)长度的信息</p><p>F</p><p>敢于去猜让解答变容易的特殊情况,并证明它</p><p>经典的0/1区间个数相等处理, 变成-1,1 和二维图</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://codeforces.com/blog/entry/103952" target="_blank" rel="noopener">官方</a></p><p><a href="https://codeforces.com/blog/entry/103952?#comment-923531" target="_blank" rel="noopener">ecnerwala E</a></p>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
            <tag> 贪心 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 树状数组 </tag>
            
            <tag> 贡献 </tag>
            
            <tag> 标记 </tag>
            
            <tag> 延后 </tag>
            
            <tag> 0/1串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces 1697F(2-sat)</title>
      <link href="/Blog/2022-06-14-CF1697F/"/>
      <url>/Blog/2022-06-14-CF1697F/</url>
      
        <content type="html"><![CDATA[<p>我的第二次 2-SAT 练习</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://codeforces.com/contest/1697/problem/F" target="_blank" rel="noopener">https://codeforces.com/contest/1697/problem/F</a></p><p>给你m个限制, 分别可能是</p><ol><li>$a_i \neq x$</li><li>$a_i+a_j \ge x$</li><li>$a_i+a_j \le x$</li></ol><p>请构造一个满足限制的长n的数组a, 且每个元素在$[1,k]$之间</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>n 2e4</p><p>m 2e4</p><p>k 10</p><p>2s</p><p>512MB</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>一眼2-sat,写过但不熟, 来看看题解如何建立图的</p><p>tourist ,jiangly也是拖的板子, XD, 看来我要好好准备板子了?</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>一个值拆成2k个点</p><p>分别是$\le 1,\le 2,\cdots,\le k,&gt;1,&gt;2,\cdots,&gt;k$</p><p>其中$\le i, &gt; i$ 是一个互补对</p><p>$(i,v,0) = a_i \le v$</p><p>$(i,v,1) = a_i &gt; v$</p><p>因为2-sat 就是每个点选或不选 0/1, 而上面的两个必定一个满足一个不满足</p><p>$(i,v,0) \to (i,v+1,0)$ 不等式关系</p><p>$(i,v,1) \to (i,v-1,1)$ 不等式关系 (可以由上面自动建立对称关系</p><p>$(i,v,1) \to (i+1,v,1)$ 非严格单增</p><p>$(i,x,0) \to (i,x-1,0)$, $a_i \ne x$</p><p>$(i,x-1,1) \to (i,x,1)$, $a_i \ne x$ (可以由上面自动建立对称关系</p><p>$(i,v,1) \to (j,x-a_i-1,0)$, $a_i + a_j \le x$, 轮换$i,j$</p><p>$(i,v,0) \to (j,x-a_i-1,1)$, $a_i + a_j \ge x$, 轮换$i,j$ </p><hr><p>对于限制必定不合法的$(i,v,x)$ , 建立 $(i,v,x) \to (i,v,x\oplus 1)$</p><h2 id="2-sat-的选择"><a href="#2-sat-的选择" class="headerlink" title="2-sat 的选择"></a>2-sat 的选择</h2><p>之前有个问题, 我一直没想太通, 现在有点思路了</p><p>假设我们完成建边和tarjan的部分</p><p>如下, 这样那怎么顺序选都没问题</p><pre><code>a0 &lt;-&gt; b0a1 &lt;-&gt; b1</code></pre><p>而对于这种, 你是不能去选b1/c1 的,而这也是Tarjan 不会处理的,因为tarjan只是合并联通块, 这种还算有答案</p><pre><code>a0 &lt;-&gt; b0b1 &lt;-&gt; c1c1 -&gt; a0</code></pre><p>这种是没有答案, 而且tarjan 的时候是判断不了的</p><pre><code>a0&lt;-&gt;b0b1&lt;-&gt;c1c0&lt;-&gt;a1</code></pre><hr><p>那么两个办法我想的</p><p><strong>方法一</strong></p><p>如果我们要加 $a[x] \to b[y]$</p><p>考虑 如果 $b[y\oplus 1]$ ,那么a不能选x, 所以同时会产生$b[y\oplus 1] \to a[x\oplus1]$</p><p>这个好处是,本身可以利用tarjan</p><p><strong>方法二</strong></p><p>在tarjan处理完scc后, 对scc的每个点的<code>反点</code>做并查集, 缺点是还要跑并查集</p><hr><p>等价性 一个奇怪的视角可以证明就是 这些操作是对称性的, 比如方法一里面每次都是对称加的边, 而方法二,不妨设scc 中的反点个数比它大,那么scc必定会合其它scc连接,最终所有并查集完成后, scc和scc反点的scc个数相等</p><hr><p>这两个任选一种以后, 最后对scc/并查集 做原图的反向边 做倒序拓扑选择,必定有解?</p><p>再看上面的 3个例子</p><p>第一个不变</p><pre><code>a0 &lt;-&gt; b0a1 &lt;-&gt; b1</code></pre><p>第二个变成如下,你需要反向拓扑选择</p><pre><code>a0 &lt;-&gt; b0 &lt;-&gt; c0a1 &lt;-&gt; b1 &lt;-&gt; c1c1 -&gt; a0</code></pre><p>第三个则全部连到一个并查集里了, 直接确定不合法了</p><hr><p>第三个是限制的不可选状态</p><p>比如 $(i,x)$ 不可选, 之前的办法是做一个 失败的节点,让它和这个节点双向连通</p><p>而现在发现其实$(i,x) \to (i,x\oplus 1)$, 因为这样如果选$(i,x)$自动造成矛盾</p><hr><p>注意区别是<code>不可选</code>还是<code>选了一定满足</code></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>我先自己写了个twosat的板子,下次也可以用</p><p><a href="https://codeforces.com/contest/1697/submission/160657743" target="_blank" rel="noopener">https://codeforces.com/contest/1697/submission/160657743</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readclass TwoSat{  vector&lt;int&gt; low; // 能达到的最小的点  vector&lt;int&gt; dfn; // tarjan 用的深搜访问次序标识  stack&lt;int&gt; stk; // tarjan 用的stk  vector&lt;int&gt; res; // tarjan 结果  vector&lt;vector&lt;int&gt; &gt; p; // 所有点  int n;  void scc(int v) {    static int id = 0;    low[v] = dfn[v] = id++;    stk.push(v);    for(auto w:p[v]){      if(dfn[w] == -1){ // 未访问过        scc(w);        low[v] = min(low[v],low[w]);      } else if(res[w] == -1){ // 访问过但没有结果(在栈中)        low[v] = min(low[v],dfn[w]);      }    }    int u;    if(low[v] == dfn[v])  {      do{        res[u = stk.top()] = v;        stk.pop();      }while(u != v);    }  }public:  TwoSat(int SZ):n(SZ){ // 点范围[0..SZ-1]    low = vector&lt;int&gt;(2*n,-1);    dfn = vector&lt;int&gt;(2*n,-1);    stk = {};    res = vector&lt;int&gt; (2*n,-1);    p = vector&lt;vector&lt;int&gt; &gt;(2*n);  }  bool calc(vector&lt;bool&gt; &amp; ans){    rep(i,0,2*n) if(res[i] == -1) scc(i);    // rep(i,0,2*n) printf(&quot;scc[%lld] = %d\n&quot;,i,res[i]);    rep(i,0,n) if(res[i*2] == res[i*2+1]) return false; // 同一个块的真假都在一个scc里    vector&lt;int&gt; revscc(2*n); // 互斥scc    rep(i,0,n) {      revscc[res[i*2]] = res[i*2+1];      revscc[res[i*2+1]] = res[i*2];    }    vector&lt;set&lt;int&gt; &gt; scc2scc(2*n);    unordered_map&lt;int,int&gt; degree; // scc入度    unordered_map&lt;int,bool&gt; scctf; // scc 真假    rep(i,0,2*n) { // 跨scc的反向边, 做拓扑选择      degree[res[i]] = 0;      for(auto j:p[i]){ // i -&gt; j        if(res[i] == res[j]) continue;        scc2scc[res[j]].insert(res[i]);      }    }    for(auto s:scc2scc){      for(auto t:s) degree[t]++;    }    vector&lt;int&gt; d0; // 入度为0    for(auto [v,d]: degree) if(!d) d0.pb(v);    rep(i,0,d0.size()) {      if(!scctf.count(d0[i])){ // 没有选择过        // printf(&quot;pick %d, unpick %d\n&quot;,d0[i],revscc[d0[i]]);        scctf[d0[i]] = true;        scctf[revscc[d0[i]]] = false;      }      for(auto item:scc2scc[d0[i]]) { // 更新入度排序        if(!(--degree[item])) d0.pb(item);      }    }    ans = vector&lt;bool&gt;(n);    rep(i,0,n) ans[i] = scctf[res[i*2+1]];    return true;  }  void p2(pair&lt;int,bool&gt; pi, pair&lt;int,bool&gt; pj){ // {i,true/false} -&gt; {j,true/false}    auto [i,bi] = pi;    auto [j,bj] = pj;    // printf(&quot;(%d,%d) -&gt; (%d,%d)\n&quot;,i,(int)bi,j,(int)bj);    // printf(&quot;(%d,%d) -&gt; (%d,%d) (auto\n&quot;,j,(int)bj^1,i,(int)bi^1);    assert(i &gt;= 0 &amp;&amp; i &lt; n);    assert(j &gt;= 0 &amp;&amp; j &lt; n);    p[2*i+bi].pb(2*j+bj);    p[2*j+(!bj)].pb(2*i+(!bi)); // 自动建立逻辑边  }};int n;int m;int k;int c(int i,int j){  return i*k+j;}void w(){  n = read();  m = read();  k = read();  TwoSat ts(n*k);  // a[i][j=0..k-1] =&gt; i*k+j  // false : &lt;= j+1  // true  : &gt;  j+1  // 不等式关系  rep(i,0,n){    rep(j,0,k-1){      ts.p2({c(i,j),0},{c(i,j+1),0}); // 自动建立反向边 ts.p2({c(i,j+1),1},{c(i,j),1});    }    ts.p2({c(i,k-1),1},{c(i,k-1),0}); // 不能选 &gt; k  }  // 非严格单增  rep(i,0,n-1){    rep(j,0,k){      ts.p2({c(i,j),1},{c(i+1,j),1});    }  }  while(m--){    int op = read();    int i = read()-1;    if(op == 1){      int x = read()-1;      if(x){        ts.p2({c(i,x),0},{c(i,x-1),0});        // ts.p2({c(i,x-1),1},{c(i,x),1}); // 对称自动      }else{        ts.p2({c(i,x),0},{c(i,x),1}); // 输入的原始 x = 1 的时候, 不能选 &lt;= 1      }    }else if(op == 2){      int j = read() - 1;      int x = read(); // a[i] + a[j] &lt;= x , a[i] &gt; v : a[j] &lt;= x-a[i] &lt; x-v, a[j] &lt; x-v-1      rep(v,1,k+1){        int v2 = x - v - 1;        if(v2 &gt;= 1 &amp;&amp; v2 &lt;= k){          ts.p2({c(i,v-1),1},{c(j,v2-1),0});          // ts.p2({c(j,v-1),1},{c(i,v2-1),0}); // 对称自动建立        }else if(v2&lt;1){ // 不可选的v , ( v2 &gt; k 说明一定满足          ts.p2({c(i,v-1),1},{c(i,v-1),0});          ts.p2({c(j,v-1),1},{c(j,v-1),0});        }      }    }else if(op == 3){      int j = read() - 1;      int x = read(); // a[i] + a[j] &gt;= x, a[i] &lt;= v : a[j] &gt;= x - a[i] &gt;= x - v &gt; x - v - 1      rep(v,1,k+1){        int v2 = x - v - 1;        if(v2 &gt;= 1 &amp;&amp; v2 &lt;= k){          ts.p2({c(i,v-1),0},{c(j,v2-1),1});          // ts.p2({c(j,v-1),0},{c(i,v2-1),1}); // 对称自动建立        }else if(v2 &gt; k){ // 不可选的v, (v2 &lt; 1 是一定满足          ts.p2({c(i,v-1),0},{c(i,v-1),1});          ts.p2({c(j,v-1),0},{c(j,v-1),1});        }      }    }  }  vector&lt;bool&gt; ans;  vector&lt;int&gt; a(n);  if(!ts.calc(ans)){    printf(&quot;-1\n&quot;);  }else{    rep(i,0,n){      rep(j,0,k){        if(!ans[i*k+j]){          a[i] = j+1;          break;        }      }    }    rep(i,0,n) printf(&quot;%d%c&quot;,a[i],&quot; \n&quot;[i==n-1]);  }}int main(){  int t = read();  while(t--) w();  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这里的问题就是说 选则一个范围的值,怎么变成2-sat需要的 真/假</p><p>这里的办法是拆成大于小于</p><p>当然从逻辑上 用 $= v$ 和$\ne v$ 也可以, 但是这样的问题是, 在做上面的和的不等式的关系时, 边的量就很大了, 不是k条边了</p><p>之前2-sat 还有点问题,缺少了一些反向的连接,和缩点后的反向拓扑序选择</p><p>准备准备2sat的板子了</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://codeforces.com/blog/entry/103835" target="_blank" rel="noopener">官方</a></p>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2-sat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atcoder abc254 G(倍增)</title>
      <link href="/Blog/2022-06-13-ac_abc254/"/>
      <url>/Blog/2022-06-13-ac_abc254/</url>
      
        <content type="html"><![CDATA[<p>G(倍增)</p><h1 id="G"><a href="#G" class="headerlink" title="G"></a>G</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://atcoder.jp/contests/abc254/tasks_print" target="_blank" rel="noopener">https://atcoder.jp/contests/abc254/tasks_print</a></p><p>n个楼, 每个楼高都是1..1e9</p><p>有m个电梯, 每个电梯在一个楼里,负责[li,ri] 之间</p><p>可以允许这个楼里, [li,ri] 范围中的移动</p><p>跨楼同楼层移动代价1</p><p>同楼电梯内移动,代价 高度差</p><p>q个询问, ai楼bi层 到 ci楼di层最小代价, 或它们不可达</p><h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h3><p>n 2e5</p><p>m 2e5</p><p>q 2e5</p><p>6s</p><p>1024mb</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h3><p>显然 同楼层答案是1或0</p><p>不同楼层,只会单调移动,不会先上再下这种, 答案 = 距离+跨楼数, 需要最小化跨楼数</p><p>而每次移动贪心距离, 这样模拟可做, 但是复杂度无法接受</p><p>显然同楼的重叠电梯可以合并</p><h3 id="官方"><a href="#官方" class="headerlink" title="官方"></a>官方</h3><p>显然上下还满足对称性, 那么只考虑从下向上</p><p>合并同楼重叠电梯(这样做了以后剩下的线段就不用考虑属于哪个楼了? 因为是一旦重叠肯定不重楼</p><p>如果 ai楼内bi移动到最高位置, ci 楼内 di 移动到最低位置, 合法提前输出</p><p><code>dp[i][j]</code> 当前建筑第i层,用j个电梯后最高能到达的楼层</p><p>考虑 离散+倍增</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>我写的按右断点跳右端点的map不知道为什么WA了除了测试点, 调了七八个小时,atcoder还没数据, 放弃了</p><p>下面是一个别人的代码,我改了部分格式,靠清理了一些线段,保持左右端点都严格单调递增, 然后用线段跳线段来做的, 我觉得完全一样啊, 吐了, 搞不动了,心态炸了</p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;(int)n;i++)#define per(i,a,n) for (int i=n;i--&gt;(int)a;)#define pb push_backint read(){int r;scanf(&quot;%d&quot;,&amp;r);return r;} // readvector&lt;array&lt;int,2&gt; &gt; ilr[200010];vector&lt;array&lt;int, 2&gt;&gt; segs;vector&lt;vector&lt;int&gt;&gt; jump;int N;int lg = 20;int n, m, q;int query(){  int i0, f0, i1, f1;  i0 = read() - 1;  f0 = read();  i1 = read() - 1;  f1 = read();  if(f0 == f1) return i0 != i1;  if (f0 &gt; f1) {    swap(i0, i1);    swap(f0, f1);  }  int ans = f1 - f0;  auto it =    lower_bound(ilr[i0].begin(), ilr[i0].end(), array&lt;int, 2&gt;{f0 + 1, -1});  if (it != ilr[i0].begin()) f0 = max(f0,(*--it)[1]);  it = lower_bound(ilr[i1].begin(), ilr[i1].end(), array&lt;int, 2&gt;{f1 + 1, -1});  if (it != ilr[i1].begin()) {    it--;    if (f1 &lt;= (*it)[1]) {      f1 = (*it)[0];    }  }  if (f0 &gt;= f1) return ans + (i0 != i1);  // 跳到一个右端点 保证f0 是右端点  ans++;  int idx = lower_bound(segs.begin(), segs.end(), array&lt;int, 2&gt;{f0 + 1, -1}) - segs.begin();  // 未被覆盖到  if (!idx) return -1;  idx--;  if (f0 &gt; segs[idx][1]) return -1;  if (segs[idx][1] &gt;= f1) return ans + 1;  if (segs[jump[idx][lg]][1] &lt; f1) return -1;  per(k,0,lg+1){    if (segs[jump[idx][k]][1] &gt;= f1) continue;    idx = jump[idx][k];    ans += 1 &lt;&lt; k;  }  idx = jump[idx][0];  return ans + 2;}int main() {  n = read();  m = read();  q = read();  rep(i,0,m){    int a, b, c;    a = read() - 1;    b = read();    c = read();    ilr[a].push_back({b, c});  }  // 每组内部 排序 与 合并  rep(i,0,n){    sort(ilr[i].begin(), ilr[i].end());    vector&lt;array&lt;int, 2&gt;&gt; temp;    for (auto [l, r] : ilr[i]) {      if (!temp.empty() &amp;&amp; l &lt;= temp.back()[1]) {        temp.back()[1] = max(temp.back()[1], r);      } else {        temp.push_back({l, r});      }    }    ilr[i] = temp;    for (auto s : temp) segs.push_back(s);  }  sort(segs.begin(), segs.end());  vector&lt;array&lt;int, 2&gt;&gt; temp;  for (auto [l, r] : segs) {    if (!temp.empty() &amp;&amp; r &lt;= temp.back()[1]) { //      continue;    }    if (!temp.empty() &amp;&amp; l == temp.back()[0]) {      temp.pop_back();    }    temp.push_back({l, r});  }  segs = temp;  N = segs.size();  jump = vector&lt;vector&lt;int&gt;&gt;(N, vector&lt;int&gt;(lg + 1));  // jump[段id][pwr] = 段id  for (int i = 0, j = 0; i &lt; N; i++) {    while (j + 1 &lt; N &amp;&amp; segs[j + 1][0] &lt;= segs[i][1]) {      j++;    }    jump[i][0] = j;  }  rep(j,0,lg){    rep(i,0,N){      jump[i][j + 1] = jump[jump[i][j]][j];    }  }  while(q--) printf(&quot;%d\n&quot;, query());  return 0;}</code></pre><p>我的代码 不知道WA在哪里了</p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readint n,m,q;vector&lt;pair&lt;int,int&gt; &gt; ilr[200010]; // 每个楼vector&lt;pair&lt;int,int&gt; &gt; segs; // 所有楼vector&lt;int&gt; maxr = {0}; // 前缀 最大rmap&lt;int,vector&lt;int&gt;&gt; jump = {}; // jump[结束位置][2**i次跳跃] = 最高位置const int lg = 20;int query(){  int i0 = read();  int f0 = read();  int i1 = read();  int f1 = read();  // 同楼层  if(f0 == f1) return i0 != i1;  // 从低到高 f0 &lt; f1  if(f0 &gt; f1){    swap(i0,i1);    swap(f0,f1);  }  int ans = f1-f0;  // 注意不在区间的情况不会跳  int itr0 = lower_bound(ilr[i0].begin(),ilr[i0].end(),make_pair(f0+1,-1)) - ilr[i0].begin();  if(itr0 &gt; 0) f0 = max(f0, ilr[i0][itr0-1].second);  int itr1 = lower_bound(ilr[i1].begin(),ilr[i1].end(),make_pair(f1+1,-1)) - ilr[i1].begin();  if(itr1 &gt; 0 &amp;&amp; ilr[i1][itr1-1].second &gt;= f1) f1 = ilr[i1][itr1-1].first;  if(f1 &lt;= f0) return ans + (i0 != i1);  // next0 可能不是某个右端点, 不可能一次跳到, 否则 perv1 &lt;= next0, 所以直接贪心去最大可达右端点  // 跳一次 保证f0 是右端点  int idx = lower_bound(segs.begin(),segs.end(),make_pair(f0+1,-1)) - segs.begin();  if(idx == 0 || maxr[idx] &lt; f0) return -1; // 未被覆盖到  f0 = maxr[idx]; // 当不可达时可能是比它小的右端点, 但是不影响结果逻辑  ans ++;  if(f1 &lt;= f0) return ans + 1;  // ? 需要吗 TODO  // if(!h.count(f0)) return -1;  if(jump[f0][lg] &lt; f1) return -1;  per(pwr,0,lg+1){    if(jump[f0][pwr] &gt;= f1) continue;    f0 = jump[f0][pwr];    ans += (1&lt;&lt;(pwr));  }  assert(f0 &lt; f1 &amp;&amp; jump[f0][0] &gt;= f1);  // printf(&quot;%d\n&quot;,ans+1 +1); // 分别是跳到比f1 大的和跳到恰好f1  return ans + 2; // 分别是跳到比f1 大的和跳到恰好f1}int main(){  n = read();  m = read();  q = read();  rep(i,0,m) {    // 注意g++ 函数处理顺序问题    // ilr[read()].pb(make_pair(read(),read()));    int pos = read();    int l = read();    int r = read();    ilr[pos].pb({l,r});  }  // 合并同楼 重叠  rep(i,1,n+1){    sort(ilr[i].begin(),ilr[i].end());    vector&lt;pair&lt;int,int&gt; &gt; tmp = {}; // 合并辅助    for(auto [l,r]: ilr[i]){      if(tmp.size() == 0 || l &gt; tmp.back().second){ // 不连续 [l0,r0] .. [l1..r1]        tmp.pb({l,r});      }else{        tmp.back().second = r;      }    }    ilr[i] = tmp;    for(auto o:tmp) segs.pb(o);  }  sort(segs.begin(),segs.end()); // 所有楼的  for(auto item:segs) maxr.pb(max(maxr.back(), item.second));  // 倍增  for(auto item:segs){    auto r = item.second;    if(jump.count(r)) continue;    jump[r] = vector&lt;int&gt;(lg+1,r);    // [...r] [r+1...    int idx = lower_bound(segs.begin(),segs.end(),make_pair(r+1,-1)) - segs.begin();    jump[r][0] = maxr[idx]; // 初始化跳2^0 = 1次  }  rep(pwr,1,lg+1){    for(auto item:segs){ // 会重复计算,不影响      auto r = item.second;      jump[r][pwr] = jump[jump[r][pwr-1]][pwr-1];    }  }  while(q--) printf(&quot;%d\n&quot;, query());  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>G</p><p>倍增, 编码速度也是问题, 写几个小时还在wa,哎</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>官方题解 <a href="https://atcoder.jp/contests/abc254/editorial" target="_blank" rel="noopener">https://atcoder.jp/contests/abc254/editorial</a></p>]]></content>
      
      
      <categories>
          
          <category> Atcoder </category>
          
          <category> ABC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 倍增 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CodeChef June Div1 Prefix Suffix Distinct(数学)</title>
      <link href="/Blog/2022-06-12-COOK142A-4/"/>
      <url>/Blog/2022-06-12-COOK142A-4/</url>
      
        <content type="html"><![CDATA[<p>主要问题不在算法,在自己写bug</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://www.codechef.com/submit-v2/PRFSUFDSTNCT" target="_blank" rel="noopener">https://www.codechef.com/submit-v2/PRFSUFDSTNCT</a></p><p>一个数组, 的前缀i个数,不重复的数值个数为pi</p><p>后缀i到结束,不重复的数值个数为si</p><p>给你p和s,问是否存在数组满足, 返回是否即可</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>n 1e5</p><p>1s</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>首先最直接的,</p><p>p[0] = s[n-1] = 1</p><p>p[n-1] = s[0]</p><p>然后 p的增量为0/1,s的增量为0/-1</p><p>再因为每个值至少贡献1次</p><p>所以如果p[i] + s[i+1] == p[n-1], 那么说明 i 和i+1 可以切开,并且这位置p增量为1,s增量为-1</p><p>对于切开后的每一段 找到变化的位置(增量为1/-1)的位置</p><p>分别跑后缀的前缀 应该小于等于前缀(与前缀首个的差)</p><p>和 前缀的后缀 应该小于等于后缀(与后缀最后一个的差)</p><h2 id="官方"><a href="#官方" class="headerlink" title="官方"></a>官方</h2><p>反而没有切割的操作,上面几个倒是有</p><p>官方 判断了个<code>a[i]+b[i] &lt;= a[n-1]</code> 跟我切割操作有点像,但是 不是错位的判断</p><p>原理和我那个也是类似,所有数贡献一次,左右统计的第i个两侧都有贡献,所以至少是a[n-1]+1</p><p>–</p><p>分析的是同一位的(p[i]-p[i-1],s[i]-s[i+1]) 的四种情况</p><p>1,1 原数组中唯一的值, 不需要额外判断, 甚至可以考虑原数组删除它</p><p>0,1 和 1,0 是对称的, 如果全部都是这两个</p><p>那么1,0 的出现意味着 右侧会有一个0,1 也就是从后缀上这个数首次出现的</p><p>可以看成1,0左括号,0,1右括号做括号匹配, 但不完全是相邻位置的, 如 (()), 可以1和3,2和4配</p><p>0,0 说明没有变化,应该被包含在某个值中, 如果记作.</p><p>那么<code>(.)(.)</code>是好的, 而<code>().()</code>,0,0无值可选</p><p>如此检查</p><hr><p><code>(.)(.)</code> 如</p><pre><code>p 111222s 222111</code></pre><p>正好一个答案是<code>111222</code></p><p><code>().()</code>如</p><pre><code>1112222111</code></pre><p>再换句 (, 上面+1, 右括号下面后一个-1, 所以考虑上下的总和变化, 出现问题就是 a[i]+b[i] &lt;= a[n-1]</p><hr><p>看了一下应该是有真的代码被我判否了, 因为我把答案逻辑塞到我代码后面return false也不对</p><p>最后发现是因为我代码 if 的l和r复制漏改了</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>按照我的逻辑AC的代码</p><p><a href="https://www.codechef.com/viewsolution/66653363" target="_blank" rel="noopener">https://www.codechef.com/viewsolution/66653363</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 1000000007#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readll p[100010]; // a 前缀 [..i] 不同的个数ll s[100010]; // a 后缀 [i..] 不同的个数bool p0[100010];bool p1[100010];// 只用 yes or noint n;// 保证范围 单增 单减 , 跨度 0/1bool check(int l,int r){  // [st..en]  if(l &gt; 0 &amp;&amp; p[l] != p[l-1]+1) return false;  if(r &lt; n - 1 &amp;&amp; p[r] != p[r+1]-1) return false;  if(l &gt; 0 &amp;&amp; s[l] != s[l-1]-1) return false;  if(r &lt; n - 1 &amp;&amp; s[r] != s[r+1]+1) return false; // 这里写成l了  if(p[r] - p[l] != s[l] - s[r])return false;  // 计算变化的点  rep(i,l,r+1){    if(i == r || p[i] != p[i+1]){      p0[i] = true;    }  }  rep(i,l,r+1){    if(i == l || s[i] != s[i-1]){      p1[i] = true;    }  }  // 跑前缀 &lt;= 前缀  {    int cur = 0;    rep(i,l,r+1){      cur += p1[i];      if( cur &gt; p[i] - p[l]+1) return false;    }  }  {    int cur = 0;    per(i,l,r+1){      cur += p0[i];      if( cur &gt; s[i] - s[r]+1) return false;    }  }  return true;}bool w(){  // 清空  n = read();  fill(p0,p0+n,0);  fill(p1,p1+n,0);  rep(i,0,n) p[i] = read();  rep(i,0,n) s[i] = read();  // p [n-1] 不同的总数  if(p[n-1] != s[0]) return false;  if(p[0] != s[n-1]) return false;  if(p[0] != 1) return false;  // 跨度 0/1  rep(i,1,n)if(p[i] &lt; p[i-1] || p[i] &gt; p[i-1] + 1)return false;  rep(i,1,n)if(s[i] &gt; s[i-1] || s[i] &lt; s[i-1] - 1)return false;  int itr = 0;  rep(i,0,n-1){    if(p[i] + s[i+1] == p[n-1]){      if(!check(itr,i)) return false;      itr = i+1;    }else if(p[i] + s[i+1] &lt; p[n-1]){      // ???      return false;    }  }  return check(itr,n-1);}int main(){  int t = read();  while(t--) printf(&quot;%s\n&quot;,w()?&quot;YES&quot;:&quot;NO&quot;);  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>BUG 是我AC失败一个重大阻碍</p><p>题解的转化我也是没想到的学习了</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://discuss.codechef.com/t/prfsufdstnct-editorial/101414" target="_blank" rel="noopener">官方</a></p>]]></content>
      
      
      <categories>
          
          <category> CodeChef </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces 1687E(数学,构造,min-max容斥,kmin/kmax容斥)</title>
      <link href="/Blog/2022-06-07-CF1687E/"/>
      <url>/Blog/2022-06-07-CF1687E/</url>
      
        <content type="html"><![CDATA[<p>评分3500,题是国内洛谷大佬出的, t神都炸了</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://codeforces.com/contest/1687/problem/E" target="_blank" rel="noopener">https://codeforces.com/contest/1687/problem/E</a></p><p>长n的数列a</p><p>初始 v = 1</p><p>不超过1e5操作,让gcd(all(ai * aj)) = v,i != j, 就是所有不相同的两个数的乘积的gcd</p><p>一次操作, 选取a的一个子序列b,(子序列=保持顺序不要求连续)</p><p>并执行<code>v = v * lcm(b)</code>或 <code>v = v / lcm(b)</code>, 注意的是过程中,v 可以不是整数, 这里是数学除,不是整除</p><p>同时保证,所有选取的b的长度和 小于1e6</p><p>输出任何一个满足要求的方案</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>n 1e5</p><p>ai 1e6</p><p>3s</p><p>512MB</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>考虑所有与 a1 乘的</p><p><code>a1 * gcd(a2,...,an)</code></p><p>所有与a2乘的</p><p><code>a2 * gcd(a1,a3,...,an)</code></p><p>但怎么组合并不知道</p><p>反过来,既然是gcd/lcm,乘法,那么就考虑质数的出现计数</p><p>所有ai的两两相乘的gcd,其实就是 每个质数出现次数, 最小的两个和</p><p>所以目标的v 是O(n log ai) 可以得到的</p><hr><p>那么问题是如何通过lcm去搞, 题目里说 It can be shown that the answer exists</p><p>如果是两个数的gcd</p><p>gcd(a,b) * lcm(a,b) = ab</p><p>gcd(a,b) = lcm(a,a) * lcm(b,b) / lcm(a,b)</p><hr><p>考虑一下小的情况</p><blockquote><p>两个数</p></blockquote><p>v = a0 a1 = lcm(a0,a0) * lcm(a1,a1)</p><blockquote><p>三个数</p></blockquote><p>a0 = k0 q x y</p><p>a1 = k1 q y z</p><p>a2 = k2 q z x</p><p>其中 q = gcd(a0,a1,a2)</p><p>gcd(a0,a1) = qy</p><p>gcd(a1,a2) = qz</p><p>gcd(a2,a0) = qx</p><p>那么有 lcm(a0,a1,a2) = k0 k1 k2 q x y z</p><p>lcm(a0,a1) = k0 k1 q x y z</p><p>lcm(a1,a2) = k1 k2 q x y z</p><p>lcm(a2,a0) = k2 k0 q x y z</p><p>那么 目标 v = q q x y z</p><p>而观察上面的lcm, 注意到如果用一个的, 会出现如果要x y z 相等 那么会造成 q比它们多, 需要使用一个元素</p><p>那么 q x y z = lcm0 lcm1 lcm2 / lcm 012</p><blockquote><p>四个数</p></blockquote><p>考虑从三个数变形</p><p>a0 = k0 q x y</p><p>a1 = k1 q y z</p><p>a2 = k2 q z x</p><p>a3</p><p>目标是 v = gcd(a3 q,q q x y z)</p><p>这相当于 v(a0,a1,a2,a3) = gcd(a3 gcd(a0,a1,a2),v(a0,a1,a2))</p><p>如果按照这个写法,去看3个数</p><p>v(a0,a1,a2) = gcd(a2 gcd(a0,a1), v(a0,a1))</p><p>= lcm(a2 gcd(a0,a1) lcm(v(a0,a1)) / lcm(a2 gcd(a0,a1), v(a0,a1))</p><p>= v(a0,a1) a2 gcd(a0,a1) / lcm(a2 gcd(a0,a1), v(a0,a1))</p><p>= v(a0,a1) lcm(a2) lcm(a0) lcm(a1) / (lcm(a2 gcd(a0,a1), v(a0,a1)) lcm(a0,a1))</p><p>= ???</p><p>= 0 1 2 / 012</p><p>只能说 v(a0,a1) / (lcm(a2 gcd(a0,a1), v(a0,a1) lcm(a0,a1) == lcm(0,1,2) ?</p><p>没有什么思路</p><hr><p>再会看题目 n是1e5, 但希望操作不要超过1e5</p><p>但注意到上面3个数的时候用了4次,</p><p>具体例子</p><p>a0 = 11 2 3 5</p><p>a1 = 13 2 5 7</p><p>a2 = 17 2 7 3</p><p>lcm(0,1) = 11 13 2 3 5 7</p><p>lcm(1,2) = 13 17 2 3 5 7</p><p>lcm(2,0) = 17 11 2 3 5 7</p><p>lcm(0,1,2) = 11 13 17 2 3 5 7</p><p>v(0,1,2) = 2 2 3 5 7 = lcm0 lcm1 lcm2 / lcm012</p><p>说明3个的做法对于大的n并不通用, 通用的应该要能达到n个是n次的样子</p><p>对于大的n, 不会使用单个, 因为单个会有独立的系数, 任何其它gcd无法消掉</p><hr><p>那不如强行拆一下四个数</p><p>其中k是独立的部分</p><pre><code>a0 = k0  b c d        w x y    qa1 = k1  b     e f    w x   z  qa2 = k2    c   e   g  w   y z  qa3 = k3      d   f g    x y z  q</code></pre><p>发现其中出现次数都是C(4,i)对应的表现</p><p><code>v = w x y z q q</code></p><p>一个为组的轮换 (1次) (2次) (3次) (4次)</p><p>两个为组的轮换 (3次) (5次) (6次) (6次)</p><p>三个为组的轮换 (3次) (4次) (4次) (4次)</p><p>四个为组的轮换 (1次) (1次) (1次) (1次)</p><p>以线性方程组的知识, 显然 <code>(0 0 1 2) = (1 2 3 4) + 2(1 1 1 1) - (3 4 4 4)</code>, 次数是 <code>4 + 2 * 1 + 4</code> 要10次</p><hr><p>剩下的观察就是, n 1e5, 而 ai 1e6</p><p>也就是说可能有不少的因子被干掉了</p><p>并不知道如何量化分析了</p><p>只知道 k0,k1,k2,k3,b,c,d,e,f,w,x,y,z 应该是两两互质的, 否则把它们的gcd提取出来转到下一级别</p><p>而如果全部互质, 那么<code>2*3*5*7*8*11*13 = 240240</code> 在超界的边缘</p><p>似乎不可能构成的样子</p><h2 id="官方"><a href="#官方" class="headerlink" title="官方"></a>官方</h2><p>考虑容斥原理</p><p>一样的, 对于一个质数的幂次 在结果中 = 这个质数最小出现的两个幂次的和</p><p>广义 容斥</p><p>$\gcd_{i\ne j}{A_i\times A_j}=\prod_{T\subseteq U}\text{lcm}(T)^{(-1)^{|T|}(|T|-2)}$</p><p>证明一下这个表达式</p><p>因为对于不同质数,可以独立的看其幂次</p><p>不妨设对于一个具体质数, 它在这些数组元素中的幂次从小到大为 <code>p0 p1 &gt;=p1 &gt;=p1 ...</code>, 也就是a0按照p的幂次排序</p><p>需要的是$p_1+p_2$</p><p>$(lcm(a_1)) \cdot (lcm(a_2) \cdot lcm(a_1,a_2)^0 ) \cdot ( a_3^{ 1 + 0 + (-1) } \cdot (a4^{ 1 + 0 + (-1 \cdot 3) + 2 \cdot 1}) \cdot (a_5^{1 + 0 + (-1 \cdot 6) + (2 \cdot 4) + (-3 \cdot 1)}) \cdots$</p><p>$ = a_1 \cdot a_2 = p^{p_1+p_2}$</p><p>这么神奇的吗</p><p>你会发现$lcm_k, k \ge 3$ 的幂次为</p><p>$ \sum_{i=1}^k (-1)^i \cdot (i-2) \cdot C(k-1,i-1) $</p><p>$ = - \sum_{i=0}^{k-1} (-1)^i \cdot (i-1) \cdot C(k-1,i)$</p><p>$ = - \sum_{i=0}^{w} (-1)^i \cdot (i-1) \cdot C(w,i) , w = k-1 \ge 2$</p><p>$ = - \sum_{i=0}^{w} (-1)^i \cdot i \cdot C(w,i)$ ( 因为$w \ge 2 &gt; 0 时, 0 = (1-1)^w = \sum_{i=0}^{w} (-1)^i \cdot C(w,i)$</p><p>$ = - \sum_{i=0}^w (-1)^i \cdot i \cdot \frac{w!}{i!(w-i)!} $</p><p>$ = - \sum_{i=1}^w (-1)^i \cdot i \cdot \frac{w!}{i!(w-i)!} $</p><p>$ = - \sum_{i=1}^w (-1)^i \cdot \frac{w!}{(i-1)!(w-i)!} $</p><p>$ = - w \sum_{i=1}^w (-1)^i \cdot \frac{(w-1)!}{(i-1)!(w-i)!} $</p><p>$ = - w \sum_{i=1}^w (-1)^i \cdot C(w-1,i-1) $ ( 同上 因为$w-1 \ge 2-1 &gt; 0 时, 0 = (1-1)^w = \sum_{i=0}^{w} (-1)^i \cdot C(w,i)$</p><p>$ = - w \cdot 0$</p><p>$ = 0 $</p><p>其中 $ k - 1 = w \ge 2$</p><p>算强行证明了</p><hr><p>题解的过程是 有得到第k小的数的反演公式 $k\text{-th}\min{S}=\sum\limits_{\varnothing\ne T\subseteq S}(-1)^{|T|-k}\tbinom{|T|-1}{k-1}\max{T}$</p><p>那么 其实就是最小的(k=1) + 次小的(k=2) 得到</p><hr><p>一个可重整数集$S$, 其中整数范围$[1,10^6]$, 那么 总能选出大小不超过7的子集$T\subseteq S$, 让$\gcd(S)=\gcd(T)$</p><p>易证,因为$gcd(S) \le 10^6$ 所以它的质因子个数不超过7个, T只需要每个质因子的最小幂次选出来就行了</p><p>但和本题还是有区别</p><p>本题是 $gcd_2(S)$的情况, 两两下标不同乘积的gcd</p><p>这样考虑 先让集合$T$为空, 然后我们针对质数p 的幂次来讲, 假设前面已经选了几轮了, 那么最坏情况, 没有选p的最低和次低幂次, 所以为了让p的幂次满足, 任选两个最低和次低幂次, 也就是填2个, 而这种情况说明$gcd_2(S)$ 至少包含p的一次方</p><p>所以 最多有7个不同的有效p,最多选14个就能达成</p><hr><p>这样也没要求最小数量</p><p>直接用上面的lcm和gcd的min/max 表达式就可以了</p><hr><p>因为可能其它数字 虽然贡献是两个0次,但是因为, 只做了幂次最小限制,会让它们的gcd不止是对应的幂次</p><p>wa5或者看下面的例子</p><pre><code>2   3 5 72     52 2 32 2     7</code></pre><p>注意到3,5,7的最小两个幂次和都是0,而2的最小两个幂次和为1+1=2</p><p>但是如果你只选前两个去做集合运算,那么gcd = 2 5</p><p>所以你可以通过数量控制</p><h3 id="关于Min-Max-容斥"><a href="#关于Min-Max-容斥" class="headerlink" title="关于Min-Max 容斥"></a>关于Min-Max 容斥</h3><p>$max_k(S) = $ 集合$S$的第$k$大元素</p><p>TODO 再整理一篇文章: 反演 =&gt; 二项式反演 =&gt; min-max 反演 =&gt; kmax/kmin 反演</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>感觉代码还真不难写, 纯代码不到100行,毕竟给了3s</p><p><a href="https://codeforces.com/contest/1687/submission/159885371" target="_blank" rel="noopener">https://codeforces.com/contest/1687/submission/159885371</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_back#define all(O) O.begin(),O.end()ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readint n;int a[100010];int v2p[1000010]; // 每个数的质数拆解const int INF = 0x3f3f3f3f;int getpwr(int v,int p){  int r = 0;  while(v % p == 0){    r++;    v/=p;  }  return r;}int main(){  int n = read();  rep(i,1,n+1) a[i] = read();  // 质数 到最低两个幂次 和对应的数的下标  unordered_map&lt;int, vector&lt; pair&lt;int,int&gt; &gt; &gt; p2low2;  // 质数  rep(i,2, 1000000){    if(v2p[i])continue; // 合数    p2low2[i] = vector(2,make_pair(INF,-1));    for(ll j = i*i;j &lt;= 1000000;j+=i){      v2p[j] = i;    }  }  // 筛出至多14个数  rep(i,1,n+1) {    vector&lt;int&gt; rm;    for(auto &amp;item: p2low2){      auto &amp;[p,low2] = item;      low2.push_back({getpwr(a[i],p),i});      sort(all(low2));      low2.pop_back();      if(low2.back().first == 0 &amp;&amp; p2low2.size() &gt;= 7 + 1 + rm.size()){ // wa5, 0 幂次贡献也有作用        rm.push_back(p);      }    }    for(auto p:rm) p2low2.erase(p);  }  vector&lt;int&gt; pos;  for(auto &amp;[p,low2]:p2low2){    pos.push_back(low2[0].second);    pos.push_back(low2[1].second);  }  assert(pos.size() &lt;= 14);  // 排序去重  sort(all(pos));  pos.erase(unique(all(pos)),pos.end());  int cnt = 0;  // 公式输出  rep(bits,1,(1&lt;&lt;pos.size())){    // lcm{set} ^ ( (-1)^|set| (|set| - 2))    int t = __builtin_popcount(bits);    int pwr = (t%2?-1:1) * (t-2);    cnt += abs(pwr);  }  printf(&quot;%d\n&quot;,cnt);  rep(bits,1,(1&lt;&lt;pos.size())){    // lcm{set} ^ ( (-1)^|set| (|set| - 2))    int t = __builtin_popcount(bits);    int pwr = (t%2?-1:1) * (t-2);    if(!pwr) continue;    int op = pwr &lt; 0 ? 1 : 0;    pwr = abs(pwr);    while(pwr--){      printf(&quot;%d %d&quot;,op,t);      rep(i,0,pos.size()){        if(bits &amp; (1&lt;&lt;i)){          printf(&quot; %d&quot;, pos[i]);        }      }      printf(&quot;\n&quot;);    }  }  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>光是这个容斥公式, 我都得不出, 全靠手工算了个特例</p><p>知识点1, kmin/kmax 反演 有地一个公式</p><p>知识点2, 从gcd 集合, 推理到gcd2集合的元素个数上限和一种构造方案</p><p>gcd2(S) =&gt; gcd2(T) =&gt; kmin容斥</p><hr><p>思考角度从小量枚举和得到的线性公式是可以的,而主要缺乏相关反演知识,应该去补充</p><p>然后有感觉到可能被值的范围限制了运算, 但是没想到考虑从gcd 演变到gcd2</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://codeforces.com/blog/entry/103493" target="_blank" rel="noopener">官方</a></p><p><a href="https://www.luogu.com.cn/problem/solution/CF1687E" target="_blank" rel="noopener">luogu</a></p><p><a href="https://www.luogu.com.cn/blog/command-block/xuan-ku-fan-yan-mo-shu" target="_blank" rel="noopener">反演</a></p>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 构造 </tag>
            
            <tag> min-max容斥 </tag>
            
            <tag> kmin/kmax容斥 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces 1687D(数学,跳点)</title>
      <link href="/Blog/2022-06-05-CF1687D/"/>
      <url>/Blog/2022-06-05-CF1687D/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://codeforces.com/contest/1687/problem/D" target="_blank" rel="noopener">https://codeforces.com/contest/1687/problem/D</a></p><p>$f(x) = $比x大的最小平方数</p><p>$g(x) = $比x小的最大平方数</p><p>如果 $x - g(x) &lt; f(x) - x$ 那么$x$是好的</p><p>给长度$n$的单调数组$a$, 求最小非负$k$,使得$a_i+k$ 全为好的</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>$n \le 10^6$</p><p>$a_i \le 2\cdot 10^6$</p><p>2s</p><p>256MB</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>先做点数学变形</p><p>易知对于任意$x=a_i$, 如果$\exists w, x \in [w^2,w^2+w]$ 那么$x$是好的</p><p>然后 真不会了</p><h2 id="官方"><a href="#官方" class="headerlink" title="官方"></a>官方</h2><p>显然 $k \le a_n^2$, 因为 $[a_n^2,a_n^2+a_n]$ 的长度都是 $a_n$ 一定能放下所有数</p><p>根据上面的令$f(x) = w$, $w$由$x$唯一得到,也可能不存在, 且有$max(w) \le a_n$, </p><p>枚举$f(a_1 + k)$的结果$w_1$, 因为$w_1 \le a_n$ 得到$\le a_n$个初始的$k$取值范围区间</p><hr><p>然后枚举 $f(a_i + k)$ 的所有区间</p><p>这里有个神奇的地方在于</p><p>如果把好的位置用x标出来</p><pre><code>1 2 3 4 5 6 7 8 9 10 11 12x x   x x x     x  x  x  x </code></pre><p>那么选择一个好的完整区间, 向右任意平移, 去取交, 一定只会和一个区间相交, 这样就保证了无论怎么交 都是连续的区间</p><p>因此这里假设计算之前$k$的范围是$[min(k),max(k)]$ , 那么计算$[a_i+min(k),a_i+max(k)]$中合法的区间, 而这一定是其中连续的一段, 所以只需要$min,max$两个指针就能维护$k$的取值范围</p><hr><p>伪代码</p><pre><code>for w_1 = sqrt(a_1)...a[n]: // 枚举w = f(a_1+k)  krange = [...] // k的可选范围  for i = 2..n:    // 注意到 合法与不合法的间隔单调递增, 所以 交完后还是连续区间    krange = krange 交 calc(krange, a_i)    if len(krange) == 0:      break  if len(krange) &gt; 0:    return krange.start</code></pre><p>这样外层$w_1$范围$O(a_n)$, 每轮内部循环最多$n$次, 总复杂度$O(n a_n)$, 过不了</p><hr><p>实际上只需要考虑的是$f(a_i+k) \neq f(a_{i-1} + k)$, 这样的$a_{i-1}$和$a_i$带来的影响 </p><p>因为如果 $i \in [l,r]$ 都让$f(a_i + k) = w$的话, 那么只有端点$l$和$r$ 会真实的对$k$的区间产生贡献</p><p>对于给定的 $f(a_1+k) = w_1$ ,相邻的$f$不等的情况不超过$O(\frac{a_n}{w_1})$种</p><p>因为 $a_1+k \in [w_1^2,w_1^2+w_1]$, 所以$a_n+k \in [w_1^2+a_n-a_1,w_1^2+w_1 + a_n-a_1]$</p><p>$f(a_n+k) \le \sqrt{w_1^2+w_1 + a_n-a_1} \le \sqrt{(w_1+1)^2 + a_n + (\frac{a_n}{2(w_1+1)})^2} \le w_1+1 + \frac{a_n}{2(w_1+1)}$, 得证</p><p>? 有啥简单一点的证明方式吗</p><p>所以总复杂度是 $O(\sum_{w_1=\sqrt{a_1}}^{a_n}{\frac{a_n}{w_1}}) = O(a_n log (a_n))$,</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://codeforces.com/contest/1687/submission/159707568" target="_blank" rel="noopener">https://codeforces.com/contest/1687/submission/159707568</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readint n;ll a[1000010]; // 有序 ai &lt; 2e6ll mysqrt(ll v){  ll l = 1;  ll r = v;  while(l != r){    ll mid = (l+r)/2;    // 先控范围防止 overflow    if( v/mid &lt; mid ){      r = mid - 1;    }else if( mid * mid &lt;= v &amp;&amp; (mid+1)*(mid+1) &gt; v){      return mid;    }else if( (mid+1) * (mid+1) &lt;= v){      l = mid + 1;    }else {      r = mid - 1;    }  }  return l;}// k 的初始范围 [l_k..r_k], 初始f(a_1+k) = wbool calc(ll w,ll &amp;l,ll &amp;r){  while(true){    // [a[i] + l_k, a[i] + r_k] \subset [w^2,w^2+w]    // 找同为w的最大的j [a[j] + l_k, a[j] + r_k] \subset [w^2,w^2+w]    // (a[j] + l_k) \in [w^2,w^2+w] 即, a[j] &lt;= w^2+w - l_k    //                                  r_k &lt;= w^2+w-a[j]    int idx = lower_bound(a,a+n,w*(w+1)-l+1) - a; // j = idx-1    r = min(r,w*(w+1) - a[idx-1]); // 更新 r_k &lt;= w^2+w - a[j]    if(l &gt; r) return false;    if(idx == n)return true; // 最后一个    w = mysqrt(a[idx]+r); // 下一个位置的w, (a[idx]+r_k) \in [w_1^2,(w_1+1)^2]    l = max(l,w*w - a[idx]);    r = min(r,w*(w+1) - a[idx]);    if(l &gt; r) return false;  }  assert(false);  return true;}int main(){  n = read();  rep(i,0,n) a[i] = read();  // w = f(a_0 + k) = [sqrt(a[0])..a[n-1]]  rep(w,mysqrt(a[0]),a[n-1]+1){    // 初始化 k的范围[l..r]    ll l = max(w*w - a[0],(ll)0);    ll r = w*(w+1) - a[0];    if(r &lt; l) continue;    // 成功的话 k \in [l..r] 都是合法的, l就是要求的最小的    if(calc(w,l,r)){      printf(&quot;%lld\n&quot;,l);      return 0;    }  }  assert(false);  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过枚举$w = f(a_0+k)$来让$k$的取值范围是连续的一段, 且只有$a$的区间端点有影响</p><p>完全没想到是通过$w$来划分的, 也就是还是有点按结果划分的感觉,但又不是二分的划分形式</p><p>而且这里$w$会让变化次数是$O(\frac{a_n}{w})$ 也是优化的关键点</p><p>然后就是这个神奇的刚刚好, 向右平移的交一定是连续区间</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://codeforces.com/blog/entry/103493" target="_blank" rel="noopener">官方</a></p>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 跳点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces 1691F(贡献统计,组合数,树)</title>
      <link href="/Blog/2022-06-04-CF1691F/"/>
      <url>/Blog/2022-06-04-CF1691F/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://codeforces.com/contest/1691/problem/F" target="_blank" rel="noopener">https://codeforces.com/contest/1691/problem/F</a></p><p>树,n个点,点上1~n</p><p>给定k</p><p>对于点r, 树的一个k个点的子点集S, 令f(r,S) = 根为r, 且包含所有S中点的原树的子树最少的点的个数</p><p>你需要计算 所有 r和S的组合 求 所有f(r,S)的和</p><p>答案mod 1e9+7</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>n 2e5</p><p>3s</p><p>512MB</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>看数据范围n方都不行, 既然又是求和</p><p>那么估计又是算贡献一类</p><p>从树的结构讲, 与其算贡献不如算不被贡献</p><p>一个点u,连接了很多点v0,v1,v2,v3</p><p>如果要u不被贡献, 那么r和S的所有点一定在某个vi的联通块内,不会是不同vi的联通块内</p><p>而选择来讲, 对于S, 就是C(联通块大小,k), 对于r就是联通块大小</p><p>注意联通块 &lt; k时 方案为0</p><hr><p>感觉就过了???不想写代码</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>鸽</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>感觉给时间, 就这样随便搞一搞就完了?</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>无</p>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
            <tag> 组合数 </tag>
            
            <tag> 贡献统计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pollard-Rho 质数拆分,分解</title>
      <link href="/Blog/2022-06-03-pollard-rho/"/>
      <url>/Blog/2022-06-03-pollard-rho/</url>
      
        <content type="html"><![CDATA[<h1 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h1><p>在之前做Project Euler 216 的时候</p><p>学了一下 如何利用别人的答案,在log n时间内判断n是否是一个 64位以内的质数的 Miller-Rabin 判别法</p><p>但如果这个数不是质数, 如何能拆解还没有解决</p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h2><p>回到最初的起点, for一遍 那也是$\sqrt(n)$</p><p>而众所周知, $\sqrt {2^{64}} = 2^{32} = $ 4.2e9</p><p>单独算一次的时间复杂度都接受不了</p><h2 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h2><p>相信随机的力量, 先特判是否质数</p><p>在不停的随一个判断是否<code>gcd != 1</code> 来找因数</p><hr><p>问题是, 生日悖论(一个房间里有23个人，则他们中有两人生日相同的概率超过一半)</p><p>换句话说, 反复生成随机数,有很高几率生成了不少一样的</p><h2 id="Pollard-的伪随机数"><a href="#Pollard-的伪随机数" class="headerlink" title="Pollard 的伪随机数"></a>Pollard 的伪随机数</h2><p>问题变成 我们希望它概率上看起来随机,值上有不重复得不那么随机</p><p>$x_{n+1} = f(x_n) = (x_n^2 + c) mod N$</p><p>但也不一定如期望, 例如 x = 0, c= 24,N = 9400, 很有规律, 因为这个递推式说白了就是下一项由上一项决定,肯定有循环,只是循环的早晚</p><p>低空间,低时间判断环? 那不是经典面试题双指针吗?(floyd判环算法)</p><p>初始$x_1 = y_1$</p><p>$x_{n+1} = f(x_n)$</p><p>$y_{n+1} = f(f(y_n))$</p><p>每次判断$gcd(|x_n - y_n|,N) &gt; 1$, 和是否到达环, 成环则换一个c来跑</p><hr><p>性质 |i-j| 是p的倍数,则 |f(i)-f(j)| 也是p的倍数</p><p>如果看作环上指针, 也就意味这两个指针距离相等时,其它距离和这个距离相等的两个指针之差,都是p的倍数,</p><p>而快慢指针每次会让距离+1, 而对于环上的视角, 其实追上慢指针相当于逐渐减少</p><h2 id="实现和细节"><a href="#实现和细节" class="headerlink" title="实现和细节"></a>实现和细节</h2><p>据说$O(n^{\frac{1}{4}}\log n)$</p><p>$N = 4,N = 1$ 需要特判</p><p>素数平方提前判断</p><p>让x=0</p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;#include &lt;atcoder/modint&gt;using mint = atcoder::modint998244353;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readtypedef __int128_t lll;ll quick_p(lll b, ll p,ll mod){  lll r = 1;  while(p){    if(p%2)(r*=b)%=mod;    (b*=b)%=mod;    p/=2;  }  return r % mod;}bool miller_robin(ll v, ll base, ll startpwr){  lll r = quick_p(base,startpwr,v);  for(ll p = startpwr; p &lt; v-1; p *=2){    if(r == v-1) return true; // -1 开始的序列    if(r == 1) return p == startpwr; // 全1序列    (r*=r)%=v;  }  return false;}bool is_prime_64(ll v){  if(v == 2)return true;  if(v &lt; 2 || v % 2 == 0)return false;  ll p = v-1;  while(p % 2 == 0) p /= 2;  for(auto base:{2, 325, 9375, 28178, 450775, 9780504, 1795265022}){    if(base % v == 0) continue; // don&#39;t break may cause 4033 bug    // 需要所有都能找到-1开始, 或奇数次开始 全1    if(!miller_robin(v,base,p)) return false;  }  return true;}ll my_sqrt(ll v){  if(v &lt;= 1) return v;  ll l = 1; // 左ok  ll r = v; // 右not ok  while(r - l &gt; 1){    ll m = (l+r)/2;    (v/m &lt; m ? r : l) = m; // 防止 overflow  }  return l;}unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();mt19937 rand_num(seed);ll randll(ll low,ll hi){  return low + (rand_num() % static_cast&lt;ll&gt;(hi - low + 1));}ll Pollard_Rho(ll N) { // 返回一个&gt; 1的因数  assert(N &gt; 1);  if (N == 4) return 2;  lll ret = my_sqrt(N); // 质数平方 效率低 提前判断  if(ret * ret == N) return ret;  while(true) {    ll c = randll(1, N - 1); // 生成随机的c    auto f = [=](lll x) { return ((lll)x * x + c) % N; }; // ll 表示__int128，防溢出    ll t = 0, r = 0; // 初始两个相同    do{      t = f(t); // 1倍速度      r = f(f(r)); // 2倍速度      ll d = gcd(abs(t - r), N);      if (d &gt; 1 &amp;&amp; d &lt; N) return d;    }while (t != r);  }}// 分解x为质因数, sortedvector&lt;ll&gt; fenjie(ll x) {  vector&lt;ll&gt; res = {};  deque &lt;ll&gt; arr = {x};  while(arr.size()){    ll v = arr.front();    arr.pop_front();    if(v == 1) continue;    if(is_prime_64(v)) {      res.pb(v);      continue;    }    ll divisor = Pollard_Rho(v);    arr.push_back(divisor);    arr.push_back(v/divisor);  }  sort(res.begin(),res.end());  return res;}</code></pre><h2 id="固定128距离"><a href="#固定128距离" class="headerlink" title="固定128距离"></a>固定128距离</h2><p>减少求gcd的次数, 128次 或者 即将乘起来是N的倍数</p><p>大概是$O(n^{\frac{1}{4}})$</p><pre><code class="cpp">ll Pollard_Rho(ll N) {  assert(N!=1);  if (N == 4) return 2;  if (is_prime(N)) return N;  if (is_prime_square(N)) return prime_square(N);  while(true){    ll c = randint(1, N - 1);    auto f = [=](ll x) { return ((lll)x * x + c) % N; };    ll t = 0, r = 0, p = 1, q;    do {      for (int i = 0; i &lt; 128; ++i) { // 令固定距离C=128        t = f(t), r = f(f(r));        if (t == r || (q = (lll)p * abs(t - r) % N) == 0) break; // 如果发现环，或者积即将为0，退出        p = q;      }      ll d = gcd(p, N);      if (d &gt; 1) return d;    } while (t != r);  }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
            <tag> prime </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atcoder arc141 C D E</title>
      <link href="/Blog/2022-06-02-ac_arc141/"/>
      <url>/Blog/2022-06-02-ac_arc141/</url>
      
        <content type="html"><![CDATA[<p>C(math, 括号对)D(math,集合,数论,动归)E(并查集)</p><h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://atcoder.jp/contests/arc141/tasks/arc141_c" target="_blank" rel="noopener">https://atcoder.jp/contests/arc141/tasks/arc141_c</a></p><p>他给两个排列p和q, 长度2n</p><p>构造 长2n的括号字符串,含有n个左括号,n个右括号</p><p>使得p是所有 让 s[p[i]] 为合法括号序列中的字典序最小的</p><p>同时q是所有 让 s[q[i]] 为合法括号序列中的字典序最大的</p><h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h3><p>n&lt;=2e5</p><p>2s</p><p>1024mb</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h3><p>显然开始和最后的位置分别是 左右括号</p><p>对于p, 当左右括号都可以选时,一定会选没有被选坐标最小的</p><p>当前缀完成匹配时, 只能选左括号, 这时选左括号坐标最小的</p><p>于是, 如果当前坐标以前的没有选完,那么说明当前位置是左括号,且没有被选的是右括号</p><p>对于q,类似的, 先选最大的, 左括号也是先选最大的</p><p>这样分别确定的右括号不少于 左括号个数</p><hr><p>但是对于剩余没有填的位置怎么做,我没有思路了,因为它不只需要保证一个排列合法,它需要保证p和q都合法</p><h3 id="官方"><a href="#官方" class="headerlink" title="官方"></a>官方</h3><p>前面还是一样的, 但这里强调了是 奇数处出现, 因为 要前面匹配完,说明前面用了偶数个</p><p>而且不像我那样 需要 前缀未填完, 而只是 奇小于下一个偶, P[2i-1] &lt; P[2i]</p><p>但说是 如果还是有多个候选的,那么就是没有方案</p><p>如果只有一个候选S,就看是否同时满足p和q</p><p>简单的来讲如果S或它的逆序是一个合法的括号序列, (一般情况也可以类似证明, 因为一般的S 可以表示成合法和 和 逆序合法的连接</p><p>令 L1 &lt; L2 &lt; L3 … &lt; LN 分别是左括号的下标</p><p>R1 &lt; R2 &lt; R3 … &lt; RN 分别是右括号的下标</p><p>既然S是合法的,那么有 Li &lt; Ri</p><p>因此字典序最大的排列是$L_N,R_N,L_{N-1},R_{N-1},…,L_1,R_1$</p><p>因此 S是唯一的</p><p>并且确定的过程和上述描述的也是一致的</p><hr><p>如果S的逆序是合法的</p><p>那么有</p><p>令 L1 &lt; L2 &lt; L3 … &lt; LN 分别是左括号的下标</p><p>R1 &lt; R2 &lt; R3 … &lt; RN 分别是右括号的下标</p><p>既然S的逆序列是合法的,那么有 Li &gt; Ri</p><p>所以字典序最小的是$L_1,R_1,L_2,R_2,…,L_N,R_N$</p><p>并且确定的过程和上述描述的也是一致的</p><hr><p>再对于一般序列来讲</p><p>又回到 括号序列的常用技巧,左括号+1,右括号-1</p><p>那么其实就是 一些在正平面的一些曲线和负平面的一些曲线,</p><p>显然由和0点隔开的 顺序上也相互独立(见官方youtube上画的图</p><p>这样 对于每一段来说,是正平面则由最大序列唯一确定, 是负平面则由最小序列</p><p>所以 整体都是唯一的</p><p>这样就是官方提接说的一般序列的 拼接类似</p><p>综上得证</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/arc141/submissions/32155305" target="_blank" rel="noopener">https://atcoder.jp/contests/arc141/submissions/32155305</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;(int)n;i++)int read(){int r;scanf(&quot;%d&quot;,&amp;r);return r;} // readint p[400010];int q[400010];char s[400010];char sets(int i,char ch){  return (s[i] &amp;&amp; s[i] != ch) ? 0 : (s[i] = ch);}bool work(){  int n = read() * 2; // 2e5 * 2  rep(i,0,n) p[i] = read() - 1;  rep(i,0,n) q[i] = read() - 1;  for(auto [arr, cmp]:vector&lt;pair&lt;int *,int&gt; &gt; {{p, 1},{q,-1}}){    rep(i,0,n-1) {      if((arr[i] - arr[i+1]) * cmp &lt;= 0) continue; // 出现反序列      if(!sets(arr[i],&#39;(&#39;) || !sets(arr[i+1],&#39;)&#39;)) return false;    }  }  rep(i,0,n) if(!s[i]) return false; // 不唯一  // check 可能一个合法 另一个不合法  for(auto [arr,st,d]:vector&lt;tuple&lt;int*,int,int&gt; &gt;{{p,0,1},{q,n-1,-1}}){    // 双指针    int i0 = st; // 找所有值    int i1 = st; // 只找左括号    int cnt = 0;    vector&lt;bool&gt; vis(n,false);    rep(i,0,n){      int pos ; // 选取的位置      if(cnt == 0){        while(vis[i1] || s[i1] != &#39;(&#39;) i1+=d;        pos = i1;      }else{ // cnt &gt; 0        while(vis[i0])i0+=d;        pos = i0;      }      if(arr[i] != pos) return false; // 和提供的不一致      vis[pos] = true;      cnt += s[pos] == &#39;(&#39;?1:-1;    }    if(cnt) return false;  }  printf(&quot;%s\n&quot;,s);  return true;}int main(){  if(!work()) printf(&quot;-1\n&quot;);  return 0;}</code></pre><h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p><a href="https://atcoder.jp/contests/arc141/tasks/arc141_d" target="_blank" rel="noopener">https://atcoder.jp/contests/arc141/tasks/arc141_d</a></p><p>对于一个集合S, 任意两个元素不成倍数关系,那么认为是一个好集合</p><p>给一个n个元素,元素值范围在[1,2m]之间的集合, 元素值不重复, 给值时从小到大</p><p>对于每个元素,判断是否存在一个S的子集,包含该元素且是好集合</p><h3 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h3><p>M&lt;=N&lt;2M</p><p>M 3e5</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><h3 id="我的想法"><a href="#我的想法" class="headerlink" title="我的想法"></a>我的想法</h3><p>既然给值就是从小到大, 那么省去了排序</p><p>既然一定要a[i], 那么它的倍数和约数一定不可行,而约数是log级别的个数,</p><p>这里虽然问是否能恰好m个, 但如果&gt;=m 合法,删掉多于m的依然合法</p><p>所以变成能否有不少于m个</p><p>对于即不是ai倍数,也不是ai约数的, 考虑最多能取多少个</p><p>于是集合被化分成(ai,ai约数,ai倍数) (其它), 那么包含ai的最大的个数是 1+max(其它)</p><hr><p>首先 值的倍数从均摊上讲 也是 log级别的, 因为 1/2+1/3+1/4… 在小的时候是 常数倍</p><p>但 剩下的如何尽可能多的取, 以及如果只是暴力去尝试的话, 显然 会达到至少 n平方</p><hr><p>另一个就是互斥关系,  如果建立互斥关系的2-sat图, 跑tarjan ,能一次计算</p><p>注意到互斥关系不会变, 所以2-sat不会变, 但是怎么选一个而不选其它</p><h3 id="官方-1"><a href="#官方-1" class="headerlink" title="官方"></a>官方</h3><p><strong>其实是个卡着边界的问题</strong></p><p>考虑所有奇数的2的幂次倍</p><p><code>(1,2,4,8,16...),(3,6,12,24...),(5,10,20...)</code></p><p>注意到的是 ,一共有m组,且每组内部两两是倍数关系, 因此我们选的答案,不会同时出现在一组中, 所以 至多选m个</p><hr><p>这个对答案也有帮助, 如果题目给的S, 在上述的2的幂次倍中 有的组不存在,那么显然达不到m</p><p>现在问题是跨组会不会有 倍数关系</p><p>假设 $x_1 &lt; x_2$ 都是奇数, 选了 $x_1 2^{p_1},x_22^{p_2}$</p><p>那么如果成倍数一定是 $p_2 \ge p_1$ 且 $x_2$是$x_1$的倍数</p><p>换句话说, 要想合法, 那么一个数的约数对应的2的幂次要比它本身大</p><hr><p>考虑 每个奇数的2的幂次的上下界, [Li,Ri]</p><p>直接动归转移方程</p><p>对于<code>R[value] = min(R[value 的因子]) - 1 且存在于S</code></p><p>对于<code>L[value] = max(L[value的倍数]) + 1 且存在于S</code></p><p><code>R1,R2,R3,...R,被选的值,L,...,L</code> 将是合法解, <code>[Li &lt;= 被选的幂次 &lt;= Ri]</code></p><p>因为前面的尽可能大,后面尽可能小且 被选值在范围中</p><hr><p>综上 因为因子数和均摊倍数个数都是log级别,所以总的均摊代价就是log级别</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/arc141/submissions/32169715" target="_blank" rel="noopener">https://atcoder.jp/contests/arc141/submissions/32169715</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readbool exist[600010];vector&lt;int&gt; ys[600010]; // 所有真奇数约数int L[600010];int R[600010];int a[600010];int n,m;bool w(){  n = read();  m = read()*2;  rep(i,0,n) {    exist[a[i] = read()] = 1;  }  rep(i,1,m/2+1){    if(i%2 == 0)continue;    rep(t,3,m/2+1){      if(t%2 == 0)continue;      if(i*t &gt; m)break;      ys[i*t].push_back(i);    }  }  // 先检查是否所有组都有  rep(i,1,m+1){    if(i%2==0)continue;    bool found = false;    int itr = i;    while(itr &lt;= m){      if(exist[itr]){        found = true;        break;      }      itr*=2;    }    if(!found)return false;  }  // 计算R  rep(i,1,m){    if(i%2 == 0) continue;    int pwr = 20;    // 计算它因数对它的限制    for(auto item:ys[i]){      pwr = min(pwr,R[item]-1);    }    // 找一个范围内且存在的    bool found = false;    while(pwr &gt;= 0){      if(i * (1&lt;&lt;pwr) &lt;= m){ // 小心 out bound        if(exist[i * (1&lt;&lt;pwr)]){          R[i] = pwr;          found = true;          break;        }      }      pwr--;    }    // printf(&quot;L %lld =&gt; %d\n&quot;,i,pwr);    if(!found) return false; // 不存在合法范围的值  }  // 计算L  per(i,1,m){    if(i%2 == 0) continue;    int pwr = 0;    // 计算它倍数对它的限制    rep(k,3,m+1){      if(k%2==0)continue;      if(i*k &gt; m)break;      pwr = max(pwr,L[i*k]+1);    }    // 找一个范围内且存在的    bool found = false;    while( i*(1&lt;&lt;pwr) &lt;= m){      if(exist[i * (1&lt;&lt;pwr)]){        L[i] = pwr;        found = true;        break;      }      pwr++;    }    if(!found) return false; // 不存在合法范围的值    if(L[i] &gt; R[i]) return false;  }  // 计算答案  rep(i,0,n){    int v = a[i];    int pwr = 0;    while(v%2 == 0){      pwr++;      v/=2;    }    printf(&quot;%s\n&quot;, L[v] &lt;= pwr &amp;&amp; pwr &lt;= R[v]?&quot;Yes&quot;:&quot;No&quot;);  }  return true;}int main(){  if(!w()) rep(i,0,n) printf(&quot;No\n&quot;);  return 0;}</code></pre><h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p><a href="https://atcoder.jp/contests/arc141/tasks/arc141_e" target="_blank" rel="noopener">https://atcoder.jp/contests/arc141/tasks/arc141_e</a></p><p>n方个点, <code>(1..n,1..n)</code></p><p>q 个询问</p><p>每个询问 a,b,c,d</p><p>会把 点((a+k)%n,(b+k)%n) 和 点((c+k)%n,(d+k)%n) 相连, 其中k取 0 到 n-1</p><p>询问之间是影响的, 是在上一次结果上继续连</p><p>每次回答一个询问操作后,剩下的联通块数</p><h3 id="范围-2"><a href="#范围-2" class="headerlink" title="范围"></a>范围</h3><p>n 2e5</p><p>q 2e5</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h3><p>首先, 其实让a,b,c,d 变成 a1=(a+n-a)%n,b1=(b+n-a)%n,c1=(c+n-a)%n,d1=(d+n-a)%n, 因为k取[0..n-1], 所以等价</p><p>变成 k,(b1+k)%n,(c1+k)%n,(d1+k)%n</p><p>画图, 会发现 (k,(b1+k)%n) 在一条45度角的一条斜线上,((c1+k)%n,(d1+k)%n) 也在一条45度角的一条斜线上</p><ol><li>如果共线, 那么 如果原来不是一个联通块,则 减少了 n-1个联通块, 如果原来是多个联通, 那么对结果影响 = -(个数-1)</li></ol><p>有了这个思路, 我们问题通过图像可以变一变</p><p>沿着+1,+1的45度, 形成n组点,每组点有个属性内部是否相连</p><p>考虑两组之间的关系, </p><p>1次连接, 那么这两组形成的是n个连通块, 且内部联通关系,一旦有一个联通则连通</p><p>而这个值其实 = gcd(偏移量间隔)</p><p>所以未连接和 连接一次的偏移量间隔为 n</p><p>而对两个组的影响是相同的</p><p>所以变成</p><p>哪些组属于一个并查集合, 它们自身内部的偏移量等价(一个值) 它们与根的偏移量等价</p><hr><p>似乎就可以做了</p><p>但感觉在合并并查集时更新需要注意</p><hr><p>然后 真的 我就AC了???? atcoder真的是数学场吗</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><p><a href="https://atcoder.jp/contests/arc141/submissions/32185372" target="_blank" rel="noopener">https://atcoder.jp/contests/arc141/submissions/32185372</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 1000000007#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readint gcd(int a,int b){  while(b!=0){    a=a%b;    swap(a,b);  }  return a;}int fa[200010];int a[4];int inner[200010]; // 组内部最小间隔, 一定是n的因子int tofa[200010]; // 跨组偏移距离ll n;int getfa(int i){  if(i == fa[i]) return i;  int newfa = getfa(fa[i]);  tofa[i] = ((tofa[i] + tofa[fa[i]])%n)%inner[newfa];  return fa[i] = newfa;}// new root u// u and v is old rootvoid link(int u,int v,int off){  fa[v] = u;  inner[u] = gcd(inner[u],inner[v]);  tofa[v] = off % inner[u];}int main(){  n = read();  ll q = read();  ll ans = n*n;  iota(fa,fa+n,0);  fill(inner,inner+n,n);  rep(i,0,q){    rep(j,0,4) a[j] = read();    per(j,0,4) (a[j] += n-a[0])%=n;    int g1 = a[1] - a[0];    int g2 = (a[3]-a[2]+n)%n;    int off = a[2] - a[0];    int f1 = getfa(g1);    int f2 = getfa(g2);    // 同组更新内部间隔    if(f1 == f2){      // ans -= inner[f1] - inner[f1];      // printf(&quot;SAME %d[%d] =&gt; &quot;,f1,inner[f1]);      ans -= inner[f1];      inner[f1] = gcd(inner[f1], 2*n + tofa[g1] - tofa[g2] + off); // 不是off      ans -= -inner[f1];      // printf(&quot;%d \n&quot;,inner[f1]);    }else{ // 不同组 合并组      // printf(&quot;DIFF %d[%d] + %d[%d] =&gt; &quot;,f1,inner[f1],f2,inner[f2]);      // g1-&gt;f1, g2-&gt;f2      // f2-&gt;f1?      // f1 - f2 = (f1 - g1) - (f2 - g2) + (g2 - g1)      // ans -= inner[f1] + inner[f2] - inner[f1];      ans -= inner[f1] + inner[f2];      link(f1,f2, (2*n + tofa[g1] - tofa[g2] + off)%n);      ans -=  - inner[f1];      // printf(&quot;%d \n&quot;,inner[f1]);    }    printf(&quot;%lld\n&quot;,ans);  }  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>C</p><p>这个基本的能想到, 但是没有尝试更多数据, 去考虑它的唯一性, 还在想怎么填中间的</p><p>这方面要培养,有点像反过来想题目, 如果题目本身设计上有唯一性只是需要证明, 这个思路方向, 因为毕竟是确定有答案的题目而不是开放性问题</p><p>另外就是括号序列还是不熟悉, 如果熟悉常见+1,-1套路,画图去思考也会简单不少</p><p>虽然从逻辑上 我的 当前前面未填完,则当前(,未填都是),  数学上好像 更多信息, 但这里反而成了干扰</p><p>据说能用DP做?</p><p>D</p><p>这数学性好强啊, 知识点是属于集合论的和数论的,甚至有点抽屉原理,</p><p>能想到奇数与它的2的幂次倍数的分组是这个题的核心一点</p><p>这一想出后面就自然很多了</p><p>E</p><p>我这赛后没有看题解,竟然AC了 ??????</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>官方题解 <a href="https://atcoder.jp/contests/arc141/editorial/" target="_blank" rel="noopener">https://atcoder.jp/contests/arc141/editorial/</a></p><p><a href="https://www.youtube.com/watch?v=_oUQyyjp4Wk" target="_blank" rel="noopener">官方youtube</a></p>]]></content>
      
      
      <categories>
          
          <category> Atcoder </category>
          
          <category> ARC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
            <tag> 并查集 </tag>
            
            <tag> 动归 </tag>
            
            <tag> 括号对 </tag>
            
            <tag> 集合 </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces 1685 C D1</title>
      <link href="/Blog/2022-06-01-CF1685_C_D1/"/>
      <url>/Blog/2022-06-01-CF1685_C_D1/</url>
      
        <content type="html"><![CDATA[<p>C(括号对,前缀和,数学)D1(构造,排列,并查集)</p><h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://codeforces.com/contest/1685/problem/C" target="_blank" rel="noopener">https://codeforces.com/contest/1685/problem/C</a></p><p>给你一个 n个左括号 n个右括号 的序列</p><p>最小次数, 翻转子区间,让整个括号合法</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>n 1e5</p><p>1s</p><p>256MB</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h3><p>括号嘛, 认知还在任意前缀1的个数大于等于0的个数</p><p>想的是先转换成0/1,两个指针包裹 两头贪心</p><p>没了, 没思路了, 感觉贪心都不对的</p><p>写了果然wa了</p><h3 id="官方"><a href="#官方" class="headerlink" title="官方"></a>官方</h3><p>别统计1和0, 直接 左括号1贡献,右括号-1贡献 XD</p><p>同样的也就是前缀和 大于等于0</p><p>一个数学结论, 至多两次就能让结果合法</p><p>如果 前缀i是 所有前缀中最大的,那么翻转 <code>[1..i]</code>和<code>[i+1,2n]</code> </p><p>因为 对于 j&lt;=i,新的前缀 newpre[j] = pre[i] - pre[j] &gt;= 0</p><p>因为 对于 j&gt; i,新的前缀 newpre[j] = pre[2n] - pre[j] + pre[i] = pre[i] - pre[j] &gt;= 0</p><hr><p>那么问题变成有没有办法一次翻转, 因为0次是直接合法,很容易判断,2次有上述方案</p><p>对于一次反转, 如果是<code>[L,R]</code>, 那么必然有 <code>L &lt;= 首个负前缀l, R&gt;= 最后一个负前缀r</code></p><p>再数学一点 对于 $i \in [L,R] $, <code>newpre = pre[R] - pre[i-1] + pre[L] &gt;= 0</code></p><p><code>pre[i-1] &lt;= pre[L] + pre[R]</code> 也就是 区间里所有的都不大于两头的和</p><p>而<code>pre[i]</code> 的可选值是 <code>[L..l-1][l..r][r+1..R]</code></p><p>注意到<code>[l..r]</code> 始终被选, 而两头的随着<code>L</code>和<code>R</code>变化</p><p>如果<code>L</code>选<code>[0..l-1]</code>中最大</p><p>如果<code>R</code>选<code>[r+1..2n]</code>中最大</p><p>那么对于两头的来说, 一定成立,而对<code>[l..r]</code> 来说 它们是能选到的最大的,如果这个还不满足,则没有办法了</p><p>如果这个满足则是答案</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://codeforces.com/contest/1685/submission/159099077" target="_blank" rel="noopener">https://codeforces.com/contest/1685/submission/159099077</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 1000000007#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // read// n对括号// reverse substringchar s[200010];int n;int pre[200010];void calc(int st){  int last = -1;  per(i,0,n){    if(pre[i+1] &lt; 0){      last = i;      break;    }  }  // printf(&quot;[%d %d]\n&quot;,st,last);  int ml = 0;  int mr = 0;  rep(i,0,st){    ml = max(ml,pre[i+1]);  }  rep(i,last,n){    mr = max(mr,pre[i+1]);  }  rep(i,st,last+1){    if(pre[i+1] &gt; ml+mr){      // rev2      printf(&quot;2\n&quot;);      int maxi = 0;      rep(i,0,n){        if(pre[i+1] &gt; pre[maxi]){          maxi = i+1;        }      }      printf(&quot;1 %d\n&quot;,maxi);      printf(&quot;%d %d\n&quot;,maxi+1,n);      return ;    }  }  printf(&quot;1\n&quot;);  int maxl = 0;  rep(i,0,st){    if(pre[i+1] &gt; pre[maxl]) maxl = i+1;  }  int maxr = n-1;  rep(i,last,n){    if(pre[i+1] &gt; pre[maxr]) maxr = i+1;  }  printf(&quot;%d %d\n&quot;,maxl+1,maxr);}void w(){  n = read();  n*=2;  scanf(&quot;%s&quot;,s);  rep(i,0,n) pre[i+1] = pre[i] + (s[i] ==&#39;(&#39;?1:-1);  rep(i,0,n){    if(pre[i+1] &lt; 0){      calc(i);      return ;    }  }  printf(&quot;0\n&quot;);}int main(){  int t = read();  while(t--)w();  return 0;}</code></pre><h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p><a href="https://codeforces.com/contest/1685/problem/D1" target="_blank" rel="noopener">https://codeforces.com/contest/1685/problem/D1</a></p><p><a href="https://codeforces.com/contest/1685/problem/D2" target="_blank" rel="noopener">https://codeforces.com/contest/1685/problem/D2</a></p><p>给一个1到n的排列p</p><p>定义一个排列p的代价为</p><p>$\sum {q_i - p_{q_{i+1}}}$</p><p>找最小代价的排列q</p><p>D2: Hard version: 最小代价排列中字典序最小的</p><h2 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h2><p>t 100 组测试</p><p>n 200, $\sum{n} \le 400$</p><p>1s</p><p>256mb</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h3><p>注意到上面的求和表达式,也就是每一项和它的后一项的差的绝对值,</p><p>那么如果一个排列q合法,那么 对它循环的旋转也合法</p><p>再来看期望最小值, 如果能够成 |1-1|+..+|v-v| ,全部是相同相减, 那么最小就是0, 而这种需要所有的跳转关系构成一个大环, 而这样解法也就唯一(对于循环的最小来说)</p><p>以样例中的2 1, =&gt; |1 - (P2=1)| + |2 - (P1=2)| = 0</p><p>对于不够成大环的, 必定跳转关系是多个小环</p><p>以样例中的2 3 1 4, 这样 是 1-&gt;3-&gt;2 构成环 ,4 单独一个环, 那么如果让环内代价为0, 那剩下的就是两头的链接代价, </p><p>|1 - (P3=1)| + |3 - (P2=3)| + |2 - (P4=4)| + |4 - (P1=2)| = 2+2</p><p>|3 - (P2=3)| + |2 - (P1=2)| + |1 - (P4=4)| + |4 - (P3=1)| = 3+3</p><p>|2 - (P1=2)| + |1 - (P3=1)| + |3 - (P4=4)| + |4 - (P2=3)| = 1+1</p><p>其实是环中选出一个值 和 其它环作拼接, (这里保证环内最小 不知道细节怎么证,但感觉看起来这样贪没啥问题</p><p>再比如样例 5 4 3 2 1, 环分别是 1-&gt;5, 2-&gt;4, 3</p><p>分别拿出来1,2,3</p><p>(5-&gt;1) (3) (4-&gt;2)</p><p>代价就是 |1-3| + |3-2| + |2-1|</p><p>这里也很清晰的是, 这样如果确定了拿出来的值,那么最小代价 = 2|max - min|</p><hr><p>综上所述</p><ol><li><p>找环</p></li><li><p>每个环拿出一个值来连接, 让所有拿出来的值 最大减最小尽量小, 这样D1 做完了</p></li><li><p>需要在这样的方法中, 1. 正负顺序, 2, 循环平移到1开始 的字典序列最小</p></li></ol><hr><p>问题来了</p><p>找环很简单, 但是如何让每个环拿出来一个值,差尽量小?</p><p>这里我想到的是染色+滑动窗口, 记录最小的滑动窗口和位置</p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 1000000007#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readint p[210];int p2i[210];int c[210]; // 染色void w(){  int n = read();  fill(c+1,c+n+1,-1);  rep(i,1,n+1) {    p[i] = read();    p2i[p[i]] = i;  }  int color = 0;  rep(i,1,n+1) {    if(~c[i])continue;    int itr = i;    do{      c[itr] = color;      itr = p2i[itr];    }while(itr != i);    color++;  }  // 单个环唯一  if(color == 1){    int itr = 1;    do{      printf(&quot;%d &quot;,itr);      itr = p2i[itr];    }while(itr != 1);    printf(&quot;\n&quot;);    return ;  }  vector&lt;int&gt;cnt(color,0); // 当前滑窗各种颜色个数  // 答案 起始位置  int ansst = 0;  int anssz = n+1;  // 滑窗  int l = 1;  int r = 0;  int cur = 0; // 滑窗内颜色种数  while(cur &lt; color &amp;&amp; r+1 &lt; n+1) if(++cnt[c[++r]] == 1) cur ++;  // [l..r] 包含所有颜色  while(l &lt;= r){    if( r-l+1 &lt;= anssz){      anssz = r-l+1;      ansst = l;      // printf(&quot;[%d %d]\n&quot;,l,r);    }    if( -- cnt[c[l++]] == 0 ) cur--;    while(cur &lt; color &amp;&amp; r+1 &lt; n+1){      ++r;      cnt[c[r]] ++;      if(cnt[c[r]] == 1) cur ++;    }    if(cur &lt; color)break;  }  // [ansst..ansst+anssz-1]  fill(c+1,c+n+1,-1);  rep(i,ansst,ansst+anssz - 1 + 1){    if(~c[i])continue;    int itr = i;    do{      printf(&quot;%d &quot;,p2i[itr]);      c[itr] = 1;      itr = p2i[itr];    }while(itr != i);  }  printf(&quot;\n&quot;);}int main(){  int t = read();  while(t--)w();  return 0;}</code></pre><p>然而实现以后wa2的第11个样例了</p><pre><code>41 3 2 4</code></pre><p>如果按照我上面所说的, (2,3) (1) (4) 这样的三个环, 那么 最大最小差是|4-1| = 3, 所以答案是6</p><p>然而, 给了一个拆掉环还更小的方法</p><p>q = <code>1 3 4 2</code></p><p><code>|1 - P3| + |3 - P4| + |4 - P2| + |2 - P1| = |1 - 2| + |3 - 4| + |4 - 3| + |2 - 1| = 4</code></p><p>emmmmmmm</p><p>所以我的思路的细节并卜行</p><h3 id="官方-D1"><a href="#官方-D1" class="headerlink" title="官方 D1"></a>官方 D1</h3><p>也是先考虑什么时候可以得到零</p><p>也是按照 跳转构成的环 来看, 假设有k个环</p><p>跨环 的链接 至少是1, 所以下界是 2(k-1)</p><hr><p>给出一种构造方法</p><p>初始化 p1 = p</p><p>for x = 1..n-1 如果 对当前p1 来说 x和 x+1在不同的环中, 则交换他们</p><p>显然根据学过的 排列的环的性质来讲, 每次交换两个环里的值 相当于把两个环合并</p><p>那么 也就是k-1次操作就可以全部合并成一个环</p><hr><p>最后 $q_i = p1_{q_{i+1}}$ 了, 显然这就是一个环, 这个答案对于p1来说,就是0</p><p>但我们求的是对于p</p><p>$|q_i - p1_{q_{i+1}}| = |p1_{q_{i+1}} - p_{q_{i+1}}|$ 了, 反过来看操作毕竟交换是对称的, 考虑从p1变到p, 每一次交换至多会让结果+2, 因为交换的是两个相邻的值, 所以 答案不大于2(k-1)</p><p>综上 从下界看 不小于2(k-1),  从操作上看不大于2(k-1), 所以这个方案就是2(k-1)</p><hr><p>至此 并查集随便搞一搞 D1 就做了</p><p>D2 现场只有4个人AC了 XD</p><p>pi向i连一条有向边</p><p>问题变成, 添加一些 i-&gt;i-1 和  i-1 -&gt; i 变成 存在欧拉回路</p><p>其实和上面 等价的, 这里的环和上面的边对应, 而成欧拉回路, 就是和变成新的环</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><h3 id="D1"><a href="#D1" class="headerlink" title="D1"></a>D1</h3><p><a href="https://codeforces.com/contest/1685/submission/159201728" target="_blank" rel="noopener">https://codeforces.com/contest/1685/submission/159201728</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 1000000007#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readint p[210];int p2i[210];int vis[210]; // 染色int fa[210];int getfa(int i){ return i==fa[i]?i:(fa[i] = getfa(fa[i]));}void link(int u,int v){  int fu = getfa(u);  int fv = getfa(v);  if(fu == fv)return;  fa[fu] = fv;}void w(){  int n = read();  fill(vis+1,vis+n+1,false);  iota(fa,fa+n+1,0);  rep(i,1,n+1) {    p[i] = read();    p2i[p[i]] = i;  }  rep(i,1,n+1){    if(vis[i])continue;    int itr = i;    do{      vis[itr] = true;      link(itr,i);      itr = p2i[itr];    }while(itr != i);  }  rep(v,1,n){    if(getfa(v) == getfa(v+1))continue;    swap(p[p2i[v]],p[p2i[v+1]]);    swap(p2i[v],p2i[v+1]);    link(v,v+1);  }  int itr = 1;  do{    printf(&quot;%d &quot;,itr);    itr = p2i[itr];  }while(itr != 1);  printf(&quot;\n&quot;);}int main(){  int t = read();  while(t--)w();  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>C</p><p>括号匹配还是不熟, 1,-1贡献 比1和0统计好很多</p><p>这最大值翻转只需要两次也是妙啊</p><p>后面的切割和最值</p><p>完全就是math,math,math</p><p>D1</p><p>想到环 和 环之间是好的</p><p>但是我构造能力实在是太菜了</p><p>而且下界估计想法也有问题,错误的下界估计也会影响思路</p><p>感觉这个题还是属于排列的环相关的知识点</p><p>然后有上下界相等, 和操作与逆向操作对结果的影响</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://codeforces.com/blog/entry/103198" target="_blank" rel="noopener">官方</a></p><p><a href="https://www.cnblogs.com/QQQ0000/p/16321569.html" target="_blank" rel="noopener">https://www.cnblogs.com/QQQ0000/p/16321569.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 前缀和 </tag>
            
            <tag> 构造 </tag>
            
            <tag> 排列 </tag>
            
            <tag> 括号对 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces 1682EF</title>
      <link href="/Blog/2022-05-29-CF1682EF/"/>
      <url>/Blog/2022-05-29-CF1682EF/</url>
      
        <content type="html"><![CDATA[<p>E(排序,排列,拓扑排序,数学,无代码)F(网络流,二分图,排序,树状数组,扫描线, 前缀和,离线,差分)</p><h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://codeforces.com/contest/1682/problem/E" target="_blank" rel="noopener">https://codeforces.com/contest/1682/problem/E</a></p><p>给一个不含重复数字的<code>1~n</code>的排列数组a</p><p>然后有人通过m次交换,让数组有序, 每次交换记录了被交换数字的坐标(i,j)</p><p>其中交换次数是最小次数</p><p>现在把交换的坐标对的顺序打乱了给你, 问怎么把交换数组重排序让它恢复, 保证合法</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>n 2e5</p><p>m &lt;= n-1</p><p>ai &lt;= n</p><p>2s</p><p>256MB</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h3><p>先考虑自己会怎么交换,能够最小的次数</p><p>如果给你的数组, 有多个坐标和值构成环 , 那么最小次数 = (这些环长-1)的和</p><p>而每次交换一定让一个位置跑到合法的位置上,并且跑到合法以后不会再动这个位置</p><p>因此两个位置只会出现一次不会重复</p><p>或者从环的角度看,一次操作,就是 让环的一条边没了连接环的两端</p><p>所以考虑类似做拓扑排序, 每次选择一个 交换后有合法产生且能让 目标不再被操作的进行处理</p><p>问题在比赛时重复添加的bug没考虑清楚, 但即使修复了重复添加 依然wa5</p><h3 id="官方"><a href="#官方" class="headerlink" title="官方"></a>官方</h3><p>还好wa5数据小(当然比赛时看不了数据</p><pre><code>4 32 3 4 11 22 43 4</code></pre><p>果然我想的交换 虽然次数上表述是对的,但是操作上不一定是删了环上的边,</p><p>而是可以交换环上任意两点, 这样的话, 如果是环边,就是环-1</p><p>如果不是环边实际上是把环切割成两个小环,而总代价不会减少</p><p>而如果是这样,上面的实现当然也不对了,不再是交换后不会再交换了</p><hr><p>举一个例子来说</p><p> <code>a-&gt;b-&gt;c-&gt;d-&gt;e-&gt;f-&gt;a</code>: 意思是位置a的值应该要去位置b, 位置b的值应该要去位置c …</p><p> 那么如果交换了<code>位置a</code>和<code>位置e</code></p><p> 那么新的来说 <code>位置e</code>的值需要去位置<code>b</code></p><p> 也就是说当发生(位置i,位置j) 交换以后</p><p> i和j就不再属于同一个环了, 并且它们分别属于它们的来源的环</p><p> 再去掉无关的抽象一次 <code>x0-&gt;x1-&gt;....-&gt;y0-&gt;y1-&gt;...</code>, 如果(x1,y1)交换, 则得到这样两个环 <code>x0-&gt;x1) (....-&gt;y0-&gt;y1) (...</code></p><hr><p>这样于是就有了 假设x和多个y换,如(x,y0),(x,y1)</p><p><code>x-&gt;....-&gt;y0-&gt;...-&gt;y1-&gt;...</code>,</p><p>那么对于x来说,它和这些y的顺序一定是按箭头方向从近到远的</p><p>因为 如果先换了y1,就会变成<code>x) (...-&gt;y0-&gt;...-&gt;y1) (...</code>, 这样x都和y0不在同一个环上,再交换会合并环而不是拆环了</p><p>那么对于有x的所有交换就有了拓扑关系, 因为交换的对称性, 所有的交换序列都有了拓扑关系, 然后建立个拓扑图, 随便拓扑排序一下就好了</p><hr><p>实现要素</p><p>找环, vis数组 + dfs 随便搞</p><p>把交换和环一起处理, <code>vector&lt;int&gt; [idx] =</code> 发生了的交换</p><p>环上可以做的是值 -&gt; 下标</p><p>建立拓扑, 再从环中提取这些交换 并建立拓扑, 判断前后就是 <code>(下标差 + 环长)% 环长</code> 就知道前后了</p><p>拓扑排序, 维护入度计数 和 入度为0的点的数组</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>无(鸽子)</p><h1 id="F"><a href="#F" class="headerlink" title="F"></a>F</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p><a href="https://codeforces.com/contest/1682/problem/F" target="_blank" rel="noopener">https://codeforces.com/contest/1682/problem/F</a></p><p>长n 数组a, 非严格递增排序</p><p>长n 数组b, bi != 0</p><p>一共q组询问,每次询问l,r, 保证sum(b[l..r]) == 0</p><p>b[l..r] 中 小于0的点作为左侧点, 大于0的点作为右侧点, 建立二分图</p><p>左侧点i 向 右侧点j 有一条 无限容量,每单位flow代价 为 abs(ai - aj) 的边</p><p>源点S, 汇点T</p><p><code>S-&gt;左侧i</code>, cost = 0, 容量|bi|</p><p><code>右侧j-&gt;T</code>, cost = 0, 容量|bj|</p><p>问你, 图的最大流的最小cost为多少, 答案 mod 1e9+7</p><h2 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h2><p>n 2e5</p><p>q 2e5</p><p>ai [0,1e9]</p><p>bi [-1e9,1e9], bi != 0</p><p>3s</p><p>256mb</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h3><p>而如果和为零,其实也就是说 负数和 = 正数和</p><p>那么建立的图,左右侧点连接的边都是无限容量, 而和源点汇点的边容量为 |bi|</p><p>所以其实最大流显然是 abs|负数和/或正数和|</p><p>换句话说 不需要S和T</p><p>就是每个左侧点发出|bi|的流量,每个右侧点接受|bi|的流量, 然后 左侧i到右侧j, 的无线容量的边,每单位流量 = |ai-aj|的代价</p><p>问最小代价</p><hr><p>如果单次, 贪心</p><p>是不是左侧按照ai大小排序,右侧也按照ai大小排序</p><p>然后每次最小未输的左侧和右侧点进行1单位flow</p><p>证明, 如果有交差(左小到右大,右小到左大)那么必然交换1单位结果更小,而唯一不存在交叉的就是都按照ai排序</p><p>代价 = ai排序后 对应输送</p><p>或者看成所有的 |bi|个ai 进行排序分别得到l数组和r数组</p><p>然后答案 <code>= sum{abs(r[i] - l[i])}</code></p><p>这样如果是单次查询就没啥东西</p><hr><p>题目条件中说了ai非严格单调递增</p><p>因此不需要自己去排序了</p><p>但我并不知道怎么维护,能进行多次查询</p><h3 id="官方-1"><a href="#官方-1" class="headerlink" title="官方"></a>官方</h3><p>上面我的思路的结论是没问题的,但是在计算代价时实际上可以变成 不是去排序</p><p>初始化, 大于零和小于零bi绝对值和都为0, 分别记作 S+, S-,</p><p>然后遍历i从l到r, 每次遍历后更新S+,S-</p><p>如果 当前bi &gt; 0 且 S+ &gt;= S-, 那么说明 这一部分的ai在计算绝对值时全部取负号,因为它要和比它大的ai配</p><p>所以贡献为 -ai * |bi|</p><p>如果 当前bi &gt; 0 且 S+ &lt; S-, 那么说明 这一部分的ai在计算绝对值时, 有min((S-) - (S+), |bi|)个取负号, 剩下的取负号,因为它一部分和前面配对,一部分和后面配对</p><p>所以贡献为 ai <em> min((S-) - (S+),|bi|) - ai </em> (|bi| - min((S-)-(S+),|bi|)) = ai * (2min((S-)-(S+),|bi|) - |bi|)</p><p>如果 当前bi &lt; 0 且 S+ &lt;= S-, 那么说明 这一部分的ai在计算绝对值时全部取负号,因为它要和比它大的ai配</p><p>所以贡献为 -ai * |bi|,和上面同理</p><p>bi&lt;0, S+ &gt; S- 也是一样的</p><p>综上 都需要ai乘, 那么变化的是ai的贡献的次数, 而这个次数相关的就是 [b[l]..b[i-1]] 的正负绝对值和的差, 再和bi的大小关系</p><p>显然 这样的思考方式比我排序依次减和绝对值求和的效率高,因为对于每个i是O(1)的,总代价就是O(r-l), 而我的那样需要O(sum(|b[l..r]|))</p><p>而上面的 (S+)-(S-) 其实 等于 sum{b[l..i-1]}</p><hr><p>后缀 变形(也可以前缀变形,同理, 计算[0..i]</p><p>如果按上述的方法,计算了 [i..n] 的结果, 记录为 res[i]</p><p>那么对于查询[l..r], 且 sum{b[l..r]} == 0, 那么答案就是 res[l] - res[r+1], 因为 [l..r]为0了, 所以从r+1开始向后运算时, 一定是正负绝对值差是0</p><p>当然这个直接暴力计算res的代价是$O(n^2)$</p><p>反过来从贡献角度考虑</p><p>a[i] 要 贡献给 res[j], j&lt;=i</p><p>与 ai,bi, sum{b[j..i-1]} = pre[i-1] - pre[j-1] 有关</p><p>而对于具体的i, ai,bi,pre[i-1]是常量, pre[j-1]随着j变化</p><p>pre[i-1]-pre[j-1] 根据上面的推论, 有两头段会让a[i] 常数贡献, 中间一段与pre[j-1]线性关系</p><p>考虑 {pre[j-1],j } 二元组排序, 注意 j&lt;=i 的范围限制</p><p>然后就变成 区间贡献统计, 区间线性贡献统计, 上树状数组或者线段树?</p><hr><p>具体一点</p><p>前缀和$p_i = \sum_{k=1}^{i} b_k$</p><p>$j \le i$</p><hr><p>$b_i &gt; 0$ 时</p><p>若 $p_{i-1} - p_{j-1} \ge 0$, 有 $res_j += a_i * -b_i $</p><p>若 $p_{i-1} - p_{j-1} \le -b_i$, 有 $res_j += a_i * b_i $</p><p>若 $-b_i &lt; p_{i-1} - p_{j-1} &lt; 0$, 有 $res_j += a_i * ( 2p_{j-1} - 2p_{i-1} - b_i ) $</p><hr><p>$b_i &lt; 0$ 时</p><p>若 $p_{i-1} - p_{j-1} \le 0$, 有 $res_j += a_i * -b_i $</p><p>若 $p_{i-1} - p_{j-1} \ge - b_i$, 有 $res_j += a_i * b_i $</p><p>若 $ 0 &lt; p_{i-1} - p_{j-1} &lt; - b_i $, 有 $res_j += a_i * ( 2p_{j-1} - 2p_{i-1} - b_i ) $</p><hr><p>问题是, 不只是需要 满足 大小关系, 还需要范围, 而且p的排序后下标就不再连续</p><p>先不考虑$j \le i$</p><p>建立个 下标数组, 按照$p_i$ 大小排序</p><p>那么 对于i 来说, 它对三个连续范围内每个贡献 常数($a_i \cdot -b_i$ 或 $ a_i \cdot b_i $ 或 $ a_i \cdot (-2p_{i-1} - b_i) $) / 线性函数的系数 $2a_i$</p><p>这样 当你要求具体 查一个位置的时候, 就树状数组 求点值</p><p>而这个操作 可以通过 差分数组+树状数组完成, 范围增加 = 范围起始点差值+, 范围结束点差值-, 单点值 = 前缀和</p><hr><p>剩下的问题是如何控制$j \le i$</p><p>考虑扫描指针,先让所有点都贡献,然后 随着扫描指针从1到n,增加它的反贡献 相当于去掉它的贡献</p><p>这样的话我们就能算出每个<code>res[i] =</code> 单点常数 + 单点线性系数$\cdot p_{i-1}$</p><p>最后所有询问 直接 <code>res[l] - res[r+1]</code></p><h3 id="jiangly"><a href="#jiangly" class="headerlink" title="jiangly"></a>jiangly</h3><p>似乎jiangly的比官方题解更简单, 他做了a数组的差分, 直接用差分和前缀b算的, 没有再用原始的b和a了</p><p>在白板上画了一下jiangly老哥的代码</p><p>发现jiangly老哥的想法其实 有点牛顿积分-&gt;勒贝格积分的味道</p><p><img src="/Blog/img/CF1682F.png" alt></p><p>$i \in [l,r]$</p><p>我们以<code>a[i]-a[i-1]</code> 这段间隔贡献的长度来看</p><p>发现, 假设以<code>j</code>开头,那么这段的贡献的长度为$|p_{i-1} - p_{j-1}|$</p><p><strong>鹅妹子嘤!!!!!</strong></p><p>这直接和单个bi没关系,也不用大于零小于零分类和范围分类讨论了, 只和b前缀和 与 a差分相关了</p><p>而且简洁到 对<code>ans[l..r]</code>贡献就是$(a[i] - a[i-1]) * |p_{i-1} - p_{l-1}|$</p><p>注意这里和题解也不一样, 不需要先后缀数组res, 再去求差, 直接算每个位置对答案的贡献</p><hr><p>剩下的就一样了</p><p>为了解决绝对值的问题, 对$p_i$排序</p><p>因为对于一个具体的查询来说 j是给定值,所以 你需要的是$(a[i] - a[i-1]) * p_{i-1}$的和 与 $a[i] - a[i-1]$ 的和</p><p>对于 $p_{i-1} &gt; p_{j-1}$ 的 正贡献,而 $p_{i-1} &lt; p_{j-1}$ 的负贡献</p><p>所以计算答案时, 从$p_i$ 从小到达算, 并且根据$p_i$的指针更新 每个位置i 贡献的正负</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p><a href="https://codeforces.com/contest/1682/submission/158828392" target="_blank" rel="noopener">https://codeforces.com/contest/1682/submission/158828392</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;// jiangly// https://codeforces.com/contest/1682/submission/158055817// power 和 norm 和std有冲突using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // read// 基于 mod P 的整数, structZconstexpr int P = 1000000007;// assume -P &lt;= x &lt; 2Pint mynorm(int x) {  if (x &lt; 0) {    x += P;  }  if (x &gt;= P) {    x -= P;  }  return x;}template&lt;class T&gt;T mypow(T a, ll b) {  T res = 1;  for (; b; b /= 2, a *= a) {    if (b % 2) {      res *= a;    }  }  return res;}struct Z {  int x;  Z(int x = 0) : x(mynorm(x)) {}  Z(ll x) : x(mynorm(x % P)) {}  int val() const {    return x;  }  Z operator-() const {    return Z(mynorm(P - x));  }  Z inv() const {    assert(x != 0);    return mypow(*this, P - 2);  }  Z &amp;operator*=(const Z &amp;rhs) {    x = ll(x) * rhs.x % P;    return *this;  }  Z &amp;operator+=(const Z &amp;rhs) {    x = mynorm(x + rhs.x);    return *this;  }  Z &amp;operator-=(const Z &amp;rhs) {    x = mynorm(x - rhs.x);    return *this;  }  Z &amp;operator/=(const Z &amp;rhs) {    return *this *= rhs.inv();  }  friend Z operator*(const Z &amp;lhs, const Z &amp;rhs) {    Z res = lhs;    res *= rhs;    return res;  }  friend Z operator+(const Z &amp;lhs, const Z &amp;rhs) {    Z res = lhs;    res += rhs;    return res;  }  friend Z operator-(const Z &amp;lhs, const Z &amp;rhs) {    Z res = lhs;    res -= rhs;    return res;  }  friend Z operator/(const Z &amp;lhs, const Z &amp;rhs) {    Z res = lhs;    res /= rhs;    return res;  }  friend istream &amp;operator&gt;&gt;(istream &amp;is, Z &amp;a) {    ll v;    is &gt;&gt; v;    a = Z(v);    return is;  }  friend ostream &amp;operator&lt;&lt;(ostream &amp;os, const Z &amp;a) {    return os &lt;&lt; a.val();  }};// 树状数组 0-indextemplate &lt;typename T&gt;struct Fenwick {  const int n;  vector&lt;T&gt; a;  Fenwick(int n) : n(n){    a.resize(n);  }  // [x] += v  void add(int x, T v) {    for (int i = x + 1; i &lt;= n; i += i &amp; -i) {      a[i - 1] += v;    }  }  // [0..x)  T sum(int x) {    T ans = 0;    for (int i = x; i &gt; 0; i -= i &amp; -i) {      ans += a[i - 1];    }    return ans;  }  // [l,r)  T rangeSum(int l, int r) {    return sum(r) - sum(l);  }};int main() {  int n = read(), q = read();  vector&lt;int&gt; a(n);  vector&lt;ll&gt; b(n + 1);  rep(i,0,n) a[i] = read();  // 倒序做差分  per(i,1,n) a[i] -= a[i - 1];  rep(i,1,n+1) {    b[i] = read();    // 前缀和    b[i] += b[i - 1];  }  // 离线  vector&lt;array&lt;ll, 4&gt;&gt; qry(q); // 查询 按照 {b[l-1],l-1,r,qidx} 排序  rep(i,0,q) {    int l = read()-1, r = read();    qry[i] = {b[l], l, r, i};  }  sort(qry.begin(), qry.end());  // https://en.cppreference.com/w/cpp/algorithm/ranges/iota  // https://www.cplusplus.com/reference/numeric/iota/  // 按照bi 前缀和 大小排序下标  vector&lt;int&gt; p(n);  iota(p.begin(), p.end(), 0);  sort(p.begin(), p.end(), [&amp;](int i, int j) { return b[i] &lt; b[j]; });  Fenwick&lt;Z&gt; s(n), c(n);  rep(i,0,n) {    // 先全部正贡献    s.add(i, Z(b[i]) * a[i]);    c.add(i, a[i]);  }  vector&lt;Z&gt; ans(q);  int j = 0;  for (auto [v, l, r, i] : qry) {    while (j &lt; n &amp;&amp; b[p[j]] &lt;= v) { // 根据 bi 前缀大小 决定贡献正负      int k = p[j++];      // 树状数组不支持修改, 只支持增量 ,实际是改成负贡献      s.add(k, -2*Z(b[k]) * a[k]);      c.add(k, -2*a[k]);    }    ans[i] = s.rangeSum(l, r) - c.rangeSum(l, r) * v;  }  for (auto x : ans) {    printf(&quot;%d\n&quot;,x.val());  }  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>E 的关键在于</p><p>不只有相邻的可以换, 不相邻的同环上也可以换(Wa5, 这点还是<strong>应该枚举稍微大一点的</strong>, 其实wa5 的点数才4</p><p>交换同环 = 拆环, 交换异环 = 合环</p><p>而交换两点,<strong> 这两点分别属于它们前个点的环</strong> 从而推得 同点和其它点多次交换时的先后顺序</p><p>有了先后顺序的逻辑,后面拓扑就无脑做了</p><p>F</p><p>简化的部分做了</p><p>但是 在排序对应 相减 取 绝对值 求和的部分, 没有想到怎么转换成 正负号标记, 还是说明绝对值相关知识点不够熟练</p><p>而即使看题解时 知道了这样转化, 也没有变成后缀来求的思路, 还在想分治</p><p>而且后缀的思路也是提供一个叫 无效答案同规则的差是可以得到有效答案的, 就像函数补充中间点一样</p><hr><p>看jiangly的代码, 一个是 基于mod的 struct,可以让逻辑代码里完全不需要写mod 也不用担心写掉, 减少心智负担</p><p>第二个是 没有 using namespace std 减少碰撞</p><p>iota 可以填数组, sort+lambda 简化排序</p><p>另外就是 using namespace std; 是个坏习惯, 比如这里norm和power就有冲突</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://codeforces.com/blog/entry/103097" target="_blank" rel="noopener">官方</a></p><p><a href="https://codeforces.com/contest/1682/submission/158055817" target="_blank" rel="noopener">jiangly</a></p>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络流 </tag>
            
            <tag> 扫描线 </tag>
            
            <tag> 排序 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 树状数组 </tag>
            
            <tag> 前缀和 </tag>
            
            <tag> 离线 </tag>
            
            <tag> 二分图 </tag>
            
            <tag> 排列 </tag>
            
            <tag> 拓扑排序 </tag>
            
            <tag> 差分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces 1684FGH</title>
      <link href="/Blog/2022-05-28-CF1684FGH/"/>
      <url>/Blog/2022-05-28-CF1684FGH/</url>
      
        <content type="html"><![CDATA[<p>F(双指针,滑窗,同值跳点,前缀最值)G(二分图匹配,数学)H(构造,分治,小值枚举,无代码)</p><h1 id="F"><a href="#F" class="headerlink" title="F"></a>F</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://codeforces.com/contest/1684/problem/F" target="_blank" rel="noopener">https://codeforces.com/contest/1684/problem/F</a></p><p>长n数组a</p><p>m个区间[l,r]</p><p>自己任选一个范围(与上面的区间无关),修改区间中所有值成任意值, 让上面区间每个区间都没有重复的数</p><p>问 你任选的区间最短长度</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>n 2e5</p><p>m 2e5</p><p>ai 1e9</p><p>2s</p><p>256MB</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h3><p>ai和n不成比例,与具体值无关, 无脑离散化一下,把ai范围降低到n</p><p>对于一个区间[l,r], 如果覆盖了一侧,如[l0,r],那么其实很好求l0的最大值(因为要区间尽量小</p><p>只需要通过<code>v2idx[v] = last index</code>, 跳一跳就行了</p><p>那么其实可以得到 这些l0 中最小的l0, 记为 L, 同样可以得到最大的R</p><p>那么 答案一定是包含了<code>[L,R]</code>的</p><p>那么问题变成了, 如果就是给你一个区间,但是是部分覆盖如何做到最短, [l,r] 你要找 <code>[l...[L..R]...r]</code></p><p>其中 <code>[l..L-1][R+1..r]</code> 不存在重复的数,还要<code>[L,R]</code>最短</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>如果答案是<code>[L,R]</code> 也就是 任何给的线段[l,r]中,不存在相同值都不属于<code>[L,R]</code>,</p><p>先让<code>L = 1</code>, 那么找<code>r</code> 跟上面说的一样, 找到max(min(ri))</p><p>然后,如果L左移1,R会如何变化</p><p>如果<code>[L+1,R]</code> 满足则就是<code>R</code>否则<code>R</code>只能增大, 甚至 <code>L+1</code>就无法合法了</p><p>注意到 如果有同样的<code>l</code> ,那么只用考虑<code>r</code>更大的即可</p><hr><p><code>[L..R] =&gt; [L+1..?]</code></p><p>首先 如果 <code>[lastpos[v[L]]...L]</code> 被包含在某个区间中, 那么必定不可行, 之后更大的L也不可行了break掉</p><p>如果 大于R的 value = v[L]的 位置在p</p><p>且<code>[L...p]</code>在某个区间中, 那么必定<code>[L+1..R]</code>不合法</p><p><code>[L+1...p]</code> 则是新的合法的</p><hr><p>上面两个都需要的是查询 左端点在<code>[0...pos]</code> 中的给定线段, 右侧端点最大值</p><p>这个注意到是一次赋值,多次查询没有更改的,直接前缀最大值</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://codeforces.com/contest/1684/submission/158651275" target="_blank" rel="noopener">https://codeforces.com/contest/1684/submission/158651275</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb emplace_back#define all(x) (x).begin(), (x).end()#define pii pair&lt;int, int&gt;ll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readconst int N = 200000;int f[N+10]; // 前缀最大值[前缀左端点] = 最大右侧端点ll a[N+10];vector&lt;int&gt; gist[N+10]; // gist[值] = vector&lt;int&gt; 下标pii seg[N+10]; // 题目给的线段ll mnl[N+10]; // mnl[ir] = 最小合法il =&gt; [il..ir]没有重复的数bool s[N+10]; // 存在过的数int n,m;void solve() {  // clear  fill(f,f+n,-1);  fill(gist,gist+n,vector&lt;int&gt;());  n = read();  m = read();  rep(i,0,n) a[i] = read();  // 离散一下  vector&lt;pii&gt; sa ;  rep(i,0,n) sa.push_back({a[i],i});  sort(all(sa));  rep(i,0,n) {    auto [v,j] = sa[i];    if(i == 0) a[j] = 0;    else if(v == sa[i-1].first) a[j] = a[sa[i-1].second];    else a[j] = a[sa[i-1].second] + 1;  }  rep(i,0,n) gist[a[i]].pb(i);  rep(i,0,m){    int l = read();    int r = read();    seg[i] = {--l,--r};    f[l] = max(f[l], r);  }  rep(i,1,n) f[i] = max(f[i-1],f[i]);  // 双指针 [il...ir] 没有重复的数  // mnl[ir] = 合法的最小il  int il = n;  per(ir,0,n){    while (il &amp;&amp; !s[a[il - 1]]) s[a[--il]] = true;    mnl[ir] = il;    s[a[ir]] = false;  }  // mnr 为L = 1 时 R的最小值 , [R+1..n] 要么就是 本身合法线段要么就是 [R+1..r] 合法  ll mnr = -1;  rep(i,0,m){    auto [l,r] = seg[i];    if (mnl[r] &lt;= l) continue; // 本身就合法 直接忽略    mnr = max(mnr, mnl[r] - 1);  }  if (mnr == -1) {    printf(&quot;0\n&quot;);    return;  }  ll ans = mnr + 1;  // L 每次 +1  // [l..mnr] =&gt; [l+1..?]  rep(l,0,n-1){    // l 不是 a[l] 首次出现的位置    if (gist[a[l]][0] != l) {      // 上一个同样值的位置      int pr = *(--lower_bound(all(gist[a[l]]), l));      // 左端点小于等于 pr, 的最大右端点, 如果删除了 就会有区间包含[pr...l] 有两个a[l]      // 再移动 就不可能了, 所以直接break      if (f[pr] &gt;= l) break;    }    // 下一个 为a[l] 的 且在某个区间中    if (gist[a[l]].back() &gt; mnr ) {      int nxt = *upper_bound(all(gist[a[l]]), mnr);      if (f[l] &gt;= nxt) mnr = nxt;    }    assert(mnr &gt; l);    ans = min(ans, mnr - l);  }  printf(&quot;%lld\n&quot;,ans);}int main() {  int t = read();  while (t--) solve();  return 0;}</code></pre><h1 id="G"><a href="#G" class="headerlink" title="G"></a>G</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p><a href="https://codeforces.com/contest/1684/problem/G" target="_blank" rel="noopener">https://codeforces.com/contest/1684/problem/G</a></p><p>t 是一个数组</p><p>考虑Euclid求gcd</p><pre><code>function Euclid(a, b):    if a &lt; b:        swap(a, b)    if b == 0:        return a    r = reminder from dividing a by b    if r &gt; 0:        append r to the back of t    return Euclid(b, r)</code></pre><p>p 是一个包含不超过m的正数对的数组</p><p>t 初始为空</p><p>然后 对p的所有 数对 运行上述算法</p><p>t然后被打乱了给你</p><p>你需要找一个 数组, len &lt;= 2e4, 能产生 t, 或者判断它不可能存在</p><h2 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h2><p>len(t) 1e3</p><p>m 1e9</p><p>1 &lt;= ti &lt;= m</p><p>1s</p><p>256mb</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h3><p>其实就是 辗转相除<code>(a,b), a&gt;b</code> 中间的所有非零余数</p><p><code>b &gt; v, a &gt;= b + v &gt; 2v</code></p><p>所以如果有值不满足<code>m &gt; 2v</code> 则直接不可能输出-1</p><p>否则直接无脑<code>2v+1,v+1</code>?, 但注意到<code>2v+1,v+1,v,1</code> 还会产生1, 也就是不行的</p><p>另外<code>3v,2v,v</code> 不会有额外产生,如果有多余的<code>3v &lt;= m</code> 可以这样处理掉</p><p>所以只用考虑<code>3v &gt; m &gt; 2v</code> 的v值<code>m/2 &gt; v &gt; m/3</code> (非整除)</p><p><code>a = 2v+i,b = v+i,v,i,...</code> (i &lt;= m-2v &lt; v)</p><p>但怎么选i, 以及处理之后的余数,并没有任何想法</p><p>v的选择可以从大到小, 这样也可能消耗掉 一部分 <code>m/2 &gt; v &gt; m/3</code></p><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>一样 先把v的范围限定在了<code>3v &gt; m &gt; 2v</code>, 范围以外的和我想的一样的处理</p><p><code>m &gt;= a=2v+i,b=v+i,v,i,...</code></p><p>也就是考虑到 <code>2v + gcd(v,i) &lt;= 2v+i &lt;= m</code></p><p>也就是对于每个 <code>v &gt; m/3</code>, 一定存在一个是它因数的<code>x</code>,且<code>2v + x &lt;= 2m</code></p><p>于是建立二分图</p><p>左边 &gt; m/3, 右边 &lt;= m/3</p><p>做二分图匹配即可</p><hr><p>我的问题,在i 和 m/3大小判断错了, 其实<code>2v+i = a &lt;= m</code>和<code>v &gt; m/3</code> 就可以得到<code>i &lt; m/3</code>的</p><p>这样的话,v必然是靠小于等于m/3的消耗掉的,不如直接贪约数</p><p>有一说一,写起来其实会比F简单?</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p><a href="https://codeforces.com/contest/1684/submission/158654516" target="_blank" rel="noopener">https://codeforces.com/contest/1684/submission/158654516</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backll read(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // readconst int N = 1000;vector&lt;int&gt; g[N+10]; // g[二分图左端点] = vector&lt;&gt;右端点int with[N+10]; // with[右端点] = 链接的来源左端点int vis[N+10]; // 二分图每轮选左侧起始点时,是否访问到ll a[N+10];bool dfs(int v) {  if (vis[v]) return false;  vis[v] = 1;  // 直接就有可选终点  for (auto to : g[v]) {    if (with[to] == -1) {      with[to] = v;      return true;    }  }  // 递归走 v -&gt; to0 -&gt; with[to0] -&gt; t1 -&gt; with[t1] - ... -&gt; took  for (auto to : g[v]) {    if (dfs(with[to])) {      with[to] = v; // 更新指向      return true;    }  }  return false;}int main() {  int n = read();  int A = read();  // 二分图  vector&lt;ll&gt; l;  vector&lt;ll&gt; r;  rep(i,0,n) {    a[i] = read();    (3 * a[i] &gt; A ? l : r).pb(a[i]);  }  // 建立边  rep(i,0,l.size()) {    rep(j,0,r.size()) {      if (l[i] % r[j])continue;      if(2 * l[i] + r[j] &gt; A) continue;      g[i].pb(j);    }  }  // 二分图匹配  fill(with,with+r.size(),-1);  rep(i,0,l.size()) {    fill(vis,vis+l.size(),0);    if(!dfs(i)){      // 未消耗掉所有 &gt; m/3      printf(&quot;-1\n&quot;);      return 0;    }  }  vector&lt;pair&lt;ll,ll&gt;&gt; ans;  rep(j,0,r.size()) {    if (with[j] == -1) {      ans.pb({3 * r[j], 2 * r[j]}); // &lt;= m/3 的 直接 `3v,2v =&gt; v`    } else { // 2v+i,v+i =&gt; v,i      ans.pb({2 * l[with[j]] + r[j], l[with[j]] + r[j]});    }  }  printf(&quot;%d\n&quot;,(int)ans.size());  for (auto [a,b]: ans) printf(&quot;%lld %lld\n&quot;,a,b);  return 0;}</code></pre><h1 id="H"><a href="#H" class="headerlink" title="H"></a>H</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p><a href="https://codeforces.com/contest/1684/problem/H" target="_blank" rel="noopener">https://codeforces.com/contest/1684/problem/H</a></p><p>给0/1串s, 切分成任意多个不相交子串, 然后让这些子串表示的二进制值的和是2的幂次</p><h2 id="范围-2"><a href="#范围-2" class="headerlink" title="范围"></a>范围</h2><p>|s| 1e6</p><p>2s</p><p>256mb</p><h2 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h2><h3 id="我的思路-2"><a href="#我的思路-2" class="headerlink" title="我的思路"></a>我的思路</h3><p>如果1的个数是2的幂次, 那么直接全部拆碎就完了</p><p>不妨设一共有$w$个1,且 $2^k &lt; w &lt; 2^{k+1}$</p><p>除了最后一位1, 任何一个1 都可变成2的贡献,不论是通过 11还是10, 它对w的贡献就是+1</p><p>但是如果连续的两个1,至多有一个可以贡献2,</p><p>同样除了最后两位1, 任何一个1 都可变成4的贡献,通过1XX, 对w贡献是+3</p><p>但是如果连续的三个中出现的1,至多有一个可以贡献4,</p><p>所以 (w-2)/3 个1 可以变成贡献4, 于是可以多贡献 (w-2)</p><p>但值得注意的是, 之所以 (w-2)/3 一个是因为尾部, 一个是因为 连续的3个中出现1, 才会不能让所有的1贡献4, 下限是(w-2)/3</p><p>这样的话,也就是说 有部分的贡献的是2, 总可以补全到$&gt;= 2^{k+1}$</p><pre><code>100 = 4 (+3)10,0 = 2 (+1)1,0,0 = 1101 = 5 (+3)10,1 = 3 (+1)1,0,1 = 2110 = 6 (+4)1,10 = 3 (+1)11,0 = 3 (+1)1,1,0 = 2111 = 7 (+4)11,1 = 4 (+1)1,1,1 = 3</code></pre><p>所以对于所有1开头的3位, 有的贡献可以+1,+3, 有的贡献可以+1,+4</p><p>2^{k+1}-1 &gt;= w &gt;= 2^k+1</p><p>所以 通过+3,+4 让w和 2^{k+1}的距离 在某个3元组能达到<code>[1,3]</code>之间, 剩下的<code>[1,3]</code>就靠<code>+1</code>补满</p><p>且, 注意到如果是靠不少+3达到的,那么剩余的长3的组一定还不少, 不会耗尽所有</p><p>所以w足够大时,必定可行</p><p>需要考虑w小的时候, 但多么小呢?</p><p>w = 1,2,4,8直接可行</p><p>w = 3 时, dst = 4. +1 必定可行</p><p>w = 5 时, dst = 8, 需要+3, <code>(111)(110)</code> 就是个不能用上面切割达到的</p><p>w = 6,7 时, dst = 8, 需要+2/+1, 必定两/一次+1可以达到</p><p>w = 9 时, dst = 16, 需要+7, <code>(111)(111)(111)</code> ,也是不能用上面切割达到</p><p>w = …</p><p>这块细节就不知道怎么搞, 也不知道大于多少以后w一定可以</p><h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><p>1,2,4,等2的幂次, 直接切碎</p><p>k = 3 可以用上面我说的方法</p><p>k = 5</p><p>如果1连续, 1111+1 = 10000</p><p>否则1之间存在0, 存在一个0,则101存在,多个0,则100存在. 101+1+1+1=1000, 100+1+1+1+1 = 1000</p><p>k &gt; 5</p><p>solve(l,r,k,n) 函数表示把有k个1的[l..r]段切来和为n</p><p>这里目标n也是放在 2的log(2,k)向上取整幂次, </p><p>足够大的n, 考虑是按照k 来切开, 让它分别为 k/2向下取整和 k/2向上取整, 并且 让它们的和都是 n/2</p><p>solve(l,r,k,n) = solve(l,pos,k/2,n/2) and solve(pos+1,r,k-k/2,n/2)</p><p>然后界限来就是说 k = 6..11 时 如何搞</p><hr><p>这里其实可以自己随便乱搞了,毕竟范围有限,目标明确</p><p>官方英文题解里有具体方法</p><hr><p>这里方法上有一个要注意的是, 当 1的个数是 <code>(2的幂次)+1</code> 时, 它期望切割出来的<code>2的(幂次-1)</code>那一部分还是需要到</p><p>比如 <code>17 = 16+1</code>个1, 期望的结果是 <code>2**5 = 32</code></p><p><code>17 = 8+9</code>, <code>9</code>的期望结果是<code>16</code>没问题, 但是<code>8</code> 也需要<code>16</code> 而不是得到<code>8</code></p><p>但注意到这个问题集中在2的幂次上</p><p>所以再向下考虑4个1要得到8</p><p>考虑最左1开头的数:</p><p><code>111</code>: 111+1=1000</p><p><code>110</code>: 110+1+1 = 1000</p><p><code>101</code>: 后面一个1贡献2,1个1贡献1, 101+10+1 = 1000</p><p><code>100</code>: 后面一个1贡献2,两个1贡献1, 100+10+1+1 = 1000</p><p>都可以得到8</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><p>鸽, 构造+枚举小值 是我太菜了</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>F:</p><p>一个是 包含两个相同值,转化成包含两个相邻相同值,因为同样的值出现多次, 只用考虑相邻 v…v…v, 只用考虑[v…v]…v 或v…[v…v]</p><p>看起来没离散2e5个&lt;1e9的map效率还行啊, 仅仅是查询的话</p><p>双指针 + 滑窗还是写不熟啊</p><p>G:</p><p>这里主要在i的范围判断错了,如果 i &gt; m/3 那么 <code>2v+i &gt;= 2m/3 + m/3 = m</code>, 我数学太菜了</p><p>H:</p><p>从小特例开始考虑算是有一定思路是对的, 但是要敢于分情况讨论</p><p>但是这个分治的确没想到,就算想到一半, 可能没想到让k/2向下和向上取整,都去等于 n/2</p><p>或者整体来说, 没想到 和可以拆成 和的一半 对应 1个数的一半</p><p>特别是这里敢于 2的幂次+1这种数也这样拆</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://codeforces.com/blog/entry/102995" target="_blank" rel="noopener">官方</a></p>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 分治 </tag>
            
            <tag> 构造 </tag>
            
            <tag> 双指针 </tag>
            
            <tag> 滑窗 </tag>
            
            <tag> 前缀最值 </tag>
            
            <tag> 同值跳点 </tag>
            
            <tag> 二分图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nowcoder 牛客练习赛99 E(图特殊情况)</title>
      <link href="/Blog/2022-05-27-nowcoder-34330E/"/>
      <url>/Blog/2022-05-27-nowcoder-34330E/</url>
      
        <content type="html"><![CDATA[<h1 id="比赛总结"><a href="#比赛总结" class="headerlink" title="比赛总结"></a>比赛总结</h1><p><a href="https://ac.nowcoder.com/acm/contest/34330/E" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/contest/34330/E</a></p><p>考虑存在一个点 其它点仅和它断边</p><p>注意sum n很大, 清理按m清理</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;n;i++)// n(完全图), n-1, &lt;= n-2?int p2[1000010];ll n ;ll m ;vector&lt;int&gt;uv;void w(){  scanf(&quot;%lld %lld&quot;,&amp;n,&amp;m);  rep(i,0,m){    int u,v;    scanf(&quot;%d %d&quot;,&amp;u,&amp;v);    p2[u] ++ ;    p2[v] ++ ;    uv.push_back(u);    uv.push_back(v);  }  // 完全图  if(m == n*(n-1)/2){    printf(&quot;0\n&quot;);    return ;  }  if(m == n*(n-1)/2 - 1){     printf(&quot;-1\n&quot;);    return ;  }  // 连了4个点 -2  // 连了3个点 -1  // sum n 很大  if(n*(n-1)/2 - m &gt; n){    printf(&quot;-2\n&quot;);    return ;  }    rep(i,1,n+1){      if(p2[i] == n-1 - (n*(n-1)/2 - m)){        printf(&quot;-1\n&quot;);        return ;      }    }  printf(&quot;-2\n&quot;);}int main(){  int t;  scanf(&quot;%d&quot;,&amp;t);  while(t--){      w();      for(auto u:uv)p2[u] = 0;      uv = {};  }  return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> NowCoder </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces 1679F(dp,bitmask,特殊表示,动归状态设计)</title>
      <link href="/Blog/2022-05-26-CF1679F/"/>
      <url>/Blog/2022-05-26-CF1679F/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://codeforces.com/contest/1679/problem/F" target="_blank" rel="noopener">https://codeforces.com/contest/1679/problem/F</a></p><p>$[0..10^n)$的所有n位整数,不足的补前导零</p><p>给m个 (ui,vi) 数对, (ui不等于vi)</p><p>x 表示成十进制的数字数组 [d1,d2,…,dn]</p><p>一次操作可以交换相邻的d, 但需要满足 这两个数的 (di,di+1)或(di+1,di) 出现在 (ui,vi)中</p><p>如果一个数x能够通过上述转换变成y,那么认为它们是相等的, x和x自身相等</p><p>问题$[0..10^n)$ 有多少个不同的数, 答案mod 998244353</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>n 5e4</p><p>m 45</p><p>u,v [0,9]</p><p>3s</p><p>256MB</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>先提取一下有用没用的信息,首先m没啥用因为实际就是所有数对的上限</p><p>如果x 中有两个数字 c0,c1 但是这两个数字没有在d中出现过, 那么这两个数字的相对前后关系不会改变</p><p>换句话说,如果两个相等的 它们互相可以转化,那么它们一定属于某个集合,集合里两两可以转化, 而有限集合一定有最小的, 我们用每个集合中数值最小的来表示一整个集合</p><p>于是 这个最小值值可以表示成 <code>[单调递增] [单调递增] [单调递增]</code> , 每两个单调递增之间 的值是不在数对里的</p><p>所以如果我们可以得到<code>[起始,结束,长度]</code>的方案数就可以考虑转移方程了</p><p><code>f[i][j][len1] = sum{ f[i][k][len0] * inc[ &lt; k][j][len1-len0] } + inc[i][j][len]</code></p><p>看似复杂度没法搞,而实际上连逻辑也不一定对 <code>201</code>, 它允许 (0,1),(2,1) 那么显然<code>120</code>和它相等且更小</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>思路是类似的, 也是集合的代表元, 但是并不是靠单调递增划分</p><p>而是说<code>[序列长度l]</code> 在后面加上mask中的数,它不会被移动到前面</p><p>那么,d会移动到前面的条件就是,序列的尾部的一串数都大于<code>d</code>,且都可以和d交换</p><p><code>[x,d1,d2,d3,...,ds,y]</code></p><p>其中 x &gt; y, 且 y 可以和<code>x,d1,...,ds</code>交换</p><p><code>dp[suff][mask]</code> 表示, suff个digits, 且只有mask中的digit可以被移到最左</p><hr><p>考虑长度为s 的一个具体的串 等价最小串 <code>X=[d0,d1,d2,.....,ds]</code></p><p>它<strong>最长</strong>的前缀<code>[d0,d1,d2,....dt]</code> 包含的digits <strong>两两可换</strong>, 我们把这样的digits变成mask, X 可以表示成贡献到 <code>dp[s][mask]</code> 中</p><p>那么现在如果左边放一个d, 变成<code>X1 = [d,d0,d1,d2,...,ds]</code></p><p>一旦d和 mask 中某个值可换, 记为e, 且<code>d &gt; e</code></p><p>显然,因为mask中两两可换,所以<code>X1</code> 可以变成 <code>[d,e,d0,d1,d2,...,ds]</code>, 然后交换e,d 得到 <code>[e,d,d0,d1,d2,...,ds]</code></p><p>因为<code>e &lt; d</code> ,所以 这个值比<code>X1</code> 小</p><p>即是<code>X</code>前面不能插入<code>d</code>, 如果 mask 中存在比d小,且和d相连的任何一个e</p><p>这样可选的<code>d</code>的范围就出来了, 这部分可以预处理</p><blockquote><p>从X而非mask的角度来看,就是说插入了d以后,得到的值依然是 集合表示的最小值(代表元)</p></blockquote><hr><p>mask的变化</p><p>如果d可以放,那么<code>X1 = [d,d0,d1,d2,...,ds]</code>, 显然,它的 最长两两可换前缀中有<code>d</code>, 且剩余的部分从<code>mask</code> 中取, 因为mask本身就是两两可换,所以只用考虑和d是否有边</p><p>所以新mask = d | mask 中和d有边的点</p><hr><p>注意到mask 的意义是 mask 中的值两两可换, 又是X的最大前缀</p><p>所以这里其实会计算不少<code>无效的mask</code>, 但因为算次数,这些次数一定是0, 不影响答案</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://codeforces.com/contest/1679/submission/158638333" target="_blank" rel="noopener">https://codeforces.com/contest/1679/submission/158638333</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 998244353#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backnamespace X{  ll r(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // read  void add(ll &amp;v0,ll &amp;v1){(v0+=v1%MOD)%=MOD;} // add with MOD};using namespace X;const int S = 10;// mask 意义, mask中两两可换, 是X的最大前缀// camp[mask0] = mask1, mask1任意一个bit 和 mask0 中的比它小的bit都没有链接// 在 mask1中的digit 才能加入到 mask0vector&lt;int&gt; camp(1&lt;&lt;S,(1&lt;&lt;S)-1);bool conn[S][S]; // 连接状态ll dp[2][1 &lt;&lt; S];int trans[1 &lt;&lt; S][S]; // [mask][digit] = newmask,int main() {  int n = r();  int m = r();  rep(i,0,m) {    int u = r();    int v = r();    conn[u][v] = conn[v][u] = 1;  }  // 计算 camp  // O(S^2 * 2^S)  rep(mask,0,1 &lt;&lt; S){    rep(c,0,S){ // c 在 mask 中      if (!(mask &amp; (1 &lt;&lt; c))) continue;      rep(j,c+1,S){ // j &gt; c        if (conn[c][j]) {          camp[mask] &amp;= ~(1 &lt;&lt; j);        }      }    }  }  // 计算trans  // O(S^2 * 2^S)  rep(mask,0,1 &lt;&lt; S) {    rep(c,0,S){      trans[mask][c] = 1 &lt;&lt; c;      rep(j,0,S){        // j 出现在mask 中, (c,j) 可以交换        if ((mask &amp; (1 &lt;&lt; j)) &amp;&amp; conn[c][j]) {// 和 mask 中存在相连          trans[mask][c] |= 1 &lt;&lt; j;        }      }    }  }  // 滚动数组  int cur = 0;  dp[0][0] = 1;  // O(n * S * 2^S)  rep(i,0,n){    // clear    fill(dp[cur^1],dp[cur^1] + (1&lt;&lt;S),0);    rep(mask,0,1&lt;&lt;S){      if (dp[cur][mask] == 0) continue;      rep(c,0,S){        // 在camp[mask] 中的才能加        if (!(camp[mask] &amp; (1 &lt;&lt; c))) continue;        add(dp[cur ^ 1][trans[mask][c]] , dp[cur][mask]);      }    }    cur ^= 1;  }  ll ans = 0;  rep(mask,1,1&lt;&lt;S) add(ans,dp[cur][mask]);  printf(&quot;%lld\n&quot;, ans);}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我的思路里关于 排序,代表元都有了, 这是好事,但是</p><p>其实这里一个核心 在于怎么把 最小值元素X,抽象的表示到一个dp的state中</p><p>这里给出的state的设计方案是最长两两可换的前缀的bitmask, 和长度来表示</p><p>换句话说如果有人告诉我怎么设计state,那么转移方程还是随便写的</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://codeforces.com/blog/entry/102859" target="_blank" rel="noopener">官方</a></p>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动归 </tag>
            
            <tag> bitmask </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces 1681E(rmq 倍增)F(树上同值跳点,切割联通块大小)</title>
      <link href="/Blog/2022-05-25-CF1681EF/"/>
      <url>/Blog/2022-05-25-CF1681EF/</url>
      
        <content type="html"><![CDATA[<h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://codeforces.com/contest/1681/problem/E" target="_blank" rel="noopener">https://codeforces.com/contest/1681/problem/E</a></p><p>n行n列的迷宫</p><pre><code>5555544445333452234512345</code></pre><p>左下角第一层,然后它八临的第二层,再8临第三层</p><p>不同层之间有墙隔着,部分墙的位置有门, 每两层之间有<strong>恰好两个门</strong>, 一个是上下方向,一个是左右方向, 门是双向通的</p><p>q个询问两点之间最少的移动步数</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>n 1e5</p><p>q 2e5</p><p>6s</p><p>512MB</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>n很大显然无法建立图</p><p>但我们可以考虑如果是图会怎么做</p><p>首先如果没有任何阻挡,那么两点之间的曼哈顿距离为 走个直角, 因此如果两个同色,那么必然答案就是曼哈顿距离</p><p>那么就是考虑不同颜色</p><p>显然也不会 一个色不连续的走到,否则这段路径直接同色最短, 综上 如果 a &lt; b , 那么a-&gt;b 的距离 = <code>a-&gt;某个门-&gt; a+1-&gt;某个门-&gt;a+2 -&gt;某个门 -&gt; ... -&gt; b</code></p><p>再改改</p><p>位置pos -&gt; 门(a,0) -&gt; 门(b-1,0) -&gt; 位置dst</p><p>位置pos -&gt; 门(a,0) -&gt; 门(b-1,1) -&gt; 位置dst</p><p>位置pos -&gt; 门(a,1) -&gt; 门(b-1,0) -&gt; 位置dst</p><p>位置pos -&gt; 门(a,1) -&gt; 门(b-1,1) -&gt; 位置dst</p><p>如果我们能快速求两个门之间的最短距离就好了</p><p>直接考虑rmq的办法, 记录 (位置i,0/1号门, 2的幂次j距离, 0/1号门) 的最小距离</p><p>这样复杂度为$O(n \cdot log(n) )$ 的初始化和 $O( log(n))$ 的单次查询</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>无</p><p>会的, 不想写了</p><h1 id="F"><a href="#F" class="headerlink" title="F"></a>F</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p><a href="https://codeforces.com/contest/1681/problem/F" target="_blank" rel="noopener">https://codeforces.com/contest/1681/problem/F</a></p><p>给到一个n个点的树, 边上有整数</p><p>记f(u,v) = 点u到点v简单路径上 只出现了一次的数字的个数</p><p>求对于所有u &lt; v 的点对, f(u,v)的总和</p><p>边的值[1..n] 不需要自己离散化了</p><h2 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a>范围</h2><p>n 5e5</p><p>6s</p><p>1024mb</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>显然假设一条边上写的是 x</p><p>那么从贡献角度来讲, 它对答案的贡献是,左侧端点不再经过值为x边的点数 乘上 右侧端点不再经过值为x边的点数</p><p>问题呢, 如果我们通过叶子统计汇总,那么每个叶子上需要记录<code>O(n)</code>个值的出现次数, 那显然就n 方了</p><p>那么我们考虑对于一个d, 在dfs时,不要影响到其它的块的办法</p><p>任意选一个点作为根,先考虑 dfs过程中经过了两个边为d</p><p>分别是(u0,v0,d) 和  (u1,v1,d)</p><p>那么 (u1,v1) 的贡献 = 以v0为根的d断开的联通块大小 乘上 以v1为根的d断开的联通块大小</p><p>而 以v为根的d断开的联通块大小 = v为根的子树大小 - sum{最近的d断开的 以v1/v2/v3/v4… 为根的树的大小}</p><p>这样 辅助数组 记录深搜过程中 上一个同边对应的点即可, 空间就是O(n),</p><hr><p>还有一个问题, 如果是 dfs中首次出现的呢</p><p>这里的方法是对于每一个d 假装树的根的父节点连出去的就是d,即可</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p><a href="https://codeforces.com/contest/1681/submission/158413431" target="_blank" rel="noopener">https://codeforces.com/contest/1681/submission/158413431</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backconst int N = 5e5;int idx;tuple&lt;int,int,int&gt; e[N*2 + 10]; // {u,v,d}vector&lt;pair&lt;int,int&gt; &gt; u2vi[N+10]; // [u] = vector&lt;{v,i}&gt;int loc[N*2+10]; // [d] = 深搜过程中 当前深搜链上 边为d的叶向端点int lst[N*2+10]; // lst[v] = v作为叶节点父边为d , 通向根的链上,最近一个边为d的叶向节点 //上一个v&#39;int sz[N+10]; // 子树大小, 纯的树统计,不考虑边值ll f[N*2+10]; // 考虑边值有效的树的大小int n;void dfs(int u, int fa) { // 点, 父节点  sz[u] = 1; // 纯的子树大小  for(auto [v,ei]: u2vi[u]){    int d = get&lt;2&gt;(e[ei]);    if (v == fa) continue;    lst[v] = loc[d]; // 即帮助深搜恢复loc[d], 也自己记录了它到根的简单路径上最近的 边为d的叶向节点    loc[d] = v; // 当前的深搜的链上 边为d的叶向端点    dfs(v, u);    loc[d] = lst[v]; // 恢复上一次的 loc[d]    sz[u] += sz[v];  }  // 原理就很简单了 对于 u-&gt;v, 边为d 来说, 以v为根的连通块大小 = 它的子树大小 - sum{它子树中紧邻的边d的根为v&#39; 的子树大小}  f[u] += sz[u];  f[lst[u]] -= sz[u];}int main() {  cin &gt;&gt; n;  rep(i,1,n){    int u, v, d;    scanf(&quot;%d %d %d&quot;,&amp;u,&amp;v,&amp;d);    e[i] = {u,v,d};    u2vi[u].push_back({v,i});    u2vi[v].push_back({u,i});  }  // 初始化f 和 loc  rep(i,1,n+1){    f[i + n] = n;    loc[i] = i + n; // 初始化为每个值 对应虚拟节点为 value+n  }  dfs(1, -1);  ll ans = 0;  rep(i,2,n+1){    ans += (f[i] * f[lst[i]]);  }  printf(&quot;%lld\n&quot;,ans);  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实相当于线性数组的变性, 靠值来记录上一个同样值的位置, 不同的是线性可以直接坐标差得到中间的联通块, 而 树状可以dfs知道 到根最近的同样的值在哪, 而联通块的信息直接表示在根上</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://codeforces.com/blog/entry/103163" target="_blank" rel="noopener">官方</a></p>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> 贡献统计 </tag>
            
            <tag> sosdp </tag>
            
            <tag> 联通块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces 1679E(sosdp,子集和dp,动态规划,贡献统计)</title>
      <link href="/Blog/2022-05-24-CF1679E/"/>
      <url>/Blog/2022-05-24-CF1679E/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://codeforces.com/contest/1679/problem/E" target="_blank" rel="noopener">https://codeforces.com/contest/1679/problem/E</a></p><p>长度n,前17个小写字母组成的字符串s,其中有?表示t中任意字符</p><p>q次询问,每次给17个字母中的一个子集,问把?所有填子集的填法中,原串的回文子串个数和, 答案mod 998244353</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>n 1e3</p><p>t 17</p><p>q 2e5</p><p>2s</p><p>256MB</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>首先看到q 2e5, 和 t 17, 因为2^17 == 131072,其实可以变成求所有方案的答案</p><p>统计所有回文子串 的效率最好就是选取中心,再枚举长度</p><p>那么这个题也是这样做, 枚举中心向两边搜索</p><p>其中注意到的是,当选定中心后,如果对称位置上有一个问号一个确定字符,那么这个问号必定填这个字符</p><p>如果两个都是问号,那么自由度+1, 它</p><p>如果对称都填了但是不一样,那么到此结束</p><p>也就是n方可以统计 <code>cnt[必要字符bitmask][自由度] = 次数</code></p><p>那么 每次询问bitmask 是 M 的话</p><p><code>ans[M] = sum { cnt[m 是M的子集][i = 0..] * size(M)^i }</code></p><p>那么问题来了, 朴素计算我必定超时, 但是我不知道如何dp, 看Codeforces的群里有人说sosdp</p><h2 id="SOSDP-子集和DP"><a href="#SOSDP-子集和DP" class="headerlink" title="SOSDP 子集和DP"></a>SOSDP 子集和DP</h2><p>$F[mask] =\sum_{i \in mask}A[i]$</p><h3 id="暴力枚举-O-4-n"><a href="#暴力枚举-O-4-n" class="headerlink" title="暴力枚举 $O(4^n)$"></a>暴力枚举 $O(4^n)$</h3><pre><code class="cpp">rep(mask,0,1 &lt;&lt; N){  rep(i,0,1 &lt;&lt; N){ // 枚举 mask, 检测是否是它的子集    if((i&amp;mask) == i) F[mask] += A[i];  }}</code></pre><h3 id="枚举子集和-O-3-n"><a href="#枚举子集和-O-3-n" class="headerlink" title="枚举子集和$O(3^n)$"></a>枚举子集和$O(3^n)$</h3><p>子集遍历</p><p>也可以dfs,当然dfs会多函数调用和堆栈 比如mask = 111, i依次为 111,110,101,100,011,010,001,000, 注意到的是mask中间穿插0对应的就是i对应位置穿插0,看起来就像每次<code>-1</code></p><pre><code class="cpp">rep(mask,0,1 &lt;&lt; N){  F[mask] = A[0]; // 所有集合包含空集 空集合也作为停止条件  for(int i = mask;i;i = (i-1)&amp;mask){ // 这就是传说中的二进制枚举子集 ,     F[mask] += A[i];  }}</code></pre><h3 id="SOSdp-O-n2-n"><a href="#SOSdp-O-n2-n" class="headerlink" title="SOSdp $O(n2^n)$"></a>SOSdp $O(n2^n)$</h3><p><code>dp[mask][i]</code> 表示 高位和mask一致, 低<code>[0..i]</code>位所有方案的和</p><p><code>dp[10110][2] = A[10000]+A[10010]+A[10100]+A[10110]</code></p><p>状态转移</p><p>第i位为0时,<code>dp[mask][i] = dp[mask][i-1]</code></p><p>第i位为1时,<code>dp[mask][i] = dp[mask][i-1] + dp[mask xor (1 &lt;&lt; i)][i-1]</code></p><p>这样变成递推 或者记忆化搜索,可以 $O(n2^n)$ 完成</p><p>上面合并一下变成,<code>dp[mask][i] = dp[mask][i-1] + (mask &amp; (1 &lt;&lt; i)?dp[mask xor (1 &lt;&lt; i)][i-1]:0)</code></p><p>注意到<code>i</code>依赖于<code>i-1</code>还可以滚动数组降低空间</p><pre><code class="cpp">rep(mask,0,1&lt;&lt;N) f[mask] = A[mask];rep(i,0,N){  // 这里不需要从大到小, 因为dp[mask]已经初始化了,只会更新1 &lt;&lt; i上为1的,而更新的来源是1 &lt;&lt; i上不是1的  rep(mask,0,1 &lt;&lt; N){    if(mask &amp; (1 &lt;&lt; i)) f[mask]+=f[mask ^ (1 &lt;&lt; i)];  }}</code></pre><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>我的暴力的代码</p><pre><code class="cpp">ans[mask] = 0;sz = bitcount(mask)rep(qmark,0,501){ // 自由的问号个数  ti = pow(sz,qmark)  for(int i = mask;i;i = (i-1)&amp;mask){    ans[mask] += cnt[i][qmark] * ti  }}</code></pre><p>这是$O(n 3^{|t|})$ 的复杂度 肯定过不了</p><p>通过sosdp降低到$O(n t 2^{|t|})$ 虽然降低了不少,但是依然过不了</p><p>这里<code>dp</code> 改一个方式设计, 变成贡献统计</p><p>先交换一下循环层级</p><pre><code class="cpp">ans[mask] = 0;sz = bitcount(mask)for(int i = mask;i;i = (i-1)&amp;mask){  rep(qmark,0,501){    ans[mask] += cnt[i][qmark] * pow(sz,qmark)  }}</code></pre><p>因为<code>{i,qmark}</code>中i是mask的子集,而<code>{i,qmark}</code>对mask 的贡献来讲 只与<code>bitcount(mask)</code> 有关,与<code>mask</code> 具体无关</p><pre><code>rep(i,0,(1 &lt;&lt; N)){  rep(sz,1,17+1){    rep(qmark,0,501){      cost[i][sz] += cnt[i][qmark] * pow(sz,qmark);    }  }}ans[mask] = 0;sz = bitcount(mask)// sosdp 优化掉for(int i = mask;i;i = (i-1)&amp;mask){  ans[mask] += cost[i][sz];}</code></pre><p>下面得到优化了, 但上面看起来复杂度并没有变好</p><p>但既然都说道贡献统计了,就去看贡献来源</p><p>在我们初始找回文时<code>[i...j]</code> 如果是一个回文,它的必须字符集为mask,自由度为qmark</p><p>那么</p><pre><code class="cpp">rep(sz,1,17+1){  cost[mask][sz] += pow(sz,qmark);}</code></pre><p>这样 初始化就变成$O(|t| n^2)$</p><hr><p>综上 $O(初始化幂次 |t|n + 初始化贡献 |t| n^2 + 初始化答案 |t|^2 2^{|t|} + 查询 |t|q )$</p><p>注意到 题目要统计 所有字符串个数,也就是说 同一个位置的回文串 在不同字符串中出现,要多次统计</p><p>所以</p><pre><code class="cpp">rep(sz,1,17+1){  cost[mask][sz] += pow(sz,qmark) * pow(sz,total qmark - used qmark);}</code></pre><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><a href="https://codeforces.com/contest/1679/submission/158244316" target="_blank" rel="noopener">https://codeforces.com/contest/1679/submission/158244316</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 998244353#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backconst int t = 17;char s[1010]; // 读入char s2[2010]; // 插入井号简化搜索int n;ll p[t+10][1010]; // 幂次预处理ll cost[(1&lt;&lt;t)+10][t+10]; // 具体的值ll ans[(1&lt;&lt;t)+10][t+10]; // 由具体值的子集和的答案char query[t+10];int main(){  rep(i,1,t+1){    p[i][0] = 1;    rep(pwr,1,1000+1){      p[i][pwr] = p[i][pwr-1]*i%MOD;    }  }  scanf(&quot;%d&quot;,&amp;n);  scanf(&quot;%s&quot;,s);  int qtotal = 0;  rep(i,0,n) qtotal += s[i] == &#39;?&#39;;  // 字符两两间插入井号方便处理奇偶  s2[0] = s[0];  rep(i,1,n){    s2[i*2-1] = &#39;#&#39;;    s2[i*2] = s[i];  }  // 中心  rep(c,0,n*2-1){    int mask = 0;    int qmark = 0;    int qcnt = 0;    rep(l,0,n*2-1){ // 长度      int il = c-l;      int ir = c+l;      if(il &lt; 0 || ir &gt;= n*2-1)break;      qcnt += s2[il] == &#39;?&#39;;      qcnt += il != ir &amp;&amp; s2[ir] == &#39;?&#39;;      if(s2[il] == &#39;#&#39;)continue; // 不贡献的      if(s2[il] == s2[ir]){        if(s2[il] == &#39;?&#39;){          qmark++;        }      }else{ // 不等        if(s2[il] == &#39;?&#39;){          mask |= (1 &lt;&lt; (s2[ir] - &#39;a&#39;));        }else if(s2[ir] == &#39;?&#39;){          mask |= (1 &lt;&lt; (s2[il] - &#39;a&#39;));        }else{ // 不同的字符          break;        }      }      // 贡献统计      rep(sz,1,17+1){        // 不同字符串 同一个位置回文串的贡献要多次统计 所以要乘上 其余位置是问号的所有放入方案 让此处的贡献倍数 sz**(qtotal - qcnt)        (cost[mask][sz] += p[sz][qmark] * p[sz][qtotal - qcnt] % MOD )%=MOD;      }    }  }  // sosdp  rep(sz,1,t+1){    rep(mask,0,1 &lt;&lt; t){      ans[mask][sz] = cost[mask][sz];    }    rep(i,0,t){      rep(mask,0,1 &lt;&lt; t){        if(mask &amp; (1 &lt;&lt; i)) (ans[mask][sz] += ans[mask ^ (1 &lt;&lt; i)][sz])%=MOD;      }    }  }  // query  int q; // 2e5  scanf(&quot;%d&quot;,&amp;q);  while(q--){    // string to mask    scanf(&quot;%s&quot;,query);    int sz = strlen(query);    int mask = 0;    rep(i,0,sz){      mask |= (1&lt;&lt;(query[i]-&#39;a&#39;));    }    printf(&quot;%lld\n&quot;, ans[mask][sz]);  }  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>回文的奇偶处理,可以用两两间插入不会出现的字符,如井号,方便枚举中心</p><p>学了一手sosdp</p><p>看ssr的twitter说有快速zeta变换, 搜下来看转移方程似乎就是sosdp, <a href="https://zhuanlan.zhihu.com/p/33328788?ivk_sa=1024320u" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/33328788?ivk_sa=1024320u</a></p><p>顺便这里的dp转化过程中 通过贡献和来优化效率</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://codeforces.com/blog/entry/102859" target="_blank" rel="noopener">官方</a></p>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> 贡献统计 </tag>
            
            <tag> sosdp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atcoder arc140 D(树的边与点,贡献统计,DP,特殊题目条件)</title>
      <link href="/Blog/2022-05-23-ac_arc140D/"/>
      <url>/Blog/2022-05-23-ac_arc140D/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://atcoder.jp/contests/arc140/tasks/arc140_d" target="_blank" rel="noopener">https://atcoder.jp/contests/arc140/tasks/arc140_d</a></p><p>初始有 n 个点，给定一个长度为 n 的数组 ai，若 ai≠−1，则有无向边 (i,ai)，若 ai=−1，则点 i 可以连向 1∼n 任意点，求所有图的联通块个数之和</p><p>n 2e3</p><p>答案mod 998244353</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>考虑G中一个联通分量</p><p>如果它有N点,N个边,那么它恰好有一个环</p><p>这关键就在题目的特殊性上,因为(i-&gt;ai),即每个点连出一条边,所以n个点组成的联通分量一定恰好N个边, 题目条件特点!</p><p>因此 题目变成统计环的 而不是统计联通分量</p><p>然后先考虑 非-1的部分已经构成的环, 这部分如果再和其它相连,那么额外连的部分一定不会再有环,是个树,所以其它和它连的部分一定不会再贡献,</p><p>所以在考虑-1构成环的话不会考虑已经初始有环的联通分量</p><p>对于目前剩余没有环的联通分量是树,把这些树标号从1到k,并且b[i]表示这些树的点的个数, 注意到它一定只有一条未连接的边</p><p>现在考虑一个环的构成, 一定是由一些树连成的</p><p>树1-&gt;树2-&gt;树3-&gt;树k-&gt;树1</p><p>我们不考虑没有参与到环中的其它树,即使它从联通分量角度连进来了, 我们之考虑对环的构成直接有贡献的树</p><p>那么 如果是由 k个构成的,每一个的树的出点是固定的,但是入点的选择是上一个树的点的个数, 而它们排成环的方案是(k-1)! </p><p>所以环的构成是$(k-1)! \times \prod_{i=1}^{k} B_{x_i}$</p><p>n 很小 n方 可以接受可以DP</p><p>说是分治计算$\prod_{i=1}^{K} (1 + B_ix)$可以做到 n log(n)</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><a href="https://atcoder.jp/contests/arc140/submissions/31923069" target="_blank" rel="noopener">https://atcoder.jp/contests/arc140/submissions/31923069</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 998244353#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backint n;int a[2010];// 读入int fa[2010]; // 并查集父节点int sz[2010]; // 点个数bool cir[2010]; // 是否有环int getfa(int x){  return x == fa[x]?x:(fa[x] = getfa(fa[x]));}void link(int u,int v){  int fu = getfa(u);  int fv = getfa(v);  if(fu == fv){    cir[fu] = true; // 有环    return;  }  sz[fv] += sz[fu]; // 大小  cir[fv] |= cir[fu]; // 环  fa[fu] = fv;}ll mypow(ll v,int pwr){  ll r = 1;  while(pwr){    if(pwr%2)(r*=v)%=MOD;    (v*=v)%=MOD;    pwr/=2;  }  return r;}ll fac[2010] = {1}; // 阶乘int main(){  cin&gt;&gt;n;  int freecnt = 0; // 自由度 -1 个数  rep(i,1,n+1){    fa[i] = i;    sz[i] = 1;    fac[i] = fac[i-1]*i%MOD;    scanf(&quot;%d&quot;,a+i);    freecnt += a[i] == -1;  }  rep(i,1,n+1){    if(a[i] == -1)continue;    link(i,a[i]);  }  vector&lt;int&gt; arr ;  int circnt = 0;  rep(i,1,n+1){    if(fa[i] != i)continue; // 非联通块根    if(cir[i]){ // 环      circnt++;      continue;    }    arr.push_back(sz[i]); // 树 有一个自由度  }  ll ans = circnt * mypow(n,freecnt) % MOD; // 本身就是环的贡献  vector&lt;ll&gt; mulsum(n+10,0); // dp mulsum[树的个数] = sz乘积和  mulsum[0] = 1;  rep(i,0,(int)arr.size()){    rep(k,0,i+1){      // 注意前面一半只是 k+1个构成环的方案数, 对于环以外的 freecnt-k-1的自由度任意搭配 才是这些环对总答案的贡献值      (ans += fac[k] * mulsum[k] % MOD * arr[i] % MOD * mypow(n,freecnt-k-1) % MOD)%=MOD;    }    per(k,0,i+1){      (mulsum[k+1] += mulsum[k]*arr[i])%=MOD;    }  }  printf(&quot;%lld\n&quot;,ans);  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我想了很久,都没有注意到题目条件特殊性带给联通分量的特殊性, 这还是不应该,应该加强这方面的反应</p><p>其实也算是树的知识没有警醒我, 边=点-1,那么就会反应到这里连通分量的边 &lt;= 点 且 &gt;= 点-1</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://atcoder.jp/contests/arc140/editorial/3971" target="_blank" rel="noopener">官方</a></p>]]></content>
      
      
      <categories>
          
          <category> Atcoder </category>
          
          <category> ARC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
            <tag> DP </tag>
            
            <tag> 树 </tag>
            
            <tag> 贡献统计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces 1680F(无向图,奇数环,偶数环,树上差分)</title>
      <link href="/Blog/2022-05-20-CF1680F/"/>
      <url>/Blog/2022-05-20-CF1680F/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://codeforces.com/contest/1680/problem/F" target="_blank" rel="noopener">https://codeforces.com/contest/1680/problem/F</a></p><p>给一个连通无向图,n点,m 边</p><p>点覆盖: (所有边至少一个点属于点集</p><p>lenient点覆盖: 是点覆盖,且至多一条边两个点都在点集中</p><p>找出一个 lenient点覆盖</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>t 1e4</p><p>n 1e6</p><p>5s</p><p>512MB</p><h1 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h1><p>首先 如果能黑白染色,成功,那么也就是每个边一端黑一端白, 全选黑或全选白都是一个答案</p><p>如果 黑白染色出现冲突,那么这两个点一定在一个奇环上</p><p>也就是这个奇环上存在两个点都是黑色, 最可以先把这个环上的边全部当作不存在,重新做染色,如果能成功, 计算这个环上同一个并查集点的颜色关系,</p><p>如果两两都不在同一个集合中那么说明拆了环都是独立的部分,那么任意染黑白即可</p><p>如果存在 a—–b 同集合中</p><p>a,b 同色 , [a..b]个数奇数的一半一定是黑白间隔</p><p>a,b 异色 , [a..b]个数偶数的一半一定是黑白间隔</p><p>换句话说, 其实原图去掉那个两个点都在集合中的边, 剩下的满足黑白染色,现在则是看哪些确定可以连起来</p><p>过程中检查冲突</p><p>如果剩余还有没连的 任选一个作为分割即可</p><hr><p>但是 实现上能找环但如何找奇环</p><p>独立染色可以写,但合并时如何实现?</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>前面几段和我想的一样, 奇偶黑白染色, 也就是需要在奇数环上剪断一条边,让整个染色合法</p><p>这里主要是 对无向图做dfs建立树</p><p>那么出现环的时候就是子节点指向父节点的时候</p><p>我们在dfs过程中黑白染色,那么出现回边时根据染色就可以知道它是奇环还是偶环,</p><p>如果我们统计了每条边出现在我们找到的奇环上的次数,和偶环上的次数,那么 如果一条边出现在奇数环上次数等于所有奇环次数,偶数环次数为零,那么删除这条边即可(可能有多个满足,任意删除一条)</p><p>// 必要性proof见下面, 充分显然</p><p>所以接下来就是当发生回环时,如何统计边在奇环偶环上出现次数了,如果直接对边计数,那么复杂度就过不了</p><p>树上差分, cnt[id]表示边id到根的所有边都 进行了+cnt[id],这样 当有点u到点v的回边时,就 cnt[faedge[u]]++,cnt[faedge[v]]–, 对于不在树上的回边<code>edge[id] = {u,v}</code>不需要差分直接统计, cnt[id]++</p><p>最后统计完后整理具体次数</p><p>然后找满足的边拆掉,再染色即可(注意拆掉边两端需要是黑色</p><h2 id="性质证明"><a href="#性质证明" class="headerlink" title="性质证明"></a>性质证明</h2><p>这里 显然的是 如果是两端同色的点, 那么它一定在所有奇环中,不在所有偶环中</p><p>也就是必要性显然</p><p>如果我们枚举了所有的环,那么拆掉它,所有奇数环也被拆掉了, 所以充分性也成立</p><p>问题是上面的实现 并没有枚举所有的环,枚举的只是树边+一条回边的所有环, 而环可能是由多条回边构成的</p><p>引理1: 如果环A和环B的一部分拼成环C,那么ABC中要么全是偶环,要么其中两个是奇环,</p><p>(这里拼成的意思是 A 和 B 有共用的一条链, C= (A-共用链)+(B-共用链)</p><p>那么要证明的是两部分, 这个两端同色的边也在未统计到的多回边的奇数环中,不在未统计到的多回边偶数环中</p><blockquote><p>如果它(两端同色的边)不在未统计到的多回边奇数环中</p></blockquote><p>那么这个环H(奇,回边=n) 可以拆成一个H1(奇,回边n-1) + H(偶,回边1)</p><p>因为H(偶,回边1) 我们一定计算到了, 只能递归下降, 且不会在 它们两的重复边上,因为它不在偶环上</p><p>那么这个环H(奇,回边=n) 可以拆成一个H1(偶,回边n-1) + H(奇,回边1)</p><p>因为H(奇,回边1) 我们一定计算到了 所以它在奇数环中</p><p>综上它一定在 未统计到的多回边奇数环中</p><blockquote><p>如果它在未统计到的多回边偶数环中</p></blockquote><p>那么这个环H(奇,回边=n) 可以拆成一个H1(偶,回边n-1) + H(偶,回边1) </p><p>它一定不在 H(偶,回边1) 中, 所以递归下降,且它也不在 两个环共用的边上</p><p>那么这个环H(偶,回边=n) 可以拆成一个H1(奇,回边n-1) + H(奇,回边1)</p><p>注意到上述结论, 这个边一定在这两个环里都有,因此这个边在它们重复的边上而不在偶环里</p><p>因此 得证</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><a href="https://codeforces.com/contest/1680/submission/158000410" target="_blank" rel="noopener">https://codeforces.com/contest/1680/submission/158000410</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define pb push_back#define rep(i,a,b) for(int i = (a);i&lt;(b);i++)#define all(v) (v).begin(),(v).end()const int N = 1000000;int n,m;int odd; // 奇环个数int cnt0[N+10]; // cnt0[边]偶环个数，int cnt1[N+10]; // cnt1[边]奇环个数，int c[N+10]; //c节点颜色，bool vis[N+10]; // dfs中访问过, 多次复用int fe[N+10]; //fe父边// 读入pair&lt;int,int&gt; e[N+10]; // [边] = {点id,点id}vector&lt;pair&lt;int,int&gt;&gt; G[N+10]; // [点] = 数组 {点id,边id}//二分图染色同时找环void dfs(int u,int p/*父边*/,int cl /*颜色*/ ) {  c[u]=cl;  vis[u]=1; // 管的当前到根的链上是否有, 减少重复计算 简化差分统计  fe[u]=p;  for(auto [v,id]:G[u]){    if (id==p)continue;    if (c[v]==-1){ // 未访问过      dfs(v,id,cl^1);    } else if(!vis[v]){ // 非父节点      continue;    } else if (c[v]==(cl^1)) { //偶环      cnt0[id]++; // 不在树上的回边      cnt0[p]++; // 树上边 差分统计 表示这个边到根的次数都+1      if(~fe[v])cnt0[fe[v]]--; // 这个边到根的次数都-1    } else { // if (c[v]==cl) {//奇环      odd++; // 奇环个数      cnt1[id]++;      cnt1[p]++;      if(~fe[v])cnt1[fe[v]]--;    }  }  vis[u]=0;//回溯时撤销访问标记}// 整理差分数组，得到每条边的计数, 只用处理树边,递归, 不用处理非树的回边void dfs2(int u) {  vis[u]=1;  for(auto [v,_]:G[u]){    if (vis[v]) continue;    dfs2(v);    if (fe[u]!=-1&amp;&amp;fe[v]!=-1){      cnt0[fe[u]]+=cnt0[fe[v]];      cnt1[fe[u]]+=cnt1[fe[v]];    }  }}void dfs3(int u,int cl) { //二分图染色  c[u]=cl;  for(auto [v,_]:G[u]){    if (c[v]!=-1) continue;    dfs3(v,cl^1);  }}void run(){  // 一系列初始化  odd=0;  scanf(&quot;%d %d&quot;,&amp;n,&amp;m);  rep(i,0,n) G[i].clear();  fill(cnt0,cnt0+m+3,0);  fill(cnt1,cnt1+m+3,0);  fill(c,c+n+3,-1);  fill(vis,vis+n+3,0);  // 读入  rep(i,0,m){    int u,v;    scanf(&quot;%d %d&quot;,&amp;u,&amp;v);    e[i]={--u,--v};    G[u].pb({v,i});    G[v].pb({u,i});  }  dfs(0,-1,0); // 以0 为根染色0搜索  // 整理树上差分数组 变成每个边的统计  fill(vis,vis+n+3,0);  dfs2(0);  int id=-1;  if (odd) {//存在奇环    rep(i,0,m){      // 需要完全相等 所有已知奇环都覆盖了它, 且没有偶环覆盖了它, proof? 必要性显然, 充分性呢?      if (cnt1[i]==odd &amp;&amp; cnt0[i]==0) {        id = i; // 任选一条        break;      }    }    if (id == -1) {      printf(&quot;NO\n&quot;);      return;    }    //删边    auto [u,v] = e[id];    sort(all(G[v]));    sort(all(G[u]));    G[u].erase(lower_bound(all(G[u]),make_pair(v,-1)));    G[v].erase(lower_bound(all(G[v]),make_pair(u,-1)));  }  // 再次染色  fill(c,c+n+3,-1);  dfs3(0,1);  int f=(id==-1?0:c[e[id].first]^1); //保证被删边的端点颜色为1  printf(&quot;YES\n&quot;);  rep(i,0,n){    printf(&quot;%d&quot;,c[i]^f);  }  printf(&quot;\n&quot;);}int main() {  int T;  scanf(&quot;%d&quot;,&amp;T);  while(T--)run();  return 0;}// 1-2-3-4,3-1,4-1// 奇边切 3-1在回边上//// 1-2-3-4-5, 3-1, 5-1//// 奇边切 1-2或2-3,在树边上//</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>知识点</p><p>无向图 = dfs -&gt; 树+回边</p><p>而一部分无向图的环 = 多个树边+一条回边? 也可能由回边组成的环</p><p>树上差分 = 记录当前点到根的所有边的统一操作,如+1/-1</p><p>学了一手<code>fill()</code>函数,看起来很好用啊</p><p>然后 无向图 树上dfs, 的父边而不是父点 <code>dfs(int u,int fe /*father edge*/)</code></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://codeforces.com/blog/entry/102852" target="_blank" rel="noopener">官方</a></p><p><a href="https://blog.csdn.net/FelFa_1414666/article/details/124790751" target="_blank" rel="noopener">csdn</a> 修复了一些越界和等式操作, 修改了部分变量和包裹逻辑,整体</p>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无向图 </tag>
            
            <tag> 奇数环 </tag>
            
            <tag> 偶数环 </tag>
            
            <tag> 树上差分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode周赛293D (lower_bound,set, 动态开点线段树)</title>
      <link href="/Blog/2022-05-15-leetcode-weekly-contest-293-D/"/>
      <url>/Blog/2022-05-15-leetcode-weekly-contest-293-D/</url>
      
        <content type="html"><![CDATA[<h1 id="set-lower-bound"><a href="#set-lower-bound" class="headerlink" title="set+lower_bound"></a>set+lower_bound</h1><p><a href="http://www.cplusplus.com/reference/algorithm/lower_bound/" target="_blank" rel="noopener">http://www.cplusplus.com/reference/algorithm/lower_bound/</a></p><p>On non-random-access iterators, the iterator advances produce themselves an additional linear complexity in N on average.</p><p>set不支持随机访问,所以std::lower_bound 用在set上就不再是log级别了, 而是均摊n级别了,所以要用set::lower_bound而不是std::lower_bound</p><h1 id="动态开点线段树"><a href="#动态开点线段树" class="headerlink" title="动态开点线段树"></a>动态开点线段树</h1><p>一般来说 空间够常见是开4N大小</p><p>但是如果空间很大但是点是离散的又需要在线处理(不能离线离散化)的情况</p><p>每个点记录左右节点+lazytag+没有节点要访问时,动态开点idx, 查询时对于没有开点的直接返回空,而不是开点</p><pre><code class="cpp">int idx = 0;// N 按照预估点数而不是 l r 的范围了int lc[N]; // 点的左子点int rc[N]; // 点的右子点void update(int &amp;o,int l,int r,...){  if(!o) o = ++idx; // 动态开点  if(l == r){    // ...    return ;  }  update(lc[o],l,mid,...);  update(rc[o],mid+1,r,...);  // ...}... query(int o,int l,int r,int ql,int qr){  if(!o){ // 查询不用创建点    //....    return 空状态;//   }  if(ql &lt;= l &amp;&amp; r &lt;= qr){ // [ql.. [l..r].. qr]    // ...    return //;  }  auto resl = query(lc[o],l,mid,ql,qr);  auto resr = query(lr[o],mid+1,r,ql,qr);  return ...;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> NowCoder </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lower_bound </tag>
            
            <tag> set </tag>
            
            <tag> 动态开点线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nowcoder 牛客挑战赛60,CD+总结(竞赛图, 递推)</title>
      <link href="/Blog/2022-05-14-nowcoder-11200/"/>
      <url>/Blog/2022-05-14-nowcoder-11200/</url>
      
        <content type="html"><![CDATA[<h1 id="比赛总结"><a href="#比赛总结" class="headerlink" title="比赛总结"></a>比赛总结</h1><p>比赛id 11200</p><p>B:</p><p>数组空间没开够等未定义行为,不会像Codeforces报overflow等,而是默认执行报WA.</p><p>D:</p><p>TLE+WA 只会报WA</p><p>竞赛图不能创造大小为2的scc</p><pre><code class="cpp">/** * @author      : cromarmot (yexiaorain@gmail.com) * @file        : D * @created     : 星期五 5月 13, 2022 20:35:36 CST */#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (int i=a;i&lt;n;i++)// 竞赛图 任意不同两点间都有恰好一条单向边int n,m; // n 1e5, m 2e5vector&lt;int&gt;p2[100010];// scc -&gt; 成链?class Tarjan{  vector&lt;int&gt; low;  vector&lt;int&gt; dfn;  stack&lt;int&gt; stk;  vector&lt;int&gt; res;  int n;  int id = 0;  void scc(int v) {    low[v] = dfn[v] = ++id;    stk.push(v);    for(auto w:p2[v]){      if(!dfn[w]){ // 未访问过        scc(w);        low[v] = min(low[v],low[w]);      } else if(!res[w]){ // 访问过但没有结果(在栈中)        low[v] = min(low[v],dfn[w]);      }    }    int u;    if(low[v] == dfn[v])  {      do{        res[u = stk.top()] = v;        stk.pop();      }while(u != v);    }  }public:  Tarjan(int SZ):n(SZ){    low = vector&lt;int&gt;(n+1,0);    dfn = vector&lt;int&gt;(n+1,0);    stk = {};    res = vector&lt;int&gt; (n+1,0);  }  vector&lt;int&gt; calc(){    rep(i,1,n+1){      if(!res[i]){        scc(i);      }    }    return res;  }};vector&lt;int&gt; p3[100010];int du[100010];void work(){  scanf(&quot;%d %d&quot;,&amp;n,&amp;m);  Tarjan tarjan(n);  rep(i,1,n+1){    p2[i] = {};    p3[i] = {};    du[i] = 0;  }  rep(i,0,m){    int u,v;    scanf(&quot;%d %d&quot;,&amp;u,&amp;v);    p2[u].push_back(v);  }  // a-&gt;b / b-&gt;a 至少满足一条  // scc 成链? 唯一拓扑顺序  vector&lt;int&gt; num = tarjan.calc(); // scc 联通分量 标识  vector&lt;int&gt; sccsz(n+1,0);  rep(i,1,n+1){    sccsz[num[i]]   ++;  }  rep(i,1,n+1){    if(sccsz[i] == 2){      // 竞赛图不能创造大小为2的scc!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!      printf(&quot;NO\n&quot;);      return ;    }  }  // rep(i,1,n+1){  //   printf(&quot;scc: %lld: %d\n&quot;,i,num[i]);  // }  // 转化为联通分量关系  rep(i,1,n+1){    for(auto item:p2[i]){      if(num[i] == num[item])continue;      p3[num[i]].push_back(num[item]);    }  }  rep(i,1,n+1){    if(num[i] != i)continue;    sort(p3[i].begin(),p3[i].end());    int itr = 0;    rep(j,0,(int)p3[i].size()){      if(j==0 || p3[i][j] != p3[i][j-1]){ // 去重        p3[i][itr++] = p3[i][j];        // i -&gt; p3[i][j]        du[p3[i][j]]++; // 入度      }    }    p3[i].resize(itr);  }  // 拓扑 联通分量中 唯一顺序  // 入度为0  vector&lt;int&gt; d0;  rep(i,1,n+1){    if(num[i] != i)continue;    if(du[i] == 0)d0.push_back(i);  }  while(d0.size()) { // == 1    if(d0.size() &gt; 1){      printf(&quot;NO\n&quot;);      return ;    }    int i = d0[0];    // printf(&quot;D0:%d\n&quot;,i);    d0.pop_back();    rep(j,0,(int)p3[i].size()){      // i -&gt; p3[i][j]      du[p3[i][j]]--;      if(du[p3[i][j]] == 0){        d0.push_back(p3[i][j]);        if(d0.size() &gt; 1){            printf(&quot;NO\n&quot;);            return ;        }      }    }  }  printf(&quot;YES\n&quot;);}int main(){  int t;  scanf(&quot;%d&quot;,&amp;t);  while(t--){    work();  }  return 0;}</code></pre><h1 id="C题目"><a href="#C题目" class="headerlink" title="C题目"></a>C题目</h1><p><a href="https://ac.nowcoder.com/acm/contest/11200/C" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/contest/11200/C</a></p><h1 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h1><p>从1开始</p><ol><li>每次可以移动 x = x+1</li><li>如果当前格子未被染色, 则染色当前格子并且设置 x = a[x]</li></ol><p>a[x]保证非严格单调递增</p><p>n&lt;=1e6</p><p>输出把所有格子都染色的方案数</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>设 f(x)把前x个格子全部染色的方案数, 注意到虽然顺序上可能 在染前x个格子过程中,已经把后面的格子染色了,但是后面这个被染色的不计入方案统计</p><ul><li>x 如果是最后一个被染色的,那么方案数为f(x-1)</li><li>x 如果不是最后一个被染色的, 那么对于f(x-1)中, 相当于 <code>? -&gt; x -&gt; y</code>, $y \in [a_x,x-1]$, 所以它可以放在$x-a_x$个位置的前面</li></ul><p>所以方案数 = $\prod_{i=1}^n(i-a_i+1)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 1000000007#define rep(i,a,n) for (ll i=a;i&lt;n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)#define pb push_backconst double pi = acos(-1.0);int n;int a[1000010];int main(){  ll ans = 1;  cin&gt;&gt;n;  rep(i,1,n+1){    scanf(&quot;%d&quot;,a+i);    if(i-a[i]+1 &lt;= 0){      ans = 0;    }else{      (ans*=i-a[i]+1)%=MOD;    }  }  printf(&quot;%lld\n&quot;,ans);  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>状态转移的过程中, 对于上面这种,实际上也可以和方案描述不一致, 统计的时候不会包含超过当前位置的移动方案,而后面的移动方案是可以等价的插入到前面的方案中的(才可以乘法)</p><p>不过现在好的是,我能判断这个类型算是数学和转移的题了,也想到这样设计状态,但是没有细想</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://ac.nowcoder.com/discuss/952589" target="_blank" rel="noopener">https://ac.nowcoder.com/discuss/952589</a></p>]]></content>
      
      
      <categories>
          
          <category> NowCoder </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 竞赛图 </tag>
            
            <tag> 递推 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atcoder agc057 C (trie树, bit flip)</title>
      <link href="/Blog/2022-05-11-ac_agc057C/"/>
      <url>/Blog/2022-05-11-ac_agc057C/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://atcoder.jp/contests/agc057/tasks/agc057_c" target="_blank" rel="noopener">https://atcoder.jp/contests/agc057/tasks/agc057_c</a></p><p><code>0~ 2^N - 1</code>的排列</p><p>问能否通过多次任选操作(每次操作独立,在上一次操作结果基础上), 让数列单调递增, 给出方案</p><p>操作1: <code>a[i] = (a[i]+1)%(2^n)</code> , 所有值循环+1</p><p>操作2: <code>a[i] = a[i] xor x</code> , 选定一个值,所有值异或它</p><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>n&lt;=18</p><h1 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h1><p>显然连续的异或没意义,甚至题目可以改成不是+1,+任意</p><p>所以问题变成 穿插的正数个+1和xor能否让数列单调递增, 若能给出方案</p><p>考虑所有+1/xor 末尾是1, 都是让所有末尾翻转, 因此结论是 末位前两个互为0/1,后面循环这两个</p><p>同理考察第二位,发现(0和2)(1和3)两对,互为0/1,后面的同样按照4个一组循环</p><p>同理考察第三位,发现(0和4)(1和5)(2和6)(3和7)四对,互为0/1,后面的同样按照8个一组循环</p><p>换句话说, 最低位1个自由元,其它由它决定,第2低位两个自由元,剩余的也是由它决定,第低3位4个自由元,低4位8个自由元…</p><p>我想先弄好一部分位再弄剩下的,从高位到低位或从低位到高位,但是 没想到实际怎么操作</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="设计结构"><a href="#设计结构" class="headerlink" title="设计结构"></a>设计结构</h2><p><img src="https://img.atcoder.jp/agc057/ae70f93e5ead40b583e634fc51e8ccef.png" alt="trie tree"></p><p>先不看方框, 看树上的边, 从根向叶子的方向, 对应值的从低到高的位</p><p>然后关注叶子方框,例如上面的6,二进制下是110,和它的路径是一样的</p><p>再看带有n的方框,意思是如果从树上截取某个点作为根来看,如果根表示的是n,那么一条边权是0子节点是2n+0,边权是1的子节点是2n+1, 注意的是这里并不是左右节点,而是由边权决定的</p><hr><p>树的结构建好以后, 那么把叶子中再填入初始每个值所在的位置,完成初始化</p><p>接下来看+1和xor操作对树进行怎样的修改</p><h2 id="1"><a href="#1" class="headerlink" title="+1"></a>+1</h2><p><img src="https://img.atcoder.jp/agc057/70285518a991e540173c7cc763f448e0.png" alt="+1"></p><p>因为我们的树是越接近根,对应的位越低,所以+1带来的进位效果也是从根向叶子前进的</p><p>如果我们以改变树上边的权值,而不是改变左右指向的视角来看,</p><p>那么对于根</p><p>0变成1</p><p>1变成0且它的子树受到和根一样的处理</p><p>这样发现改动的实际上只有log级别个</p><h2 id="xor"><a href="#xor" class="headerlink" title="xor"></a>xor</h2><p><img src="https://img.atcoder.jp/agc057/b9c3f79d227be93340d020278b2f15e5.png" alt="xor"></p><p>xor 比 +1 其实好观察,</p><p>对于xor二进制对应位为1的层级的0变成1,1变成0</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>现在我们再回头看目标呢, 也就是位置上和它对应的值是一样的</p><p>这里可以思考为啥,是按边上的值来描述而不是左右描述的, 考虑不按照涂上那样初始摆,而是按照叶子直接放初始的值,比如这里<code>0 4 2 6 1 5 3 7</code>位置上对应的值, 在放值时就能明确的知道冲突的情况,排除一些不可能</p><p>问题变成了,如何让二叉树边上的0/1 变回 完全二叉树的位置对应的值</p><hr><p>考虑把叶子变成 0,1 序列.</p><p>如果叶子是反着的1,0, 那么只需要把上面的路径变成 从根到它都是1,这样+1 就能完成修正</p><p>修正了所有叶子以后, 问题来了, 还可以通过+1/xor的组合修正非叶子吗</p><pre><code>   1       0 1   0   0   1 ( 其它位还有 不是xor 能解决的情况0 1 0 1 0 1 0 1 ( 高位全部0,1顺序了</code></pre><p>证明不可能, 首先 这种情况, 如果能修正,必定是奇数次操作到该层, 因为 xor不改相对一致性,+每次操作到这两个中的一个就会改,所以这两个操作次数总和必为奇数,考虑它们所覆盖的叶子节点,总操作次数也为奇数</p><p>因此要么 xor翻转能得到,要么就是不可能</p><hr><p>从逻辑上, 已经完成了,还有个实现问题,如果通过枚举导数第二层,再模拟xor和+1, 虽然+1代价小,但是xor的代价可能达到O(n)的级别, 总的会变成n方</p><p>简单的增加一个翻转标识记录行的翻转状态, 因为+1是对单个点翻转,xor是行翻转,翻转两次等于未翻转,都是翻转,所以+1直接让对应位置的节点翻转, 而xor 通过行标识记录, </p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><a href="https://atcoder.jp/contests/agc057/submissions/31596691" target="_blank" rel="noopener">https://atcoder.jp/contests/agc057/submissions/31596691</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)const int N = 262144;vector&lt;int&gt; lr(N*4+10,-1); // -1 unset 0:01, 1:10int a[N+10];int n;bool build(int pos,int val,int idx = 1,int pwr = 0){  if(pwr == n)return true;  int direction = pos%2;  int v = direction != val%2;  if(lr[idx] != -1 &amp;&amp; lr[idx] != v){    return false;  }  lr[idx] = v;  return build(pos/2,val/2,idx*2+direction,pwr+1);}int xorcache[20] = {0}; // 不要实际的xor, 修改代价大vector&lt;int&gt;ans;void fix(int val){  // printf(&quot;Fix %d\n&quot;,val);  int x = 0;  {    int pwr = n-1;    int v = val;    while(pwr--){      if(v%2 == (lr[v/2] ^ xorcache[pwr])){        x |= (1&lt;&lt;(pwr));      }      v/=2;    }  }  // printf(&quot;xor %d\n&quot;,x);  if(x){    ans.push_back(x);    rep(pwr,0,n){      if((1&lt;&lt;pwr) &amp; x)xorcache[pwr]^=1; // 标记    }  }  // printf(&quot;+1\n&quot;);  {    int idx = 1;    rep(pwr,0,n){      if(lr[idx]^xorcache[pwr]){        idx=idx*2;      }else{        idx=idx*2+1;      }      lr[idx/2] ^= 1;    }  }  ans.push_back(-1);}int main(){  cin&gt;&gt;n;  rep(i,0,(1&lt;&lt;n)){    scanf(&quot;%d&quot;,a+i);  }  rep(i,0,(1&lt;&lt;n)){    int r = build(i,a[i]);    if(!r){      printf(&quot;No\n&quot;);      return 0;    }  }  // rep(i,1,8){  //   printf(&quot;lr[%lld]= %d\n&quot;,i,lr[i]);  // }  rep(i,(1&lt;&lt;(n-1)),(1&lt;&lt;n)){    if(lr[i] == 0)continue;    fix(i);  }  int x = 0;  rep(pwr,0,n){    if(lr[1&lt;&lt;pwr] ^ xorcache[pwr]){      x |= 1&lt;&lt;pwr;      xorcache[pwr] ^= 1;    }  }  if(x){    ans.push_back(x);  }  rep(pwr,0,n){    rep(i,(1&lt;&lt;pwr),(1&lt;&lt;(pwr+1))){      if(lr[i]^xorcache[pwr]){        printf(&quot;No\n&quot;);        return 0;      }    }  }  printf(&quot;Yes\n&quot;);  printf(&quot;%d\n&quot;,(int)ans.size());  rep(i,0,(int)ans.size()){    printf(&quot;%d &quot;,ans[i]);  }  printf(&quot;\n&quot;);  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实我的思路和题解中trie树的结论是一致的,但是我的思路不是trie树形状的,所以再往后推导的阻力更大</p><p>一个经验就是对于这种2的幂次的 xor 或 加减操作,可以放在trie树中批量操作, 比如稍微变一变, 就可以变成给你+1/-1/xor操作序列,和询问第idx位置是什么,这样多个操作询问交替的题目</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>官方题解 <a href="https://atcoder.jp/contests/agc057/editorial/3925" target="_blank" rel="noopener">https://atcoder.jp/contests/agc057/editorial/3925</a></p>]]></content>
      
      
      <categories>
          
          <category> Atcoder </category>
          
          <category> AGC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
            <tag> trie树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces 1677E(线段树,倍数,贡献,单调栈,离线)</title>
      <link href="/Blog/2022-05-09-CF1677E/"/>
      <url>/Blog/2022-05-09-CF1677E/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://codeforces.com/contest/1677/problem/E" target="_blank" rel="noopener">https://codeforces.com/contest/1677/problem/E</a></p><p>给定1到n的排列</p><p>q个询问</p><p>每次问[l..r] 中有多少子区间, 满足 子区间存在不同的两个数的乘积 等于 子区间最大值</p><h1 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h1><p>n &lt;= 2e5</p><p>q &lt;= 1e6</p><p>4s</p><p>1024MB</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><code>a[1..n]</code>为给的排列</p><p>离线, 把所有查询<code>[l..r]</code> 按<code>r</code>升序</p><p><code>for(i = 1..n)</code> 在<code>i == r</code> 时,回答查询<code>[l..r]</code></p><p>线段树, 叶子节点记录<code>[l..j], (j&lt;=r)</code> 有多少个是满足的, 答案就是线段树的区间求和<code>query(o,1,n,l,r)</code></p><p>问题: 遍历过程中<code>i=&gt;i+1</code>时,也就是以<code>i==r</code>作为区间结束时,合法的区间<code>起始l</code>需要+1,但<code>合法的l</code>是散的,不是一个连续的区间, 这样更新复杂度高</p><hr><p>考虑加入<code>r</code>时, 左侧比它大的端点的贡献, 首先用单调栈记录(坐标增加,值减少)</p><p><code>vector&lt;pair&lt;value,position&gt;&gt; stk</code>, 其中<code>(stk[i].value = a[stk[i].position])</code></p><p>那么加入<code>{a[r],r}</code> 后会移除值比它小的, 变成</p><p><code>stk[0] ... stk[i-1] stk[i] ... stk[j] {a[r],r}</code></p><p>讨论3部分贡献</p><ol><li><p>以<code>a[r]</code> 为区间最大值, 那么必然 $(stk[j].position, r]$ 中找最右侧的位置<code>k</code>让<code>a[k..r]</code>中能有两个乘起来等于<code>a[r]</code>, 这样, 就有$k-stk[j].position$ 个合法方案</p></li><li><p>以<code>stk[i].value</code>为区间最大值, 且<code>stk[i].value</code> <strong>不是</strong><code>a[r]</code>的倍数, $max(k) ,k \in (stk[i-1].position,stk[i].position]$, 贡献为$k-stk[i-1].position$, 因为不是倍数, 显然并不会因为多了<code>a[r]</code> 影响以这个值为最大值的左侧选取的$k$, 所以换个说法就是, 它以原来的贡献又贡献了一轮</p></li><li><p>以<code>stk[i].value</code>为区间最大值, 且<code>stk[i].value</code> <strong>是</strong><code>a[r]</code>的倍数, $max(k) ,k \in (stk[i-1].position,stk[i].position]$, 贡献为$k-stk[i-1].position$, 是倍数, 所以需要看<code>stk[i].value/a[r]</code>这个值所在的位置是否会更新<code>k</code></p></li></ol><p>这样去统计, 单调队列中</p><hr><p>考虑变化</p><p>如果我们每个线段树节点记录了 <code>(对右侧贡献的左端点数量x, 总贡献数c)</code></p><p><code>(x0,c0) =&gt; (x1,c1)</code> 是怎么变化的呢</p><p><code>x1 = x0 + 那些</code>a[r]<code>倍数中超出来的长度</code></p><p><code>c1 = c0 + x1</code></p><p>注意的是, 可以lazytag记录有多少轮没有向下, 每次修改log级别个节点就行了</p><p>(这个方法感觉有实现问题, 我尝试做了一下,发现每次需要 <code>c += x</code>, 但是因为lazytag 的关系, 你一个节点上只能保存常数个x 和 常数个次数记录, 对于在 dep 层 的变化, lazytag down到dep+1层会覆盖x, 换句话说 lazy 的部分和历史每个节点内的x相关</p><hr><p>官方的代码, 记录的是<code>(x0,y0)</code></p><p><code>y0 = c0 - x0 * 轮次, y1 = c1 - x1*(轮次+1) = (x1+c0) - x1*(轮次+1) = y0 - (x1-x0) * 轮次</code></p><p>比记录<code>和</code>好的是,在不更新时(x,y)不会变,而c会变, 每次更新后所有节点都是正确的值, 因为lazy的部分只和当前轮次相关, 而这些轮次加和以后, 就是y的变化量</p><p>注意到 lazy的部分 (x1-x0) 要么是<code>len</code>要么是<code>-len</code>,  所以把符号给到<code>轮次</code>上, lazy<code>轮次</code>的和即可</p><p>而不是全覆盖的部分, 直接去更新到准确的<code>(x,y)</code></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="官方代码-注释"><a href="#官方代码-注释" class="headerlink" title="官方代码+注释"></a>官方代码+注释</h2><p><a href="https://codeforces.com/contest/1677/submission/156392477" target="_blank" rel="noopener">https://codeforces.com/contest/1677/submission/156392477</a></p><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)const int N=2e5;#define SEG_ROOT 1,1,n#define SEG_L (o&lt;&lt;1)#define SEG_R (o&lt;&lt;1|1)#define mid (l+r)/2#define SEG_L_CHILD SEG_L,l,mid#define SEG_R_CHILD SEG_R,mid+1,r#define SEG_L_CHILD_Q SEG_L,l,mid,ql,qr#define SEG_R_CHILD_Q SEG_R,mid+1,r,ql,qrint n; // 数组长度int a[N+10]; // 原始排列 1-indexint a2i[N+10]; // 值到下标 a2i[value] = indexint di; // 单调栈的尾部下标int d[N+10]; // 单调栈,存的原数组的下标 1-index, d[stack-index] = a-indexint i2di[N+10]; // [a中下标] = 栈中下标 映射  i2di[a-index] = stack-index , 0(表示不在栈中)int ti; // 当前遍历的个数 = i-1 or iint p[N+10]; // p[stack-index] = 左侧最大合法a-indexll ans[1000005]; // 询问的答案数组vector&lt;pair&lt;int,int&gt; &gt;q[1000005]; // 询问 q[right] = vector&lt;pair&lt;left,query index&gt; &gt;vector&lt;int&gt; w[N + 10]; // 因数分解 w[value]= vector&lt;value的因数&gt;struct seg {  // 答案 = x * ti + y  ll x; // 合法的左端点位置数  ll y; // (真实答案 与 x*ti 之间补充的差), 辅助变量, 因为直接记录答案无法维护x, 同理也可以记录(真实答案,x), y = 该段贡献 - x*ti, (x0,y0)=&gt;(x1,y1) : (y0+x0*ti) + x1 = (y1+x1*(ti+1)), y1 = y0 - (x1-x0)*ti  ll tg; // 未向下传递的ti的和, y += (+/- ti) * len  ll len; // 对应区间长度 简化书写} tr[N*4 + 10];// 初始化 线段树, 只有设置len = 区间长度,其它x,y,tg全为0void make(int o,int l,int r){  tr[o].len=r-l+1;  if (l==r) return;  make(SEG_L_CHILD);  make(SEG_R_CHILD);}// lazy tag 下降void down(int o) {  // x  if (tr[o].x == tr[o].len) {    tr[SEG_L].x = tr[SEG_L].len;    tr[SEG_R].x = tr[SEG_R].len;  }  if (tr[o].x==0) {    tr[SEG_L].x=0;    tr[SEG_R].x=0;  }  // 能向下的tag一定是区间全覆盖的  if(tr[o].tg != 0){    assert(tr[o].x == tr[o].len || tr[o].x == 0);    // y, 如下clear和add 同样的 y += tg * len    tr[SEG_L].y+=tr[o].tg*tr[SEG_L].len;    tr[SEG_R].y+=tr[o].tg*tr[SEG_R].len;    // tg    tr[SEG_L].tg+=tr[o].tg;    tr[SEG_R].tg+=tr[o].tg;    tr[o].tg=0;  }}// 更新 ovoid up(int o) {  tr[o].x=tr[SEG_L].x+tr[SEG_R].x; // 贡献数  tr[o].y=tr[SEG_L].y+tr[SEG_R].y; // 修正值}// 保证 tr[o].x == tr[o].lenvoid clear(int o,int l,int r,int ql,int qr) {  if (ql &lt;= l &amp;&amp; r &lt;= qr) {    // 贡献变化 tr[o].x * ti + tr[o].y =&gt; 0 * ti (当前轮) + (tr[o].y + ti * tr[o].len)    // (tr[o].y + ti * tr[o].len) - (tr[o].x * ti + tr[o].y)    // = ti * (tr[o].len - tr[o].x)    // = 0    assert(tr[o].x == tr[o].len);    tr[o].tg+=ti; // 选中 -&gt; 未选 未向下传递的, 对于下一级来说,也是 y+=ti*(len-x), 所以+ti传下去    tr[o].y += ti*tr[o].len;// y += ti * x =&gt; y += ti * len    tr[o].x=0;    return;  }  down(o);  if (ql&lt;=mid) clear(SEG_L_CHILD_Q);  if (qr&gt;mid) clear(SEG_R_CHILD_Q);  up(o);}// [ql..qr] 现在合法// 保证了 tr[o].x == 0void add(int o,int l,int r,int ql,int qr) {  if (ql &lt;= l &amp;&amp; r &lt;= qr) {    // 贡献变化 tr[o].x * ti + tr[o].y =&gt; tr[o].len * (ti+1) 下一轮 + (tr[o].y - ti * tr[o].len)    // (tr[o].len * (ti+1) + tr[o].y - ti * tr[o].len) - (tr[o].x * ti + tr[o].y)    // = tr[o].len - (tr[o].x * ti)    // = tr[o].len    assert(tr[o].x == 0);    tr[o].tg += -ti; // 未选 -&gt; 选中 未向下传递的    tr[o].y += -ti*tr[o].len; // y += -ti*(len - x) =&gt; y+= -ti * len    tr[o].x=tr[o].len;    return;  }  down(o);  if (ql&lt;=mid) add(SEG_L_CHILD_Q);  if (qr&gt;mid) add(SEG_R_CHILD_Q);  up(o);}ll find(int o,int l,int r,int ql,int qr) {  if (ql &lt;= l &amp;&amp; r &lt;= qr) return tr[o].y+ti*tr[o].x; // 如segtree的设计定义  down(o);  ll ret = 0;  if (ql&lt;=mid) ret+=find(SEG_L_CHILD_Q);  if (qr&gt;mid) ret+=find(SEG_R_CHILD_Q);  return ret;}int main() {  int m; // 询问次数  scanf(&quot;%d%d&quot;,&amp;n,&amp;m);  // 读入排列  rep(i,1,n+1){    scanf(&quot;%d&quot;,&amp;a[i]);    a2i[a[i]]=i;  }  // 读入询问  rep(i,1,m+1) {    int l,r;    scanf(&quot;%d%d&quot;,&amp;l,&amp;r);    q[r].emplace_back(l,i);  }  // 因数  rep(i,1,n+1)    for (int j=i;j&lt;=n;j+=i)      w[j].emplace_back(i);  // 初始化 线段树, 只有设置len = 区间长度,其它x,y,tg全为0  make(SEG_ROOT);  rep(i,1,n+1) { // a[i]    while (di &amp;&amp; a[d[di]]&lt;a[i]) { // 新加入的值, 比单调栈中的最小的小, 移除操作      if (p[di]&gt;d[di-1]) clear(SEG_ROOT,d[di-1]+1,p[di]); // 从贡献标记为不贡献, 但是对于总的贡献不变      // 出栈      i2di[d[di]]=0;      di--;    }    for (int j=a[i];j&lt;=n;j+=a[i]) { // j = a[i] 的倍数, j 作为最大值时      int k=i2di[a2i[j]]; // j在栈中下标      if (!k) continue; // 不在栈中      int l=d[k-1]+1,r=d[k]; // 左端点在范围 a[l..r] 中      int e=a2i[j/a[i]]; // 乘起来等于j的另一个因数在a中的下标      if (e&lt;l || e&gt;=i) continue; // e 在范围 a[l..i) 中, 不能选同一个ie平方      e=min(e,r); // 左端点范围的最大值 a[l..e]      if (e&lt;=p[k]) continue; // p[k] 最大值不更新      // a[l..p[k]] 合法 =&gt; a[l..e] 合法      add(SEG_ROOT,p[k]+1,e); // 把[p[k]+1,e] 从不贡献变成贡献, 更新到本轮结束时该有的(x,y)      p[k]=e;    }    // 入栈    d[++di]=i;    i2di[i]=di;    p[di]=d[di-1]; // 初始化p[di]表示以a[i]作为峰, 左侧端点不贡献    for (auto j:w[a[i]]) { // 枚举 因子对 (j,a[i]/j)      int l=d[di-1]+1;      // int r=i;      int e1=a2i[j];      int e2=a2i[a[i]/j];      if (e2&lt;=e1) continue; // 减少重复计算,主要是不等于      if (e1&lt;l || e2&gt;i) continue; // [l-1..e1..e2..i+1]      if (e1&lt;=p[di]) continue; // 不会更新可行值 [p[di] .. e1 .. i]      add(SEG_ROOT,p[di]+1,e1); // 从不贡献记为贡献, 更新到本轮结束时该有的(x,y)      p[di]=e1; // 更新    }    ti++;    for (auto t:q[i]) ans[t.second] = find(SEG_ROOT,t.first,i); // 查询[l = t.first,r = i]  }  rep(i,1,m+1) printf(&quot;%lld\n&quot;,ans[i]);  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>学会了一下新的线段树写法,以前我在左右拆点的时候, 会根据覆盖决定是</p><p><code>(ql,qr) =&gt; (ql,qr)</code> 还是<code>(ql,qr) =&gt; (ql,mid)</code> 还是 <code>(ql,qr) =&gt; (mid+1,qr)</code>  终止条件是<code>l == ql &amp;&amp; r == qr</code></p><p>这里学到了把终止条件改成<code>ql &lt;= l &amp;&amp; r &lt;= qr</code>, 这样的话, 传参就不用拆了<code>(ql,qr) =&gt; (ql,qr)</code></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://codeforces.com/contest/1678/attachments/download/16086/Codeforces%20Round%20789%20Editorial%20in%20Chinese.pdf" target="_blank" rel="noopener">https://codeforces.com/contest/1678/attachments/download/16086/Codeforces%20Round%20789%20Editorial%20in%20Chinese.pdf</a></p><p><a href="https://codeforces.com/blog/entry/102631" target="_blank" rel="noopener">https://codeforces.com/blog/entry/102631</a></p><p><a href="https://www.bilibili.com/video/BV1GS4y1b7SD" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1GS4y1b7SD</a></p>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
            <tag> 线段树 </tag>
            
            <tag> 贡献 </tag>
            
            <tag> 单调栈 </tag>
            
            <tag> 离线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces 1677D(冒泡排序, 排列)</title>
      <link href="/Blog/2022-05-09-CF1677D/"/>
      <url>/Blog/2022-05-09-CF1677D/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://codeforces.com/contest/1677/problem/D" target="_blank" rel="noopener">https://codeforces.com/contest/1677/problem/D</a></p><p>1到n的排列,进行k次冒泡排序<code>(for i = 0..n-1{if a[i] &gt; a[i+1]: swap(a[i],a[i+1])})</code>以后</p><p>每一位与它前面的逆序对个数为<code>v[i]</code></p><p><code>v[i] = count(a[j] &gt; a[i] &amp;&amp; j &lt; i)</code></p><p>现在给定数组<code>v</code>,其中<code>-1</code>表示任意值, 求有多少个原始序列 能k次冒泡排序后,逆序对满足v</p><p>答案<code>mod 998244353</code></p><p>保证<code>-1&lt;= vi &lt;=i</code></p><h1 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h1><p>t &lt;= 1000</p><p>k &lt; n &lt;= 1e6</p><p>2s</p><p>256MB</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>观察冒泡排序过程中 逆对的变化</p><p>如果<code>a[i]</code>前面有比它大的, 那么一次冒泡排序后,至多有一个移动到它后面, 且<code>a[i]</code>移动到了<code>a[i-1]</code></p><p>因此对于逆序对 <code>v[0] v[1] v[2] ... v[n]</code> 的变化是</p><p>如果<code>v[i] &gt; 0</code> , 那么一次排序后 <code>v[i-1] = v[i]-1</code></p><p>对于<code>v[i] == 0</code>, <code>0 v[i+1] v[i+2] v[i+3] ... v[j-2] v[j-1] 0</code>, 两个0之间其它非零</p><p>注意到上面 非0的结论, <code>(v[i+1]-1) (v[i+2]-1) (v[i+3]-1) ... (v[j-2]-1) (v[j-1]-1) 0 (v[?j+1]-1)</code>,</p><p>即是这个<code>0</code>会移动到下一个<code>0</code>的前一个位置,<code>a[j-1] = a[i]</code></p><hr><p>所以<code>0-index</code></p><p>最终<code>v[i] == 0</code> 操作前 <code>v[i+k] &lt;= k</code>(反证法) , <code>&lt;= min(k,i)</code></p><p>最终<code>v[i] &gt; 0</code> 操作前 <code>v[i+k] = k</code></p><p>最终<code>v[i] == -1</code> 操作前 <code>v[i+k]</code> 任意(<code>&lt;=i</code>)</p><p>最后k位一定是<code>0</code></p><hr><p>综上, 我们可以求得初始的<code>v</code>数组</p><p>其中 <code>[0..k-1]</code> 任意</p><p>其中 <code>[k..n]</code> 由按上述 平移确定具体情况</p><p>接下来讨论排列方案计算方式</p><p>如果完全自由就是<code>n!</code>,</p><p>考虑从<strong>后向前选</strong>, 如果位置<code>i</code>不受限制, 那么它有<code>i+1</code>种选法, 相当于每个位置的方案数和下标同增 <code>w[i] = i+1</code>(0-index)</p><p>如果它明确知道前面有几个比它小的, 那么只有唯一选法</p><p>如果它前面比它小的允许<code>&lt;=k</code>, 那么它有<code>k+1</code>种选法, 相当于<code>[0..k]</code>每个一种</p><hr><p>题目保证了<code>v[i]</code> 的范围,所以最多判断一下后k位是否为0即可</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><a href="https://codeforces.com/contest/1677/submission/156367090" target="_blank" rel="noopener">https://codeforces.com/contest/1677/submission/156367090</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 998244353#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)#define per(i,a,n) for (ll i=n;i--&gt;(ll)a;)int n,k;int v[1000010];int main(){  int t;  cin&gt;&gt;t;  while(t--){    scanf(&quot;%d %d&quot;,&amp;n,&amp;k);    rep(i,0,n){      scanf(&quot;%d&quot;,v+i);    }    ll ans = 1;    rep(i,0,n){      if(i &lt; k){ // 前k个自由        (ans*=i+1)%=MOD;      }else if(v[i-k] == -1){ // -1 自由        (ans*=i+1)%=MOD;      }else if(v[i-k] == 0){ // &lt;=k 即 [0..k] , k+1种        (ans*=k+1)%=MOD;      } // v[i-k] != 0 , 唯一选择(从后向前)    }    // 最后k个一定是0(也可以-1表示0)    rep(i,0,k){      if(v[n-1-i] &gt; 0)ans = 0;    }    printf(&quot;%lld\n&quot;,ans);  }  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>感觉还是考察 冒泡排序及其性质</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.bilibili.com/video/BV1GS4y1b7SD" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1GS4y1b7SD</a></p>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
            <tag> 冒泡排序及其性质 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atcoder arc139 D 频率频次, 贡献统计, 二项式分布</title>
      <link href="/Blog/2022-04-25-ac_arc139D/"/>
      <url>/Blog/2022-04-25-ac_arc139D/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://atcoder.jp/contests/arc139/tasks/arc139_d" target="_blank" rel="noopener">https://atcoder.jp/contests/arc139/tasks/arc139_d</a></p><p>长度为n的有序数组a</p><p>每次操作, 选择[1~m]中的一个插入并<strong>保持有序</strong>, 删除下标为X的数(1-index)</p><p>进行k次操作的所有结果的剩余数组元素的和, 模 998244353</p><h1 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h1><p>n,m,k &lt;= 2000</p><p>$X \in [1,n]$</p><p>$a_i \in [1,m]$</p><p>2s</p><p>1024MB</p><h1 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h1><p>如果知道 最后结果数组中, 位置i 为v 的出现次数,那么 最后只需要求和即可</p><p><code>cnt(a[i] == v)</code></p><p>注意到 a一直是有序的,也就是 <code>cnt(a[i] == v)</code> 也意味着 <code>a[i..n] &gt;= v</code></p><p><code>cnt(a[i] == v) = cnt(a[i..n] &gt;= v) - cnt(a[i..n] &gt;= v-1)</code></p><p>把<code>指定位置等于</code> 转化成 <code>指定范围大于等于</code>, 就能更容易进行状态转移了</p><p><code>dp[0..k][1..n][1..m]</code></p><p><code>dp[itr][idx][v] =</code> 第itr次操作后, 从idx到n 都大于等于v的方案数</p><p>注意到 转移的系数和 itr 无关,所以可能可以矩阵快速幂</p><blockquote><p>但是我没推出来</p></blockquote><h1 id="官方题解翻译"><a href="#官方题解翻译" class="headerlink" title="官方题解翻译"></a>官方题解翻译</h1><p>如果 对于$\forall v \in [1..m]$ 我们能找到结果中 $\leq v$ 的数出现的次数 的期望(频次 = 总次数 * 频率), 那么就能计算答案了(和上面我思路同理 都是 等于转化成 大于等于/小于等于)</p><p>题意转换:</p><blockquote><p>对于一个指定的$v$</p></blockquote><p>给定 $x \in [0,N]$</p><blockquote><p>$x$的意义是初始数组中 $\leq v$的个数</p></blockquote><p>操作: 概率$p = \frac{v}{m}$ 让<code>x=x+1</code>, 如果 $x\ge X$ , 让<code>x=x-1</code></p><blockquote><p>意义是 有概率$p$ 选择不超过$v$的数, 那么个数加一</p></blockquote><blockquote><p>如果 总个数 大于 删除下标, 那么 必定被删除一个, 那么个数减一</p></blockquote><p>找到执行了$K$次操作后, $x$的期望值</p><blockquote><p>也就是 剩下 $\leq v$ 的个数</p></blockquote><p>注意到$|x - (X-1)|$ 会单调递减</p><blockquote><p>换句话说, 如果 $初始x &gt; (X-1)$ 那么$初始x \ge 最终x \ge (X-1)$</p></blockquote><blockquote><p>如果 $初始x &lt; (X-1)$ 那么$初始x \leq 最终x \leq (X-1)$</p></blockquote><blockquote><p>$初始x$ 是从输入的a中统计的</p></blockquote><p>如果我们指定了最终的x, 那么得到这个x的 概率可以用二项式系数和幂次得到</p><hr><p>设 初始值为$x_0$, 最终为$x_1$</p><p>若 $x_0 \leq x_1 &lt; X-1$</p><p>也就是$k$次 操作中 $x_1 - x_0$ 次增加了1, 其它时候全未增加</p><p>概率为 $C(k, x_1-x_0) \cdot p^{x_1-x_0}(1-p)^{k-(x_1-x_0)}$</p><p>若 $x_0 &lt; x_1 = X-1$ (如果 都是$X-1$那概率就是1)</p><p>也就是$k$次 操作中 至少$x_1 - x_0$ 次增加了1, 其它时候任意</p><p>概率为 $\sum_{i=0}^{k-(x_1-x_0)} C(k, x_1-x_0 + i) \cdot p^{x_1-x_0 + i}(1-p)^{k-(x_1-x_0 + i)}$</p><p>看起来难算, 但是因为 上面的$x_1 \neq X-1$的和$x_1 = X-1$构成了所有情况, 所以实际上直接 1减去上面概率和就是剩下概率</p><hr><p>对于$初始x_0$大于$X-1$的同理</p><p>其中组合数可以预处理,幂次可以快速幂</p><p>综上 可算</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><a href="https://atcoder.jp/contests/arc139/submissions/31271889" target="_blank" rel="noopener">https://atcoder.jp/contests/arc139/submissions/31271889</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 998244353#define rep(i,a,n) for (ll i=a;i&lt;(ll)n;i++)ll a[2010];ll pro[2010][2010]; // [v][cnt] 结果 &lt;= v 的有cnt个的概率ll c[2010][2010];ll mypow(ll v,ll pwr){  v=(v+MOD)%MOD;  ll r = 1;  while(pwr){    if(pwr%2)(r*=v)%=MOD;    (v*=v)%=MOD;    pwr/=2;  }  return r;}// C(m,n) = m!/(n!(m-n)!)ll C(ll m,ll n){  if(n &gt; m)return 0;  return c[m][n];}int main(){  rep(i,1,2005){    c[i][0] = c[i][i] = 1;    rep(j,1,i){      c[i][j] = (c[i-1][j-1] + c[i-1][j])%MOD;    }  }  ll n,m,k,x;  cin&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;x;  ll invm = mypow(m,MOD-2);  x--; // 先减1  rep(i,0,n){    scanf(&quot;%lld&quot;,a+i);  }  sort(a,a+n);  rep(v,1,m+1){    int stx = 0;    rep(i,0,n){      if(a[i] &lt;= v)stx++;      else break;    }    if(stx == x){ // 结果必定 x      pro[v][x] = 1;      continue;    }    // p = v/m    ll p = v * invm %MOD;    rep(endx,0,n+1){      if(stx &lt; x){ // stx &lt;= endx &lt;= x        if(stx &lt;= endx &amp;&amp; endx &lt; x){          // C(k,endx-stx) * p^(endx-stx) * (1-p)^(k-(endx-stx))          pro[v][endx] = C(k,endx-stx) * mypow(p,endx-stx) %MOD * mypow(1-p,k-(endx-stx)) % MOD;        }      }else { // stx &gt; x =&gt; stx &gt;= endx &gt;= x        if(stx &gt;= endx &amp;&amp; endx &gt; x){          // C(k,stx-endx) * (1-p)^(stx-endx) * p^(k-(stx-endx))          pro[v][endx] = C(k,stx-endx) * mypow(1-p,stx-endx) %MOD * mypow(p,k-(stx-endx)) % MOD;        }      }    }    // 最后处理 (endx == x) , 等于 1-其它概率和    pro[v][x] = 1;    rep(endx,0,n+1){      if(endx == x)continue;      (pro[v][x] -= pro[v][endx])%=MOD;    }  }  ll leqv[2010] = {0};  ll ans = 0;  rep(v,1,m+1){    rep(cnt,0,n+1){      (leqv[v] += cnt*pro[v][cnt]%MOD)%=MOD; // 期望长度 = sum{期望*长度}    }    (ans += v*(leqv[v] - leqv[v-1]) %MOD)%=MOD; // count( == v) = count(&lt;= v) - count(&lt;= v-1)  }  printf(&quot;%lld\n&quot;, ((ans * mypow(m,k)%MOD)+MOD)%MOD); // 频次 = 总次数 * 频率  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p> 相对于以前不会 <code>count(x = v) = count(x &gt;= v) - count(x &gt;= v+1) = count(x &lt;= v) - count(x &lt;= v-1)</code> , 已经算是有进步,能想到转换了</p><ol><li><p>但是 对于上面 转换成概率 和 小于统计的想法还是不够, 一个是 想用坐标表示而不是明确的值的分界线表示, 题解就没有坐标作为键,只是把坐标作为值</p></li><li><p>虽然从频次上也能算,但是上到概率,推概率公式,算出概率再转换成频次都会容易进入思路, 需要增加 频次和概率之间的转换意识</p></li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>官方题解 <a href="https://atcoder.jp/contests/arc139/editorial/3860" target="_blank" rel="noopener">https://atcoder.jp/contests/arc139/editorial/3860</a></p><p>Youtube官方 <a href="https://www.youtube.com/watch?v=tIdPBN2x6KU" target="_blank" rel="noopener">https://www.youtube.com/watch?v=tIdPBN2x6KU</a></p>]]></content>
      
      
      <categories>
          
          <category> Atcoder </category>
          
          <category> ARC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 频率频次 </tag>
            
            <tag> 贡献统计 </tag>
            
            <tag> 二项式分布 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces 1671F(暴力 组合数)</title>
      <link href="/Blog/2022-04-25-CF1671F/"/>
      <url>/Blog/2022-04-25-CF1671F/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://codeforces.com/contest/1671/problem/F" target="_blank" rel="noopener">https://codeforces.com/contest/1671/problem/F</a></p><p>t 组测试</p><p>问 [1~n]的所有排列中</p><p>x个相邻逆序对, k个逆序对 有多少个, 答案取mod 998244353</p><h1 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h1><p>t&lt;=3e4</p><p>n &lt;= 998244353 - 1</p><p>k &lt;= 11</p><p>x &lt;= 11</p><p>4s</p><p>512MB</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>k和x很小</p><p>直接暴力算出 12! 的所有排列,记录 其中 (k,x) 和长度</p><p>那么答案相当于 把这些排列 插入到有序数字中</p><p>所以 再计算一个组合数</p><p>需要注意的是, [1~10] 的排列 可能是由 [1-4][1-6]的排列组成的, 所以 要注意不可分割的排列统计, 或者插入的时候 不支持相邻</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>暂无</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>暴力和关联性的思路对了, 但为啥我在想矩阵乘法而不是组合数,让我自己卡住了</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
            <tag> 暴力 </tag>
            
            <tag> 组合数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atcoder arc139 C 构造</title>
      <link href="/Blog/2022-04-25-ac_arc139C/"/>
      <url>/Blog/2022-04-25-ac_arc139C/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://atcoder.jp/contests/arc139/tasks/arc139_c" target="_blank" rel="noopener">https://atcoder.jp/contests/arc139/tasks/arc139_c</a></p><p>nxm格子选尽可能多的点</p><p>让每个点(x,y)的(x+3y)互不相等</p><p>且每个点(x,y)的(3x+y)互不相等</p><p>n,m &lt;= 1e5</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>我的思路是, 这相当于做的线性变换</p><p>每个点变成 (x,y) =&gt; (3x+y,x+3y)</p><p>要结果的点 的横纵坐标互不相等</p><p>那么原来是矩形的点, 映射后变成了斜着平行四边形的点</p><p>然后想办法尽可能多的找点, 但是我可能点画得不算多, 没有找到规律</p><pre><code class="py">import matplotlib.pyplot as pltx = []y = []for i in range(1, 10):    for j in range(1, 10):        x.append(3*i+j)        y.append(i+3*j)plt.plot(x, y, &#39;ro&#39;)ax = plt.gca()ax.set_xlim(0)ax.set_ylim(0)ax.xaxis.set_minor_locator(plt.MultipleLocator(1))ax.yaxis.set_minor_locator(plt.MultipleLocator(1))plt.grid(which=&#39;minor&#39;)plt.show()</code></pre><p><img src="/Blog/img/AC_AGC_139_1.png" alt="1"></p><hr><p>先考虑特殊情况足够大</p><p>那么对于 3x+y 有没有可能尽量排满</p><p>两种办法让3x+y 的增量为1</p><p>(x,y) =&gt; (x,y+1)</p><p>(x,y) =&gt; (x+1,y-2)</p><p>比较神奇的是</p><p>如果你考虑<code>x+3y</code>每次增加1的方案,是对称的</p><p>(x,y) =&gt; (x+1,y)</p><p>(x,y) =&gt; (x-2,y+1)</p><p>那么如图, 两个方法选的点(蓝色路线 和 绿色路线) 是一样的</p><p><img src="/Blog/img/AC_AGC_139_2.png" alt="2"></p><p>因此, 如果刚好 N=M, 且N是奇数, 就按照这个方法去选即可, 这样相当于把所有可能的(x+3y),(3x+y)的值都取到了</p><hr><p>非一般情况, 首先N,M 是可以轮换</p><p>所以不妨设 N&lt;=M</p><p>注意最大的个数,会被min(3n+m,n+3m) 限制, 也就是点的上界</p><p>但是如果短的边也是奇数的话</p><p>可以这样操作</p><p><img src="/Blog/img/AC_AGC_139_3.png" alt="3"></p><p>这样即满足题意, 又达到了上界</p><hr><p>两边不等,但是短边是 偶数长度</p><p><img src="/Blog/img/AC_AGC_139_5.png" alt="5"></p><p>这样即满足题意, 又达到了上界</p><hr><p>还有一个情况</p><p>两边相等,但是 是偶数长度</p><p><img src="/Blog/img/AC_AGC_139_4.png" alt="4"></p><p>如图, 距离上界还差4个, 但是看起来按现有的选法最多再选3个</p><p>下面证明 就是差一个</p><p>首先如果 N=2 , 那么M=2 最多选取 NM = 3N+M-4个</p><p>对于 N &gt;= 4,且为偶数</p><p>S = 从(3,1)开始, 通过多次 (+1,-3) / (+3,-1) 到达的所有点</p><p>注意到 这个集合中 其实就是 转换坐标轴后以 (3,1) 开始,同纵坐标,和同横坐标,反复关联的点</p><p><img src="/Blog/img/AC_AGC_139_6.png" alt="6"></p><p>而这些点,在x上的可选值 为 N/2-1, y上的可选值为N/2, 也就是S中的点本身是互相影响的点,而这些点占了N/2个位置,最多却只能选N/2-1, 因此 总的上界也是比范围小一</p><p>所以 不论N=2还是N&gt;=4 的偶数情况, 上述少选一个的方案 既能达到 又是上界</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>(无)</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>官方题解 <a href="https://atcoder.jp/contests/arc139/editorial/3863" target="_blank" rel="noopener">https://atcoder.jp/contests/arc139/editorial/3863</a></p><p>Youtube官方 <a href="https://www.youtube.com/watch?v=tIdPBN2x6KU" target="_blank" rel="noopener">https://www.youtube.com/watch?v=tIdPBN2x6KU</a></p>]]></content>
      
      
      <categories>
          
          <category> Atcoder </category>
          
          <category> ARC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
            <tag> 构造 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces 1661F(你真的会二分吗)</title>
      <link href="/Blog/2022-04-15-CF1661F/"/>
      <url>/Blog/2022-04-15-CF1661F/</url>
      
        <content type="html"><![CDATA[<p><img src="https://pbs.twimg.com/media/FQXM2cgVUAAVXpe?format=png&amp;name=360x360" alt></p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://codeforces.com/contest/1661/problem/F" target="_blank" rel="noopener">https://codeforces.com/contest/1661/problem/F</a></p><p>给你n个线段</p><p>问最少切多少次,让切割后所有线段长度平方和不大于m</p><h1 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h1><p>n&lt;=1e5</p><p>线段长度和 &lt;= 1e9</p><p>m &lt;= 1e18</p><p>7s</p><p>512MB</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="尝试"><a href="#尝试" class="headerlink" title="尝试"></a>尝试</h2><p>对于最外层的答案, 显然二分答案</p><p>那么问题变成了 如果指定切割k次, 能否满足条件</p><p>贪心: 从小到大, 判断剩余期望与已切割, 显然如果 当前 乘上段数 不大于剩余值, 那么不需要切割, 否则任意不合法必定存在比当前段更大的值, 要切也是切更大的</p><p>一定不切割的状态 能证明了, 但是不是这种状态时,可能切割也可能不切割, 即使切割, 怎么计算次数也不知道</p><p><a href="https://codeforces.com/contest/1661/submission/153691360" target="_blank" rel="noopener">https://codeforces.com/contest/1661/submission/153691360</a></p><p>例如两个线段 <code>3,4</code>, 要结果小于17, 最好的办法是均分4, 而这种没有对应的贪心规则, 上述方法不能判断</p><hr><p>另一个正确但是会超时的思路是</p><p>我们如果知道一个具体的段,要切割成多少份, 那么显然可以数学O(1)就算出这一段切割的最小值,(切割出来的尽量相等)</p><p>那么一个段 从 k次变成k+1次 它带来的变化量也是 上述计算相减,也是O(1)的</p><p>那么 我们直接维护优先队列 <code>(多切割一次代价,线段编号,当前切割次数)</code>, 这样每次取最大的切一下,放回去</p><p>复杂度就是 O(线段长度和), 也能直接计算出k次最优</p><p>问题是O(线段长度和)的计算代价, 甚至说这就是枚举答案了,外层的二分都没意义了</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>注意到 一个线段 随着切割次数变多, 每次贡献的代价也是单调递减的!!!!!!</p><p>再结合上面的 优先队列思路, 其实就是选取了k次最大值, 那么也就是 被选的 &gt;=x, 未被选的 &lt;= x</p><p>也就变成了找x, 满足如果被选的都是 大于x 则不满足题意,且如果被选的都是 大于等于 x 则满足题意</p><p>那么个数也就自然 是 大于x的个数,加上 与目标差距 除以 x 向上取整了</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 1000000007#define rep(i,a,n) for (ll i=a;i&lt;n;i++)#define per(i,a,n) for (ll i=n;i--&gt;a;)#define pb push_backconst double pi = acos(-1.0);// 0 &lt; a1 &lt; a2 &lt; a3..an 传送点// 传送消耗 (ai-aj)**2 能量// + 一些整数点 =&gt; a0 -&gt; an 能量消耗 &lt;= m// 最小整数点个数ll a[200010];vector&lt;ll&gt; segs ;int n;ll m;ll f(ll len, ll part){  if(part &gt; len)return len;  ll minv = len/part;  ll maxcnt = len%part;  // printf(&quot;f(%lld %lld) =&gt; %lld %lld =&gt; %lld\n&quot;,len,part,minv,maxcnt,minv*minv*(part - maxcnt) + (minv+1)*(minv+1) * maxcnt);  return minv*minv*(part - maxcnt) + (minv+1)*(minv+1) * maxcnt;}// 大于等于x的贡献都选pair&lt;ll,ll&gt; calc(ll x){ // 切割次数, 消耗平方值  assert(x &gt; 0);  ll cnt = 0; // 个数  ll sum = 0; // 消耗  rep(i,0,n){    if(x &lt;= 2){      sum += f(segs[i],1) - f(segs[i],segs[i]); // 1*1*segs[i];      cnt += segs[i] - 1;      continue;    }    // 最大的都不满足    if(f(segs[i],1) - f(segs[i],2) &lt; x){      continue;    }    // 二分切割的段    int l = 1, r = segs[i]; // l 满足 r 不满足    while(l+1&lt;r){      int mid = (l+r)/2;      if(f(segs[i],mid) - f(segs[i],mid+1)&gt;= x){        l = mid;      }else{        r = mid;      }    }    sum += f(segs[i],1) - f(segs[i],r);    cnt += l;  }  return {cnt,sum};}int main(){  ll cost = 0;  scanf(&quot;%d&quot;,&amp;n);  rep(i,1,n+1){    scanf(&quot;%lld&quot;,a+i);    segs.push_back(a[i]-a[i-1]);    cost += (a[i] - a[i-1])*(a[i] - a[i-1]);  }  scanf(&quot;%lld&quot;,&amp;m);  if(cost &lt;= m){    printf(&quot;0\n&quot;);    return 0;  }  // 找的是 x 不是答案  // l 满足 r 不满足  ll l = 0, r = 1&#39;000&#39;000&#39;000&#39;000&#39;000&#39;000;  while(l+1&lt;r){    // printf(&quot;[%lld %lld]\n&quot;,l,r);    ll mid = (l+r)/2;    if(calc(mid).second &gt;= cost - m){      l = mid;    }else{      r = mid;    }  }  assert(l != 0);  auto [c,s] = calc(r); // x+1 的所有  printf(&quot;%lld\n&quot;,c + (cost - m - s)/l + !!((cost - m - s)%l));  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>里面这个 二分好像很有用, 感觉之前做PE应该遇到过类似的,但是没想到二分,唉 我好蠢啊</p><h1 id="数学证明"><a href="#数学证明" class="headerlink" title="数学证明"></a>数学证明</h1><p>其实这里有一个东西 没有严格证明</p><p>就是 f(x,k) - f(x,k+1) 随着k增大而减小</p><p>难就难在它是整数划分, 如果是实数的话, 直接分析导数即可</p><p><a href="https://codeforces.com/blog/entry/101790?#comment-903251" target="_blank" rel="noopener">dreamoon</a></p><p><a href="https://codeforces.com/blog/entry/101790?#comment-903475" target="_blank" rel="noopener">jiangly</a></p><p>简单的说, 把 (x,k-1)的方案 和 (x,k+1)的方案拼在一起, 那么它一定是 2x 分割2k块的一个方案</p><p>那么 显然 (x,k)的方案的两倍 恰好是(2x,2k)的最优解</p><p>因此 2f(x,k) &lt;= f(x,k-1) + f(x,k+1) 即</p><p>f(x,k-1) - f(x,k) &gt;= f(x,k) - f(x,k+1) 得证</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/Code92007/article/details/124089868" target="_blank" rel="noopener">https://blog.csdn.net/Code92007/article/details/124089868</a></p>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷 P1036(prime)</title>
      <link href="/Blog/2022-04-11-luoguP1036/"/>
      <url>/Blog/2022-04-11-luoguP1036/</url>
      
        <content type="html"><![CDATA[<p>好久不登洛谷了, 最近翻了一下之前的一个帖子, 当时应该有其他事 没后续跟进了</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://www.luogu.com.cn/problem/P1036" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P1036</a></p><p>n个数</p><p>选k个出来和是质数的方案数</p><h1 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h1><p>n&lt;=20</p><p>ai&lt;=5e6</p><p>1s</p><p>128MB</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="数筛TLE"><a href="#数筛TLE" class="headerlink" title="数筛TLE"></a>数筛TLE</h2><p><a href="https://www.luogu.com.cn/record/25067342" target="_blank" rel="noopener">https://www.luogu.com.cn/record/25067342</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define ten5 100000+10#define MOD 1000000007#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define iif(c,t,f) ((c)?(t):(f))#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)#define pb push_back#define mp make_pairconst double pi = acos(-1.0);bool p[100000010];int ans = 0;int a[30];int n,k;void dfs(int idx,int picked,int cnt){  if(picked == k){    ans+=!p[cnt];    return ;  }  if(n - idx &lt; k-picked)return ;  dfs(idx+1,picked+1,cnt+a[idx]);  dfs(idx+1,picked,cnt);}int main(){  cin&gt;&gt;n&gt;&gt;k;  rep(i,0,n){    scanf(&quot;%d&quot;,a+i);  }  p[1] = 1;  rep(i,2,10001){    if(p[i] == 1)continue;    for(int j=i*i;j&lt;100000001;j+=i){      p[j] = 1;    }  }  dfs(0,0,0);  cout&lt;&lt;ans&lt;&lt;endl;  return 0;}</code></pre><h2 id="循环到根号n判质数竟然过了-而且搜到的一堆题解都是这样做"><a href="#循环到根号n判质数竟然过了-而且搜到的一堆题解都是这样做" class="headerlink" title="循环到根号n判质数竟然过了?而且搜到的一堆题解都是这样做"></a>循环到根号n判质数竟然过了?而且搜到的一堆题解都是这样做</h2><p><a href="https://www.luogu.com.cn/record/25067748" target="_blank" rel="noopener">https://www.luogu.com.cn/record/25067748</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define ten5 100000+10#define MOD 1000000007#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define iif(c,t,f) ((c)?(t):(f))#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)#define pb push_back#define mp make_pairconst double pi = acos(-1.0);//bool p[100000010];int ans = 0;int a[30];int n,k;bool pp(int v){  if(v==1)return 1;  int maxv = int(sqrt(v))+2;  rep(i,2,maxv){    if(v%i==0 &amp;&amp; v!=i){      return 1;    }  }  return 0;}void dfs(int idx,int picked,int cnt){  if(picked == k){    // ans+=!p[cnt];    ans+=!pp(cnt);    return ;  }  if(n - idx &lt; k-picked)return ;  dfs(idx+1,picked+1,cnt+a[idx]);  dfs(idx+1,picked,cnt);}int main(){  cin&gt;&gt;n&gt;&gt;k;  rep(i,0,n){    scanf(&quot;%d&quot;,a+i);  }  // p[1] = 1;  // rep(i,2,10001){  //   if(p[i] == 1)continue;  //   for(int j=i*i;j&lt;100000001;j+=i){  //     p[j] = 1;  //   }  // }  dfs(0,0,0);  cout&lt;&lt;ans&lt;&lt;endl;  return 0;}</code></pre><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>虽然当时发了帖子, 但是里面都在喷我表达不规范 XD, 没人给我说是数据其实很小的问题</p><p><a href="https://www.luogu.com.cn/discuss/153208" target="_blank" rel="noopener">https://www.luogu.com.cn/discuss/153208</a></p><p>数筛 是$O(sum + 2^n)$</p><p>而上面AC的代码是$O(max(2^n, sqrt(sum) \cdot 2^k))$</p><p>如果真如题目所说的数据范围, 其实数筛更有可能过大数据, 然而实际数筛TLE了</p><p>也有老哥说n实测出来最大是7,(7的话那的确第二种没啥问题), 那题目说你妈<code>n&lt;=20</code>呢?</p><p><a href="https://www.luogu.com.cn/discuss/347995" target="_blank" rel="noopener">https://www.luogu.com.cn/discuss/347995</a></p><h2 id="造数据"><a href="#造数据" class="headerlink" title="造数据"></a>造数据</h2><p>通过简单的尝试,生成了以下数列</p><pre><code class="py">for i in range(20):  print(5000000-1-6*i)</code></pre><pre><code>20 114999999 4999993 4999987 4999981 4999975 4999969 4999963 4999957 4999951 4999945 4999939 4999933 4999927 4999921 4999915 4999909 4999903 4999897 4999891 4999885</code></pre><p>这数据下</p><p>数筛<code>0.88s</code></p><p>后面方法<code>1.022s</code></p><p>电脑配置<code>i7-7700HQ</code></p><p>编译命令<code>clang++ -o Main Main.cpp -std=gnu++17 -O2 -g -Wall -Wcomma -Wextra -fsanitize=integer,undefined,null,alignment</code></p><h2 id="真题解-Miller-robin-特殊判定序列-这个可以极快判定64位以内的质数"><a href="#真题解-Miller-robin-特殊判定序列-这个可以极快判定64位以内的质数" class="headerlink" title="真题解 Miller robin + 特殊判定序列, 这个可以极快判定64位以内的质数"></a>真题解 Miller robin + 特殊判定序列, 这个可以极快判定64位以内的质数</h2><p><a href="https://www.luogu.com.cn/record/73708925" target="_blank" rel="noopener">https://www.luogu.com.cn/record/73708925</a></p><p><a href="https://yexiaorain.github.io/Blog/2021-06-12-project-euler216/">关于质数判别之前做PE时也写过</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef uint64_t ull;#define pb push_back#define rep(i,a,n) for (ll i=a;i&lt;n;i++)ll quick_p(ll b, ll p,const ll mod){  ll r = 1;  while(p){    if(p%2)(r*=b)%=mod;    (b*=b)%=mod;    p/=2;  }  return r%mod;}ll mr(ll base,ll v){  if(base &gt; v)return true;  ll startp = v-1;  while(startp%2 == 0)startp&gt;&gt;=1;  ll p = startp;  ll r = quick_p(base,p,v);  while(p != v-1){    if(r == v-1)return true;    if(r == 1)return p == startp;    p*=2;    // overflow    (r*=r)%=v;  }  return false;}bool is_prime_64(ll v){  if(v &lt; 2)return false;  if(v &lt; 4)return true;  // %6 = 1 or 5  if((v % 6) % 4 != 1)return false;  ll test_g[] = {2, 325, 9375, 28178, 450775, 9780504, 1795265022};  rep(i,0,7){    if(!(mr(test_g[i],v)))return false;  }  return true;}int ans = 0;int a[30];int n,k;void dfs(int idx,int picked,int cnt){  if(picked == k){    ans+=is_prime_64(cnt);    return ;  }  if(n - idx &lt; k-picked)return ;  dfs(idx+1,picked+1,cnt+a[idx]);  dfs(idx+1,picked,cnt);}int main(){  cin&gt;&gt;n&gt;&gt;k;  rep(i,0,n){    scanf(&quot;%d&quot;,a+i);  }  dfs(0,0,0);  cout&lt;&lt;ans&lt;&lt;endl;  return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> luogu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces 1658F(Math only)</title>
      <link href="/Blog/2022-04-08-CF1658F/"/>
      <url>/Blog/2022-04-08-CF1658F/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://codeforces.com/contest/1658/problem/F" target="_blank" rel="noopener">https://codeforces.com/contest/1658/problem/F</a></p><p>长度n的0/1串</p><p>找多个不重叠子串满足</p><ol><li>0/1比例和原串一致</li><li>长度和为m</li></ol><h1 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h1><p>m &lt;= n &lt;= 2e5</p><p>1s</p><p>256MB</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h2><p><a href="https://t.bilibili.com/646605883381383189" target="_blank" rel="noopener">https://t.bilibili.com/646605883381383189</a></p><ol><li>字符串拼成环</li><li>长度为m的1的个数,在相邻统计中变化最多为1, 所有的1个数和=m乘总的1的个数, 因此对于长度为m的1的个数 不会都大于目标也不会都小于目标,至少一个等于目标</li></ol><p>长度为m的在原数组内则一个, 跨了原数组边界则两个</p><hr><p>很明显不满足的我想到了,一个的很好做滑动窗口入门</p><p>但是我一直在想怎么证明 两个一定可以, 想了 单测大于小于, 全局不满足,但始终没想到 拼成环就容易搞了, 哎</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define pb push_backchar s[200010];int n,m;void work(){  scanf(&quot;%d %d&quot;,&amp;n,&amp;m);  scanf(&quot;%s&quot;,s);  int cnt1 = 0;  rep(i,0,n){    cnt1+=s[i] == &#39;1&#39;;  }  if((cnt1 * m ) % n != 0){    printf(&quot;-1\n&quot;);    return ;  }  int x = (cnt1*m)/n;  int c = 0;  rep(i,0,m){    c += s[i]==&#39;1&#39;;  }  rep(i,0,n){    if(c == x){      if(i &lt;= n-m){        printf(&quot;1\n&quot;);        printf(&quot;%d %d\n&quot;,i+1,i+m);      }else{        printf(&quot;2\n&quot;);        printf(&quot;%d %d\n&quot;,1,m-(n-i));        printf(&quot;%d %d\n&quot;,i+1,n);      }      return ;    }    c += s[(i+m)%n]==&#39;1&#39;;    c -= s[i]==&#39;1&#39;;  }}int main(){  int t;  cin&gt;&gt;t;  while(t--)work();  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Math啊 Math, 我怎么就想不出呢</p><p>看<a href="https://www.bilibili.com/video/BV1Ur4y1W7Rd" target="_blank" rel="noopener">jiangly老哥的视频,他只想了15min</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://codeforces.com/blog/entry/101302" target="_blank" rel="noopener">官方题解</a></p>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces 1657F(2-SAT,tarjan,scc)</title>
      <link href="/Blog/2022-04-03-CF1657F/"/>
      <url>/Blog/2022-04-03-CF1657F/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://codeforces.com/contest/1657/problem/F" target="_blank" rel="noopener">https://codeforces.com/contest/1657/problem/F</a></p><p>一个树上,每个点有小写字母</p><p>q个描述(&lt;=4e5)</p><p>ai,bi 的简单路径得到字符串si , 注意方向可能a到b,也可能b到a</p><p>求一种满足上述所有描述的一种方案,或输出无法满足</p><h1 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h1><p>点数不超过4e5</p><p>字符串长度和不超过4e5</p><p>9s</p><p>1GB</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="2-SAT"><a href="#2-SAT" class="headerlink" title="2-SAT"></a>2-SAT</h2><p>对于被字符串覆盖到的点, 如果正反字符相等,那么必定是这个字符</p><p>如果不等那么它也只有两种可能</p><p>于是问题变成了每个点有两种可能,并且选中其中一个时会决定它被覆盖的字符串上其它点的选择</p><p>这就是2-sat问题(每个点0/1 , 选定情况会决定其它的点情况,找一种可行方案)</p><p>2-sat问题的解法就是 建立有向图(注意这里是全部双向关系) ,求最大联通分量缩点,看是否有矛盾(一个点同时选了两个不同字符)</p><p>注意这里字符串在转化成图之前, 额外操作就是多个字符串覆盖到同一个点时, 有时能直接确定哪个字符是有效的,无效字符可以在转化前确定一部分</p><p>处理也很直白,同字符唯一确定,不同字符两个可能,多个字符串覆盖, 需要一个字符出现次数刚好是多个字符出现总次数一半</p><h2 id="最大联通分量scc"><a href="#最大联通分量scc" class="headerlink" title="最大联通分量scc"></a>最大联通分量scc</h2><p>上述处理以后就是scc的求解,这直接上tarjan</p><p>tarjan 主要就是</p><p>dfn 深度搜索访问记号</p><p>low 最小可达的前向点记号</p><p>stk 当前访问栈</p><p>res 结果数组</p><pre><code>tarjan(u){    DFN[u] = Low[u] = ++Index//为节点u设定次序编号和Low初值    Stack.push(u) //将节点u压入栈中    for each(u,v) in E //枚举每一条边        if (v not visited) //如果节点v未被访问过            tarjan(v) //继续向下找            Low[u]=min(Low[u],Low[v])        else if (v in S) //如果节点v还在栈内                Low[u]=min(Low[u], DFN[v])    if ( DFN[u] == Low[u] ){ //如果节点u是强连通分量的根        component = {}        repeat{            v = S.pop//将v退栈，为该强连通分量中一个顶点            component.append(v)            until( u == v)        }        print component    }}</code></pre><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;(n);i++)#define per(i,a,n) for (ll i=(ll)n-1;i&gt;=a;i--)#define pb push_backconst int N = 400000;vector&lt;int&gt; p2[N+10];int dep[N+10];int fa[N+10];char s[N+10];map&lt;char,vector&lt;int&gt; &gt; p2charid[N+10];vector&lt;pair&lt;int,char&gt; &gt; id2pchar;vector&lt;int&gt; id2scc;vector&lt;vector&lt;int&gt; &gt; scc2ids ;vector&lt;bool&gt; vis ;char ans[N+10];class Tarjan{  vector&lt;int&gt; low;  vector&lt;int&gt; dfn;  stack&lt;int&gt; stk;  vector&lt;int&gt; res;  vector&lt;vector&lt;int&gt; &gt; p;  int n;  void scc(int v) {    static int id = 0;    low[v] = dfn[v] = ++id;    stk.push(v);    for(auto w:p[v]){      if(!dfn[w]){ // 未访问过        scc(w);        low[v] = min(low[v],low[w]);      } else if(!res[w]){ // 访问过但没有结果(在栈中)        low[v] = min(low[v],dfn[w]);      }    }    int u;    if(low[v] == dfn[v])  {      do{        res[u = stk.top()] = v;        stk.pop();      }while(u != v);    }  }public:  Tarjan(int SZ):n(SZ){    low = vector&lt;int&gt;(n+1);    dfn = vector&lt;int&gt;(n+1);    stk = {};    res = vector&lt;int&gt; (n+1);    p = vector&lt;vector&lt;int&gt; &gt;(n+1);  }  vector&lt;int&gt; calc(){    rep(i,1,n+1){      if(!res[i]){        scc(i);      }    }    return res;  }  void p2(int i,int j){    p[i].pb(j);  }};void build(int idx,int father){  fa[idx] = father;  dep[idx] = dep[father]+1;  for(auto x:p2[idx]) {    if(x == father)continue;    build(x, idx);  }}// 因为要具体路径, LCA帮不上忙,直接暴力找vector&lt;int&gt; getpath(int u,int v){  if(dep[u] &gt; dep[v])swap(u,v);  vector&lt;int&gt; r1 = {};  vector&lt;int&gt; r2 = {};  while(dep[v] &gt; dep[u]){    r1.push_back(v);    v = fa[v];  }  while(u != v){    r1.push_back(v);    v = fa[v];    r2.push_back(u);    u = fa[u];  }  r1.push_back(u);  per(i,0,r2.size()){    r1.push_back(r2[i]);  }  return r1;}bool add(int u,int v, Tarjan &amp;t){  vector&lt;int&gt; path = getpath(u, v);  // 只记录不确定的  vector&lt;int&gt;inc;  vector&lt;int&gt;dec;  rep(i,0,(int)path.size()){    int p = path[i];    char ch1 = s[i];    char ch2 = s[path.size() - 1 -i];    if(ch1 == ch2){ // 直接确定      if(ans[p] != 0 &amp;&amp; ans[p] != ch1){        return false;      }      ans[p] = ch1; // 一个的改值, 两个的是 增加统计    }else{ // 先建立关系 不关心冲突      int id = id2pchar.size();      id2pchar.push_back({p,ch1});      p2charid[p][ch1].push_back(id);      inc.pb(id);      id = id2pchar.size();      id2pchar.push_back({p,ch2});      p2charid[p][ch2].push_back(id);      dec.pb(id);    }  }  assert(dec.size() == inc.size());  rep(i,0,(int)inc.size()){    t.p2(inc[i],inc[(i+1)%inc.size()]);    t.p2(dec[i],dec[(i+1)%dec.size()]);  }  return true;}bool checkscc(int scc){  vector&lt;pair&lt;int,char&gt;&gt; pch;  for(auto id:scc2ids[scc]){    auto [p, ch] = id2pchar[id];    if(ans[p] == ch || ans[p] == 0){      pch.push_back({p,ch});    }else{      return false;    }  }  sort(pch.begin(),pch.end());  rep(i,1,(int)pch.size()){    if(pch[i-1].first != pch[i].first) continue; // 同一个点    if(pch[i-1].second != pch[i].second) return false; // 不同字符  }  return true;}bool applyscc(int scc){  vis[scc] = true;  for(auto id:scc2ids[scc]){    auto [p, ch] = id2pchar[id];    if(ans[p] == ch)continue;    if(ans[p] == 0){      ans[p] = ch;    }else{      return false;    }  }  return true;}bool rmscc(int scc){  vis[scc] = true;  for(auto id:scc2ids[scc]){    if(id == 1)continue;    auto [p, ch] = id2pchar[id];    if(ans[p] == ch) return false; // 失效和已经填入的冲突    if(p2charid[p].count(ch)){      p2charid[p].erase(ch);      if(ans[p] == 0 &amp;&amp; p2charid[p].size() == 0)return false; //      if(p2charid[p].size() == 1){        auto [ch,ids] = *p2charid[p].begin();        if(ans[p] != 0 &amp;&amp; ans[p] != ch)return false;        ans[p] = ch;        for(auto id:ids){          if(!vis[id2scc[id]]){            int r = applyscc(id2scc[id]);            if(!r)return r;          }        }      }    }  }  return true;}int main(){  id2pchar.push_back({-1,&#39;X&#39;}); // 占位0  id2pchar.push_back({-1,&#39;X&#39;}); // 建立特殊失效节点, 下标为1  int n,q;  cin&gt;&gt;n&gt;&gt;q;  rep(i,0,n-1){    int u,v;    scanf(&quot;%d %d&quot;,&amp;u,&amp;v);    p2[u].push_back(v);    p2[v].push_back(u);  }  build(1,0); // 父节点和深度  Tarjan t(2*N+2);  rep(i,0,q){    int u,v;    scanf(&quot;%d %d&quot;,&amp;u,&amp;v);    scanf(&quot;%s&quot;,s);    bool r = add(u,v,t);    if(!r){      printf(&quot;NO\n&quot;);      return 0;    }  }  // 处理每个点明确不可能的情况  rep(i,1,n+1) {    if(ans[i]){ // 已确定的      for(auto [ch,ids]:p2charid[i]){        if(ch == ans[i])continue;        for(auto id: ids){          t.p2(1,id); // 失效的          t.p2(id,1); // 失效的        }      }    }else{ // 未确定的      if(p2charid[i].size() == 0){        ans [i] = &#39;a&#39;; // 没有限制      }else { // 每次贡献两个不同的,那么答案要占恰好一半出现        int total = 0;        for(auto [ch,ids]:p2charid[i]){          total+=ids.size();        }        for(auto [ch,ids]:p2charid[i]){          if((int)ids.size()*2 != total){            for(auto id: ids){              t.p2(1,id); // 建立不可能              t.p2(id,1);            }          }        }      }    }  }  id2scc = t.calc();  scc2ids = vector&lt;vector&lt;int&gt;&gt;(id2pchar.size());  vis = vector&lt;bool&gt;(id2pchar.size());  rep(i,1,(int)id2pchar.size()){    scc2ids[id2scc[i]].pb(i);  }  // 处理掉直接不可能  bool r = rmscc(1);  if(!r){    printf(&quot;NO\n&quot;);    return 0;  }  rep(scc,2,(int)id2pchar.size()){    if(!scc2ids[scc].size())continue;    if(vis[scc])continue;    if(!checkscc(scc)){      bool r = rmscc(scc);      if(!r){        printf(&quot;NO\n&quot;);        return 0;      }    }else{      bool r = applyscc(scc);      if(!r){        printf(&quot;NO\n&quot;);        return 0;      }    }  }  rep(i,1,n+1){    if(!ans[i]){      printf(&quot;NO\n&quot;);      return 0;    }  }  printf(&quot;YES\n&quot;);  rep(i,1,n+1){    printf(&quot;%c&quot;,ans[i]);  }  printf(&quot;\n&quot;);  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>还是知识点不够, 一个是太久没写tarjan scc,一个是没搞过2-sat</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://codeforces.com/blog/entry/101161" target="_blank" rel="noopener">官方题解</a></p>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scc </tag>
            
            <tag> tarjan </tag>
            
            <tag> 最大联通分量 </tag>
            
            <tag> 2-SAT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces 1654F(神奇的逐位排序, 基数排序, 后缀数组)</title>
      <link href="/Blog/2022-03-30-CF1654F/"/>
      <url>/Blog/2022-03-30-CF1654F/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://codeforces.com/contest/1654/problem/F" target="_blank" rel="noopener">https://codeforces.com/contest/1654/problem/F</a></p><p>给一个字符串,长度$2^n$</p><p>找一个$j &lt;= 2^n$, 让<code>s[i^j]</code> 字典序最小</p><h1 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h1><p>n &lt;= 18</p><p>3s</p><p>512MB</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="我的尝试"><a href="#我的尝试" class="headerlink" title="我的尝试"></a>我的尝试</h2><p>我想到,j的位是0或1实际上意味着 原字符串 的长度2^k 区间是否交换</p><p>而判断是否交换,可以局部贪心</p><p>问题是,存在字符相等的情况, 不知道怎么记录, 试了一下random 并不能骗分哈哈</p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 1000000007#define rep(i,a,n) for (ll i=a;i&lt;n;i++)#define per(i,a,n) for (ll i=n-1;i&gt;=a;i--)#define pb push_backconst double pi = acos(-1.0);// n =&gt; 2^n length lowercase letters//// t[i] = s[i ^ j]//// find j =&gt; minimal string// n &lt;= 18// 2^n &lt;= 262144// bit1 ,一个一组,相邻交换// bit2 ,2个一组,相邻交换// bit3 ,3个一组,相邻交换// bit4 ,4个一组,相邻交换// ans(0..x)// =&gt; min(ans(0..x/2),ans(x/2+1...x)) 最小的作为前缀// 3**18 =&gt; 387420489int n;char s[270010];int ans[270010][20];int cmp(int p,int pwr,int l,int r){  // 自己所在的那一节  rep(i,0,(1&lt;&lt;pwr)){    if(s[(p + i) ^ l] &lt; s[(p + (1&lt;&lt;pwr) + i) ^ r]) return -1;    if(s[(p + i) ^ l] &gt; s[(p + (1&lt;&lt;pwr) + i) ^ r]) return 1;  }  // 对手那一行  rep(i,0,(1&lt;&lt;pwr)){    if(s[(p + (1&lt;&lt;pwr) + i) ^ l] &lt; s[(p + i) ^ r]) return -1;    if(s[(p + (1&lt;&lt;pwr) + i) ^ l] &gt; s[(p + i) ^ r]) return 1;  }  return 0;}ll tryRand(){  rep(i,1,n+1){    for(int p = 0;p &lt; (1&lt;&lt;n); p += (1&lt;&lt;i)){      int lans = ans[p][i-1];      int rans = ans[p+(1&lt;&lt;(i-1))][i-1];      int res = cmp(p,i-1,lans,rans);      // TODO 相等的情况??????      if(res == 0){        // printf(&quot;fuck?\n&quot;);        if(rand()%2){          ans[p][i] = lans;        }else{          ans[p][i] = (rans | (1&lt;&lt;(i-1)));        }      } else if(res == -1){        ans[p][i] = lans;      }else{        ans[p][i] = (rans | (1&lt;&lt;(i-1)));      }    }  }  return ans[0][n];}int main(){  srand(time(NULL));  cin&gt;&gt;n;  scanf(&quot;%s&quot;,s);  int j = tryRand();  rep(t,0,180){    int k = tryRand();    rep(i,0,(1&lt;&lt;n)){      if(s[i ^ j] &lt; s[i ^ k])break;      if(s[i ^ j] == s[i ^ k])continue;      j = k;      break;    }  }  rep(i,0,(1&lt;&lt;n)){    printf(&quot;%c&quot;, s[i ^ j]);  }  printf(&quot;\n&quot;);  return 0;}</code></pre><h2 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h2><p>实际上可以看成, 把 <code>0~n-1</code>排序</p><p>而排序是按照<code>f(s,i)</code>的字典序来比较大小的</p><p>这里的问题是 如果两两比较 依然复杂度完成不了, 如何减少比较和处理相等</p><p>考虑样例1: <code>acba</code></p><pre><code>0: acba1: caab2: baac3: abca</code></pre><p>最终期望得到</p><pre><code>3: abca0: acba2: baac1: caab</code></pre><p>然而注意到, </p><p>首位的比较 就是 s[i]</p><p>第2位的比较 就是 s[i ^ (1&lt;&lt;0)]</p><p>第3位的比较 就是 s[i ^ (1&lt;&lt;1)]</p><p>第4位的比较 就是 s[i ^ (1&lt;&lt;2)]</p><p>而 一旦首位有非相等的大小关系了,之后也就不会改变相对顺序, 不想等时 才考虑后续排序</p><hr><p>于是, 按首位排序</p><pre><code>0: a1: c2: b3: a</code></pre><p>变为</p><pre><code>0: a3: a2: b1: c</code></pre><p>记录大小顺序</p><pre><code>0: a(0)3: a(0)2: b(1)1: c(2)</code></pre><p>按照第二位排序</p><pre><code>0: ?c1: ?a2: ?a3: ?b</code></pre><p>得到</p><pre><code>1: ?a2: ?a3: ?b0: ?c</code></pre><p>整体变为(注意首位不相等的要保持顺序)</p><pre><code>3: ab0: ac2: ba1: ca</code></pre><p>记录大小顺序</p><pre><code>3: ab(0)0: ac(1)2: ba(2)1: ca(3)</code></pre><p>这样所有位排序, 更新顺序即可</p><p>换句话说就是类似基数排序, 每次是对前缀相等的一系列值的下一位 进行排序</p><p>这里注意到看上去字符串长度,有<code>1 &lt;&lt; n</code>, 但是实际上,上述排序只需要考虑2的幂次的</p><p>因为,[2..3] 的排序 实际是 ([0..1]^2)得到的排序</p><p>因为,[4..7] 的排序 实际是 ([0..3]^4)得到的排序</p><p>所以 虽然是基数排序,但是 能通过幂次 和记录大小的排序值 优化比较次数</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 1000000007#define rep(i,a,n) for (ll i=a;i&lt;n;i++)#define per(i,a,n) for (ll i=n-1;i&gt;=a;i--)#define pb push_backconst int N = 1 &lt;&lt; 18;int n, a[N], val[N], tmp[N], now;char s[N];// x 在 y 前面bool cmp(int x, int y) {  return (val[x] == val[y]) ?    val[x ^ now] &lt; val[y ^ now] :    val[x] &lt; val[y];}int main() {  cin&gt;&gt;n;  scanf(&quot;%s&quot;, s);  rep(i,0,1&lt;&lt;n){    val[i] = s[i] - &#39;a&#39;; // [0,26), 实际表示的是以 (1&lt;&lt;pwr) 跨度排序 的 顺序下标,    a[i] = i; // 相当于 0 ~ 2^n-1 中 让s字典序最小的  }  rep(pwr,0,n) {    now = 1 &lt;&lt; pwr; // 比较区间长度    sort(a, a + (1 &lt;&lt; n), cmp);    int num = 0; // 离散化顺序值    rep(j,0,1&lt;&lt;n){      if (j &gt; 0 &amp;&amp; cmp(a[j - 1], a[j])) num ++; // f(a[j-1]) &lt; f(a[j]) =&gt; num++; 明确j比前一个大      tmp[a[j]] = num;    }    rep(j,0,1&lt;&lt;n){      val[j] = tmp[j]; // 记录的是 now*2 长度 的 排序 序号    }  }  rep(i,0,1&lt;&lt;n){    putchar(s[i ^ a[0]]);  }  return 0;}</code></pre><p>pwr = 0, now = 1</p><p>如果字符 更小,则排在前面</p><p>如果字符 相等,则它^1位置的更小就排在前面, 如果依然相等,则认为当前论次比较它们两相等</p><p>修改val[i] = 表示选定异或值<code>i</code>, 让 <code>s</code>在i 的转换下, 前两位 在所有i 中的 顺序</p><p>pwr = 1, now = 2</p><p>注意到上面val意义已经变化</p><p>val[i] 表示的是 i 引起的转换 的前两位的排序值</p><p>如果排序值更小,则排在前面</p><p>如果排序值相等,则它^2位置的更小就排在前面, 如果依然相等,则认为当前论次比较它们两相等</p><p>修改val[i] = 表示选定异或值<code>i</code>, 让 <code>s</code>在i 的转换下, 前4位 在所有i 中的 顺序</p><p>pwr = 2, now = 4</p><p>val[i] 表示的是 i 引起的转换 的前4位的排序值</p><p>如果排序值更小,则排在前面</p><p>如果排序值相等,则它^4位置的更小就排在前面, 如果依然相等,则认为当前论次比较它们两相等</p><p>修改val[i] = 表示选定异或值<code>i</code>, 让 <code>s</code>在i 的转换下, 前8位 在所有i 中的 顺序</p><p><code>pwr = n, now = 2**n</code></p><p>val[i] 表示的是 i 引起的转换 的前now位的排序值</p><p>如果排序值更小,则排在前面</p><p>如果排序值相等,则它xor now 位置的更小就排在前面, 如果依然相等,则认为当前论次比较它们两相等</p><p>修改val[i] = 表示选定异或值<code>i</code>, 让 <code>s</code>在i 的转换下, 前<code>now*2</code>位 在所有i 中的 顺序</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>每次排序,再记录顺序, 方便后续比较,而不仅仅排序就完了, 这个记录顺序很重要</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://codeforces.com/blog/entry/100127" target="_blank" rel="noopener">官方题解</a></p>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基数排序 </tag>
            
            <tag> 后缀数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces 1654E(按类别分治)</title>
      <link href="/Blog/2022-03-29-CF1654E/"/>
      <url>/Blog/2022-03-29-CF1654E/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://codeforces.com/contest/1654/problem/E" target="_blank" rel="noopener">https://codeforces.com/contest/1654/problem/E</a></p><p>给一数列,修改尽量少的值让整个数列等差</p><h1 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h1><p>n &lt;= 1e5</p><p>1&lt;= ai &lt;= 1e5</p><p>5s</p><p>1GB</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>实际上是二维点(i,ai),找直线经过最多的点</p><p>考虑增量 小于 sqrtn,那么选中斜率, 计算每个点沿着斜率与y轴交点 出现的最多次即可, 不要用map,用数组和清理数组实现</p><p>考虑增量 大于 sqrtn,以每个点作为起点,那么最多尝试这个点向后n/sqrt(n) 个点, 把这些点计算出现最多次数的斜率, 数量不多,可以用map</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 1000000007#define rep(i,a,n) for (ll i=a;i&lt;n;i++)#define per(i,a,n) for (ll i=n-1;i&gt;=a;i--)#define pb push_backconst double pi = acos(-1.0);const int N = 100000;int a[N+10];int used[32000010];int n;int work(){  int SQRT = 316;  int ans = 0;  // 增量 &lt;= SQRT;  rep(i,0,SQRT+1){    vector&lt;int&gt; rm;    rep(j,0,n){      // 非负便宜量      int v = a[j] + SQRT*N- j*i; // max = 31600000+100000      if(!used[v])rm.push_back(v);      ans = max(ans,++used[v]);    }    // clear    for(auto v:rm){      used[v] = 0;    }  }  // 增量 大于 SQRT  rep(j,0,n){ // 下标    map&lt;int,int&gt; kcnt;    rep(i,j+1,n){ // 增量      if(a[j] + (i-j) * SQRT &gt; N) break;      if( (a[i] - a[j]) % (i-j) == 0){        kcnt[(a[i] - a[j]) / (i-j)]++;      }    }    for(auto [k,cnt]:kcnt){      // printf(&quot;a[%lld] = %d : k=%d cnt = %d\n&quot;,j,a[j],k,cnt+1);      ans = max(ans, cnt+1);    }  }  return ans;}int main(){  cin&gt;&gt;n;  rep(i,0,n){    scanf(&quot;%d&quot;,a+i);  }  int ans = work();  // 翻转  rep(i,0,n/2){    swap(a[i],a[n-1-i]);  }  printf(&quot;%d\n&quot;,n - max(ans,work()));  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>按照一个值,分段处理,每一段都是性能满足的</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://codeforces.com/blog/entry/100127" target="_blank" rel="noopener">官方题解</a></p>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分治 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces 1648D(二分，单调队列，前缀和，线段树，区间覆盖，动态规划)</title>
      <link href="/Blog/2022-03-21-cfP1648D/"/>
      <url>/Blog/2022-03-21-cfP1648D/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://codeforces.com/contest/1648/problem/D" target="_blank" rel="noopener">https://codeforces.com/contest/1648/problem/D</a></p><p><code>3xn</code> 左上角 走到 右下角，只能右和下两个方向的走，价值= 经过块的值的和</p><p>第一行，第三行直接可走，第二行需要额外代价<code>v</code>,开启<code>[l,r]</code>一段</p><p>问总获得价值最大值</p><h1 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h1><p>n &lt;= 5e5</p><p>块上值 -1e9 ~ 1e9</p><p>可选扩展 5e5 个，扩展代价 1~1e9</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="行走代价简化"><a href="#行走代价简化" class="headerlink" title="行走代价简化"></a>行走代价简化</h2><p>走过的样子无非是</p><pre><code>xxxxxx     xxxxxxx           xxxxxxxxx</code></pre><p>拆分一下, </p><p>第一段： 第一行+，第二行-</p><p>第二段： 第二行+，第三行+</p><pre><code>     i++++++-----            j+++++++++++++            +++++++++</code></pre><p>那么行走代价为<code>s[i]+t[j]</code></p><p>剩下就是开放(i,j)的最小代价 </p><h2 id="状态与转移与范围最值"><a href="#状态与转移与范围最值" class="headerlink" title="状态与转移与范围最值"></a>状态与转移与范围最值</h2><p>考虑从<code>(1,1)</code>走到<code>(2,i)</code>, 其中当前使用的最右侧的开放端点是<code>i</code></p><pre><code>     ?xxxxxx      i     xxxxxxxx        [   ]      [  ]    [  ]</code></pre><p><code>dp[i]</code> = <code>(1,1) -&gt; (2,i)</code> 且<code>i</code> 是当前最右侧开放的点, 上述条件下 , 最大的 <code>s[?] - cost(?,i)</code></p><p>这里两点</p><ol><li><code>i</code> 是某个区间右侧端点, 且走到了这个位置</li><li>dp表示的是这样范围中最大的, 包含<code>s</code> 和 <code>cost</code> , 这里很神奇，没有t意味着，下面转移时并不用考虑第二行所选位置对dp的影响</li></ol><p>也就是一个准确，一个范围最值</p><hr><p>状态转移，</p><p>要么是通过第一行直接进入所选区间走到i,</p><p>要么就是先走到<code>(2,j)</code>, 再在一个区间内走到i, 所以 j 在 <code>[l-1,r]</code> 内</p><pre><code>     ?xxxxxx       j     xxxxxxxxx           [      ]xxxxxx            i     xxxxxxxxxxxxxx</code></pre><p><code>dp[i] = max(dp[j] - cost(i,j).value)</code></p><hr><p>剩下的就是最终的答案, 因为可能走到不是某个区间的终点，就去第三行了</p><pre><code>     ?xxxxxx         i  j     xxxxxxxxxxxxxx                  xxxxxxx              [      ]</code></pre><p><code>ans = max(dp[i] - cost(i,j).value + t[j])</code>， <code>i</code>,<code>j</code> 在某个区间内，<code>i &lt; j</code>, 对于相等的情况 上面直接<code>+t[i]</code>就更新</p><p>换个角度，先固定一个区间,<code>cost</code>确定,再在这个区间里找 <code>max(dp[i]+t[j])</code></p><p>其中<code>i</code> 在<code>[l-1,r]</code>内</p><hr><p>注意到上面的方案，一定经过了某个开放区间的终点，开放区间为 &gt;= 1 个 ，所以还有一种情况，只开放了一个区间，i和j都在区间之中</p><p>上面最重要的是控制成了<strong>一个</strong>区间,但不一定是唯一一个区间</p><p>而上面的操作和只开放一个区间十分的像，都是开放一个区间，左dp[i],右t[j] 和(i &lt; j) 左s[i],右t[j] (i &lt;= j)</p><p>注意到对于左dp,右t的情况，i==j只会产生比最优更小的答案，所以可以考虑在最值处理时合并<code>left[i] = min(dp[i],dp[i-1],s[i])</code></p><p>最后特化成只开放一个区间的问题</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 1000000007#define rep(i, a, n) for (ll i = a; i &lt; n; i++)#define pb push_back#define SEG_ROOT 1,0,n-1#define SEG_L o&lt;&lt;1,l,m#define SEG_R o&lt;&lt;1|1,m+1,rconst double pi = acos(-1.0);const int N = 500&#39;000;ll s[N + 10];ll t[N + 10];ll dp[N + 10];ll a[3][N + 10];vector&lt;tuple&lt;int, int, ll&gt; &gt; rlv;ll seg[2][N * 4 + 10];ll segans[N * 4 + 10];const ll INF = 0x3f3f3f3f3f3f3f3f;ll query(int o, int l, int r, int ql, int qr) {  if (l == ql &amp;&amp; r == qr)    return seg[0][o];  int m = (l + r) / 2;  if (qr &lt;= m) {    return query(SEG_L, ql, qr);  } else if (ql &gt; m) {    return query(SEG_R, ql, qr);  } else {    return max(query(SEG_L, ql, m),               query(SEG_R, m + 1, qr));  }}void update(int o, int l, int r, int pos) {  if (l == r) {    seg[0][o] = dp[l];    return;  }  int m = (l + r) / 2;  if (pos &lt;= m)    update(SEG_L, pos);  else    update(SEG_R, pos);  seg[0][o] = max(seg[0][o &lt;&lt; 1], seg[0][o &lt;&lt; 1 | 1]);}void build(int o, int l, int r) {  if (l == r) {    seg[0][o] = dp[l];    return;  }  int m = (l + r) / 2;  build(SEG_L);  build(SEG_R);  seg[0][o] = max(seg[0][o &lt;&lt; 1], seg[0][o &lt;&lt; 1 | 1]);}// [l,r]为开放段void buildans(int o, int l, int r) {  if (l == r) {    // 可以dp到[l-1] 或[l]    seg[0][o] = max(max(dp[l], s[l]), l &gt; 0 ? dp[l-1] : -INF);    seg[1][o] = t[l];    segans[o] = seg[0][o] + t[l];    return;  }  int m = (l + r) / 2;  buildans(SEG_L);  buildans(SEG_R);  seg[0][o] = max(seg[0][o &lt;&lt; 1], seg[0][o &lt;&lt; 1 | 1]);  seg[1][o] = max(seg[1][o &lt;&lt; 1], seg[1][o &lt;&lt; 1 | 1]);  segans[o] = max(seg[0][o &lt;&lt; 1] + seg[1][o &lt;&lt; 1 | 1],                  max(segans[o &lt;&lt; 1], segans[o &lt;&lt; 1 | 1]));};// {最大值, 最大dp, 最大t}vector&lt;ll&gt; qans(int o, int l, int r, int ql, int qr) {  if (ql == l &amp;&amp; qr == r) {    return {segans[o], seg[0][o], seg[1][o]};  }  int m = (l + r) / 2;  if (qr &lt;= m) {    return qans(SEG_L, ql, qr);  } else if (ql &gt; m) {    return qans(SEG_R, ql, qr);  }  auto lres = qans(SEG_L, ql, m);  auto rres = qans(SEG_R, m + 1, qr);  return {max(max(lres[0], rres[0]), lres[1] + rres[2]), max(lres[1], rres[1]),          max(lres[2], rres[2])};}int main() {  int n, q;  scanf(&quot;%d %d&quot;, &amp;n, &amp;q);  ll a2 = 0;  rep(i, 0, 3) {    rep(j, 0, n) { scanf(&quot;%lld&quot;, &amp;a[i][j]); }  }  rep(i, 0, n) a2 += a[2][i];  s[0] = a[0][0];  rep(i, 1, n) { s[i] = s[i - 1] + a[0][i] - a[1][i - 1]; }  t[0] = a2 + a[1][0];  rep(i, 1, n) { t[i] = t[i - 1] + a[1][i] - a[2][i - 1]; }  rep(i, 0, q) {    int r, l;    ll v;    scanf(&quot;%d %d %lld&quot;, &amp;l, &amp;r, &amp;v);    rlv.pb({r - 1, l - 1, v});  }  ll ans = -INF;  // 按右端点排序  sort(rlv.begin(), rlv.end());  // 处理 使用一次区间直接进入的  vector&lt;int&gt; pos;  // 单调队列  unsigned long itr = 0;  rep(i, 0, n){    dp[i] = -INF;  }  rep(i, 0, n) {  // 下标    while (pos.size() &amp;&amp; s[pos.back()] &lt;= s[i]) {      pos.pop_back();    }    pos.pb(i);    while (itr &lt; rlv.size() &amp;&amp; get&lt;0&gt;(rlv[itr]) == i) {      // 区间内最大值      dp[i] = max(          dp[i],          s[*lower_bound(pos.begin(), pos.end(), get&lt;1&gt;(rlv[itr]))] -              get&lt;2&gt;(rlv[itr]));  // cost &gt; 0选自己没影响      if (dp[i] != -INF) {        ans = max(ans, dp[i] + t[i]);        // printf(&quot;dp[%lld] =&gt; %lld\n&quot;, i, dp[i]);      }      itr++;    }  }  build(SEG_ROOT);  itr = 0;  for(auto [r,l,v]:rlv){    // 注意可以上一个结束的位置[?..l-1] 和当前 [l..r] 是相邻而不是重叠    // dp[i] = max(dp[&lt;i] - cost);    ll newdpi = query(SEG_ROOT, max(0,l-1), max(0,r-1)) - v;    if (newdpi &gt; dp[r]) {      dp[r] = newdpi;      ans = max(ans, dp[r] + t[r]);      // printf(&quot;update: dp[%lld] =&gt; %lld\n&quot;, i, dp[i]);      update(SEG_ROOT, r);    }  }  buildans(SEG_ROOT);  // [l...r] =&gt; [l..m] [m+1,r]  for (auto [r, l, v] : rlv) {    auto qres = qans(SEG_ROOT, l, r);    if (qres[0] &lt;= -INF)      continue;    ans = max(ans, qres[0] - v);  }  printf(&quot;%lld\n&quot;, ans);  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>一个核心的点就是区间覆盖，转换成刚好走到以某个区间结束的动规，感觉要是一个纯的动规还可能想到，合在一起竟然卡住了</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://codeforces.com/blog/entry/100592" target="_blank" rel="noopener">官方题解</a></p><p><a href="https://www.cnblogs.com/C202044zxy/p/15980776.html#!comments" target="_blank" rel="noopener">C202044zxy</a></p><p><a href="https://blog.csdn.net/cggghh/article/details/123322440" target="_blank" rel="noopener">cggghh</a></p><p><a href="https://www.cnblogs.com/Sstee1XD/p/15974290.html" target="_blank" rel="noopener">Sstee1XD</a></p><p><a href="https://www.shuizilong.com/house/archives/codeforces-round-775/" target="_blank" rel="noopener">某岛</a></p>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 二分 </tag>
            
            <tag> 前缀和 </tag>
            
            <tag> 单调队列 </tag>
            
            <tag> 区间覆盖 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF 1641 D (字典树,集合,贡献统计)</title>
      <link href="/Blog/2022-03-08-cf1641D/"/>
      <url>/Blog/2022-03-08-cf1641D/</url>
      
        <content type="html"><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p><a href="https://codeforces.com/contest/1641/problem/D" target="_blank" rel="noopener">https://codeforces.com/contest/1641/problem/D</a></p><p><code>n(1e5)</code>个数组</p><p>每个数组长度为<code>m(&lt;=5)</code>, 包含值<code>(&lt;1e9)</code>, 每个数组有总代价<code>w(&lt;=1e9)</code></p><p>找出两个数组，让它们的值没有重复，且代价和最小，求最小代价</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><ol><li><p>随机映射到0-15,注意同一个数一定映射到相同数，不同数可能映射到相同数, 多次运行提高概率期望到2, orz(见YB Lin 的链接)</p></li><li><p>集合数学性质</p></li></ol><p>一个集合属于A,又属于B，</p><p>如果该集合个数为奇数，则+1</p><p>如果该集合个数为偶数(包含空集合)，则-1</p><p>那么，如果A,B有公共元素，则结果为0，否则为1</p><p>然后维护一个Trie树，上面是所有子集</p><hr><p>把原数组按照w排序</p><p>利用Trie树找到首个合法的组合i,j</p><p>因为要答案最小，所以 i &lt; i’, 则有 j’&lt; j</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i, a, n) for (ll i = a; i &lt; n; i++)#define pb push_back#define all(a) a.begin(), a.end()// trie 树， 用index取代指针// 集合按照从小到大 展开存成树节点struct node {  // 只会新增不会移除， cnt为0 和 移除等价  unordered_map&lt;int, int&gt; next;  // [值] =&gt; 树节点index  int cnt;};vector&lt;node&gt; g;int new_node() {  g.push_back(node{{}, 0});  return g.size() - 1;}// 新把数组变化 放入trie树void add(const vector&lt;int&gt;&amp; x,         int c /* 1(加入) or -1(移除) */,         int v = 0 /* trie 树 节点 index*/,         int i = 0 /* 遍历数组下标 */) {  if (i == x.size()) {    g[v].cnt += c;  // 在trie树 的所有集合表示的位置都+1    return;  }  // 不存在创建新节点  if (!g[v].next.count(x[i]))    g[v].next[x[i]] = new_node();  add(x, c, v, i + 1);                // 不选择当前的情况  add(x, c, g[v].next[x[i]], i + 1);  // 选择当前的情况}// 初始全是0// 如果和 已经加入的 某个数组重合，那么与这个数组贡献的cnt 的结果为 0// 如果和 已经加入的 某个数组不重合，那么与这个数组贡献的cnt 的结果为 1// 而trie上的贡献是满足**累加**性质，所以与 trie树直接计算cnt// 如果为0，则和所有数组现有的都冲突，否则存在一个数组和它没有重合int get_cnt(const vector&lt;int&gt;&amp; x, int v = 0, int i = 0) {  if (i == x.size()) {    return g[v].cnt;  }  int res = get_cnt(x, v, i + 1);  // 第i位 不选  if (g[v].next.count(x[i]))       // 第i位 存在（集合存在） 并选择    res -= get_cnt(x, g[v].next[x[i]] /* trie 树的下一个节点 */,                   i + 1);  // 奇偶加减交替  return res;}int main() {  int n, k;  ios::sync_with_stdio(0);  cin.tie(0);  cout.tie(0);  cin &gt;&gt; n &gt;&gt; k;  vector&lt;pair&lt;int, vector&lt;int&gt;&gt;&gt; a = vector(n, make_pair(0, vector&lt;int&gt;(k, 0)));  rep(i, 0, n) {    rep(j, 0, k) {      cin &gt;&gt; a[i].second[j];  // 读入每个数组    }    cin &gt;&gt; a[i].first;  // 数组权重  }  rep(i, 0, n) {  // 数组内按照值排序    sort(all(a[i].second));  }  sort(all(a));  // 按权重排序  new_node();    // trie 根节点 空集合  int res = -1;  int i = 0;  // 和 trie 树中 任何一个重复 都会 让 get_cnt &gt; 0  while (i &lt; n &amp;&amp; !get_cnt(a[i].second)) {    // 首个一定加入, 如果和现有所有数组都冲突，那么加入trie树    // 如果存在一个不是和所有都冲突的 , 会触发 get_cnt 不为0    add(a[i].second, 1);    i += 1;  }  if (i &gt;= n) {    cout &lt;&lt; -1 &lt;&lt; &quot;\n&quot;;    return 0;  }  // i 是首个 与 [0...i-1]中某个不会冲突的  int j = i;  // 从i倒向查找  while (get_cnt(a[i].second)) {  // 直到所有都冲突，找到一个最小的j    j -= 1;    add(a[j].second, -1);  // 每次从trie树中移除一个  }  // j &lt; i 互相不冲突, 最小的i对应的最小的j  res = a[i].first + a[j].first;  // j&#39; &lt; j &lt; i &lt; i&#39;  for (i += 1; i &lt; n &amp;&amp; j &gt; 0; ++i) {    while (get_cnt(a[i].second)) {  // 循环直到 和 前面都冲突      j -= 1;                       // 找一个 最小的j 让 i和j不冲突      add(a[j].second, -1);         // 移除    }    // 不一定是有效值（可能i,j是冲突的），但是因为代价排序关系，保证不会影响最小值    res = min(res, a[i].first + a[j].first);  }  cout &lt;&lt; res &lt;&lt; &quot;\n&quot;;  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>先按照价值排序，</li><li>再从小到大找到首个和前面某个不冲突的</li><li>找到前面最小的与当前不冲突的，确定一个合法j &lt; i</li><li>i增加，每次找更小的j与新的i不冲突的，或者找不到跳过这个i, 每次更新最小值</li></ol><p>关键的核心就是,trie树保存的是两两冲突的数组的所有集合，而与trie树 做子集重合get_cnt运算，如果与已加入的所有都有重合则总结果为0，否则大于0, 相当于trie能帮助完成批量判断</p><h1 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h1><p><a href="https://codeforces.com/blog/entry/100249" target="_blank" rel="noopener">官方题解</a></p><p><a href="https://blog.csdn.net/m0_51068403/article/details/123140941" target="_blank" rel="noopener">YB Lin 概率映射 sosdp 乱搞</a></p><p><a href="https://blog.csdn.net/neweryyy/article/details/123214206" target="_blank" rel="noopener">neweryyy</a></p>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
            <tag> algorithm </tag>
            
            <tag> codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>project euler 516 (5-smooth,二分,前缀和,prime)</title>
      <link href="/Blog/2022-02-11-project-euler516/"/>
      <url>/Blog/2022-02-11-project-euler516/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://projecteuler.net/problem=516" target="_blank" rel="noopener">https://projecteuler.net/problem=516</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>求<code>n &lt; 10^12</code>, <code>phi(n)</code>的值仅包含质因数2,3,5的所有<code>n</code>的和，mod<code>2^32</code></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h2><p>$\phi(n) = n(1-\frac{1}{p_0})(1-\frac{1}{p_1})(1-\frac{1}{p_2})\cdots$</p><p>其中$p_i$均为$n$的质数因数</p><p>性质:</p><p>$\phi(x)\phi(y)=\phi(xy), gcd(x,y)==1$</p><p>$\phi(prime)\phi(x)=(prime-1)\phi(x), gcd(x,prime)==1$</p><h2 id="题目转换"><a href="#题目转换" class="headerlink" title="题目转换"></a>题目转换</h2><p>$n = 2^{q_0}3^{q_1}5^{q_2} p_0p_1p_2\cdots$</p><p>其中$p_i + 1$ 是只包含$2,3,5$ 质因子的数</p><h2 id="广搜2-3-5"><a href="#广搜2-3-5" class="headerlink" title="广搜2,3,5"></a>广搜2,3,5</h2><p>$x =&gt; 2x,3x,5x$</p><p>广搜小于$10^{12}$的所有只包含质因数$2,3,5$的数</p><h2 id="质数判别"><a href="#质数判别" class="headerlink" title="质数判别"></a>质数判别</h2><p>小于$2^{64}$里的质因数可以 Miller-Robin算法 常数级别 判别</p><h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h2><p>$n = 2^{q_0}3^{q_1}5^{q_2} p_0p_1p_2\cdots$</p><p>后面又可以拆分成$2^{q_0}3^{q_1}5^{q_2}$ 和 $p_0p_1p_2\cdots$</p><p>右边每个质数最多一次方，直接生成所有的积，左边还是上面求的</p><p>要两部分数组内容乘积小于n, 可以左侧枚举二分右侧，右侧枚举二分左侧都一样的, 通过前缀和辅助得到和</p><h1 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h1><p><a href="https://en.wikipedia.org/wiki/Euler%27s_totient_function" target="_blank" rel="noopener">Euler’s totient function</a></p>]]></content>
      
      
      <categories>
          
          <category> Project Euler </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pe </tag>
            
            <tag> project euler </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atcoder agc1560 B, dp,分治,前缀和,数学</title>
      <link href="/Blog/2021-12-06-ac_agc056B/"/>
      <url>/Blog/2021-12-06-ac_agc056B/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://atcoder.jp/contests/agc056/tasks/agc056_b" target="_blank" rel="noopener">https://atcoder.jp/contests/agc056/tasks/agc056_b</a></p><p>一个长度为n的排列</p><p>对于q个查询构成的大小为q向量有多少种</p><p>其中每次查询排列[l..r] 中最大值的下标</p><p>n &lt;= 300</p><p>查询不重复, 合法(l &lt; r)</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>考虑把数字从大到小放入排列的位置.</p><p>假设把N放在位置pos,那么有三类区间</p><ol><li>包含pos的</li><li>完全在pos左侧</li><li>完全在pos右侧</li></ol><p>那么显然对于所有查询区间包含pos的,返回都是pos</p><p>而对剩余的,如果把左侧位置的所有值保持相对顺序,右侧位置的所有值保持相对顺序, 然后调整值让左侧所有值大于右侧所有值, 对于输出的q维向量没有变化.(因为相对顺序不变,左侧和右侧内部,原来哪个位置大还是哪个大,且都在pos单侧互不影响), 因此不妨我们选定pos后如此调整</p><h2 id="先不考虑重复"><a href="#先不考虑重复" class="headerlink" title="先不考虑重复"></a>先不考虑重复</h2><p>那么设计状态<code>dp[i][j][pos] =</code> 在<code>[i..j]</code>中, <code>pos</code>为最大值, 且属于<code>[i..j]</code>中某个<strong>完整</strong>区间的 方案数</p><p>那么注意到上面,当我们选定了pos, 就是把区间划分成<code>[i..pos-1]pos[pos+1..j]</code></p><p>原题的答案变为 <code>sum(dp[0][n-1][pos = 0..n-1])</code></p><p>其中注意到,我们在对于无效的pos结果为0, 例如 pos不属于<code>[i..j]</code>中任何一个完整区间, 其对应的情景是最大值不属于任何一个区间,那么 这个位置删掉都行 更不用考虑值了</p><p>那么上面的转移方程有</p><p><code>dp[0][n-1][pos] = sum(dp[0][pos-1][0..pos-1]) * sum(dp[pos+1][n-1][pos+1..n-1])</code></p><p>也就是 左侧 和 右侧分别独立计算.</p><p>而这个计算规则实际上和原问题是同一个问题. 因此可以看成是分治</p><p><code>dp[i][j][p] = sum(dp[i][p-1][i..p-1]) * sum(dp[p+1][j][p+1..j])</code></p><p>其中 sum为零时,记为1,属于空方案</p><hr><p>引理: 分治中数值的大小无影响,只有输出有影响</p><p>因为隔离性,假设右侧不动,来考虑左侧的排列数值变化,但产出向量不变,对结果有什么影响.</p><p>假设左侧存在<code>[1..2][3..4]</code> 非重叠 或者 <code>[1..2][2..3]</code>重叠区间或其它任何状态, 那么可能不同的值,有相同的向量产生 </p><p>一旦左侧的产出向量确定了, 注意到转移方程的剩余部分,一个是pos,那一定比左侧都大,而右侧根据它们的隔离性,比左侧都小,所以转移方程的任何剩余向量也不会受到影响.</p><p>所以, 转移方程只与单侧的向量产生相关, 与具体值无关</p><hr><p>上面的东西,看上去搞个前缀和,再<code>for(len)for(左端点i)for(最大值下标pos)</code> 就搞完了</p><h2 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h2><p>基本的东西有了,下面是精确计算值</p><p>正如上面的例子<code>[1..2][3..4]</code></p><p>如果是1234 输出是(2,4)</p><p>如果是3412 输出也是(2,4)</p><p>而对于dp来说,一个是按照 第4位 开始划分,一个是按照第2位开始划分的. 有重复的问题</p><hr><p>同样,对于<code>[1..2][2..3]</code> 来说</p><p>如果312 和  213 也会重复.分别是第1位和第3位最大进行讨论的, 而它们的输出都是(1,3)</p><p>注意, 这里 132 和231 不会重复统计</p><hr><p>一个办法是容斥(本文不会提到</p><hr><p>另一个就是发现其数学性质</p><p>当在<code>[i..j]</code> 中 pos是最大值的下标 且属于其中某个完整区间时</p><p>如果<code>[i..pos-1]</code> 中的最大值 在idx, 且idx和pos 在<code>[i..j]</code> 中不属于任何同一个完整区间, 那么 让idx变为 <code>[i..j]</code>中的最大值, pos改为次大值,总输出向量不变</p><p>证明</p><p>因为前面假设过, value[pos] &gt; 所有左侧值 &gt; 所有右侧值,所以pos最大,idx次大</p><p>交换以后,value[idx] &gt; value[pos] &gt; 其它左侧值 &gt; 所有右侧值</p><p>按情况讨论区间</p><ol><li>pos右侧的所有区间,因为包含的内容全在右侧值中,所以都不受影响</li><li>包含pos的所有区间, 原本输出pos, 因为不包括idx,现在pos次大,所以依然输出pos</li><li>pos左侧所有区间, 只有idx变大了,但对于所有左侧区间来说,相对顺序都没有变化, 所以左侧的也都没有变</li></ol><p>所以总的向量没有变</p><hr><p>以上证明了,如果<code>[i..pos-1]</code>中的最大值和pos在<code>[i..j]</code>中不属于同一个完整区间,那么会被重复统计. 所以</p><p><code>dp[i][j][p] = sum(dp[i][p-1][i..p-1]) * sum(dp[p+1][j][p+1..j])</code></p><p>要改为</p><p><code>dp[i][j][p] = sum(dp[i][p-1][f(p)..p-1]) * sum(dp[p+1][j][p+1..j])</code></p><p><code>f(p) =</code> 最小的 在<code>[i..j]</code>中和<code>p</code>属于同一个完整区间的 </p><hr><p>不漏从dp过程中已经保证了,上面我们只是提到了去重,而并不能说明所有重复都没有了.下面证明所有重复都没有了</p><p>即是证明 任何输出向量,只会被至多统计一次</p><p>不妨设某个 输出被统计了两次.</p><p>根据统计过程, 如果它在首次被不同的最大值下标统计了,那么</p><ol><li>这两个下标属于同一个区间,和下标是最大值矛盾,一个区间只有一个下标是最大值</li><li>这两个下标不属于任何同一个区间,那么根据上面的变化, 只会统计在左侧为更大值</li></ol><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>基于 heno239 的代码 <a href="https://atcoder.jp/contests/agc056/submissions/27693073" target="_blank" rel="noopener">https://atcoder.jp/contests/agc056/submissions/27693073</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i, a, n) for (ll i = a; i &lt; n; i++)#define per(i, a, n) for (ll i = n - 1; i &gt;= a; i--)constexpr ll mod = 998244353;#define all(v) (v).begin(), (v).end()struct modint {  int n;  modint() : n(0) { ; }  modint(ll m) {    if (m &lt; 0 || mod &lt;= m) {      m %= mod;      if (m &lt; 0)        m += mod;    }    n = m;  }  operator int() { return n; }};bool operator==(modint a, modint b) {  return a.n == b.n;}modint operator+=(modint&amp; a, modint b) {  a.n += b.n;  if (a.n &gt;= mod)    a.n -= mod;  return a;}modint operator-=(modint&amp; a, modint b) {  a.n -= b.n;  if (a.n &lt; 0)    a.n += mod;  return a;}modint operator*=(modint&amp; a, modint b) {  a.n = ((ll)a.n * b.n) % mod;  return a;}modint operator+(modint a, modint b) {  return a += b;}modint operator-(modint a, modint b) {  return a -= b;}modint operator*(modint a, modint b) {  return a *= b;}modint operator^(modint a, ll n) {  if (n == 0)    return modint(1);  modint res = (a * a) ^ (n / 2);  if (n % 2)    res = res * a;  return res;}ll inv(ll a, ll p) {  return (a == 1 ? 1 : (1 - p * inv(p % a, a)) / a + p);}modint operator/(modint a, modint b) {  return a * modint(inv(b, mod));}modint operator/=(modint&amp; a, modint b) {  a = a / b;  return a;}vector&lt;int&gt; vle[305];       // [r pos] = {l pos...} 区间右端点到左端点modint dp[305][305][305];   // [l][r][x] = [l..r-1] 最大的是x的方案数, 其中不论l取值多少,x与[l,r-1]至少属于[l,r-1]中的一个完整区间modint rdp[305][305][305];  // rdp[l][r][i] =  dp[l][r][0..i-1] 的前缀和// 默认 全false, 右端点在[l+1..r]之间，长度 &lt;= r-l 的区间是否存在bool exi[305][305];int cl[305];  // 计算过程中[l..r-1] 中, cl[i] = 与i同属于完整区间属于[l..r-1]的 最左端点int main() {  int n, m;  scanf(&quot;%d %d&quot;, &amp;n, &amp;m);  rep(i, 0, m) {    int l, r;    scanf(&quot;%d %d&quot;, &amp;l, &amp;r);    vle[r].push_back(l - 1);  }  // 同样右端点 左端点从小到大, 方便后面二分找满足条件的左端点  rep(i, 0, n + 1) sort(all(vle[i]));  rep(len, 1, n + 1) {    // 枚举 长度[1..n], 因为每次划分是 左右两个更短的范围    rep(r, len, n + 1) {  // 右端点从小到大 [len..n]      int l = r - len;    // 左侧端点 = 右端点-长度      int nw = r; // 遍历过程中,当前属于[l..r-1]的完整区间的最小左端点      per(j, l + 1, r + 1) {  // j（右端点）从大到小 [l+1,r] 范围内的每个右端点        // 第一个大于或等于某个元素的位置, 二分查找        int t = lower_bound(all(vle[j]), l) - vle[j].begin();        if (t &lt; vle[j].size()) {  // [nw,j] 区间小于等于 len          nw = min(nw, vle[j][t]);        }        // 右端点 [j..r] 中的区间的最小左端点, 不存在的情况 r &gt; j - 1        cl[j - 1] = nw;      }      if (nw == r) {  // 没有任何有效区间        exi[l][r] = false;        continue;      }      exi[l][r] = true;  // 右端点在 [l+1 ..r], 长度小于等于 len 的区间 存在      rep(x, l, r) {    // [l..r-1]        if (x &lt; cl[x])  // 不存在 [l,r] 之间的小区间 包含 坐标x          continue;        // [l..x-1]x[x+1..r-1]        // 存在右端在 [l+1..x], 长度小于 x-l 的区间,        // sl = sum{dp[l][x][cl[x]..x-1]}        // 注意这里, 当[l..x-1]不存在时是1, 而[l..x-1]存在时,因为防止重复统计可能[cl[x]..x-1]是0        modint sl = exi[l][x] ? rdp[l][x][x] - rdp[l][x][cl[x]] : (modint)1;        // 存在右端在 [x+2..r], 长度小于 r-x-l 的区间,        // sr = sum{dp[x+1][r][x+1..r-1]}        // 而对于右侧 似乎可以直接判断前缀和是否非零,但实际上因为是取mod运算,可能为mod的倍数,所以还是需要一个exi的辅助数组        modint sr =            exi[x + 1][r] ? rdp[x + 1][r][r] - rdp[x + 1][r][x + 1] : (modint)1;        dp[l][r][x] = sl * sr;  // [l,r-1]中 最大的下标为x, 方案数        // 下面由此输出        // printf(&quot;%d %lld %lld =&gt; %d %d\n&quot;,l,r,x,(int)sl,(int)sr);      }      rep(j, l, r) {        // [l..r-1]        // rdp[l][r][j] = dp[l][r][0..j-1] 前缀和        rdp[l][r][j + 1] = rdp[l][r][j] + dp[l][r][j];      }    }  }  printf(&quot;%d&quot;, (int)rdp[0][n][n]); // [0,n-1] 最大下标[0..n-1]的方案数  return 0;}</code></pre><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><pre><code class="cpp">//// [l          x-1]x[x+1          ]r// x 是最大值// dp[l][r][x] = 左边方案数 x 右边方案数, 其中右边的长度覆盖了x//             = sum{dp[l][x][cl[x]..x-1]} * sum{dp[x+1][r][x+1..r-1]}//             = x 是最大值，对左侧的影响当前 最近的是 cl[x]////// 012345678//  xx//   xxx//     xxx//      xx//        xx///*9 52 33 55 76 78 9*//*l r x ==sl*sr[l r) 左闭右开,所以 实际区间是[l..r-1]len = 21 3 1 =&gt; 1 11 3 2 =&gt; 1 15 7 5 =&gt; 1 15 7 6 =&gt; 1 17 9 7 =&gt; 1 17 9 8 =&gt; 1 1len = 30 3 1 =&gt; 1 10 3 2 =&gt; 1 1 (0不属于完整区间,所以没有 0 3 01 4 1 =&gt; 1 11 4 2 =&gt; 1 1 (虽然3和属于[2..4]的完整区间,但这里的区间是[1..3],3 不属于这之间的任何完整区间, 所以也没有 1,3,32 5 2 =&gt; 1 12 5 3 =&gt; 1 12 5 4 =&gt; 1 14 7 4 =&gt; 1 2 (首次包含关系 区间,一个[4..6]一个[5..6],右侧 = dp[5][7][5] + dp[5][7][6] = 1+1 = 2, 也就是[4..6] 最大值在4时,不影响右侧不包含它的区间,右侧有两种值4 7 5 =&gt; 1 14 7 6 =&gt; 1 15 8 5 =&gt; 1 15 8 6 =&gt; 1 16 9 7 =&gt; 1 16 9 8 =&gt; 1 1len = 40 4 1 =&gt; 1 10 4 2 =&gt; 1 11 5 1 =&gt; 1 3 (同 上面 4 7 41 5 2 =&gt; 1 1 (这个和下面两个都是 1 1, 但实际上有些不同, 下面两个的左边的1, 如果按照上面右侧的统计法,应该是 2 而不是1, 注意到上面算sl和sr是有区别的,一个是[cl[x]..x-1], 一个是[x+1..r], 如果一致应该是[l..x-1]而不是[cl[x]..x-1], 说面 左侧最大值, 一定要和x属于同一组,如果不同组, 让左侧更大,其它平移补位, 总输出不变. 所以下面两个都是1.1 5 3 =&gt; 1 11 5 4 =&gt; 1 1 2 6 2 =&gt; 1 12 6 3 =&gt; 1 12 6 4 =&gt; 1 13 7 4 =&gt; 1 23 7 5 =&gt; 1 13 7 6 =&gt; 1 14 8 4 =&gt; 1 24 8 5 =&gt; 1 14 8 6 =&gt; 1 15 9 5 =&gt; 1 25 9 6 =&gt; 1 25 9 7 =&gt; 0 15 9 8 =&gt; 0 1len = 50 5 1 =&gt; 1 30 5 2 =&gt; 1 10 5 3 =&gt; 1 10 5 4 =&gt; 1 11 6 1 =&gt; 1 31 6 2 =&gt; 1 11 6 3 =&gt; 1 11 6 4 =&gt; 1 12 7 2 =&gt; 1 42 7 3 =&gt; 1 42 7 4 =&gt; 1 22 7 5 =&gt; 1 12 7 6 =&gt; 1 13 8 4 =&gt; 1 23 8 5 =&gt; 1 13 8 6 =&gt; 1 14 9 4 =&gt; 1 44 9 5 =&gt; 1 24 9 6 =&gt; 1 24 9 7 =&gt; 0 14 9 8 =&gt; 0 1len = 60 6 1 =&gt; 1 30 6 2 =&gt; 1 10 6 3 =&gt; 1 10 6 4 =&gt; 1 11 7 1 =&gt; 1 121 7 2 =&gt; 1 41 7 3 =&gt; 1 41 7 4 =&gt; 1 21 7 5 =&gt; 1 11 7 6 =&gt; 1 12 8 2 =&gt; 1 42 8 3 =&gt; 1 42 8 4 =&gt; 1 22 8 5 =&gt; 1 12 8 6 =&gt; 1 13 9 4 =&gt; 1 43 9 5 =&gt; 1 23 9 6 =&gt; 1 23 9 7 =&gt; 0 13 9 8 =&gt; 0 1len = 70 7 1 =&gt; 1 120 7 2 =&gt; 1 40 7 3 =&gt; 1 40 7 4 =&gt; 1 20 7 5 =&gt; 1 10 7 6 =&gt; 1 11 8 1 =&gt; 1 121 8 2 =&gt; 1 41 8 3 =&gt; 1 41 8 4 =&gt; 1 21 8 5 =&gt; 1 11 8 6 =&gt; 1 12 9 2 =&gt; 1 82 9 3 =&gt; 1 82 9 4 =&gt; 1 42 9 5 =&gt; 1 22 9 6 =&gt; 1 22 9 7 =&gt; 0 12 9 8 =&gt; 0 1len = 80 8 1 =&gt; 1 120 8 2 =&gt; 1 40 8 3 =&gt; 1 40 8 4 =&gt; 1 20 8 5 =&gt; 1 10 8 6 =&gt; 1 11 9 1 =&gt; 1 241 9 2 =&gt; 1 81 9 3 =&gt; 1 81 9 4 =&gt; 1 41 9 5 =&gt; 1 21 9 6 =&gt; 1 21 9 7 =&gt; 0 11 9 8 =&gt; 0 1len = 90 9 1 =&gt; 1 240 9 2 =&gt; 1 80 9 3 =&gt; 1 80 9 4 =&gt; 1 40 9 5 =&gt; 1 20 9 6 =&gt; 1 20 9 7 =&gt; 0 10 9 8 =&gt; 0 1*/</code></pre><h2 id="改版"><a href="#改版" class="headerlink" title="改版"></a>改版</h2><p>对于上面代码改了主要几个部分</p><p>把<code>[l,r]</code>改为左右都是闭区间了,不用考虑加减1的描述范围</p><p>把所有下标按照题目变成<code>1-index</code>而不是上面的<code>0-index</code>,因为这样也方便前缀和不用单独处理下标0</p><p>去掉了 大佬的modint, 假设没有modint的实现的情况下,直接加mod运算</p><p><a href="https://atcoder.jp/contests/agc056/submissions/27743665" target="_blank" rel="noopener">https://atcoder.jp/contests/agc056/submissions/27743665</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i, a, n) for (ll i = a; i &lt; n; i++)#define per(i, a, n) for (ll i = n - 1; i &gt;= a; i--)constexpr ll mod = 998244353;#define all(v) (v).begin(), (v).end()vector&lt;int&gt; vle[305];   // [r pos] = {l pos...} 区间右端点到左端点ll dp[305][305][305];   // [l][r][x] = [l..r] 最大的是x的方案数, 其中不论l取值多少,x与[l,r]至少属于[l,r]中的一个完整区间ll rdp[305][305][305];  // dp 前缀和bool exi[305][305];     // 默认 全false, 在[l..r]之间 是否存在完整区间int cl[305];            // 右端点 in [i..最右侧] = 区间的最小左端点int main() {  int n, m;  scanf(&quot;%d %d&quot;, &amp;n, &amp;m);  rep(i, 0, m) {    int l, r;    scanf(&quot;%d %d&quot;, &amp;l, &amp;r);    vle[r].push_back(l);  }  rep(i, 1, n+1) sort(all(vle[i]));  rep(len, 2, n+1) {              // 枚举 长度    rep(r, len, n+1) {            // 右端点 从小到大      int l = r - len + 1;        // 左侧端点 = 右端点 - 长度 +1      int nw = r + 1;             // 左端点, 在[l..r] 中      per(j, l, r + 1) {          // j（右端点）从大到小 [l,r] 范围内的每个右端点        int t = lower_bound(all(vle[j]), l) - vle[j].begin();        if (t &lt; vle[j].size()) nw = min(nw, vle[j][t]);        cl[j] = nw;      }      if (nw == r+1) {            // 没有任何有效区间        exi[l][r] = false;        continue;      }      exi[l][r] = true;           // 右端点在 [l+1 ..r], 长度小于等于 len 的区间 存在      rep(x, l, r+1) {            // [l..x-1]x[x+1..r]        if (x &lt; cl[x]) continue;  // 不存在 [l,r] 之间的小区间 包含 坐标x        ll sl = exi[l][x-1] ? rdp[l][x-1][x-1] - rdp[l][x-1][cl[x]-1] : 1;        ll sr = exi[x+1][r] ? rdp[x+1][r][r] - rdp[x + 1][r][x] : 1;        dp[l][r][x] = ((sl%mod) * (sr%mod))%mod;    // [l,r-1]中 最大的下标为x, 方案数      }      rep(j, l, r + 1) rdp[l][r][j] = (rdp[l][r][j-1] + dp[l][r][j])%mod;    }  }  printf(&quot;%lld&quot;, (rdp[1][n][n]+mod)%mod);   return 0;}</code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>官方题解 <a href="https://atcoder.jp/contests/agc056/editorial/3045" target="_blank" rel="noopener">https://atcoder.jp/contests/agc056/editorial/3045</a></p>]]></content>
      
      
      <categories>
          
          <category> Atcoder </category>
          
          <category> AGC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
            <tag> dp </tag>
            
            <tag> 分治 </tag>
            
            <tag> 前缀和 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atcoder arc130 E, 细节题，不会依然不会</title>
      <link href="/Blog/2021-12-01-ac_arc130E/"/>
      <url>/Blog/2021-12-01-ac_arc130E/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://atcoder.jp/contests/arc130/tasks/arc130_e" target="_blank" rel="noopener">https://atcoder.jp/contests/arc130/tasks/arc130_e</a></p><p>一个数组，每次选最小值中的一个+1，记录下标。</p><p>形成了一个下标数组。</p><p>现在给你下标数组，求满足下标数组的字典序最小的原数组</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>题目样例为例</p><p><code>1 1 4 4 2 1</code></p><p>如果 我们能给他们分组</p><p><code>1 | 1 4 | 4 2 1</code></p><p>那么，很容易知道合法的最小结果</p><p><code>1 (操作前大小为1)| 1 4 (操作前大小为2) | 4 2 1 (操作前大小为3)</code></p><p>我们只关心</p><p><code>1 | 1 4 (操作后所有为3)</code></p><p>所以原数组为</p><p><code>3-2 3-0 3-0 3-1</code> = <code>1 3 3 2</code></p><hr><p>所以核心问题变成去找这个层之间的分割线</p><p>见下面代码中的注释</p><p><code>last(pos) =</code> 这个位置值相同的值的上一个位置</p><p><code>cur[value] =</code> 位置，辅助计算last的数组</p><p><code>cnt</code> 当前层的个数</p><p><code>mx</code> 上一层至少的结束的位置/当前层至少的起始位置</p><p><code>f(pos)=</code> pos是有效的层级分割值，或者-1</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><a href="https://atcoder.jp/contests/arc130/submissions/27574012" target="_blank" rel="noopener">jiangly 大佬的代码</a> 加的注释的</p><p><a href="https://atcoder.jp/contests/arc130/submissions/27614814" target="_blank" rel="noopener">https://atcoder.jp/contests/arc130/submissions/27614814</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i, a, n) for (ll i = a; i &lt; n; i++)// 若按照 最后一次出现的顺序排序1~n// 最优结果的起始最小值一定是1// 那么所有最优结果 在所有操作后 一定满足 AN-1&lt;=A1&lt;=A2&lt;=A3&lt;=...&lt;=ANint main() {  int N, K;  scanf(&quot;%d %d&quot;, &amp;N, &amp;K);  vector&lt;int&gt; i(K);  rep(k, 0, K) {    scanf(&quot;%d&quot;, &amp;i[k]);    i[k]--;  // (0-index)  }  vector&lt;int&gt; last(K);  // 这个位置上同一个数上一次出现的位置 last[pos] = oldpos  vector&lt;int&gt; cur(N, -1);  // 最后一次出现的位置 cur[value] = pos  rep(k, 0, K) {    last[k] = cur[i[k]];    cur[i[k]] = k;  }  vector&lt;int&gt; f(K + 1, 0);  // 相当于找有效分割线 = 分割线的层级，从0开始  int cnt = 0;  int mx = -1;  rep(k, 0, K) {    mx = max(mx, last[k]);  // 更新最近上一组数 的最大下标    if (last[k] == -1) {    // 当前值首次出现      cnt++;                // 属于组的个数+1    }    // -1 无效值    // 最大位置 和 当前位置之间个数小于 cnt 则 无效    // 上一个位置无效则 无效,    // 因为如果当前是分割线，那么当前到上一个分割线的距离一定恰好是cnt    f[k + 1] =        (mx &gt;= k + 1 - cnt || f[k + 1 - cnt] == -1) ? -1 : 1 + f[k + 1 - cnt];  }  int c = -1;    // 分割最小层数  int len = -1;  //  rep(k, mx + 1,      K + 1) {  // 对于最后一组分割，最后一组里各不相同，且组长度 &lt;= cnt    // 上一个分割线有效    // 尚无合法的，或当前层数小于等于 上一个方案    if (f[k] &gt;= 0 &amp;&amp; (c == -1 || c &gt;= f[k])) {      c = f[k];  // 更新层数      len = k;   // 最后一组的起点位置    }  }  // 没有有效的最后一组  if (c == -1) {    cout &lt;&lt; &quot;-1\n&quot;;    return 0;  }  // 从最后的结果反推初始值,  // 这里排除了最后一组，所以在最后一组之前，所有值是相等的  vector&lt;int&gt; A(N, c + 1);  // 最后的结果  rep(k, 0, len) { A[i[k]]--; }  rep(i, 0, N) { printf(&quot;%d%c&quot;, A[i], &quot; \n&quot;[i == N - 1]); }  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>跳表什么都会，但是能把细节分析出来，感觉是熟练度而不是什么缺失的知识点。属于这次学会了，下次可能还是不会的题。</p>]]></content>
      
      
      <categories>
          
          <category> Atcoder </category>
          
          <category> ARC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces 1609E(线段树)</title>
      <link href="/Blog/2021-11-30-cfP1609E/"/>
      <url>/Blog/2021-11-30-cfP1609E/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://codeforces.com/contest/1609/problem/E" target="_blank" rel="noopener">https://codeforces.com/contest/1609/problem/E</a></p><p>给你字符串只包含abc</p><p>给你q次操作,每次操作修改一个位置上的字符为’a’/‘b’/‘c’中的一种</p><p>每次操作后,问对于当前字符串,至少修改多少个字符,使字符串不包含abc子序列</p><p>子序列定义: 字符串任意位置删除任意个得到的剩余字符串</p><h1 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h1><p>字符串长度 1e5</p><p>询问次数 1e5</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>一个可以过的方案是</p><p><code>seg(l,r,state) = 最少次数</code></p><p>其中<code>l,r</code>表示一个区间,通过线段树维护</p><p>state 是 5bit的状态分别对应a,b,c,ab,bc, 是否在区间中出现过</p><hr><p>那么 线段树节点关系 是</p><p><code>f(根, mergestate(statel,stater)) = min(f(左节点,statel)+f(右节点,stater))</code></p><p>其中 产生<code>abc</code>的不更新 根节点状态</p><hr><p>问题是 实现起来感觉有点卡常数  $q \cdot log(N) 32 \cdot 32 $ 的运算量 ,2464ms/3000ms 过的, 看到有些其它状态设计,状态如果更少会更快</p><p>tourist 300ms 过的</p><hr><p>另一个想法是,实际上变成 <code>[不存在a][不存在b][不存在c]</code>的字符串就好了</p><p>那 操作代价(其实就是分别移除a,b,c) = <code>count[a][0..i]+count[b][i+1..j]+count[c][j+1..end]</code></p><p>所以对count计算总是先a后b再c</p><p>变成了维护 <code>f(l,r,startch, endch) = 最少代价</code></p><p>也就是 在区间[l,r]上 起始位置是计算startch,结束位置是计算endch</p><p>这样状态数最多<code>3x3</code>,根据<code>a,b,c</code>的顺序, 真实有效的只有6 个, 计算代价 常数就小很多</p><h1 id="代码-前一种"><a href="#代码-前一种" class="headerlink" title="代码(前一种)"></a>代码(前一种)</h1><p><a href="https://codeforces.com/contest/1609/submission/137409899" target="_blank" rel="noopener">https://codeforces.com/contest/1609/submission/137409899</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;#define rep(i, a, n) for (int i = a; i &lt; n; i++)#define pb push_backconst int INF = 0x3f3f3f3f;  // 无限大操作int n, q;char s[100010];int t[400010][40];// bits// 0 a// 1 b// 2 c// 3 ab// 4 bcvoid mergeState(int o) {  rep(i, 1, (1 &lt;&lt; 5)) { t[o][i] = INF; }  rep(i, 1, (1 &lt;&lt; 5)) {  // 左state    if (t[o &lt;&lt; 1][i] == INF)      continue;    rep(j, 1, (1 &lt;&lt; 5)) {  // 右state      // abc = &#39;a&#39; + &#39;bc&#39; or &#39;ab&#39; + &#39;c&#39;      if (((i &amp; (1 &lt;&lt; 0)) &amp;&amp; (j &amp; (1 &lt;&lt; 4))) ||          ((i &amp; (1 &lt;&lt; 3)) &amp;&amp; (j &amp; (1 &lt;&lt; 2)))) {        continue;      }      // new bit state      int k = i | j;      // ab = &#39;a&#39;+&#39;b&#39;      if ((i &amp; (1 &lt;&lt; 0)) &amp;&amp; (j &amp; (1 &lt;&lt; 1))) {        k |= (1 &lt;&lt; 3);      }      // bc = &#39;b&#39; + &#39;c&#39;      if ((i &amp; (1 &lt;&lt; 1)) &amp;&amp; (j &amp; (1 &lt;&lt; 2))) {        k |= (1 &lt;&lt; 4);      }      t[o][k] = min(t[o][k], t[o &lt;&lt; 1][i] + t[o &lt;&lt; 1 | 1][j]);    }  }}void calc(int o, int pos) {  rep(i, 1, (1 &lt;&lt; 5)) {  // 状态    t[o][i] = (i &amp; (1 &lt;&lt; (s[pos] - &#39;a&#39;))) ? 0 : INF;  }  rep(ch, &#39;a&#39;, &#39;c&#39; + 1) {    if (ch == s[pos])      continue;    // 一次修改    rep(i, 1, (1 &lt;&lt; 5)) {      if (i &amp; (1 &lt;&lt; (ch - &#39;a&#39;))) {  // 包含该bit        t[o][i] = min(t[o][i], 1);      }    }  }}void update(int o, int l, int r, int pos, char ch) {  if (l == r) {    s[pos] = ch;    calc(o, l);    return;  }  int m = (l + r) / 2;  if (pos &lt;= m) {    update(o &lt;&lt; 1, l, m, pos, ch);  } else {    update(o &lt;&lt; 1 | 1, m + 1, r, pos, ch);  }  mergeState(o);}void build(int o, int l, int r) {  if (l == r) {    calc(o, l);  } else {    int m = (l + r) / 2;    build(o &lt;&lt; 1, l, m);    build(o &lt;&lt; 1 | 1, m + 1, r);    mergeState(o);  }}int main() {  scanf(&quot;%d %d&quot;, &amp;n, &amp;q);  scanf(&quot;%s&quot;, s);  build(1, 0, n - 1);  rep(i, 0, q) {    int pos;    char ch;    scanf(&quot;%d %c&quot;, &amp;pos, &amp;ch);    update(1, 0, n - 1, pos - 1, ch);    int ans = INF;    rep(i, 1, (1 &lt;&lt; 5)) { ans = min(ans, t[1][i]); }    printf(&quot;%d\n&quot;, ans);  }  return 0;}</code></pre><h2 id="可能包含改成恰好包含快了不少"><a href="#可能包含改成恰好包含快了不少" class="headerlink" title="可能包含改成恰好包含快了不少"></a>可能包含改成恰好包含快了不少</h2><p><a href="https://codeforces.com/contest/1609/submission/137444815" target="_blank" rel="noopener">https://codeforces.com/contest/1609/submission/137444815</a></p><p>1216 ms/3000 ms</p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;#define rep(i, a, n) for (int i = a; i &lt; n; i++)#define pb push_backconst int INF = 0x3f3f3f3f;  // 无限大操作int n, q;char s[100010];int t[400010][40];// bits// 0 a// 1 b// 2 c// 3 ab// 4 bcvoid mergeState(int o) {  rep(i, 1, (1 &lt;&lt; 5)) { t[o][i] = INF; }  rep(i, 1, (1 &lt;&lt; 5)) {  // 左state    if (t[o &lt;&lt; 1][i] == INF)      continue;    rep(j, 1, (1 &lt;&lt; 5)) {  // 右state      // abc = &#39;a&#39; + &#39;bc&#39; or &#39;ab&#39; + &#39;c&#39;      if (((i &amp; (1 &lt;&lt; 0)) &amp;&amp; (j &amp; (1 &lt;&lt; 4))) ||          ((i &amp; (1 &lt;&lt; 3)) &amp;&amp; (j &amp; (1 &lt;&lt; 2)))) {        continue;      }      // new bit state      int k = i | j;      // ab = &#39;a&#39;+&#39;b&#39;      if ((i &amp; (1 &lt;&lt; 0)) &amp;&amp; (j &amp; (1 &lt;&lt; 1))) {        k |= (1 &lt;&lt; 3);      }      // bc = &#39;b&#39; + &#39;c&#39;      if ((i &amp; (1 &lt;&lt; 1)) &amp;&amp; (j &amp; (1 &lt;&lt; 2))) {        k |= (1 &lt;&lt; 4);      }      t[o][k] = min(t[o][k], t[o &lt;&lt; 1][i] + t[o &lt;&lt; 1 | 1][j]);    }  }}void calc(int o, int pos) {  rep(i, 1, (1 &lt;&lt; 5)) {  // 状态    t[o][i] = INF;  }  rep(ch, &#39;a&#39;, &#39;c&#39; + 1) {    if (ch == s[pos]){      t[o][1&lt;&lt;(ch-&#39;a&#39;)] = 0;    }else{      t[o][1&lt;&lt;(ch-&#39;a&#39;)] = 1;    }  }}void update(int o, int l, int r, int pos, char ch) {  if (l == r) {    s[pos] = ch;    calc(o, l);    return;  }  int m = (l + r) / 2;  if (pos &lt;= m) {    update(o &lt;&lt; 1, l, m, pos, ch);  } else {    update(o &lt;&lt; 1 | 1, m + 1, r, pos, ch);  }  mergeState(o);}void build(int o, int l, int r) {  if (l == r) {    calc(o, l);  } else {    int m = (l + r) / 2;    build(o &lt;&lt; 1, l, m);    build(o &lt;&lt; 1 | 1, m + 1, r);    mergeState(o);  }}int main() {  scanf(&quot;%d %d&quot;, &amp;n, &amp;q);  scanf(&quot;%s&quot;, s);  build(1, 0, n - 1);  rep(i, 0, q) {    int pos;    char ch;    scanf(&quot;%d %c&quot;, &amp;pos, &amp;ch);    update(1, 0, n - 1, pos - 1, ch);    int ans = INF;    rep(i, 1, (1 &lt;&lt; 5)) { ans = min(ans, t[1][i]); }    printf(&quot;%d\n&quot;, ans);  }  return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atcoder arc130 D, 树上DP,子树点乘代价合并,总代价为n方</title>
      <link href="/Blog/2021-11-29-ac_arc130d/"/>
      <url>/Blog/2021-11-29-ac_arc130d/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://atcoder.jp/contests/arc130/tasks/arc130_d" target="_blank" rel="noopener">https://atcoder.jp/contests/arc130/tasks/arc130_d</a></p><p>给一个树,对节点赋值<code>1~n</code>,两两互不相同,</p><p>限制:树上的点要么小于它直接相邻所有点的值,要么大于它直接相邻所有点的值</p><p>求方案数.</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>显然任意选一个为根, 大于和方案和小于的方案对称性,可以只算一个然后乘2</p><p>也可以,看成二分图,但是是求满足拓扑序的赋值方案数</p><hr><p>注意到大于和小于关系,只需要颠倒就能实现,所以这里我们只讨论 根节点大于所有直接相邻的子节点</p><p>我们考虑树上DP</p><p>状态设计为 <code>ans[i][j] =</code> 节点i在它和它的所有子树节点中,排序从小到大刚好为j的方案数</p><p>对于一个选定的节点,有子树T1,T2,T3,T4,…</p><p>设它们的根节点为r1,r2,r3,r4,…</p><p>设它们的节点个数为s1,s2,s3,s4,…</p><p>那么, 我们考虑维护合并这些子树.</p><p>因为 我们这里考虑的是 当前节点要大于所有子树的根节点</p><p>所以 合并的时候维护 <code>dp[i] =</code> 已合并的子树中,根节点最大值恰好为<code>i</code>的方案数</p><hr><p>以T1和T2为例</p><p>分成两种, T1的根更大,和T2的根更大(可以对称处理)</p><p>下面讨论 T1根更大</p><p>设r1在T1 中的位置为i<code>(1-index)</code></p><p>合并后的序列为<code>(i-1个T1中的点 和 j个T2中的点) r1 ((s1-i)个T1中的点 和 (s2-j)个T2中的点)</code></p><p>注意在两个子树分别的内部,顺序已经固定, 所以只有交叉的顺序不定</p><p>方案为 $C((i-1)+j,i-1) \cdot C((s1-i)+(s2-j),s1-i) \cdot ans[r1][i]$</p><p>再考虑, T2中的r2的位置,因为T1根更大,所以r2只能在前j个中</p><p>$dp[i+j] += C(i+j-1,i-1) \cdot C(s1+s2-i-j,s1-i) \cdot ans[r1][i] \cdot (ans[r2][1]+\cdots +ans[r2][j])$</p><p>右边的和可以前缀和O(1),</p><p>组合数可以预处理递推O(1),</p><p>所以</p><p>我们通过 循环一遍T1的节点数,再一遍T2的节点数数,就能得到dp, 每个<code>+=</code> 是O(1)</p><p><strong>这里总代价n2,而我错误估计以为n3就没写,哭了</strong></p><p>乍看上去,所有节点处理一次,每个节点是子树之间合并,个数的乘积是n3复杂度</p><p>实际上,考虑贡献, 一次合并子树的两个子树节点个数乘积大小的代价, 相当于,两个子树之间的节点建立一个配对关系.又因为任何两个节点至多建立两次(讨论根更大)关系,所以总代价为$O(n^2)$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 998244353#define rep(i, a, n) for (ll i = a; i &lt; n; i++)int n;  // &lt;=3000vector&lt;int&gt; p2[3010]; // 树连接关系// [node i][从小到大第j个] = 方案数vector&lt;vector&lt;ll&gt; &gt; ans(3010, vector&lt;ll&gt;(1, 0));ll qC[3010][3010]; // 预处理组合数void mergeTable(const vector&lt;ll&gt;&amp; arr0,                const vector&lt;ll&gt;&amp; arr1,                vector&lt;ll&gt;&amp; res) {  vector&lt;ll&gt; presum(arr1.size(), arr1[0]);  rep(i, 1, arr1.size()) { presum[i] = (arr1[i] + presum[i - 1]) % MOD; } // 前缀和  // arr0 根更大 , root(arr0) &gt; root(arr1)  // 虽然每次代价是 子树大小之和 x arr0.size()，看起来是三次方，  // 但实际上,从贡献角度思考 总代价n2  rep(i, 0, arr0.size()) {    rep(j, 0, arr1.size()) {      // arr0: i 个 左侧， arr0.size()-i-1 个 右侧      // arr1: j+1 个 左侧, arr1.size()-j-1 个右侧      // res: i+j+1 个左侧, arr0.size()+arr1.size()-i-j-2 个右侧      // presum = presumof arr1      // 就是表达式 加上了MOD      (res[i + j + 1] +=       (((arr0[i] * qC[i + j + 1][i]) % MOD *         qC[arr0.size() + arr1.size() - i - j - 2][arr0.size() - i - 1]) %        MOD * presum[j]) %       MOD) %= MOD;    }  }}void dfs(int idx, int fa/*父节点*/, int g/*大于小于关系*/) {  vector&lt;ll&gt; dp = {};  // [最大的子树 根节点 位置] = 方案数  for (auto item : p2[idx]) {    if (item == fa)      continue;    dfs(item, idx, g ^ 1);    if (g) {  // 逆向      // 只用一次也不需要恢复了      reverse(ans[item].begin(), ans[item].end());    }    if (!dp.size()) {      dp = ans[item];    } else {      vector&lt;ll&gt; res(dp.size() + ans[item].size(), 0);      mergeTable(dp, ans[item], res); // dp 根更大      mergeTable(ans[item], dp, res); // ans[item] 根更大      dp = res;    }  }  ans[idx] = vector&lt;ll&gt;(dp.size() + 1, 0);  if (dp.size() == 0) {    // 叶子节点    ans[idx][0] = 1;  } else {    ll cnt = 0;    rep(i, 0, dp.size() + 1) { // 实际上也是前缀和, 当前节点 大于 所有子树根节点      ans[idx][i] = cnt;      (cnt += dp[i]) %= MOD;    }  }  if (g) {    reverse(ans[idx].begin(), ans[idx].end());  }}int main() {  rep(i, 0, 3001) {    rep(j, 0, i + 1) {      qC[i][j] = j == 0 ? 1 : (qC[i - 1][j] + qC[i - 1][j - 1]) % MOD;    }  }  scanf(&quot;%d&quot;, &amp;n);  rep(i, 0, n - 1) {    int u, v;    scanf(&quot;%d %d&quot;, &amp;u, &amp;v);    p2[u].push_back(v);    p2[v].push_back(u);  }  dfs(1, 0, 0);  ll res = 0;  rep(i, 0, n) { (res += ans[1][i]) %= MOD; }  printf(&quot;%lld\n&quot;, (2 * res) % MOD); // 大于小于对称性 乘2  return 0;}</code></pre><p><a href="https://atcoder.jp/contests/arc130/submissions/27588953" target="_blank" rel="noopener">submissions</a></p><p><a href="https://atcoder.jp/contests/arc130/editorial/2996" target="_blank" rel="noopener">官方题解</a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>可以当作知识点的: 子树全部 节点数相乘的代价,总代价是$O(n^2)$</li><li>复杂度也可以在纸上不要脑补</li></ol>]]></content>
      
      
      <categories>
          
          <category> Atcoder </category>
          
          <category> ARC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atcoder arc127 D Sum of Min of xor(分治,bits,xor)</title>
      <link href="/Blog/2021-09-29-ac_arc127d/"/>
      <url>/Blog/2021-09-29-ac_arc127d/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://atcoder.jp/contests/arc127/tasks/arc127_d" target="_blank" rel="noopener">https://atcoder.jp/contests/arc127/tasks/arc127_d</a></p><p>题目大意,(atcoder 的这个题没有“背景”，直接去看原题，就是题意</p><p>给等长数组A,B, 对于两两坐标i,j, 计算$min(A_i \oplus A_j, B_i \oplus B_j )$</p><p>求所有min的和</p><p>范围</p><p>$n \leq 250000 , A_i,B_i &lt; 2^{18}$</p><h1 id="想"><a href="#想" class="headerlink" title="想"></a>想</h1><p>先做一些简单的分析,N 有点大，$N^2$的话肯定超时, 那么基本范围是$N ,  N log(N)$ 左右的</p><p>$2^{18} = 262144$</p><hr><p>min(x,y)+max(x,y) = x+y</p><hr><p>一些 $\oplus$ 的常见知识, $(A \oplus B) = (A + B) \bmod 2$, 其中<code>加</code>和<code>模</code>采取 <code>每位不进位</code>且<code>允许超过2的任意值</code>, 这个好处是能计数</p><p>例如 5 = 101,7=111, 9 = 1001</p><p>$(0,1,0,1)+(0,1,1,1)+(1,0,0,1) = (1,2,1,3) $</p><p>$(1,2,1,3) \bmod 2 = (1,0,1,1) $</p><p>所以$5 \oplus 7 \oplus 9 = 11$, 同时我们知道最高位1个1，2个0</p><hr><p>a &lt; b 那么 $a \oplus b$ 的最高位1出现在b</p><p>反过来</p><p>$a \oplus b$ 最高位出现在b , 那么 a &lt; b</p><p>(归纳法易证</p><hr><p>$a \oplus (b+c+d+e+\cdots) =$ 后面部分通过上面按位不进位加和统计的每一位 0 个数 或1个数，在看与a对应位是否相等</p><p>通过前缀和或者扫描记录当前， 长度为n的数组的两两$\oplus$的和 的时间复杂度O(N) 就能完成</p><hr><p>综上，我们可以直接算出 min， 也可以去算max然后拿总和减去min</p><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p>把所有数看成18位，不足高位补零</p><p>我们 关心$(A_i \oplus A_j) \oplus (B_i \oplus B_j) $ 的最高位的bit从哪里来，这样我们就知道哪个最大了</p><p>$(A_i \oplus A_j) \oplus (B_i \oplus B_j) = (A_i \oplus B_i) \oplus (A_j \oplus B_j) $</p><hr><p>令$C_i = A_i \oplus B_i$</p><p>w = 18</p><p>把$C_i$分类成两组, 一组是 第$w$位为$1$的，另一组是$w$位为$0$的</p><p>每组内，循环这个方法并且w-1</p><hr><p>对于组之间的，</p><p>$C_i$的$w$位为1, $C_j$的$w$位为0 , 对于高于w位的，因为通过上面的分治，两边保持一致，也就是$\oplus$以后都是0了不需要考虑</p><p>对于$w$位为1 里面我们还可以分类为 $A_i$ 的w位是0或1两类</p><p>$G_{x,y}$ w位是x，A的w位是y</p><p>$G_{1,0},G_{0,0}$, 高位1来自B的$\oplus$</p><p>$G_{1,0}, G_{0,1}$, 高位1来自A的$\oplus$</p><p>$G_{1,1}, G_{0,0}$, 高位1来自A的$\oplus$</p><p>$G_{1,1}, G_{0,1}$, 高位1来自B的$\oplus$</p><p>也就是分组的时间复杂度就是$2^L$</p><p>下面考虑</p><p>$G_{i_0,i_1,i_2,\cdots} $ 与 $G_{j_0,j_1,j_2,\cdots}$ 中 如果高位来自A的$\oplus$</p><p>那么贡献为</p><p>$ \sum B_{i_?} \oplus B_{j_?}$</p><p>也就是，上面想求总和提到过的方法, 通过按位计数，拿着一块求和的单个复杂度为$O(L\cdot size(G))$, 总复杂度为$O(L\cdot N)$</p><hr><p>然后注意处理$C_i$ 一致的组，这样的组里面，两两的异或值相同, 也需要上面的按位计数的求和</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 1000000007#define rep(i,a,n) for (ll i=a;i&lt;n;i++)#define per(i,a,n) for (ll i=n-1;i&gt;=a;i--)#define pb push_backint A[250010];int B[250010];const int L = 18;// 两两xor和 A[i0[?]]ll xorSum(vector&lt;int&gt; &amp; i0){  if(i0.size() == 0)return 0;  vector&lt;int&gt; bits = vector&lt;int&gt;(20,0);  ll ans = 0;  rep(i,0,i0.size()){    if(i &gt; 0){      rep(b,0,L){        ans += ((A[i0[i]]&gt;&gt;b) % 2)?          ((ll)1 &lt;&lt; b) * (i - bits[b]):          ((ll)1 &lt;&lt; b) * (bits[b]);      }    }    rep(b,0,L){      bits[b]+=(A[i0[i]]&gt;&gt;b)%2;    }  }  return ans;}// 任意左Arr[i0[?]] xor 任意右Arr[i1[?]] 的和ll xorSum(vector&lt;int&gt; &amp; i0,vector&lt;int&gt; &amp; i1, int * Arr){  if(i0.size() == 0 || i1.size() == 0)return 0;  vector&lt;int&gt; bits = vector&lt;int&gt;(20,0);  rep(i,0,i0.size()){    rep(b,0,L){      bits[b]+=(Arr[i0[i]]&gt;&gt;b)%2;    }  }  ll ans = 0;  rep(i,0,i1.size()){    rep(b,0,L){      ans += ((Arr[i1[i]]&gt;&gt;b) % 2)?        ((ll)1 &lt;&lt; b) * (i0.size() - bits[b]):        ((ll)1 &lt;&lt; b) * (bits[b]);    }  }  return ans;}// pwr 以上的位， idxs里面 A[i]^B[i] 两两相等ll f(int pwr,vector&lt;int&gt; &amp; idxs){  if(pwr &lt; 0){    // (Ai xor Aj) xor (Bi xor Bj) = (Ai xor Bi) xor (Aj xor Bj) = 0    return xorSum(idxs);  }  // groups  vector&lt;int&gt; gC[2] = {{},{}}; // w 位的 C  vector&lt;int&gt; gCA[2][2] = {{{},{}},{{},{}}};// w 位 C 和 A的 零一  for(auto i:idxs){    int C = A[i]^B[i];    gC[(C&gt;&gt;pwr)%2].pb(i);    gCA[(C&gt;&gt;pwr)%2][(A[i]&gt;&gt;pwr)%2].pb(i);  }  ll ans = 0;  rep(i,0,2){    if(gC[i].size() &lt; 2) continue;    ans += f(pwr-1,gC[i]);  }  // bit  rep(bA0,0,2){    rep(bA1,0,2){      ans += (bA0 ^ bA1)?        xorSum(gCA[0][bA0],gCA[1][bA1], B):        xorSum(gCA[0][bA0],gCA[1][bA1], A);    }  }  return ans;}int main(){  int n;  cin&gt;&gt;n;  rep(i,0,n){    scanf(&quot;%d&quot;,A+i);  }  rep(i,0,n){    scanf(&quot;%d&quot;,B+i);  }  vector&lt;int&gt;idxs;  rep(i,0,n){    idxs.pb(i);  }  printf(&quot;%lld&quot;,f(L,idxs));  return 0;}</code></pre><h1 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h1><p><a href="https://atcoder.jp/contests/arc127/editorial/2697" target="_blank" rel="noopener">https://atcoder.jp/contests/arc127/editorial/2697</a></p>]]></content>
      
      
      <categories>
          
          <category> Atcoder </category>
          
          <category> ARC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
            <tag> enum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>project euler 233 (直角三角形)</title>
      <link href="/Blog/2021-09-24-project-euler233/"/>
      <url>/Blog/2021-09-24-project-euler233/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://projecteuler.net/problem=233" target="_blank" rel="noopener">https://projecteuler.net/problem=233</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>$f(N) = $ 和 $(0,0)(0,N),(N,0),(N,N)$ 共圆的整点的个数</p><p>例如 $f(10000) = 36$</p><p>求 $1 \leq i \leq 10^{11}$ 使得$f(i)=420$ 的所有$i$的和</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="我目前想到的"><a href="#我目前想到的" class="headerlink" title="我目前想到的"></a>我目前想到的</h2><h3 id="对称性"><a href="#对称性" class="headerlink" title="对称性"></a>对称性</h3><p>首先 圆上的点 (x,y) 满足</p><p>$(x-\frac{N}{2})^2+(y-\frac{N}{2})^2 = \frac{N^2}{2}$</p><p>根据对称性</p><p>我们只用考虑 $\frac{N}{2} &lt; x &lt; y $ 的个数，然后乘8 加4(对角线的点)</p><p>$420 = 52 \cdot 8 +4$</p><p>所以这里我们其实 需要求满足上述两个条件的整点 方案为52的即可</p><h3 id="奇偶"><a href="#奇偶" class="headerlink" title="奇偶"></a>奇偶</h3><p>若 N 为奇数</p><p>$(2x-N)^2+(2y-N)^2 = 2N^2$, 要解的方程是$a^2+b^2=2c^2, (0 &lt; a &lt; c &lt; b )$且$a,b,c$均为奇数的形式</p><p>若 N 为偶数，令 $N=2k$</p><p>$(x-k)^2+(y-k)^2 = 2k^2$, 要解的方程是$a^2+b^2=2c^2$ 的形式</p><p>考虑 到$\bmod 4$ 的情况</p><p>$ 0^2 = 0 \bmod 4 $</p><p>$ 1^2 = 1 \bmod 4 $</p><p>$ 2^2 = 0 \bmod 4 $</p><p>$ 3^2 = 1 \bmod 4 $</p><p>所以 $(a,b,c)$ 同奇偶</p><p>因此如果k仍然是偶数，则继续除以2，反复迭代直到c为奇数</p><p>最终我们只用考虑 奇数的形式</p><blockquote><p>也得到结论如果N是偶数，那么$f(N) = f(\frac{N}{2})$</p></blockquote><h3 id="公约数"><a href="#公约数" class="headerlink" title="公约数"></a>公约数</h3><p>若 $gcd(a,b) = k &gt; 1$，那么显然 $gcd(a,c) = k$</p><p>所以$(a,b,c)$同时除以$k$依然成立</p><p>同理$(a,c),(b,c)$ 只用考虑 $(a,b,c)$ 两两互质，非互质的是通过互质的倍数得到的</p><p>令 $g(c) = $ 使得 $a^2+b^2=2c^2 ,(0 &lt; a &lt; c &lt; b),(a,b,c)$ 两两互质 且 全为奇数(废话，可以不加这条因为是等式的结论)  的方案数</p><p>$c$是奇数时 $ f(c) = \sum_{c = 0 \bmod i}g(i)$</p><h3 id="变形-与-直角三角形"><a href="#变形-与-直角三角形" class="headerlink" title="变形 与 直角三角形"></a>变形 与 直角三角形</h3><p>$a^2+b^2=2c^2, (0 &lt; a &lt; c &lt; b )$且$a,b,c$均为奇数的形式</p><h4 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h4><p>$b^2 - 2c^2 = -a^2$ 然后 佩尔方程类似的去解</p><p>如果能得到不同a的初始解，剩余的解很容易得到，但是初始解还是只能枚举</p><h4 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h4><p>令$d = \frac{a+b}{2}$,$e = \frac{b-a}{2}$</p><p>则$d,e$为整数且奇偶互异, </p><p>带入 $(d-e)^2+(d+e)^2=2c^2$</p><p>即$d^2+e^2=c^2$</p><p>这和 直角三角形的基础解是一一对应的,(<a href="http://yexiaorain.github.io/Blog/2020-06-08-project-euler075/">直角三角形基础解的讲解 见 PE075 的题解</a>)</p><p>所以 $k(a,b,c)$ 与 $k(d,e,c)$ 一一对应</p><p>所以 问题变成了</p><p> c 为直角三角形边 恰好 52 种的方案数</p><h3 id="计算方案数-与-方案数性质"><a href="#计算方案数-与-方案数性质" class="headerlink" title="计算方案数 与 方案数性质"></a>计算方案数 与 方案数性质</h3><p>根据 直角三角形基础解的性质</p><p>若 满足$c = k (m^2+n^2), (m&gt;n&gt;0) , (m+n)=1 \bmod 2$</p><p>则 c 是一个直角三角形的斜边</p><p>问题是 数量级在$10^{11}$ 虽然 m 和n 都不到$10^6$了，但是基于时间和空间 依然 无法暴力</p><h2 id="费马平方和定理"><a href="#费马平方和定理" class="headerlink" title="费马平方和定理"></a>费马平方和定理</h2><p>奇质数能表示为两个平方数之和的<strong>充分必要条件</strong>是该质数被4除余1</p><h3 id="如果两个整数都能表示为两个平方数之和，则它们的积也能表示为两个平方数之和"><a href="#如果两个整数都能表示为两个平方数之和，则它们的积也能表示为两个平方数之和" class="headerlink" title="如果两个整数都能表示为两个平方数之和，则它们的积也能表示为两个平方数之和"></a>如果两个整数都能表示为两个平方数之和，则它们的积也能表示为两个平方数之和</h3><p><code>Brahmagupta-Fibonacci Identity</code></p><p>$(a^2+b^2)(c^2+d^2) = (ac+bd)^2 + (ad-bc)^2$</p><blockquote><p>只有$ad=bc$ 时右侧有0的平方 , 也就是两个整数成$c^2/a^2$的倍数</p></blockquote><h3 id="如果一个能表示为两个平方数之和的整数被另一个能表示为两个平方数之和的素数整除，则它们的商也能表示为两个平方数之和"><a href="#如果一个能表示为两个平方数之和的整数被另一个能表示为两个平方数之和的素数整除，则它们的商也能表示为两个平方数之和" class="headerlink" title="如果一个能表示为两个平方数之和的整数被另一个能表示为两个平方数之和的素数整除，则它们的商也能表示为两个平方数之和"></a>如果一个能表示为两个平方数之和的整数被另一个能表示为两个平方数之和的素数整除，则它们的商也能表示为两个平方数之和</h3><p>$a^2+b^2 = k (c^2+d^2)$,$(c^2+d^2) = p$为素数</p><p>$(cb-ad)(cb+ad) = c^2(a^2+b^2)-a^2(c^2+d^2) = (c^2k-a^2)p$</p><p>若$cb-ad$ 是 p 的倍数(另一半假设,对称同理)</p><p>$kp^2 = (a^2+b^2)(c^2+d^2) = (ac+bd)^2+(ad-bc)^2$</p><p>得到 $ap+bq$ 也是 p的倍数</p><p>$k = (\frac{ac+bd}{p})^2+(\frac{ad-bc}{p})^2$ 能表示成整数的平方和</p><h3 id="如果一个能表示为两个平方数之和的整数被另一个不能表示为两个平方数之和的整数整除，则它们的商也必有一个不能表示为两个平方数之和的因子"><a href="#如果一个能表示为两个平方数之和的整数被另一个不能表示为两个平方数之和的整数整除，则它们的商也必有一个不能表示为两个平方数之和的因子" class="headerlink" title="如果一个能表示为两个平方数之和的整数被另一个不能表示为两个平方数之和的整数整除，则它们的商也必有一个不能表示为两个平方数之和的因子"></a>如果一个能表示为两个平方数之和的整数被另一个不能表示为两个平方数之和的整数整除，则它们的商也必有一个不能表示为两个平方数之和的因子</h3><p>$a^2+b^2 = x \cdot p_1 \cdot p_2 \cdots p_n$ x不能表示为两个数的平方和, 则 $p_i$ 中至少有一个不能表示为两个平方数之和的因子</p><p>如果$p_i$ 都能表示成，那么根据上面的结论，必定能表示成平方和，矛盾</p><h3 id="如果-a-b-互素，那么-a-2-b-2-所有因子都能表示为两个平方数之和"><a href="#如果-a-b-互素，那么-a-2-b-2-所有因子都能表示为两个平方数之和" class="headerlink" title="如果$a,b$互素，那么$a^2+b^2$ 所有因子都能表示为两个平方数之和"></a>如果$a,b$互素，那么$a^2+b^2$ 所有因子都能表示为两个平方数之和</h3><p>$a^2+b^2 = x \cdot p_1 \cdot p_2 \cdots p_n $</p><p>$a = mx \pm c, b = nx \pm d$, 其中 $ 2|c| \leq x,2|d| \leq x$</p><p>有 $a^2+b^2 = m^2x^2 \pm 2mxc + c^2 + n^2x^2 \pm 2nxd + d^2 = Ax+(c^2+d^2)$</p><p>$c^2+d^2 = kx$</p><p>令$g = gcd(c,d)$</p><p>因为$a,b$互素, 所以 $a,x$ 互素， 所以 $c,x$ 互素, 同理 $d,x$ 互素, 所以$g,x$ 互素</p><p>$g^2((\frac{c}{g})^2+(\frac{d}{g})^2) = kx$, 说明中间的部分也是$x$的倍数</p><p>能得到 $e^2+f^2=k_1x$ 且$e,f$互素</p><p>$k_1x = e^2+f^2 \leq c^2+d^2 \leq (\frac{x}{2})^2 + (\frac{x}{2})^2 = \frac{x^2}{2}$</p><p>有 $k_1 \leq \frac{x}{2}$</p><p>由上一个定理，若x非平方和，那么k包含非平方和因子,令这个因子为$x’$</p><p>$x’ \leq k_1 \leq \frac{x}{2} &lt; x $</p><p>综上 如果$a,b$互质,x是 $a^2+b^2$ 的因子，且$x$不能被表示成两个数的平方和，那么存在一个小于$x$的数，也满足是$a^2+b^2$的因子,且比$x$小，同时也是不能表示成两个数的平方和。</p><p>然而整数无法无限下降，所以所有因子 都能表示成两个数的平方和</p><h3 id="4n-1-形式的素数是平方分解数"><a href="#4n-1-形式的素数是平方分解数" class="headerlink" title="$4n+1$形式的素数是平方分解数"></a>$4n+1$形式的素数是平方分解数</h3><p>$p = 4n + 1$</p><p>$1,2^{4n},3^{4n},…,(4n)^{4n}$ 模$p$余1 (费马小定理)</p><p>$2^{4n}-1,3^{4n}-2^{4n},…,(4n)^{4n}-(4n-1)^{4n}$ 均是$p$的倍数</p><p>$a^{4n} - b^{4n} = (a^{2n}+b^{2n})(a^{2n}-b^{2n})$</p><ol><li>若 $p$ 是任意一个 $a^{2n}+b^{2n}$ 的因子，注意到 $a,p$ 互质, $b,p$互质,$a,b$ 互质（a=b+1）</li></ol><p>由上一条引理，$p$ 是互素平方和的因子，所以$p$可以拆解成两个数的平方和</p><ol start="2"><li>否则 $p$ 是所有 $a^{2n}-b^{2n}$ 的因子</li></ol><p>$(x+1)^{2n} - x^{2n} = ((x+1)^n + x^n) ((x+1)^n - x^n)$</p><h4 id="差分-f-x-为-n-次多项式，那么-f-x-的-n-阶差分为-n-a-n"><a href="#差分-f-x-为-n-次多项式，那么-f-x-的-n-阶差分为-n-a-n" class="headerlink" title="差分 $f(x)$ 为$n$次多项式，那么 $f(x)$ 的$n$阶差分为 $n!a_n$"></a>差分 $f(x)$ 为$n$次多项式，那么 $f(x)$ 的$n$阶差分为 $n!a_n$</h4><p><img src="http://nonagon.org/ExLibris/sites/default/files/images/Differences-Cubes.jpg" alt="差分"></p><p>$ f(x) = a_0 + a_1x $</p><p>$ f(x+1) - f(x) = a_1 $ 一次多项式得证</p><p>若 $n-1$次多项式成立</p><p>设 $f$ 是$n$次多项式 $ f(x) = a_0 + a_1x+ \cdots + a_nx^n $</p><p>$ g(x) = f(x+1) - f(x) = k_0 + k_1x+ \cdots + a_n \cdot n x^{n-1} $ </p><p>$g$是 $n-1$次多项式，且其最高项的系数为 $a_n \cdot n $</p><p>因为 $g(x)$ 的$n-1$阶差分为 $(n-1)!(a_n \cdot n)  = n! a_n$，归纳法递推得证</p><p>回到上面 我们因为p是所有减法式子的因子，因此$f(x) = x^{2n}$的$2n$阶差分为$(2n)!$, 差分过程中始终是$p$的倍数</p><p>而$(2n)!$不是$p$的倍数，所以矛盾。必然$p$是上面某个加法的因子</p><blockquote><p>综上，$4n+1$ 形式的素数是平方分解数</p></blockquote><p>$4n+3$ 根据模4的余数，显然不是</p><blockquote><p>综上充要得证: 一个奇素数是平方分解数，那么它是$4n+1$, 一个素数是$4n+1$形式，那么它是平方分解数</p></blockquote><h2 id="补充性质"><a href="#补充性质" class="headerlink" title="补充性质"></a>补充性质</h2><p>$p = x^2+y^2$ 质数唯一表示</p><p>$p = a^2+b^2=c^2+d^2$</p><p>轮换性质，不妨设$a&gt;c&gt;d&gt;b$</p><p>$(ac+bd)(ad+bc) = (a^2+b^2)cd +(c^2+d^2)ab = p(cd+ab)$</p><p>至少一个是p的倍数, 若 $(ac+bd) = Kp$ , </p><p>$0 &lt; (a-c)^2+(b-d)^2 = a^2+b^2+c^2+d^2-2ac-2bd = 2p-2Kp &lt; 2p $，</p><p>同时除2,$0 &lt; p-Kp &lt; p $ 矛盾</p><p>因此$p$ 唯一表示成两个</p><h2 id="回到题目"><a href="#回到题目" class="headerlink" title="回到题目"></a>回到题目</h2><p>我们之前的结论是：</p><p>若 满足$c = k (m^2+n^2), (m &gt; n &gt; 0) , (m+n)=1 \bmod 2$</p><p>则 $c$ 是一个直角三角形的斜边, 求有52个解的所有的$c$的和</p><p>现在有的理论基础是：</p><p>若$a,b$ 互质,则$a^2+b^2$所有质因子都是$4n+1$的形式, 且这些质因子自身唯一分解</p><p>反过来$4n+1$的质数的乘积 能表示成 $a^2+b^2$，但是可能$a,b$不互质, 例如$5^4 = 5^2(5^2) = 5^2(3^2+4^2)=15^2+20^2$</p><p>所以上面的一个数$c$质因数分解,则 模4余3的质因子和2全在k中,模4余1的因子可以在k中也可以不在k中</p><p>$k(m^2+n^2) = c = 2^{c_1} p_1^{a_1} \cdots p_r ^{a_r} q_1^{b_1} \cdots q_s ^{b_s}$</p><p>$k$是$2^{c_1}q_1^{b_1} \cdots q_s ^{b_s}$ 的倍数</p><p>$p_1^{a_1} \cdots p_r ^{a_r}$是$(m^2+n^2)$ 的倍数</p><h1 id="表示方法来源的唯一性-一个仅由4n-1素数乘积构成的数的平方数分解，全部恰好由其任意一个素数的表示法与剩余部分的表示法生成"><a href="#表示方法来源的唯一性-一个仅由4n-1素数乘积构成的数的平方数分解，全部恰好由其任意一个素数的表示法与剩余部分的表示法生成" class="headerlink" title="表示方法来源的唯一性, 一个仅由4n+1素数乘积构成的数的平方数分解，全部恰好由其任意一个素数的表示法与剩余部分的表示法生成"></a>表示方法来源的唯一性, 一个仅由4n+1素数乘积构成的数的平方数分解，全部恰好由其任意一个素数的表示法与剩余部分的表示法生成</h1><p>我们下面只关心$X = m^2+n^2 = p_1^{d_1} \cdots p_r ^{d_r}$的部分, 这里幂次用d区别了上面的a，表示确定选择的部分，仅仅是上面a的部分约数即可</p><p>任意拆一个质因子</p><p>$X = (p_1^{d_1} \cdots p_i^{d_i-1}\cdots p_r ^{d_r})\cdot p_i$</p><p>已知对于左侧任意一个表示法$a^2+b^2$, 和 右侧的一个唯一的表示法$c^2+d^2$</p><p>由费马平方和定理第一条, 可以对$X = (a^2 + b^2)(c^2 + d^2) = (ac+bd)^2+(ad-bc)^2 = (ac-bd)^2+(ad+bc)^2$</p><p>也就是 对于给定$(a,b), p $ 能产生考虑正负的16个点，这8个点一组，每组内的点按坐标轴和对角线对撑</p><p>$((a,b), p) =&gt; (\pm(ac+bd),\pm(ad-bc)) or (\pm(ac-bd),\pm(ad+bc))$ 或交换横纵坐标 </p><hr><p>反过来，考虑$X = e^2+f^2 = $ 的一个任意的表示法</p><p>$X = e^2+f^2 = (p_1^{d_1} \cdots p_i^{d_i-1}\cdots p_r ^{d_r})\cdot (c^2+d^2)$</p><p>由上面费马平方和定理第二条</p><p>$(p_1^{d_1} \cdots p_i^{d_i-1}\cdots p_r ^{d_r}) = (\frac{ec+fd}{p})^2+(\frac{ed-fc}{p})^2$ 能表示成整数的平方和 或 $= (\frac{ec-fd}{p})^2+(\frac{ed+fc}{p})^2$能表示成平方和的倍数</p><p>所以，至少有一个拆解</p><p>如果是第一个</p><p>$((\frac{ec+fd}{p})^2+(\frac{ed-fc}{p})^2)(c^2+d^2) = (c\frac{ec+fd}{p}+d\frac{ed-fc}{p})^2+(c\frac{ed-fc}{p}-d\frac{ec+fd}{p})^2 = (\frac{e(c^2+d^2)}p)^2+(\frac{-f(c^2+d^2)}p)^2 = e^2+f^2$</p><p>第二个同理可证，说明了刚好为逆运算</p><p>也就说明了，对于每一个$X$的表示，其所有的可行拆解对应逆运算能得到$X$对应的表示,那么在考虑所有正负的情况下，通过 费马定理第一条，能不漏的计算出$X$的所有表示</p><hr><p>然后整理一下值，我们发现$(\pm a,\pm b), (\pm b,\pm a)$ 所产生的16个点不会因为$a,b$的正负和顺序受到影响</p><p>所以我们仅去考虑$0 &lt; a &lt; b$, 也就是x正向轴，和y=x正向 之间区域的点作为a,b ，同时产生的点也仅考虑在这个区域的点。</p><p>那么有，根据费马定理的第一步，每组$((a,b),p)$ 产生两个新的点</p><h1 id="点的计数-TODO"><a href="#点的计数-TODO" class="headerlink" title="点的计数(TODO"></a>点的计数(TODO</h1><p>这样保证了点的不漏,每多一个质数，原来的一个点就能产生新的两个点，数量显然是$2^{d_1+d_2+\cdots+d_r-1}$</p><p>接下来考虑不重复计数</p><p>$((a,b), p = c^2+d^2) =&gt; ((ac+bd),(ad-bc)) or ((ac-bd),(ad+bc))$ </p><p>若 $ac+bd = ad+bc $, 即$(a-b)(c-d) = 0$ 不会成立</p><p>若 $ac+bd = | ac - bd | $, 即$bd=0$或$ac =0$ 不会成立</p><p>所以 对于一个$((a,b),p)$ 产生的两个点必不相同</p><hr><p>考虑不同的$a,b$, $a_1^2+b_1^2 = a_2^2+b_2^2$</p><p>$((a_1,b_1),p) =&gt; ((a_1c+b_1d),(a_1d-b_1c)) or ((a_1c-b_1d),(a_1d+b_1c))$</p><p>$((a_2,b_2),p) =&gt; ((a_2c+b_2d),(a_2d-b_2c)) or ((a_2c-b_2d),(a_2d+b_2c))$</p><p>若 $a_1c+b_1d = a_2c+b_2d$,</p><p>?????????????????????</p><blockquote><p>目前看 相关资料，表示Dummit &amp; Foote, 3rd ed., p 291有相关证明</p></blockquote><h1 id="点的计数"><a href="#点的计数" class="headerlink" title="点的计数"></a>点的计数</h1><h2 id="引理定义们"><a href="#引理定义们" class="headerlink" title="引理定义们"></a>引理定义们</h2><p>除法: 对于所有$a,b\in \mathbb{Z},b \neq 0$,有唯一$q,r\in \mathbb{Z}, 0\leq r &lt; |b|$ 使得 $a=bq+r$</p><p>整除: 对于$a,b\in Z$ $a$是$b$的除数，当存在一个整数$x$, 使得$ax = b$, 写作$a \mid b$,不整除写作$a \nmid b$</p><p>恒成立的整除: $1 \mid a,-1 \mid a, a \mid a, -a \mid a$</p><p>质数: 仅有上述恒成立的整除关系，且为正，非1</p><p>互质: $a,b$ 互质，当它们公共的除数，仅有正负1</p><p>最大公约数: $gcd(a,b)$ 所有a和b共有的约数中最大的一个</p><p>合数: $a = p_1\cdot p_2 \cdots p_k$, 唯一表示</p><h1 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h1><p><a href="https://proofwiki.org/wiki/Brahmagupta-Fibonacci_Identity" target="_blank" rel="noopener">Brahmagupta-Fibonacci Identity</a></p><p><a href="https://en.wikipedia.org/wiki/Fermat%27s_theorem_on_sums_of_two_squares" target="_blank" rel="noopener">Fermat’s theorem on sums of two squares</a></p><p><a href="http://nonagon.org/ExLibris/fermat-sum-two-squares-calculator" target="_blank" rel="noopener">Fermat Sum of Two Squares Calculator</a></p><p><a href="https://mathworld.wolfram.com/Fermats4nPlus1Theorem.html" target="_blank" rel="noopener">Fermat’s 4n+1 Theorem</a></p><p><a href="https://www.math.uchicago.edu/~may/VIGRE/VIGRE2008/REUPapers/Bhaskar.pdf" target="_blank" rel="noopener">SUM OF TWO SQUARES</a></p>]]></content>
      
      
      <categories>
          
          <category> Project Euler </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pe </tag>
            
            <tag> project euler </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF 1556 F 图，互斥拆分，bitmap枚举子集，概率论</title>
      <link href="/Blog/2021-09-03-cf1556F/"/>
      <url>/Blog/2021-09-03-cf1556F/</url>
      
        <content type="html"><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p><a href="https://codeforces.com/contest/1556/problem/F" target="_blank" rel="noopener">https://codeforces.com/contest/1556/problem/F</a></p><p>比赛n个队伍$(n\leq 14)$</p><p>第i个队伍有个$a_i(1\leq a_i \leq 10^6)$</p><p>i队和j队打，分别的获胜概率为$\frac{a_i}{a_i+a_j}$ 和 $\frac{a_j}{a_i+a_j}$</p><p>任意两个队之间打且仅打一场</p><p>如果 i直接战胜j 或者 间接战胜 i 战胜 ? 战胜 ? 战胜 j ，都算战胜j, （也就意味着 i战胜了j，j也同时战胜了i）</p><p>如果一个队战胜了其它所有队，那么它是winnner</p><p>求winner个数的期望值($\mod 10^9+7$ 意义下)</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="我的初步思路"><a href="#我的初步思路" class="headerlink" title="我的初步思路"></a>我的初步思路</h2><p>抽象成数据结构</p><p>n个点，任意两点之间有且仅有一条有向边，有向边的方向通过上述概率决定，求能走到所有点的点的个数期望值</p><p>边数 最大 $\frac{14 \cdot 13}{2} = 91$</p><p>如果一点是winner，那么进入该点的都是winner</p><p>如果一系列点构成环，那么它们要么同时是 winnner，要么同时不是winnner</p><p>单winnner 存在一个点入度为0，其它点入度全大于0，剩余点的边无论怎么排，都是单winner</p><p>双winner 不可能， 因为 两点互相能到，任意两点之间直连是仅有一条的单向边，路径上必定有其它的点，那么其它的点也是winner，必定多余2个winner</p><p>三winner 同双winner的互相可达原理，和可达路径上的点也是winner的原理，三个winner 构成环，且3个winner以外的边和它们连接全是出度，没有入度，同样剩余点的边无论怎么排都是3winner</p><p>同理</p><p>m个winner，意味着，这m个两两可达，且对m个以外的边全是出度</p><p>期望来了，</p><p>每次选m个点，让它们两两可达的概率和所有其它边是出度的概率 * m 再求和</p><p>其它边都是出度的概率好求</p><p><code>n=14</code> 枚举点的话，也只有 $2^{14} = 16384$</p><p>那么问题变成了，给定m个点，求其内部两两可达的概率</p><p>和上面类似的，如果 A -&gt; B, 那么如果B能到 其它所有，无论A的剩余边怎么连都是A也能到其它所有，且显然 B -&gt; A还有一条非直连的简单路径</p><p>但这只是保证了A,B两个点，并不是两两可达</p><h2 id="剩余"><a href="#剩余" class="headerlink" title="剩余"></a>剩余</h2><p>首先官方题解的拆分是一样的， 也是聚集到如何计算 P(winnners)</p><p>这里容斥 + 切</p><p>也就是 在winnners中选取集合subs, 集合中两两可达</p><p>subs 中所有向 $ winnners - subs$ 都是胜利的方案，这样保证了这些都是两两可达的。 这里需要证明能覆盖所有非两两可达，因为如果不是所有两两可达，那么对其中局部两两可达的进行缩点，缩点后，整个拓扑有序的，所以能找到一条切割方案， 让一侧战胜另一侧,源点两两可达（因为所有点之间都有有向路径，不可能存在多余一个的0入度的点，所以至多一个无入度的点，那么这个点缩点前就是subs）,所以上面的是充要的</p><p>下面证明，不同subs选取的互斥性</p><p>对于同一个winnners， subs0 和 subs1 的点选取不同，则至少有一个点，在且仅在其中一个集合中，那么subs0 和 subs1 中的能到subs的点集已经不同了，那么subs0和subs1 不会重复</p><p>所以 这里说是容斥，但是实际上，是选取的互斥，又全覆盖的划分</p><p>P(集合) = 集合中两两可达的概率</p><p>G(集合A,集合B) = 集合A 任何人，战胜 集合B 所有人的概率 （切的概率）</p><p>F(集合) = 仅集合内全是winners（集合外全不是winnners）的概率</p><p>ALL 所有人</p><p>$|集合| = 集合大小$</p><p>$答案 = sum( F(winners) * |winnners|)$ 概率乘值，期望公式</p><p>$F(winners) = P(winnners) \cdot G(winnners, ALL - winnners)$ 上面的结论，winnners 打败所有非winners</p><p>$P(winners) = 1 - sum ( P(sub) \cdot G(sub, winnners - sub) )$ 上面的互斥拆分</p><p>G 没啥好说，就是切上</p><p>$G(X,Y) =  \prod_{\forall x\in X, \forall y \in Y} \frac{a_x}{a_x+a_y}$</p><h2 id="公式递推起来似乎可以做了"><a href="#公式递推起来似乎可以做了" class="headerlink" title="公式递推起来似乎可以做了"></a>公式递推起来似乎可以做了</h2><p>然而，状态看起来有 $(2^n)^2$ 个，还不包括状态等，超界了</p><p>$G(X,Y) = \prod_{\forall x \in X} (\prod_{\forall y \in Y \frac{a_x}{ax+a_y}})$ </p><p>于是对于每个x,我们可以 $O(2^n)$ 计算，所有的x对于不同的Y,可以 $O(n 2^n)$计算出</p><p>那么对于一个给定$G$可以 O(n) 计算出</p><p>没太懂，这里$G_{sidefrom,sideto}$ 是怎么回事</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>这里我想的有问题, 没有正确估计到复杂度，</p><p>虽然是枚举 i去算集合,sub 是i的子集，但是 复杂度并不是$O(2^n \cdot 2^n \cdot n)$ , 分别是 i,sub,和G(sub,i-sub);</p><p>下面次数也是大概，没有那么准确，比如空和全没有排除</p><p>sub 的个数 $\sum_{i=1}^n C_i^n \cdot 2^i$</p><p>G内部计算次数 $\sum_{i=1}^n C_i^n \cdot \sum_{j=1}^{i} C_j^i \cdot j = 3^{n-1} \cdot n$, n = 14 时表达式的值为 $3^{13} \cdot 14 = 22320522$</p><p>证明见<a href="https://www.wolframalpha.com/input/?i=sum+%28n%21%2F%28i%21+*+%28n-i%29%21%29+*+%28sum+%28+i%21%2F%28j%21+*+%28i-j%29%21%29+*+j+%29%2Cj%3D1+to+i+%29+%29%2C+i+%3D+1+to+n" target="_blank" rel="noopener">wolframalpha</a> 或下方</p><p>当然通过代码cnt++也可以统计</p><pre><code>n = 14i = 16383cross = 4766585cross ret = 22320522  </code></pre><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 1000000007#define rep(i,a,n) for (ll i=a;i&lt;n;i++)#define per(i,a,n) for (ll i=n-1;i&gt;=a;i--)#define pb push_back// 末尾零的个数#define ctz __builtin_ctz#define popc __builtin_popcountconst int N = 16, N2 = 16400; // 2**14=16384int n;int a[N];ll G[N][N]; // G[i][j] = a[i]/(a[i]+a[j])ll cr[N][N2]; // [点][bit mask state]ll prob[N2];ll PowerMOD(ll a, int n, ll c = 1) {  for (; n; n &gt;&gt;= 1, a = a * a % MOD)    if (n &amp; 1) c = c * a % MOD;  return c;}// 点集A战胜点集B,O(n)int cross(int A, int B) {  ll ret = 1;  // 每次去掉A的最后一个1  for (; A; A &amp;= A - 1) {    ret = ret * cr[ctz(A)][B] % MOD;  }  return ret;}int main() {  ll ans = 0;  cin &gt;&gt; n;  int ALL = ~(-1 &lt;&lt; n);  rep(i,0,n){    scanf(&quot;%d&quot;,a+i);  }  // G[i][j] = a[i]/(a[i]+a[j])  // 没有特殊处理 i == j  rep(i,0,n){    rep(j,0,n){      G[i][j] = PowerMOD(a[i] + a[j], MOD - 2, a[i]);    }  }  // O(n * 2^n) , 每个点i，战胜点集合j(bit mask)  // 没有特殊处理 i \in j 之后计算不会使用即可  rep(i,0,n){    cr[i][0] = 1;    rep(j,1,ALL+1){      cr[i][j] = cr[i][j &amp; (j - 1)] * G[i][ctz(j)] % MOD;    }  }  // ans = sum{ |popc(i)| * prob[i]         * cross(i,j) }  //             winner数   winner内部互连    winnner战胜非winner  //  // prob[i] = 1 - sum { prob(sub) * cross(sub, i - sub)  }  // 次数  // n = 14  // i = 16383  // cross = 4766585  // cross ret = 22320522  rep(i,1,ALL+1){    prob[i] = 1;    // 这里对 i 的 子集全枚举    for (int j = i &amp; (i - 1); j; j = (j - 1) &amp; i){      (prob[i] -= prob[j] * cross(j, i - j)) %= MOD;    }    (ans += prob[i] * cross(i, ALL - i) % MOD * popc(i)) %= MOD;  }  printf(&quot;%lld\n&quot;, (ans+MOD) % MOD );  return 0;}</code></pre><h1 id="附"><a href="#附" class="headerlink" title="附"></a>附</h1><p>$\sum_{i=1}^n C_i^n \cdot \sum_{j=1}^{i} C_j^i \cdot j $</p><p>= $\sum_{i=1}^n \frac{n!}{i!(n-i)!} \cdot \sum_{j=1}^{i}  \frac{i!}{j!(i-j)!} \cdot j $</p><p>= $\sum_{i=1}^n \frac{n!}{i!(n-i)!} \cdot \sum_{j=1}^{i}  \frac{(i-1)!}{(j-1)!(i-j)!} \cdot i $</p><p>= $n \cdot \sum_{i=1}^n \frac{(n-1)!}{(i-1)!(n-i)!} \cdot \sum_{j=1}^{i}  \frac{(i-1)!}{(j-1)!(i-j)!} $</p><p>= $n \cdot \sum_{i=0}^{n-1} C_{i}^{n-1} \cdot \sum_{j=0}^{i-1} C_{j}^{i-1} $</p><p>= $n \cdot \sum_{i=0}^{n-1} C_{i}^{n-1} \cdot (1+1)^{i-1}$</p><p>= $n \cdot \sum_{i=0}^{n-1} C_{i}^{n-1} \cdot 2^{i-1}$</p><p>= $n \cdot (1+2)^{n-1}$</p><p>= $n \cdot 3^{n-1}$</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>看到14，12，20这类数，能一下向bit想，是习惯</li><li>互斥拆分还需要多练习增加经验</li><li>高效内置库，末尾0个数，所有1个数<code>#define ctz __builtin_ctz</code>,<code>#define popc __builtin_popcount</code></li><li>乘 除 模 同优先级能省掉部分括号 加快代码编写</li><li>bit 子集枚举 <code>for (int j = i &amp; (i - 1); j; j = (j - 1) &amp; i){</code></li><li>clang overflow 提示 开关 <a href="https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html" target="_blank" rel="noopener">https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html</a></li></ol><h1 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h1><p><a href="https://codeforces.com/blog/entry/94384" target="_blank" rel="noopener">官方题解</a></p><p><a href="https://codeforces.com/contest/1556/submission/127359868" target="_blank" rel="noopener">yhx-12243 code</a></p>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
            <tag> 图，互斥拆分，bitmap枚举子集，概率论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF 1558 B(dp优化) D(插入排序 反向 组合数 树状数组) E(二分 图论 数学 bfs)</title>
      <link href="/Blog/2021-08-25-cf1558BDE/"/>
      <url>/Blog/2021-08-25-cf1558BDE/</url>
      
        <content type="html"><![CDATA[<h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p><code>n &lt;= 4e6, 1e8&lt;mod&lt;1e9, mod is prime, 时间6s，内存128MB</code></p><p>$f(1) = 1$</p><p>$f(x) = \sum_{y=1}^{x-1}f(y) + \sum_{z=2}^{x}f(\lfloor \frac{x}{z} \rfloor)$</p><p>给定n和mod, 求f(x)%mod</p><h2 id="先看时间复杂度"><a href="#先看时间复杂度" class="headerlink" title="先看时间复杂度"></a>先看时间复杂度</h2><p>虽然题目给了6s, 但是 这里n已经是4e6了</p><p>显然左边可以前缀和</p><p>$ f(x) = presumf(x-1) + \sum_{z=2}^{x}f(\lfloor \frac{x}{z} \rfloor)$</p><p>左边 O(1)了</p><p>右边，注意到$\lfloor \frac{x}{z} \rfloor$ 的取值个数是$O(\sqrt{n})$ 的</p><p>这一块即使用了连续段的优化依然整个是$O(n^{1.5})$的复杂度</p><h2 id="剩余我没想到的题解部分"><a href="#剩余我没想到的题解部分" class="headerlink" title="剩余我没想到的题解部分"></a>剩余我没想到的题解部分</h2><p>考虑 S(x+1) 和 S(x) 的差别</p><p>对于加法，多一个 S(x+1-1 = x),</p><p>对于除法，多一个 S((x+1)/(x+1) = 1)</p><p>对于 i &gt; 1, 可能 S(x+1) 中是 S(i) 而 S(x)中是 S(i-1)</p><p>举例</p><pre><code>10:的除序列5,3,2,2,1,1,1,1,111:的除序列5,3,2,2,1,1,1,1,1,1(多)12:的除序列6(变),4(变),3(变),2,2(变),1,1,1,1,1,1(多)</code></pre><p>$\lfloor \frac{x+1}{i} \rfloor \neq \lfloor \frac{x}{i} \rfloor $ , 原始值变化为$\frac{1}{i} \leq 1$</p><p>$\lfloor \frac{x+1}{i} \rfloor = 1 + \lfloor \frac{x}{i} \rfloor $</p><p>$\frac{1}{i}$ 的增加在跨越一个整数时必定是整数</p><p>$ x+1 = ki $</p><p>所以 $i$ 是 x的约数时才会变</p><p>约数看成倍数, 计算到x时 -&gt; diff[kx] += f[x]-f[x-1]</p><p>直接 变成递推，时间$O(n \log n)$, 空间$O(n)$</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><p><a href="https://codeforces.com/contest/1558/submission/126928497" target="_blank" rel="noopener">on codeforces</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (int i=a;i&lt;n;i++)int n;ll MOD;// 计算之前的是结果，之后的是差异ll f[4000010];int main(){    cin&gt;&gt;n&gt;&gt;MOD;    f[1] = 1;    rep(i,2,n+1){        if(i == 2){            // 特殊 没有第一个 f[i-1]            f[i] = 2;        }else{            (f[i] += f[i-1] + (f[i-1] + f[1]))%=MOD;        }        rep(j,2,n+1){            ll ij=i*j;            if(ij &gt; n)break;            (f[ij] += f[i]-f[i-1])%=MOD;        }    }    printf(&quot;%lld\n&quot;,(f[n]+MOD)%MOD);    return 0;}</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关键点在 直接换个思路，换成计算差异，然后这里的差异能从 整数部分不同推导到 刚好是约数时会变，从而就能完成效率优化</p><h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>t &lt;= 1e5 组测试</p><p>每组</p><p>0 &lt;= m &lt; n &lt;= 2e5</p><p>所有组m保证 sum{m} &lt;= 2e5, 不对n有相应保证</p><p>每次是长度为n的数组(不提供具体值)，告诉你m个操作，每次操作x,y (y &lt; x) ，意思是把位置在x移动到y(一次插入排序的操作,也就是 y 是 最大的插入位置)</p><p>例如</p><p>1 2 3 2</p><p>如果把 最后一个2 ，可以插入在2前，也可以是3前，这里只能选择3前, 所以给的(x y)是 (4 3)</p><p>问原始序列所有值在[1~n]之间的合法方案数, MOD 998244353</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先 n 不限制，那么可能会有离散化相关的内容</p><p>假设序列开始是[a0 a1 a2 …] 那么根据m次操作，有唯一的移动结果,因为每次都指定的x和y</p><p>对于移动以后，必定 非严格单调递增</p><p>那么问题变成了两个，找到可能一样的值的组（通过能确定的不一样的值做切分），这些组如何得到答案</p><h3 id="换个计数法"><a href="#换个计数法" class="headerlink" title="换个计数法"></a>换个计数法</h3><p>令c表示，在最终序列中,相邻值“一定不同”的个数（也就是有c个小于号(来源交换推导出的大小关系)）,而最终序列中剩余的相邻的位置，可能相同可能不同</p><p>那么把这c个一定不同的位置-1，变成了 所有相邻位置可能相同可能小于， 范围由n变为了n-c</p><p>也就是 n个数，范围在[1~ n-c]中，非严格单调递增的方案数</p><p>也就是 n 个相同的球，放入 n-c 个不同盒子中（可以空盒子）</p><p>也就是 n+n-c 个相同的球，放入 n-c 个不同盒子中（不能空盒子）</p><p>挡板法,有 2n-c-1 个间隙</p><p>显然方案数 C(2n-1-c,n)</p><p>也就有了，如果能的到c就能得到答案</p><h3 id="计算必定小于个数"><a href="#计算必定小于个数" class="headerlink" title="计算必定小于个数"></a>计算必定小于个数</h3><p>离线+倒序</p><p>维护一个位置集合S,初始含有1到n</p><p>按照插入的倒序，(知道xi是单调递减的)</p><p>对于(xi,yi),</p><pre><code>// 操作前 （反向操作会让 [xi~n]这部分之后再也不会使用）[1....yi-1][yi...xi-1][xi][xi+1...n]// 操作后[1....yi-1][xi][yi...xi-1][xi+1...n]// 因为我们是反向操作，所以 关注的是这两个            !   !                                p   q                    </code></pre><p>p = S中第yi小的</p><p>q = S中第yi+1小的</p><p>标记q是 前面相邻被拆入过值的,然后删除p (因为xi是单调递减，xi 到n，在倒序处理过程中，都不再回用到，和把p变成n+1一样效果</p><p>而找第k小和移除一个数，这种可以通过线段树，树状数组来完成</p><h3 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h3><p>注意到不要做成 O(n log n), 要是O(m log n), 一个办法是，首次建立足够大的树状数组/线段树。 每轮询问结束后，再回滚，这样建树 O( max n ), 操作都是 O ( m log n )</p><p>这样 算法+效率问题都解决了</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="狗都不手写平衡树"><a href="#狗都不手写平衡树" class="headerlink" title="狗都不手写平衡树"></a>狗都不手写平衡树</h3><p>倒序+树状数组+二分法查找第k大+组合数</p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 998244353#define rep(i,a,n) for (ll i=a;i&lt;n;i++)#define per(i,a,n) for (ll i=n-1;i&gt;=a;i--)#define pb push_backconst double pi = acos(-1.0);const int N = 400000;ll fac[N+10];ll pwr(ll v,ll mi){  ll r =1;  while(mi){    if(mi%2) (r*=v)%=MOD;    (v*=v)%=MOD;    mi/=2;  }  return r;}ll inv(ll v){  return pwr(v,MOD-2);}ll C(ll n,ll m){  return (((fac[n]*inv(fac[m]))%MOD)*inv(fac[n-m]))%MOD;}int n,m;ll ta [2*N+10];ll lowbit(ll v){  return v &amp; -v;}void tinit(){  rep(i,1,2*N+1){    ta[i] = lowbit(i);  }}void tadd(int i,int v){  for(;i &lt; 2*N+1;i+=lowbit(i)){    ta[i] += v;  }}ll tpre(int i){  ll s = 0;  for(;i!=0;i-=lowbit(i)){    s+=ta[i];  }  return s;}ll getk(int k){  ll l = 0;  ll r = N+1;  while(l+1 &lt; r){    int mid = (l+r)/2;    ll p = tpre(mid) ;    if(p&gt;=k)r=mid;    else l=mid;  }  return r;}ll getc(vector&lt;int&gt;&amp;ys){  set&lt;int&gt; used ;  vector&lt;int&gt; rm;  per(i,0,m){    int y = ys[i];    used.insert(getk(y+1));    int rmi = getk(y);    rm.pb(rmi);    tadd(rmi,-1);  }  int r = used.size();  per(i,0,m){    tadd(rm[i],1);  }  return r;}int main(){  fac[0]=1;  rep(i,1,N+1){    fac[i] = (fac[i-1]*i)%MOD;  }  tinit();  int t;  cin&gt;&gt;t;  while(t--){    vector&lt;int&gt; ys;    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);    rep(i,0,m){      int x,y;      scanf(&quot;%d %d&quot;,&amp;x,&amp;y);      ys.pb(y);    }    ll c= getc(ys);    printf(&quot;%lld\n&quot;,C(2*n-c-1,n));  }  return 0;}</code></pre><h2 id="Ext"><a href="#Ext" class="headerlink" title="Ext"></a>Ext</h2><h3 id="pbds"><a href="#pbds" class="headerlink" title="pbds"></a>pbds</h3><p>对于 题解提到的 Policy-Based Data Structures 见下面洛谷日报，总之是在std以外，c++的一个扩展库里提供了对应的平衡树实现，可以不用自己去写平衡树</p><h3 id="Rope"><a href="#Rope" class="headerlink" title="Rope"></a>Rope</h3><pre><code>#include&lt;ext/rope&gt;using namespace __gnu_cxx;</code></pre><pre><code class="c++">rope&lt;变量类型&gt;变量名称;</code></pre><p>简单来说 rope是个超级string 内部实现平衡树，也就是可以不用上面的所有知识，直接正着做XD, 本意可能是用作巨大文本编辑时使用</p><p><code>crope = rope&lt;char&gt;</code></p><p><a href="https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/ext/rope" target="_blank" rel="noopener">https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/ext/rope</a></p><p>复杂度 看<a href="https://www.geeksforgeeks.org/stl-ropes-in-c/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/stl-ropes-in-c/</a> 里说 操作都是log，所以总的复杂度应该是 m log n</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://codeforces.com/blog/entry/94216" target="_blank" rel="noopener">官方题解</a></p><p><a href="https://www.luogu.com.cn/blog/Chanis/gnu-pbds" target="_blank" rel="noopener">洛谷日报39期 pbds</a></p><p><a href="https://gcc.gnu.org/onlinedocs/libstdc++/ext/pb_ds/" target="_blank" rel="noopener">gnu online doc pbds</a></p><h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>无向连通图</p><p>保证每点出度大于2</p><p>无自环和重边</p><p>点&lt;=1000</p><p>边&lt;=2000</p><p>每个点有 1&lt;= a[i],b[i] &lt;= 1e9</p><p>初始值x, 从点1出发, 每次首次经过一个点，需要满足 当前x &gt; a[i],首次经过该点后会 x+=b[i]</p><p>可以重复走边走点</p><p>额外限制，走完一条边以后不能<em>立刻</em>重走该边, 也就是不能 <code>a-&gt;b-&gt;a</code></p><p>求能够经过所有点的最小的x</p><p>每次100组测试，每次 测试内容的 sum{n}&lt;=1000 sum{m}&lt;=2000</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>显然，x单调递增，也就是如果我们能超过最大点，则所有点都能走，那么x的下界是 <code>max{最大a点的a-sum{其它b},1点相邻点的最小a}+1</code></p><p>上界 直接最大值+1</p><p>所以如果给定一个值，我们能校验其合法性的话， 那么可以二分 [既然是2分了，其实不考虑上下界 直接[1~1e9+1]开始二分也行]</p><p>定义set表示已经访问过的集合, 我们找寻两种增广路径</p><ol><li><p>到set以外的一些点的简单路径，并返回到set中， set中的点a-&gt;out-&gt;out-&gt;out…-&gt;set中的点b,我们把这些out的点加入到set中。注意因为首先我们知道set中的点任意两点至少有一条简单路径，现在能通过外部建立一条简单路径，那么必定可以仅在set中任意的行走，走到任意的点, 对于点a点b是同一个点，就更显然，我们有一个环，能在set中走环上任意点，然后即可走到set上任意点</p></li><li><p>不一定返回原来的set中，但是能在外部走成环 set中的点-&gt;out-&gt;out-&gt;out-&gt;out中出现过的点, 同上加入set中，我们又可达任意的点</p></li></ol><p>以上两种都解决了不能立刻原路返回的限制</p><p>上面两种是必要的方法，但是充分性需要证明一下，也就是没有其它的方案</p><p>如果从set中走出，无法达成上面两种，则所有出走都是死路，因为连通性和度保证不会因为边的路径限制而是死路，只会因为 不能立刻回头+a[i] 的限制而成死路，因为每走一步，既不成环也不回到set，那么out没走过的必然-1，数量离散有下界，单调递减，必有界，</p><p>证明如果全是死路，则当前set无法完成，如果全是死路，则所有路径均不会消耗所有点，且无法扩展，出走后无法行走，如果消耗完所有点，那么说明x比所有a都打，必定可以成环矛盾</p><p>再证 每次增广的顺序不会影响，初始set，</p><p>对于一个可行的x和可行的增广顺序，显然x单调递增，如果有不同的方案导致死路，那么死路前的set，可以按照合法的增广顺序操作，每一次操作的x值都大于等于 原合法顺序的值，必定可行，所以增广的顺序和初始x值是否可行没有关系, </p><p>同时 一个 set的 <code>最终x = sum{b}+初始x</code></p><p>那么问题就变成</p><p>对于给定的x，通过上述两种方案增广直到全覆盖，或者全死路为止</p><p>O(效率 log(max(a)))</p><p>那么 v-&gt;out-&gt;out-&gt;u(out) ，记录到u的时x的值 , 那么如果有另一条路径 到达u,两条路径中大x的值向小x值走动,那么可以和它构成环, 所以dfs即可</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>暴力bfs过了，没缩点 时间复杂度， 每次 bfs( O(m+n) ), 增广次数O(n), 所以 总时间复杂度 O(n(m+n)log(max(a)))</p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define t3 1000+10#define t4 10000+10#define t5 100000+10#define t6 1000000+10#define MOD 1000000007#define rep(i,a,n) for (ll i=a;i&lt;n;i++)#define per(i,a,n) for (ll i=n-1;i&gt;=a;i--)#define pb push_backconst double pi = acos(-1.0);int n,m;ll a[1010];ll b[1010];vector&lt;int&gt; p2[1010];vector&lt;ll&gt; get_circle(ll x ,vector&lt;ll&gt; &amp; vis, vector&lt;ll&gt; bfs){  vector&lt;ll&gt; cur = vector(1010,(ll)0);  vector&lt;ll&gt; fa = vector(1010,(ll)0);  int st = 0;  while(st &lt; bfs.size()){    int p = bfs[st];    for(auto item:p2[p]){      if(item == fa[p])continue; // 不能立即返回      // item set 内      if(vis[item]){        // p set 内        if(vis[p]){          continue;        }        vector&lt;ll&gt; ret ;        while(p &amp;&amp; !vis[p]){          ret.pb(p);          p = fa[p];        }        assert(ret.size());        return ret;      }      // item非set内      if(cur[item] != 0){ // 访问过        // p-&gt;item &lt;- old        // 这个比较有必要吗，因为 cur[x] &gt; a[x] 是肯定的, 所以最小值一定在a中出现，必定至少成立一个不等式        // if(cur[item] &gt; a[p] // old-&gt;item -&gt; p -&gt; ...        //   || max(cur[p],x) &gt; a[item]) { // p-&gt;item -&gt; old          vector&lt;ll&gt; ret ;          while(p &amp;&amp; !vis[p]){            ret.pb(p);            p = fa[p];          }          p = item;          while(p &amp;&amp; !vis[p]){            ret.pb(p);            p = fa[p];          }          assert(ret.size());          return ret;        // }      }else{        // 未访问过 且可达        if( max(cur[p],x) &gt; a[item] ){          bfs.pb(item);          cur[item] = max(cur[p],x) + b[item];          fa[item] = p;        }      }    }    st++;  }  return {};}bool test(ll startx){  vector&lt;ll&gt; vis = vector(1010,(ll)0);  vector&lt;ll&gt; s; // set 中的点  s.pb(1);  vis[1] =  1;  int cnt = 1;  while(true){    auto r = get_circle(startx, vis,s);    if(!r.size()){      return false;    }    for(auto item:r){      if(!vis[item]){        // TODO 缩点        vis[item] = 1;        s.pb(item);        cnt++;        startx += b[item];      }    }    if(cnt == n){      return true;    }  }}int main(){  int t;  cin&gt;&gt;t;  while(t--){    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);    rep(i,2,n+1){      scanf(&quot;%lld&quot;,a+i);    }    rep(i,2,n+1){      scanf(&quot;%lld&quot;,b+i);    }    rep(i,0,m){      int u,v;      scanf(&quot;%d %d&quot;,&amp;u,&amp;v);      p2[u].pb(v);      p2[v].pb(u);    }    ll l = 0;    ll r = 1&#39;000&#39;000&#39;001;    while(l+1 &lt; r){      ll mid = (l+r)/2;      if(test(mid)){        // printf(&quot;%lld ok\n&quot;,mid);        r = mid;      }else{        // printf(&quot;%lld not ok\n&quot;,mid);        l = mid;      }    }    printf(&quot;%lld\n&quot;,r);    // clear;    rep(i,1,n+1){      p2[i] = {};    }  }  return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分 </tag>
            
            <tag> bfs </tag>
            
            <tag> 数学 </tag>
            
            <tag> dp优化 </tag>
            
            <tag> 插入排序 </tag>
            
            <tag> 组合数 </tag>
            
            <tag> 树状数组 </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>百度之星2021 复赛1002题 (第二类斯特林数)</title>
      <link href="/Blog/2021-08-23-bestcoder2021_1002/"/>
      <url>/Blog/2021-08-23-bestcoder2021_1002/</url>
      
        <content type="html"><![CDATA[<h1 id="痛失1002只过了1001签到题"><a href="#痛失1002只过了1001签到题" class="headerlink" title="痛失1002只过了1001签到题"></a>痛失1002只过了1001签到题</h1><p>武装自己的应该是知识,而不是一堆废铜烂铁——卡尔</p><h1 id="虽然凭空推出过一些定理，但多数定理还是难以凭空推出的-QAQ"><a href="#虽然凭空推出过一些定理，但多数定理还是难以凭空推出的-QAQ" class="headerlink" title="虽然凭空推出过一些定理，但多数定理还是难以凭空推出的 QAQ"></a>虽然凭空推出过一些定理，但多数定理还是难以凭空推出的 QAQ</h1><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7095" target="_blank" rel="noopener">https://acm.hdu.edu.cn/showproblem.php?pid=7095</a></p><p>题意</p><p>1e4组测试</p><p>每组测试给定(n,m &lt;= 3k)</p><p>一个x，n个加法$+a_1,+a_2,…,+a_n$, $ \cdot b_1,\cdot b_2,\cdot b_m$，m个乘法</p><p>任意排列它们，计算从左向右，无优先级</p><p>如果 任意变量，两个表达式值都相同，那么两个表达式本质相同</p><p>求本质不同的方案数</p><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>如2加1乘(注意无优先级从左向右算)</p><p>$x+a_1 + a_2 \cdot b_1 $</p><p>$x+a_1 \cdot b_1 + a_2 $</p><p>$x+a_2 \cdot b_1 + a_1 $</p><p>$x \cdot b_1 +a_1 + a_2 $</p><p>一共4种</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>a和b间隔，</p><p>那么他们数量差不大于1</p><p>对于a分为k组，方案数</p><p>$f(a,k) * (f(b,k-1)+2f(b,k)+f(b,k+1))$</p><p>如果能线性算出 $f(a,b)$ 那么就能在时间内算出</p><h1 id="问题变成了，把n个数拆分成k个非空集合的方案数如何算"><a href="#问题变成了，把n个数拆分成k个非空集合的方案数如何算" class="headerlink" title="问题变成了，把n个数拆分成k个非空集合的方案数如何算"></a>问题变成了，把n个数拆分成k个非空集合的方案数如何算</h1><p>这就是我卡住尝试自己想，但未想出方案(oi wiki都还没人加上这个)</p><h1 id="第二类斯特林数"><a href="#第二类斯特林数" class="headerlink" title="第二类斯特林数"></a>第二类斯特林数</h1><p>S(n,m) 表示把n个不同的小球放在m个相同的盒子里（且每个盒子至少一个）方案数</p><p>第一个球 单独在一个盒子里 S(n,m)+=S(n-1,m-1)</p><p>第一个球不单独放，那就是剩余放完以后，其中一个盒子中再放入1，对于所有剩余放完后，都有m种选法S(n,m)+=mS(n-1,m)</p><p>所以</p><p>S(n,m) = S(n-1,m-1) + mS(n-1,m)</p><p>这样我们可以直接初始化完整个S</p><h1 id="回到原题"><a href="#回到原题" class="headerlink" title="回到原题"></a>回到原题</h1><p>因为 原题还是有序</p><p>上面的S是无序的，所以 每次 S(n,m) 乘上 <code>n!</code> 就行</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code class="cplusplus">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define t3 1000+10#define t4 10000+10#define t5 100000+10#define t6 1000000+10#define MOD 1000000007#define rep(i,a,n) for (ll i=a;i&lt;n;i++)#define per(i,a,n) for (ll i=n-1;i&gt;=a;i--)#define pb push_backconst double pi = acos(-1.0);ll S[3010][3010];ll pwr[3010];ll f(ll a,ll b){    return (pwr[b]*S[a][b])%MOD;}void work(){    int n,m;    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);    if(n&gt;m)swap(n,m);    ll ans = 0;    rep(k,1,n+1){        (ans+= f(n,k) * (f(m,k-1) + 2*f(m,k)+f(m,k+1)))%=MOD;    }    printf(&quot;%lld\n&quot;,ans);}int main(){    S[1][1] = 1;    rep(i,2,3001){        rep(j,1,i+1){            (S[i][j] = S[i-1][j-1] + j * S[i-1][j])%=MOD;        }    }    pwr[0]=1;    rep(i,1,3001){        pwr[i] = (pwr[i-1]*i)%MOD;    }    int t;    cin&gt;&gt;t;    while(t--){        work();    }  return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> bestcoder </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
            <tag> bestcoder </tag>
            
            <tag> 第二类斯特林数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zeckendorf&#39;s theorem</title>
      <link href="/Blog/2021-07-29-zeckendorf/"/>
      <url>/Blog/2021-07-29-zeckendorf/</url>
      
        <content type="html"><![CDATA[<h1 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h1><p>任何正整数都可以唯一表示成不连续的Fibonacci数列和</p><h1 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h1><p>Finonacci数列, 以1，2开始, 每一项=前两项之和</p><h1 id="proof"><a href="#proof" class="headerlink" title="proof"></a>proof</h1><h2 id="可表示性"><a href="#可表示性" class="headerlink" title="可表示性"></a>可表示性</h2><p>对于任意自然数n</p><p>有唯一i使得 $fib(i) &lt;= n &lt; fib(i+1)$</p><p>说明 $fib(i) &gt; n/2 $ 否则 $fib(i+1) = fib(i)+fib(i-1) &lt; fib(i)+fib(i) = 2fib(i) &lt;= n$ 矛盾</p><p>$n-fib(i) &lt; n/2$</p><p>$n-fib(i) &lt; fib(i-1)$, 否则 $n &gt;= fib(i)+fib(i-1) = fib(i+1)$，保证了非连续</p><p>说明$f(n)$ 的表示通过拆除fib(i)方案数与 $f(n-fib(i))$ 一致，</p><p>所有都是唯一可递归下降，f(0) 唯一表示为空</p><p>所以所有都可以表示</p><h2 id="下面证明唯一表示"><a href="#下面证明唯一表示" class="headerlink" title="下面证明唯一表示"></a>下面证明唯一表示</h2><p>上面我们每次取得都是不大于n的最大的fib(i), 这种情况下非连续且可表示</p><p>下面证明如果不这样操作，则不可表示，就能证明其唯一性</p><p>$fib(i) &lt;= n &lt; fib(i+1)$</p><p>证明$fib(i-1)+fib(i-3)+fib(i-5)+… &lt; fib(i) &lt; n$</p><p>$1 + fib(i-1)+fib(i-3)+fib(i-5)+… = fib(i) $</p><p>$fib(i-1)+fib(i-3)+fib(i-5)+… = fib(i) - 1 &lt; fib(i) = n$</p><p>得到 如果不取$fib(i)$,那么最大的非连续和无法构成n，则唯一性得证</p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STOER-WAGNER 无源无汇最小割</title>
      <link href="/Blog/2021-07-27-stoer-wagner/"/>
      <url>/Blog/2021-07-27-stoer-wagner/</url>
      
        <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>一个无向联通图,应该要正边权?，最小割分成两个子图</p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><blockquote><p>引理</p></blockquote><p>图G中的两个点s,t,</p><p>如果最小割分割了它们，那么直接求s到t的最小割</p><p>如果没有，那么合并s-t，得到的新图G1 和原图的最小割一致</p><hr><p>因此有方法, 任意选择点a，加入集合A中</p><p>每次选择和A距离和最大的点加入集合中，也就是上面的合并操作</p><p>注意，这里每次都不是把图里的最大的边去掉，而是集合A距离最大的点加入A中</p><p>这样反复操作，一直到剩下3个点A,b,c ，可以得到一个割的值, 除了A以外的两个点b,c在这次分割中一定是被分开了的</p><p>我们也能得到一个b和c是被分割的值</p><hr><p>重新初始的图</p><p>合并 b和c成集合B</p><p>重复上面所有操作，直到剩余3个点，B,d,e</p><hr><p>重新初始的图</p><p>合并b,c成集合B, 合并d和e成集合D</p><p>重复上面所有操作，直到剩余3个点，?a,?b,?c,</p><p>我们能到到一个分割值，也能让下一轮的操作合并两个点</p><hr><p>这样我们最终所有操作中最小的分割就是答案</p><h1 id="Proof"><a href="#Proof" class="headerlink" title="Proof"></a>Proof</h1><p>对于 每一轮剩余3个点的时候，我们有该轮的初始集合S，和另外两点$p_1,p_2$</p><p>因为合并规则一直是与S距离最大的边，所以$p_1,p_2$ 一定是被分割的，</p><p>虽然因为边的长度可能在操作过程中相等，也就意味着在每一轮操作开始时，甚至$p_1,p_2$ 是哪两个点，是不确定的,(当然我们可以给所有点提前编号，保持即使值相等的点也有一定的偏序关系，来让结果唯一)</p><p>但是可以证明，对于每次计算到剩余3个点时，其中的$p_1,p_2$来说，当前图里面这是这两个点要切割的最小割</p><hr><p>我们把这轮的$(p_1,p_2)$ 命作$(s,t)$</p><p>对于给定图$G$，和通过上述步骤得到的$s,t$</p><blockquote><p>如果两个点之间没有相连，我们在数值上可以看做有一条相连权重为0的边,在下面的计算上没有影响(因为每次取得是最大的), 连通的判断时权重为0视为不连通</p></blockquote><p>割: 把原图分成两个联通块的边集</p><p>$C$是$G$上$s-t$的一个任意的割,即$s,t$在不同连通块</p><p>$CP$是按照上述步骤得到的$s-t$的割</p><p>$W(边集)$ = 边集的权重和</p><p>$W(点集A，点v)$ = $点v$到$点集A$中所有点的边权和</p><p>要证:$W(C) \ge W(CP)$</p><hr><p>对于上述给定流程$CP$，根据点加入的顺序，命名为$a_1,a_2,a_3…a_{n-1},a_n$, 其中$s = a_{n-1},t = a_n$</p><p>对于 $i$,如果$a_{&lt; i-1}$和$a_{i}$ 位于 割C的两侧,那么称为$i$为$active$的(简化后面描述)</p><ul><li>我们不用讨论$CP$，因为序列就是$CP$产生的，所有操作都是位于$CP$割的同一连通块</li></ul><p>点集 $A_i = 集合(a_1…a_{i-1}) $</p><blockquote><p>也就是$a_i$前面的点</p></blockquote><p>边集 $C_i = 集合(边|边的两端均属于集合(a_1…a_i)) ∩ C$ </p><blockquote><p>也就是割边中，端点都在前面$a_1..a_i$ 中</p></blockquote><p>我们要证明对于每一个$active$的$i$, $W(A_i, a_i) \le W(C_i)$, </p><blockquote><p>也就是$a_i$和它之前的点的边权和 小于 割$C$中的两端来自前$a_1 … a_i$的边权和</p></blockquote><p>接下来归纳开始 (归纳的目标和总目标一致)</p><p>初始: 若$i$是最小使得$active$的，那么$W(A_i,a_i) = W(C_i)$</p><blockquote><p>因为 说明 前面的边,按照割C，都在同一侧，所以$C_i$中所有的边，都一个顶点是$a_i$</p></blockquote><p>对于$i,j,(i &lt; j)$ 都是$active$相邻</p><blockquote><p>$i$和$j$是active, $i$和$j$之间没有其它$active$的,</p></blockquote><p>$W(A_j,a_j) = W(A_i,a_j) + W(A_j - A_i, a_j) $ </p><blockquote><p>直接的拆分点集$A_j$</p></blockquote><p>$\le W(C_i) + W(A_j - A_i, a_j) $ </p><blockquote><p>根据初始条件和归纳,$W(A_i,a_j)\le W(A_i,a_i) \le W(C_i)$ , 前一半不等式是操作过程中每次选最大距离的连通，后一部分是归纳</p></blockquote><p>$= W(C_j)$</p><blockquote><p>因为$i$和$j$之间没有其它$active$，所以也就是$i$和$j$之间的点不会与小于$j$的点构成属于$C_u$的边，<br>而对于$W(A_j-A_i,a_j)$的贡献，不会和$C_i$重复因为(不包含$a_j$),</p></blockquote><p>综上</p><p>$W(A_n,a_n) \le W(C_n) = W(C)$</p><blockquote><p>左边不等式是归纳的结果，右边是因为所有C中的边且两端的点在所有点中，就是$C$自己</p></blockquote><p>结论:</p><p>也就是说，对于图$G$的$s-t$任何的割$C$，都不小于$t$单独划分出来的边权和</p><p>所以这是一个最小分割</p><hr><p>回到操作过程</p><p>也就是每一轮，都能产生$s-t$分割的最小割，之后的轮次，$s$和$t$就在同一个“连通块”里了</p><p><strong>这里有一点</strong> 实际上再思考仔细一点，这个过程中其实并不满足题意(分成两个)，因为我们很可能把原图分割成了好几个连通块，也就是不止两个。但是因为如果能分割成多个，反向操作，每次最多把两个合成一个，必定最小割是分成两个的。所以得到的答案也一定是割, 保证了正确性</p><p>也就是你合并的s和t可能，它们还并不连通，只不过你从划分上认为属于一块了</p><hr><p>综上，算法正确性证毕</p><h1 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h1><p><a href="https://basics.sjtu.edu.cn/~dominik/teaching/2016-cs214/presentation-slides/2016-12-06-StoerWagner-BigNews.pdf" target="_blank" rel="noopener">https://basics.sjtu.edu.cn/~dominik/teaching/2016-cs214/presentation-slides/2016-12-06-StoerWagner-BigNews.pdf</a></p><p><a href="https://en.wikipedia.org/wiki/Stoer%E2%80%93Wagner_algorithm" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Stoer%E2%80%93Wagner_algorithm</a></p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>project euler 218 (别写代码用数学)</title>
      <link href="/Blog/2021-07-20-project-euler218/"/>
      <url>/Blog/2021-07-20-project-euler218/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="http://projecteuler.net/index.php?section=problems&amp;id=218" target="_blank" rel="noopener">原题链接</a></p><p>直角三角形$(a,b,c)$,其中$c$为斜边</p><p>perfect定义</p><ol><li>边互质$gcd(a,b) = 1$</li><li>斜边是平方数$c = x^2$</li></ol><p>super-perfect</p><ol><li>perfect</li><li>直角三角形面积是6和28的倍数</li></ol><p>求</p><p>$c \le 10^{16}$ 内,有多少perfect的不是super-perfect</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>前面的PE我们学习到，$gcd(a,b)=1$ 的直角三角形可以唯一表示成</p><p>$(a,b,c) = (m^2-n^2,2mn,m^2+n^2)$</p><p>其中两个直角边可以对换</p><p>其中 $gcd(m,n) = 1, (m+n) = 1 (\bmod 2)$</p><p>$lcm(6,28) = 84$</p><hr><p>简化成</p><p>$m^2+n^2 = c = x^2 \le 10^{16} $</p><p>求 $mn(m^2-n^2) != 0 (\bmod 84)$ 的个数</p><hr><p>注意到 这里又是一个直角三角形公式</p><p>$ordered(m,n,x) = ordered(2uv,u^2-v^2,u^2+v^2)$</p><hr><p>即</p><p>$u &gt; v, gcd(u,v) = 1, u+v = 1 (\bmod 2)$</p><p>$u^2+v^2 \le 10^{8}$</p><p>$ordered(m,n) = ordered(2uv,u^2-v^2) $</p><p>求 $mn(m^2-n^2) != 0 (\bmod 84)$ 的个数</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>直接翻译很好写了</p><pre><code class="python">perfect_but_not_super_perfect = 0def gcd(a,b):    if b == 0:        return a    return gcd(b,a%b)for v in range(1,10**4):    if v % 100 == 0:        print(&quot;b:&quot;, v)    for u in range(v+1,10**4,2):        if gcd(u,v) != 1:            continue        if u**2+v**2 &gt; 10**8:            break;        m,n = u**2-v**2,2*u*v        if n &gt; m:            m,n=n,m        if (m*n*(m**2-n**2)) % 84 != 0:            perfect_but_not_super_perfect += 1print(&quot;ans&quot;,perfect_but_not_super_perfect )</code></pre><p>时间</p><pre><code>real    0m30.195suser    0m30.195ssys     0m0.000s</code></pre><h1 id="不要到此为止-上数学"><a href="#不要到此为止-上数学" class="headerlink" title="不要到此为止 上数学"></a>不要到此为止 上数学</h1><p>就完了吗</p><p>它要是个长长的数字可能也没这篇文章了，因为PE的 one-minute rule 已经满足了</p><p>但是它的答案是0那就激起了推导的兴趣</p><h2 id="命题"><a href="#命题" class="headerlink" title="命题"></a>命题</h2><p>$u &gt; v, gcd(u,v) = 1, u+v = 1 (\bmod 2)$</p><p>$(m,n) = (2uv,u^2-v^2) $</p><p>则 $mn(m^2-n^2) = 0 (\bmod 84)$</p><p>这里我们没有范围限制，考虑模运算的性质，没有了大小顺序正负</p><h3 id="代入"><a href="#代入" class="headerlink" title="代入"></a>代入</h3><p>$2uv(u^2-v^2)(6u^2v^2-u^4-v^4) = 0 (\bmod 84)$</p><p>$uv(u^2-v^2)(6u^2v^2-u^4-v^4) = 0 (\bmod 42)$</p><p>$42 = 2 \cdot 3 \cdot 7$</p><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p>2 显然，因为$u+v=1(\bmod 2)$ , u 和 v一奇一偶</p><p>3 如果u和v其中有3的倍数，那么是3的倍数，如果均不是3的倍数,因为 $1^2=2^2=1 (\bmod 3)$ , 所以 $u^2-v^2 = 0 (\bmod 3)$</p><p>7 如果u和v其中有7的倍数，那么是7的倍数，否则都不是7的倍数，还是写一点代码</p><pre><code class="python">for u in range(1,7):    for v in range(1,7):        print(u,v,((u**2-v**2)*(6*u*u*v*v-u**4-v**4))%7)</code></pre><p>输出都是0 得证</p>]]></content>
      
      
      <categories>
          
          <category> Project Euler </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pe </tag>
            
            <tag> project euler </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>project euler 216 (质数判别)</title>
      <link href="/Blog/2021-06-12-project-euler216/"/>
      <url>/Blog/2021-06-12-project-euler216/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>1&lt;= n &lt;=50’000’000</p><p>求让 $2n^2-1$ 为质数的有多少</p><h1 id="尝试"><a href="#尝试" class="headerlink" title="尝试"></a>尝试</h1><h2 id="裸暴力"><a href="#裸暴力" class="headerlink" title="裸暴力"></a>裸暴力</h2><p>显然我们枚举n,然后每个计算到 $\sqrt{n}$, 时间复杂度$O(n^{1.5})$</p><p>在n取这么大,要大概一个小时, 显然不满足pe的期望1min</p><h2 id="优化1"><a href="#优化1" class="headerlink" title="优化1"></a>优化1</h2><p>显然如果 $ 2n^2-1 = 0 (\bmod b)$</p><p>那么有 $ 2(b+n)^2-1 = 0 (\bmod b)$, 且这是充要的</p><p>这有两个好的性质,并不要求$2n^2-1$是质数或者合数</p><p>对于给定b总能找到一个小于b的n</p><hr><p>看上去很美好,而实际操作上,也能降低一定的复杂度,不过这个方法空间要求很大,而上面的暴力是O(1)空间</p><p>其2每次进行筛的时候也不算快,也有不少重复筛的</p><h2 id="优化2"><a href="#优化2" class="headerlink" title="优化2"></a>优化2</h2><p>我们存不下$2n^2-1$的质数,但是可以预运算$\sqrt{2n^2-1}$的质数 进行一定的提速</p><h1 id="如何判断质数"><a href="#如何判断质数" class="headerlink" title="如何判断质数"></a>如何判断质数</h1><h2 id="Level-1"><a href="#Level-1" class="headerlink" title="Level 1"></a>Level 1</h2><p>裸暴力,从2到开根</p><h2 id="Level-2"><a href="#Level-2" class="headerlink" title="Level 2"></a>Level 2</h2><p>众所周知 费马小定理$a^{p-1} = 1 (\bmod p), gcd(a,p) = 1$</p><p>当然这个表达式 p是质数一定成立,但是成立并不一定是质数</p><h2 id="Level-3"><a href="#Level-3" class="headerlink" title="Level 3"></a>Level 3</h2><p>尝试多个a的费马小定理,</p><p>依然是”概率”运气的判断,</p><p>依然可能表达式成立,但p不是质数</p><h2 id="Level-4-Miller-Rabin"><a href="#Level-4-Miller-Rabin" class="headerlink" title="Level 4 Miller-Rabin"></a>Level 4 Miller-Rabin</h2><p>把费马小定理的$p-1$拆解成$p-1 = 2^k (2m+1), m\ge 0$</p><p>也就是 2幂次和奇数的乘积</p><p>如果p是质数,我们有 $2^{2^k(2m+1)} = 1 (\bmod p)$</p><p>也就是 $2^{2^{k-1}(2m+1)} = \pm 1 (\bmod p)$</p><p>如果 $2^{2^{k-1}(2m+1)} = 1 (\bmod p)$</p><p>那么 $2^{2^{k-2}(2m+1)} = \pm 1 (\bmod p)$</p><p>同样,我们可以尝试多个a</p><p>这样的话”运气”能好很多,本身还是概率的做法</p><h2 id="Level-5"><a href="#Level-5" class="headerlink" title="Level 5"></a>Level 5</h2><p><a href="http://miller-rabin.appspot.com/" target="_blank" rel="noopener">http://miller-rabin.appspot.com/</a></p><p>我们用别人的答案!</p><p>Jim Sinclair证明了如果a的取值把下面都测试一遍,那么在 $p&lt;2^{64}$时,都是能判断质数的!</p><p>2, 325, 9375, 28178, 450775, 9780504, 1795265022</p><p>还是Miller-Rabin,不过我们使用了已有成果,(好奇是证明,还是暴力枚举,毕竟是2011-04-20的事情了</p><h2 id="Level-6-AKS"><a href="#Level-6-AKS" class="headerlink" title="Level 6 AKS"></a>Level 6 AKS</h2><p>上面要么慢,要么基于概率(或有限范围的历史答案)</p><p>$(x-a)^n = x^n-a (\bmod n), gcd(\forall a,n) = 1$,</p><p>n是质数时,根据2项式定理显然,</p><p>如果n 合数, $(X-a)^n - X^n-a $ 看成 $X$为变量, 其余部分为系数</p><p>那么 $X^i$的系数为$C(n,i) a^{n-i}$</p><p>把合数表示成其构成的质数相乘$n = p_1^m \cdots$, 那么2项式中$C(n,p_1) \neq 0 (\bmod p_1^m )$,因为$C(n,p_1) = \frac{n!}{p!(n-p)!}= \frac{(n-p+1)…(n)}{1…p}$ 分子只有n是p的倍数,分母只有p是n的倍数</p><p>所以$C(n,p_1)a^{n-p_1} \neq 0 (\bmod p_1^m)$ (因为a和n互质,不会包含因子$p_1$) 也说明 $C(n,p_1)a^{n-p_1} \neq 0 (\bmod n)$</p><p>注意我们$(X-a)^n - X^n-a $ 看成 $X$为变量, 其余部分为系数,后就是一个 f(X)的表达式, 有系数非零</p><p>例如 n = 4</p><p>$(x+a)^4 = x^4+C(4,1)ax^3+C(4,2)a^2x^2+C(4,3)a^3x+a^4 = x^4 + C(4,2)a^2x^2+a^4 (\bmod 4)$</p><p>$(x+a)^4 -(x^4+a) = 6a^2x^2+a^4-a (\bmod 4)$</p><p>想存在$x,gcd(a,4) = 1$,使得 $6a^2x^2+a^4-a \neq (\bmod 4)$, 我们的确能找到 a=1,x=1,有些地方说,</p><p>既然是关于x有系数的表达式,或者项数差异,说明它在模意义下非恒为零??? 这是模运算的什么定理吗</p><blockquote><p>小证? 写成 系数乘上 x的从1取到n的范得Vandermonde 矩阵, 系数和结果都对n取mod,所以只能全是零才有解? 甚至如果希望陪结果,可以反向推?<strong>脑补证明的感觉可能有误</strong>. 比如如果要按mod算的话,那vandermonde矩阵的n列就全是0和部分 位置XD</p></blockquote><p>但是要中间的系数全是n的倍数上面已经证明</p><p>有的地方说主要是等式而不是值?</p><p>TODO</p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>$(n-1)! = -1 (\bmod p)$ 当且仅当 p为质数,陶哲轩的书上也有这个</p><p>效率更差, 在一些特定场景有用</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><pre><code class="cplusplus">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef uint64_t ull;#define rep(i,a,n) for (ll i=a;i&lt;n;i++)// overflowll quick_p(__int128_t b, ll p,const ll mod){  __int128_t r = 1;  while(p){    if(p%2)(r*=b)%=mod;    (b*=b)%=mod;    p/=2;  }  return r%mod;}ll mr(ll base,ll v){  if(base &gt; v)return true;  ll startp = v-1;  while(startp%2 == 0)startp&gt;&gt;=1;  ll p = startp;  __int128_t r = quick_p(base,p,v);  while(p != v-1){    if(r == v-1)return true;    if(r == 1)return p == startp;    p*=2;    // overflow    (r*=r)%=v;  }  return false;}bool is_prime_64(ll v){  if(v &lt; 2)return false;  if(v &lt; 4)return true;  // %6 = 1 or 5  if((v % 6) % 4 != 1)return false;  ll test_g[] = {2, 325, 9375, 28178, 450775, 9780504, 1795265022};  rep(i,0,7){    if(!(mr(test_g[i],v)))return false;  }  return true;}bool isp(ll v){  rep(i,2,v){    if(i*i&gt;v)return true;    if(v%i == 0)return false;  }  return true;}int main(){  ll ans = 0;  rep(i,2,50&#39;000&#39;000+1){    if(i % 500&#39;000 == 0){      printf(&quot;i:%lld\n&quot;,i);    }    ans += is_prime_64(2*i*i-1);  }  printf(&quot;ans:%lld\n&quot;,ans);  return 0;}</code></pre><h1 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h1><p><a href="https://brilliant.org/wiki/prime-testing/" target="_blank" rel="noopener">https://brilliant.org/wiki/prime-testing/</a></p><p><a href="https://primes.utm.edu/prove/prove2_3.html" target="_blank" rel="noopener">https://primes.utm.edu/prove/prove2_3.html</a></p><p><a href="http://www.cse.iitk.ac.in/users/manindra/algebra/primality_v6.pdf" target="_blank" rel="noopener">2002 primes is P</a></p><p><a href="http://www.cs.tau.ac.il/~amnon/Classes/2019-Derandomization/Lectures/Lecture7-AKS-All.pdf" target="_blank" rel="noopener">http://www.cs.tau.ac.il/~amnon/Classes/2019-Derandomization/Lectures/Lecture7-AKS-All.pdf</a></p><p><a href="https://en.wikipedia.org/wiki/AKS_primality_test" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/AKS_primality_test</a></p><p><a href="https://math.stackexchange.com/questions/2155958/lemma-2-1-of-aks-algorithm" target="_blank" rel="noopener">系数与完整表达式的疑问也有人问过</a></p><p><a href="http://blog.sciencenet.cn/blog-3224443-1115018.html" target="_blank" rel="noopener">http://blog.sciencenet.cn/blog-3224443-1115018.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Project Euler </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pe </tag>
            
            <tag> project euler </tag>
            
            <tag> math </tag>
            
            <tag> prime </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>project euler 709 (OEIS A000111)</title>
      <link href="/Blog/2021-05-31-project-euler798/"/>
      <url>/Blog/2021-05-31-project-euler798/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>每次新增一个塑料袋</p><p>可以把偶数个之前的塑料袋放入这个新增的塑料袋</p><p>求n次后 的状态数</p><p>f(4)=5</p><p>f(8)=1385</p><p>求<code>f(24680)%1020202009</code></p><h1 id="打表"><a href="#打表" class="headerlink" title="打表"></a>打表</h1><p>显然 OEIS A000111</p><h1 id="DP-n-3"><a href="#DP-n-3" class="headerlink" title="DP(n^3)"></a>DP(n^3)</h1><p><code>dp[i][j] =</code> 第i步,剩余j个袋子</p><p><code>dp[i][j] = dp[i-1][j-1+d] * c(j-1+d,d), d = 0..i-j, step = 2,(i-j)%2=0</code></p><p>试图优化,内部运算也没有摆脱<code>O(n^3)</code>, n在2w 搞不了</p><h1 id="DP-n-2"><a href="#DP-n-2" class="headerlink" title="DP(n^2)"></a>DP(n^2)</h1><p><code>f(n+1) =</code></p><p>0个放袋子n+1里<code>c(n,0) * f(0) * f(n)</code></p><p>2个放袋子n+1里<code>c(n,2) * f(2) * f(n-2)</code> ,我们 不关心 这2个 和 这n-2个 内部的关系,而只关心谁在n+1袋子里,谁在袋子外,有了<code>c(n,2)</code>, 于是 这2个和n-2互不干扰,各自的结构只与其内部相关,所以方案数也就是f(2)和f(n-2)</p><p>2k个放袋子n+1里<code>c(n,2k) * f(2k) * f(n-2k)</code> ,我们 不关心 这2k个 和 这n-2k个 内部的关系,而只关心谁在n+1袋子里,谁在袋子外,有了<code>c(n,2k)</code>, 于是 这2k个和n-2k互不干扰,各自的结构只与其内部相关,所以方案数也就是f(2k)和f(n-2k)</p><p><code>f(n+1) = sum( c(n,2k) * f(2k) * f(n-2k) ), k = 0..floor(n/2)</code></p><p>令<code>g(n) = f(n)/(n!)</code>, 其实上面dp我也用了这个技巧,但是还是有剩余的阶乘,无法简化到递推</p><p><code>g(n+1) * (n+1) = sum( g(2k) * g(n-2k)), k = 0..floor(n/2)</code></p><h1 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h1><p><a href="https://hiragn.hatenablog.com/entry/2020/12/01/031135" target="_blank" rel="noopener">https://hiragn.hatenablog.com/entry/2020/12/01/031135</a></p><p><a href="https://gist.github.com/hrgnz/10c4c3afb5a332c8ad3428327e6459c0#file-pe709a-nb" target="_blank" rel="noopener">https://gist.github.com/hrgnz/10c4c3afb5a332c8ad3428327e6459c0#file-pe709a-nb</a></p>]]></content>
      
      
      <categories>
          
          <category> Project Euler </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pe </tag>
            
            <tag> project euler </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>project euler 622 (函数周期)</title>
      <link href="/Blog/2021-05-30-project-euler622/"/>
      <url>/Blog/2021-05-30-project-euler622/</url>
      
        <content type="html"><![CDATA[<h1 id="完美洗牌"><a href="#完美洗牌" class="headerlink" title="完美洗牌"></a>完美洗牌</h1><p>AAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBB</p><p>变为</p><p>ABABABABABABABABABABABABABABABABAB</p><h1 id="次数"><a href="#次数" class="headerlink" title="次数"></a>次数</h1><p>52张需要8次变回原型</p><p>需要8次的方案的张数和为412</p><p>问</p><p>需要60次的方案的张数和是多少</p><h1 id="解"><a href="#解" class="headerlink" title="解"></a>解</h1><p>首先 估计已经到2的60次方左右的搜索范围,暴力不可取</p><p>递推</p><p><code>f(i,n) = (i%n)*2+int(i&gt;=n)</code></p><p>然后我们分开写</p><p><code>f(i,n) = 2i</code> (i &lt; n)</p><p><code>f(i,n) = 2(i-n)+1</code> (i &gt;= n)</p><p>变形</p><p><code>f(i,n) = 2i - (2n-1)</code> (i &gt;= n)</p><p>合并</p><p><code>f(i,n) = (2i)%(2n-1)</code> 这里就很神奇了</p><p>相当于每个值的变化都是在乘2,又膜运算有合并性, 所以任何值a的k次后的值为 <code>(a * 2^k) % (2n-1)</code></p><p>所以要所有都会到原位其实就是 任意 a, <code>a = (a * 2^k) % (2n-1)</code></p><p>a取1,也是最大循环节</p><p>题目变成 $(2^60-1)%(2n-1) = 0$ 且 $(2^(&lt;60)-1)%(2n-1) != 0$</p><p>质因数分解一下就好</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>关键在 int(i&gt;=n)的那个表达式转换成纯的模运算表达式,后面都好做了</p>]]></content>
      
      
      <categories>
          
          <category> Project Euler </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pe </tag>
            
            <tag> project euler </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>codeforce 1521(树上拆分合并)</title>
      <link href="/Blog/2021-05-28-cf1521D/"/>
      <url>/Blog/2021-05-28-cf1521D/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://codeforces.com/problemset/problem/1521/D" target="_blank" rel="noopener">https://codeforces.com/problemset/problem/1521/D</a></p><p>评分2500</p><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给你树</p><p>每次拆一条边,连两个点</p><p>用最小操作次数让树的形状变成链状</p><p>求具体方案</p><p>样例1e4组,每个数节点小于1e5,所有节点数小于2e5</p><p>过程中没有限制一定要保持是树</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>拆与合并互不干扰,也不会因为顺序干扰,</p><p>如果先拆完再合并,合并就很easy,因为拆分出的每个联通块一定是链状.</p><p>那问题是怎么拆分</p><p>要拆的节点明显是,连接数大于3,任取一个节点为根, 计算每个节点深度,深度从大到小,那么一条点要拆边,一定是和它父节点拆(贪心性质), O(n)</p><blockquote><p>无代码</p></blockquote><h1 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h1><p>这题最有意思的地方在于,不是正确方法需要很复杂的思路,而是你能想到许许多多不正确的看似时间内的做法,</p><p>比如我考虑过</p><ol><li>多点-多点优先斷,连小于2的点. 问题:可能成环, 也可能不是最小覆盖</li><li>任选根,连leaf,断公共祖先,递归处理,也存在重复断和断得小于1的问题</li><li>找不重叠的链,断了后连:</li></ol><pre><code> 1-2-3-4-5     | 6-7-8-9-0</code></pre><p> 问题 非主链,和存在非连接链, 难找断开位置.</p><ol start="4"><li>+多点优先</li></ol><pre><code>  1      3  |      |  2------4  |      |5-6-7  8-9-0</code></pre><p> 问题: 多点成链, 2次更优,可能找到非最小</p><p>等等错误的思路干扰</p>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>project euler 686 (2的幂的前3位)???</title>
      <link href="/Blog/2021-05-10-project-euler686/"/>
      <url>/Blog/2021-05-10-project-euler686/</url>
      
        <content type="html"><![CDATA[<p>第678910个满足$2^i$前3位是$123$的,求$i$</p><h1 id="看了几个-方案"><a href="#看了几个-方案" class="headerlink" title="看了几个, 方案"></a>看了几个, 方案</h1><p>截断15位/double(相当于截断)</p><p>log转换乘为加法，本质上还是精度和截断?</p><p>递增:196/289/485(=196+285)，还是要截断 (这三个还是容易得到, 但也可能更大的组合(485+196=681))</p><pre><code>2**196=1004336277661868922213726307713226626576376871114245522063362**289=9946464728195732843107644962936416802009123015946954348809279537863189940250667510661122**485=99895953610111751404211111353381321783955140565279076827493022708011895642232499843849795298031743077114461795885011932654335221737225129801285632</code></pre><p>所以, 或者有什么精度估计的方法?</p><h1 id="感觉"><a href="#感觉" class="headerlink" title="感觉"></a>感觉</h1><p>都可能有精度问题，只是刚好得到正确答案过了?????</p><p>所以有更正确的方案吗?或者证明上面正确性的方案</p><p>这篇似乎在证 <a href="https://projecteuler.net/action=redirect;post_id=342800" target="_blank" rel="noopener">https://projecteuler.net/action=redirect;post_id=342800</a></p><h1 id="log"><a href="#log" class="headerlink" title="log"></a>log</h1><p>文章还提到了 log与渐进分数，递增与渐进分数分母的关系</p><p>$1.23 x 10^k &lt;= 2^i &lt; 1.24x10^k$</p><p>$log_{10}{1.23} + k &lt;= i \cdot log_{10}{2} &lt; log_{10}{1.24} + k$</p><p>$93 \log_{10}2= 27.995789596750246 \equiv -0.00421040324975408 \pmod {1}$</p><p>$196 \log_{10}2= 59.001879150140304 \equiv 0.001879150140304 \pmod {1}$</p><p>$289 \log_{10}2= 86.99766874689055 \equiv -0.00233125310945 \pmod {1}$</p><p>$485 \log_{10}2= 145.99954789703085 \equiv -0.00045210296915 \pmod {1}$</p><p>首先在$1~485$内，只有$196,289,485$是小于$l = log_{10}{(123+1)} - log_{10}{123} = 0.003516573722837535$的</p><p>考虑一个合法的i，得到的 $i\cdot log_{10}{2} - log_{10}{1.23}$的小数部分x</p><p>$x \in [0，0.001637423582533535(= 0.003516573722837535-0.001879150140304)]$，那么+196 依然在区间中</p><p>$x \in [0.00233125310945, 0.003516573722837535]$，那么+289 依然在区间中</p><p>$x \in x \in [0.00045210296915, 0.003516573722837535]$，那么+485 依然在区间中</p><p>三个区间的并 刚好是整个区间</p><p>综上，我们证明了间隔只是这3个中的</p><h1 id="精度"><a href="#精度" class="headerlink" title="精度"></a>精度</h1><p>其实有了这个大于小于表达式，i的精度可以观察差值, 与 可信位数乘以乘法的比较</p><p>$i\cdot log_{10}{2} - log_{10}{1.23}$的小数部分, 到$[0,0.003516573722837535]$ 的两边界</p><p>与$i$ 乘上$log_{10}{2}$的不可信位数之间的关系</p>]]></content>
      
      
      <categories>
          
          <category> Project Euler </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pe </tag>
            
            <tag> project euler </tag>
            
            <tag> math </tag>
            
            <tag> TODO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>project euler 167 (Ulam Number Sequence)</title>
      <link href="/Blog/2021-04-23-project-euler167/"/>
      <url>/Blog/2021-04-23-project-euler167/</url>
      
        <content type="html"><![CDATA[<h1 id="Ulam-序列"><a href="#Ulam-序列" class="headerlink" title="Ulam 序列"></a>Ulam 序列</h1><p>定义</p><pre><code>U(a,b,1) = aU(a,b,2) = bU(a,b,k &gt; 2) = 大于U(a,b,k-1) 且能唯一表示为 U(a,b,i) + U(a,b,j), i != j</code></pre><p>例如</p><pre><code>U(1,2,1) = 1U(1,2,2) = 2U(1,2,3) = 1+2 = 3U(1,2,4) = 1+3 = 4U(1,2,5) = 2+4 = 6 (5有两种表示方法)U(1,2,6) = 2+6 = 8 (6有两种表示方法)U(1,2,7) = 3+8 = 11 (9,10都有多种表示方法)</code></pre><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>求</p><pre><code>    U(2,5,10**11)    +U(2,7,10**11)    +U(2,9,10**11)    +U(2,11,10**11)    +U(2,13,10**11)    +U(2,15,10**11)    +U(2,17,10**11)    +U(2,19,10**11)    +U(2,21,10**11)</code></pre><h1 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h1><p>列举了几个，发现无能为力</p><p>能想到的就是 set+枚举</p><p>那至少是 K方的空间时间复杂度, 连k都没法搞，更别说k方了</p><p>果断google XD</p><h1 id="搜索到"><a href="#搜索到" class="headerlink" title="搜索到"></a>搜索到</h1><p>Schmerl and Spiegel (1994) proved that Ulam sequences (2,v) for odd v&gt;=5 have exactly two even terms. Ulam sequences with only finitely many even terms eventually must have periodic successive differences (Finch 1991, 1992abc). Cassaigne and Finch (1995) proved that the Ulam sequences (4,v) for 5&lt;=v=1 (mod 4) have exactly three even terms.</p><p>The Ulam sequence can be generalized by the s-additive sequence.</p><p>还有cos性质，不过这题可能用不到</p><p>当然如果直接用性质，也不需要写啥文章了，就像pe66，我还是从零整理了整个 pell方程和连分数关系的证明过程。</p><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ol start="0"><li>有无限多个。显然做pe到176了，这还是很明显，最大两个的和一定唯一表示，所以至少有一个大于且唯一表示的，所以得证</li><li>除了第3个，其它的都不是上两个的和, $U_{n-2}+U_{n}$ 是唯一的计算方案，所以，$U_{n-2}+U_{n} \ge U_{n+1}$, 得证</li><li>n大于2时，相邻3个能构成3角形, $U_{n-1}+U_{n} &gt; U_{n-2}+U_{n} \ge U_{n+1}$,得证</li><li>(1,2) 的Ulam sequence 是 Complete sequence，也就是任何正整数可以序列中每个数字最多用一次的和表示。直接用集合最小法，假设有集合的数，都是该序列不可表示的，那么取最小的不可表示的数,记为$x_0$，显然它没有出现在序列中，且它大于4, 取最大一个小于它的序列中的数 $0 \leq x_1=x_0-U_n &lt; U_n$, 则也不可表示, 和最小性质矛盾</li><li>任意n, $[n,2n)$之间至少有一个 数属于序列, 无限多个和$U_{n+1} \leq 2*U_n$ 得证</li><li>(1,2)的序列，i&gt;4, $i,i+1,i+2,i+3,i+4$,至多两个属于序列，首先可以看作在整数中取连续的5个数，那么根据贪心，直接取到$i$是序列中的数，否则我们做平移到i是序列中的数，只会更多。如果$i+1$也是，显然$i+2 = (i)+(2)=(i+1)+(1),i+3=(i)+(3)=(i+1)+(2),i+4=(i)+(4)=(i+1)+(3)$都有多种表示法。如果$i+2$也是，$i+3=(i+2)+(1) = (i)+(3), i+4=(i+2)+(2)=(i)+(4)$。如果$i+3$也是，$i+4=(i+3)+(1)=(i)+(4)$,得证</li></ol><p><code>(u, v)-Ulam 序列</code> is regular 如果序列的差分，是最终周期性的(也就是除去一定的非周期序列前缀后，剩余部分是周期序列)</p><h1 id="paper"><a href="#paper" class="headerlink" title="paper"></a>paper</h1><p>法文令人抠头XD, 这个老哥是 诗人作家，业余数学家!?还是重名?</p><p>英文还稍微能看，法文只剩公式靠猜为主，用了一下google的pdf翻译功能XD</p><h2 id="s-additive-sequences"><a href="#s-additive-sequences" class="headerlink" title="s-additive sequences"></a>s-additive sequences</h2><p>s-additive 如果除了开始2个以外的数，正好能表示成s种前面的数之和，因此 Ulam numbers and the (u, v)-Ulam numbers are 1-additive sequences</p><p>正整数，单增</p><p>给定前2s项，作为基础</p><p>对于n&gt;2s, $U_n$ 是大于 $U_{n-1}$的最小整数，满足 $U_{n} = U_i+U_j (u_i\neq u_j,i \neq j)$, 的最小的且正好有s个解</p><h2 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h2><p>显然, 是必要给出2s项，否则直接中断（因为要s种表示方式）</p><p>并且前s+1项 决定了 整个2s项，因为这样才能有2s+1项(有s种表示方式) $U_{2s+1} = U_{1}+U_{2s} = U_{2}+U_{2s-1} =U_{3}+U_{2s-2} = \cdots =U_{s}+U_{s+1}$</p><p>因此$U_{s+2}$可取值是$U_{s+1}+U_{1}$  或 $U_{s+1}+U_{2}$，且满足一串等式类似上面，但是并不保证 下标和为s的函数, 对于可行和来说，只有s+1种，其实就是连等式中不会出现的数只会在前s+1个中</p><p>补充定义$U_0=0$</p><p>所以说我们有两串连等式</p><p>$U_{2s+1} = U_0+U_{2s+1} = U_{1}+U_{2s} = U_{2}+U_{2s-1} =U_{3}+U_{2s-2} = \cdots =U_{s-1}+U_{s+2}$</p><p>$U_{2s+2} = U_{1 or 2} + U_{2s+1} = U_{2 or 3}+U_{2s} = U_{2 or 3}+U_{2s-1} =U_{3 or 4}+U_{2s-2} = \cdots =U_{(s) or (s+1)}+U_{s+2}$</p><p>上下相减</p><p>$U_0 - U_{1 or 2} = U_1 - U_{2 or 3} = U_2 - U_{3 or 4} = \cdots = U_{s-1} - U_{(s) or (s+1)} = 常量$</p><p>对于给定具体的一个初始序列这个值是确定的，所以是常量</p><p>很明显 这里有s个等差，注意在 $x 或 x+1$ 的取值是在一个确定位置的左侧全部取x，右侧全部取x+1  的，所以最多发生一次 不连续的差，而这个等差序列最大跨度为2个下标差</p><p>所以可能的序列有</p><p>$A$(前s项以及$U_0$完全等差): $u,2u,3u,\cdots,(s-1)u,su,v,v + u,\cdots,v+(s-2)u,v+(s-1)u$</p><blockquote><p>这个相当于上面常量的表达式在or的选择全部取左侧</p></blockquote><p>$B_1$(前s-1以及$U_0$完全等差): $u,2u,3u,\cdots,(s-1)u,v,su,v + u,\cdots,v+(s-2)u,v+(s-1)u$</p><blockquote><p>看上去和上面交换了正中两项的位置,这个相当于上面常量的表达式除了最后的一项的or取右侧，其余or的选择全部取左侧。</p></blockquote><blockquote><p>很好的是序列的性质，因为有和($U_{2n+1}$)的控制右侧的序列并不会因为交换了中间两项而改变</p></blockquote><p>$B_2$(前s-1以及$U_0$完全等差): $u,2u,\cdots,v,(s-1)u,v+u,su,\cdots,v+(s-2)u,v+(s-1)u$</p><blockquote><p>这个相当于上面的常量表达式，除了最后两项区or右侧，其它取or左侧，也就是 $U_{s+1}-U_{s-1} = U_{s}-U_{s-2} = U_{s-2}-U_{s-3} = 等差常量$ ,也就是 前s-2项 再配上$U_{s}$ 和 $U_{s+2}$ 都是等差的。</p></blockquote><blockquote><p>这里比较有意思的是，虽然$U_{s+1}-U_{s-1} = U_{s}-U_{s-2}$中的s+1超过了s，但是本身差是关于 s,s+1 之间对称的，所以$U_{s+1}-U_{s-1} = - (U_{(2s+1)-(s+1)} - U_{(2s+1)-(s-1)} ) = U_{s+2} - U_{s}$。因此序列中依然$u,2u,\cdots,su$都存在，只是位置变了，而后面的部分依然不会变，后面的部分又因为s,s+1之间对称等差性，v，v+u到 (s-1)u 也没变，只是换了位置，然后序列就神奇得像是 交叉了一下而已</p></blockquote><p>$B_{s-1}$: $u,v,2u,v+u,3u,v+2u,\cdots,su,v+(s-1)u$</p><blockquote><p>就是两个序列完全穿插到了一起，也就是上面常量表达式除了第一项取or左侧，其余全部取or右侧</p></blockquote><p>$C$: $v,u,v+u,2u,v+2u,3u,\cdots,v+(s-1)u,su$</p><blockquote><p>就是两个序列完全穿插到了一起,然后再错过一个，也就是上面常量表达式所有项取or右侧</p></blockquote><p>(目前位置不懂为什么要分成ABC三种，因为从组成来看，就是两个序列的穿插结果)</p><p>因此，可以用(s,u,v)唯一表示($u\neq v$) s-additives的序列，s决定了和的要求次数，初始序列长度，其中u决定了存在的 $u,2u,3u,\cdots,su$序列,u和v,确定了$v,v+u,v+2u,\cdots,v+(s-1)u$这个序列，这两个序列从小到大排列即可</p><p>如果u和v不互质，$gcd(u,v) * (s,u/gcd(u,v),v/gcd(u,v)) = (s,u,v)$</p><p>对于s=1，只有A/C类型的序列</p><p>u=1 只有 A类型的序列</p><p>对于 v = (s+1)u 的 我们称之为<code>自然 s-additive</code>, 因为上面提到的互质，考虑u=1，显然(s,1,s+1) = (s,2,1), 因为数列都是 1~2s</p><p>对于 $u\ge 3$ 且 $s&gt;1$ 有性质 取自$v+nu$序列，仅在$ku&lt;v&lt;(k+1)u$时 $U_{3s+k+1} = 2v+(2s-1)u$</p><p>例如 (s=3,u=3,v=10):[3,6,9,10,13,16],19,22,25,28,31,34,35(!),37,40…</p><p>$3u=9&lt;v=10&lt;(3+1)u=12$ 所以$k=3, i = 3s+k+1=14,U_i=u_{14} = 2v+(2s-1)u = 35$</p><p>证明，首先因为序列是通过$u,2u,\cdots,su$和$v,v+u,v+2u,\cdots,v+(s-1)u$以某种穿插形式初始化的，u,v互质不等，v的系数为0或1,所以在序列生成过程中已有的是$(1~s)u,v+(0~(s-1)+)u$，可能的下一个数是au,u或v+au或2v+au,</p><p>首先au不可能，因为不带v的仅有s个递增的数，不可能有s种方案</p><p>接下来v+au,刚刚好，选一个ku，再选一个v+(a-k)u,即是连续的又是刚好s个，问题只是可能不是可选的最小</p><p>对于2v+au,也就是需要选 v+ku,和v+(a-k)u,这个只会发生一次，因为v+?u,?的取值范围是从0开始的连续整数，所以2v+(a+1)u的方案必定有s+1种。同时当这个2v+au产生时，并不会产生额外的新值</p><p>因为2v+au带来的可能是 3v+bu或4v+bu,而3=0+3=1+2,4=0+4=1+3=2+2都不具备构成。</p><p>同样 对于2v+au来说，显然不对bu/v+bu产生影响，根据a的值也不对2v+bu的构成产生影响</p><p>综上在算下a的具体值和对应下标的值，得证(s&gt;1,u&gt;=3,v) 主要由 $(1~s)u,v+ku,以及一个特殊2v+(2s-1)u (如果有的话)$构成</p><p>因此对于s&gt;1的序列，还要研究的就是u=1和u=2的情况</p><h2 id="2-0"><a href="#2-0" class="headerlink" title="2.0"></a>2.0</h2><p>考虑 <code>u=2</code></p><p>文章是<code>s-additives</code>,所以用的是<code>(s,u,v)</code>,本文其实只关注<code>(1,2,&gt;=5奇数)</code></p><p>忽略 v 是偶数，因为性质上 <code>(s,2,2n) = 2(s,1,n)</code></p><h2 id="2-3"><a href="#2-3" class="headerlink" title="2.3"></a>2.3</h2><p>(1,2,v&gt;=5奇)</p><p>简写作$2,v(2)2v+1,2v+2,2v+3(2),3v,3v+4(4),5v+2,5v+4,5v+10,5v+12,5v+18,5v+20,5v+26,\cdots$</p><p>再根据v mod 4来确定最后的模式串是$7v+2,7v+6$或$7v+4,7v+12$</p><p>括号数字表示，以该数字递增</p><p>和上面证明类似(考虑2的系数和v的系数)，达到2v+1前，只会有<code>2,v+2k</code>构成，且k是从0取到$(v+1)/2$所有整数,换句话说，和的表示总是会选择2，因为如果不选2则至少(v)+(v+2) = 2v+2</p><p>接下来2v+2是一个特例,2v不可表示，所以一定是2v+2 = (v+a)+(v+(2-a)),只有a=0</p><p>注意到v的系数为1时，加的部分是偶数，所以在$(2v+2,3v]$的范围，(2v+(偶数&gt;2))有超过一种表示例如$(2v+4=v+(v+4)=2+(2v+2))$,对于$(2v+2k = v+(v+2k) = (v+2)+(v+2k-2))$其中$k&gt;=3$, 对于(2v+(奇数&gt;2)),有且仅有表示$2v+(2k+1) = 2+(2v+(2k-1))$,因为如果不选2的话v的系数只能选为1的，而v的系数为1的加的部分是偶数不可能加成2k+1</p><p>接下来3v+4,先说为啥没有$3v+1,3v+2,3v+3$,直接上表达式$3v+1=v+(2v+1)=(v+2)+(v+(v-1))$(v的取值范围让 2 != v-1), $3v+2=2+3v=v+(2v+2))$,$3v+3=v+(2v+3)=(v+2)+(2v+1))$</p><p>然后是为什么$3v+4$可选,$3=0+3=1+2$所以如果选2的话，3v+2不存在，只能$(v+a)+(2v+(4-a))$,a只能取2,唯一表示</p><p>k&gt;=1</p><p>$3v+(2k+1) = v+(2v+(2k+1)) = (v+2) + (2v+(2k-1))$, 注意到$v~3v$的等差2的序列全有</p><p>所以序列中取最大的4个$(3v)+(3v-6) = (3v-2)+(3v-4)$,k取$[1,(3v-7)/2]$时$3v+(2k+1)$都是有多个表示方法的，需要注意的是这里的增加部分和上面表示略有不同，这里即使增加的部分即使超过了v，也是没有做改写,所以也涵盖了$[4v,5v]$的部分</p><p>$3v+(4k+2)$和$3v+4k$注意到这两个都是奇数，而奇数=奇数+偶数，而偶数少得可怜，只有2和2v+2,相反v直到到3v的奇数是没有遗漏的被选择了，所以$3v+4k$是唯一表示$(2v+2)+(v+(4k-2))$而$3v+(4k+2)$则有含上面两个偶数的表示都存在。范围k，$4k-2=2v$即$k=(v+1)/2$都可以也就是$5v+2$</p><p>接下来越来越复杂，先看看我们序列有什么</p><p>$2$,$v~2v+1$的等差2的奇数序列,$2v+2$,$2v+3~3v$等差2的奇数序列,$3v~5v+2$的等差4的奇数序列</p><p>然后我暂时不想再往5v和7v去证明了</p><h2 id="定理1"><a href="#定理1" class="headerlink" title="定理1"></a>定理1</h2><p>如果 v是大于3的奇数， (2,v)-Ulam序列,仅有两个偶数项</p><p>$U_1=2$ and $U_{(v+7)/2} = 2v + 2$</p><p>本文仅需要 前½(3v + 11) terms，上面两个是唯一的偶数项（上面列举时已经证明）, 其实上面已经在列举的时候观察到了这两项，但是没有证明仅这两项是偶数</p><h2 id="引理2"><a href="#引理2" class="headerlink" title="引理2"></a>引理2</h2><p>考虑前(3v+11)/2项</p><p>$2,v,(2),2v+1,2v+2,2v+3,(2),3v,(4),5v+2,5v+4,5v+10$</p><p>我们上面还剩下 5v+4 和 5v+10没证</p><p>$5v+3=(3v)+(2v+3)=(3v+4)+(2v-1)$多解</p><p>$5v+4=2+(5v+2)$单解,$3v+2$不存在不能用$(2v+2)+(3v+2)$</p><p>$5v+5=(3v)+(2v+5)=(3v+4)+(2v+1)$多解</p><p>$5v+6=2+(5v+4)=(2v+2)+(3v+4)$多解</p><p>$5v+7=(3v)+(2v+7)=(3v+4)+(2v+3)$多解</p><p>$5v+8$ 没有表示方案</p><p>$5v+9=(3v)+(2v+9)=(3v+4)+(2v+5)$多解</p><p>$5v+10=(2v+2)+(3v+8)$单解</p><p>因此说明了 在&lt;=8v+8中 不存在别的偶解，因为如果存在则取存在的最小的且大于2v+2的，则它不能表示成两个偶数之和，否则它表示成a(小于4v+4)+b(大于4v+4),存在更小解b矛盾，</p><p>要么表示成奇数之和，注意到在$(8v+8) = (5v+10)+(3v-2)$,也就是$(5v+10)+(v~3v-2)$能表示$6v+10~8v+8$的所有偶数,同样选取$5v+2$和$5v+4$可知从$6v+4~8v+8$都有不只一种表示方法</p><p>也就是如果选取的数唯一表示的 取值中有大于$(5v+10)$的，那剩余的部分一定小于$(3v-2)$,设存在的最小大于5v+10的偶数为$5v+2 &lt; v = i(&gt; 5v+10) + j(&lt;3v - 2) &lt;= 8v+8$</p><p>那我们关心的还剩下$(5v+10,6v+4)$之间是否还村在唯一表示的偶数</p><p>$5v+(2k+1) = (3v+4j) + (2v+(2k+1-4j))$</p><p>$4j \in [0,2v-2]$ 的所有4的倍数</p><p>$(2k+1-4j) \in [-v,v]$ 的所有奇数</p><p>$(2k+1) \in [-v+2,3v-4]$ 的所有奇数都至少有一个以上的表示方式 (这里重复会怎么样？还是只要非端点，内部重复少一次，还是能大于1,毕竟如此的表示方案次数的规律是 从1开始先增后减最后是1 )</p><p>所以$5v+(2k+1) \in [4v+2,8v-4]$都是有至少两种表示方法的了</p><p>因此证明了8v+8内，有且只有两个偶数项</p><h2 id="引理3"><a href="#引理3" class="headerlink" title="引理3"></a>引理3</h2><p>x是最小的大于2v+2的偶数，那么取任意奇数r,满足$1\leq r &lt; x-2v$,那么必有i满足$0\leq i \leq v$ and $r+2i\in S$,也就是有比它小的任意奇数加某个2i后 在序列中</p><p>反证，如果上述不成立，那么r取满足$r&lt;x-2v$和${r+2i:0\leq i \leq v} 交 S = 空$的最小正奇数(r&gt;=3)，也就是一个r让上述的值都不属于S</p><p>也就有$r+2v,r+2v-2$都不属于S</p><p>注意到$r+2v = (r-2)+(2v+2) = (r+2v-2)+2$所以$(r-2)$也不属于S，否则$r+2v$唯一表示</p><p>因此有${(r-2)+2i:0\leq i \leq v} 交 S = 空$，说明了(r-2)才是最小（这里应该是r不能取大于等于3的, r 取1单独讨论也是满足）</p><p>r=1时，显然i取v，$1+2v\in S$ ，所以证毕。 </p><blockquote><p>任意 奇数r 满足 $1 \leq r &lt; x - 2v$. 存在i，满足 $0 \leq i \leq v$ and $r + 2i \in S$.</p></blockquote><hr><p>如果$x&gt;8v+8$, $a&lt;b$( 且 a和b是S中的奇数,因为偶数就那两个,不可能了)满足 x=a+b,令r=x-3v,根据引理3,我们存在$0\leq i \leq v$并且$(x-3v)+2i \in S$,</p><p>再由引理2的序列，知$\{3v-2i:0\leq i \leq v\} \subseteq S $，就是v到3v之间所有偶数都可以取到，</p><p>因此的到a和b的具体值(如果x能表示)$(a,b) = (3v-2i, x-3v+2i)$</p><p>对于$0\leq j\leq v, j\neq i$,有$x-3v+2j \notin S$ 因为如果属于，则也能找到对应的$a,b$，那么x的表示方法就不唯一了，因此0~v之间有且仅有唯一的$i$可选来得到a和b的值,</p><blockquote><p>$[x-3v, x-3v+2v = x-v]$之间所有奇数有且只有一个属于S</p></blockquote><hr><p>然后考虑$[x-5v-2,x-5v-2 + 2v = x-3v-2]$ 之间所有奇数的状况</p><p>$x-3v+2j =((x-5v-2)+(2j))+(2v+2) =  (x-3v+2j-2)+2$</p><p>说明如果$x-5v-2+2j \in S$</p><p>那么$x-3v+2j$和$x-3v+2j-2$至多只有一个存在,(否则$x−3v+2j$有多种表示方法</p><p>同时如果$x-3v+2j-2$不存在，那么$x-3v+2j$唯一表示，所以至少一个存在，</p><blockquote><p>综上，$x-5v-2+2j \in S, 0\leq j \leq v$当前仅当$x-3v+2j$和$x-3v+2j-2$其中一个存在于S</p></blockquote><hr><p>对于$[x-3v, x-v]$之间唯一可能存在的$x-3v+2i$</p><p>考虑$i$的取值</p><p>如果$0 \leq i &lt; v$, 当且仅当 $x-3v+2i - (2v+2) \in S$ 或 $x-3v+2(i+1) - (2v+2) \in S$,直接由上面的当且仅当得到</p><p>如果$i = v$, 和上面不同，这里不取不到$2(i+1)$,首先因为上面证明了 $x-3v+2v = x - v$和$x-3v$不会同时属于S,也因为$x-3v$这个值也不在$[x-5v-2, x-3v-2]$范围中，</p><p>其实对于 $0 &lt; j \leq v$, $x-3v+2j = 2+(x-3v+2j-2)=(2v+2)+(x-3v+2j-(2v+2)) \in S$，又$[x-3v,x-v]$仅能有一个奇数出现,第一个等式必不成立</p><blockquote><p>$0 &lt; j \leq v$有$x-3v+2j\in S$ 当且仅当$x-3v+2j-(2v+2)\in S$</p></blockquote><p>所以对于$0&lt;j&lt;v$,$x−3v+2j \in S$得到 $x-3v+2j - (2v+2) \in S, x-3v+2j+2 - (2v+2) \in S, $, 而又由上得到 $x-3v+2j - (2v+2)+(2v+2) \in S, x-3v+2j+2 - (2v+2)+(2v+2) \in S$,和$x-3v+2j+2 \notin S$ 矛盾</p><blockquote><p>所以$i$的可能取值只有$0$和$v$</p></blockquote><hr><p>$i=0$,$(a,b)=(3v,x-3v)$,$x-3v-(2v+2) \in S$ 或$x-3v-(2v+2)+2 \in S $</p><p>$x-3v-(2v+2) \in S$, 因为x唯一表示, 所以关于x的补也不属于S:$3v+(2v+2) \notin S$ 和枚举$5v+2 \in S$的矛盾,(依靠x的范围保证了这是两种不同的表示)</p><p>所以有 $x-3v \in S$ 当且仅当 $x-5v \in S$ =&gt; $x-5v+(2v+2) \in S$ 矛盾,因为$[x-3v,x-v]$仅有一个属于S</p><hr><p>$i=v$,$(a,b)=(v,x-v)$,$x-v-(2v+2) \in S$ 或$x-v-(2v+2)+2 \in S $</p><p>因为x唯一表示, 所以关于x的补也不属于S:$v+(2v+2) \notin S$ 或 $v+(2v+2)-2 \notin S$ 和枚举的矛盾,(依靠x的范围保证了这是两种不同的表示)</p><hr><p>综上 不存在大于8v+8的偶数</p><h2 id="周期"><a href="#周期" class="headerlink" title="周期"></a>周期</h2><p>是最终周期性的，（就是从某项开始，差分是周期的）</p><p>最小的$N(v)$记为 差分的周期,</p><p>对于大的n差分循环为$D(v) = S_{N(v)-n}-S_n$ 叫做Fundamental difference</p><p>密度$d(v) = N(v)/D(v)$</p><p>On the Regularity of Certain 1 -Additive Sequences 这篇论文还给了一个这三个取值的table, 当然对我们来说做题，其实足够了，但是我还是希望证明1.周期存在，2.如何判断进入周期了</p><blockquote><p>定义 如果一个1-additive序列的差分是最终周期性的，称它为regular的</p></blockquote><h2 id="定理2"><a href="#定理2" class="headerlink" title="定理2"></a>定理2</h2><p>如果一个1-additive 序列只有有限个偶数项，那么它是regular的</p><p>题目虽然是任意个，我们这里只证明仅有2和2v+2为偶数项的,有限项同理，核心是抽屉原理</p><p>令f(x) = 1 当x在序列中，f(x) = 0 当x不在序列中</p><p>有 $f(x) = f(x-2) xor f(x-2v-2)$</p><p>$g(x) = 向量 (f(x) f(x+2) … f(x+4v-2))$</p><p>$g(x+4v) = 向量 (f(x+4v) f(x+4v+2) … f(x+4v-2))$</p><p>所以g(x) 由与x无关的函数唯一决定 g(x+4v)</p><p>g(x) 的状态数为 2v 有限，因此g(x+4v)也是有限的</p><p>所以 g(x+4kv) 必定循环</p><p>循环证必</p><blockquote><p>注意这里取4v有点大，实际上可以缩小到一定范围都行，比如有paper是按照更小的来取的，这里主要是能制造一个靠固定公式递推的向量即可，足够大，可以完全不考虑其具体大小得到“循环”这个性质</p></blockquote><h2 id="找循环节"><a href="#找循环节" class="headerlink" title="找循环节"></a>找循环节</h2><p>直接按照上面的方法能找到一个，然后根据约数缩减即可</p><p>仔细一想，因为是从小到大尝试是否是循环节，那么这个值就一定是起始值和循环节，因此不需要约数</p><h2 id="继续"><a href="#继续" class="headerlink" title="继续"></a>继续</h2><p>我以为证明了有循环节就可以编码了，</p><p>然后写完以后，跑得很慢，看了一下论文的table上面的数据，在(2,17),(2,19),(2,21)时，循环节很大，滑窗搜索写得就有太慢了？也许是我写的问题？感觉我写的 (2v+1)k^2起 ，k是循环节，而在21时，循环节已经2e6了，感觉我内存炸掉比结果先来到</p><p>差分循环节长度$N$</p><p>循环节的差 $D = a_{N+n} - a_n$ </p><p>比如对于(2,5) 有<code>(N,D) = (32,126)</code></p><p>令$b_n $表示 $2n+1$ 的方案数</p><p>对于足够大的n, 因为有且只有两个偶数其实我们就得到 $b_n = b_{n-1} xor b_{n-v-1}$,实际上就是由2或2v+2组成</p><p>这里paper提到了ring，// 奈何我暂无相关知识(查了一下 两种运算(加法和乘法)闭合集) XD, 虽然可以抑或，但缺点是抑或没有组合性质，那就加法模2</p><p>$b_n = b_{n-1} xor b_{n-v-1} (mod 2)$,$b_n$取值范围在$0,1$中</p><p>其实我们把它们变成矩阵和矩阵乘法</p><p>初始矩阵，令</p><p>$\beta_{(v+1)/2} = (b_{-(v+1)/2} b_{-(v-1)/2} \cdots b_{(v-3)/2} b_{(v-1)/2})^T = (0 0 \cdots 0 1)^T$</p><p>也就是注意到$b_{(v-1)/2}$表示的是v可以表达，前面的都是小于v的奇数不论正负，都不能表达，从而产生奇数的序列。</p><p>转换矩阵是</p><p>$\mathbf{A}_{(v+1)\times (v+1)} = \begin{bmatrix}<br>0 &amp; 1 &amp; 0 &amp; 0 &amp; \cdots &amp; 0 &amp; 0 \\<br>0 &amp; 0 &amp; 1 &amp; 0 &amp; \cdots &amp; 0 &amp; 0 \\<br>0 &amp; 0 &amp; 0 &amp; 1 &amp; \cdots &amp; 0 &amp; 0 \\<br>\cdots &amp; \cdots &amp; \cdots &amp; \cdots &amp; \cdots &amp; \cdots &amp; \cdots \\<br>0 &amp; 0 &amp; 0 &amp; 0 &amp; \cdots &amp; 1 &amp; 0 \\<br>0 &amp; 0 &amp; 0 &amp; 0 &amp; \cdots &amp; 0 &amp; 1 \\<br>1 &amp; 0 &amp; 0 &amp; 0 &amp; \cdots &amp; 0 &amp; 1 \end{bmatrix}$</p><p>除了最后一行是递推，上面的都是平移</p><p>这里我们注意到，转换矩阵是模非零，说明矩阵存在，所以循环一定能循环到初始矩阵</p><p>我们令$p = (v+1)/2$假设$q, q &gt; p$首次让$\beta_q = \beta_p$</p><p>那么</p><p>$ N = \sum_{k=p-1}^{q-2} b_k$, 其实就是$\beta$的下标和向量内最大的b的下标差1,然后 统计这之间所有等于1的$b_k$</p><p>$D=2(q-p)$,直接就是值的差</p><p>特征多项式 $f(x) = det(xI + A) = x^{v+1}+x^v+1， f(-A) = 0$, v的奇数决定了矩阵的长宽是偶数, 用途是加速矩阵高幂次运算</p><p>我们之前有递推 $\beta_{n+1} = A \beta_n$,有这两个工具即使枚举就可以很快得到答案了</p><hr><p>推到这，我才突然回想，既然在证明循环时，已经有了递推表达式，那就不需要模拟，也不需要上面这样去算</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code class="c++">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;n;i++)#define pb push_backll v ; // (2,v)vector&lt;int&gt; arr; // [0]v,[1]v+2,[2]v+4vector&lt;ll&gt; vals; // [0]v,[1]v+2,[2]v+4int getidx(int idx){  if(idx &lt; v)return 0;  return arr[(idx-v)/2];}ll work(ll val,ll query){  arr.clear();  vals.clear();  v = val;  arr.pb(1);  vals.pb(v);  ll idx = v+2;  // zero cnt // 初始状态 v个0 1个1  for(int zCnt = 0;;idx+=2){    auto zo = getidx(idx-2) ^ getidx(idx-2*v-2);    arr.pb(zo);    if(!zo){      zCnt++;    }else{ // zo == 1      if(zCnt == v){        // query is enough large        printf(&quot;%lld:%zu %lld\n&quot;,v, vals.size(),idx-v);        query -= 2 + 1; // 2even number and 0-index        ll ans = vals[query % vals.size()] + (query/vals.size()) * (idx-v);        printf(&quot;[%lld]\n&quot;,ans);        return ans;      }else{        zCnt = 0;        vals.pb(idx);      }    }  }  // never be here  return 0;};int main(){  ll ans = 0;  rep(i,2,11){    ans += work(2*i+1, 100&#39;000&#39;000&#39;000);  }  printf(&quot;Ans: %lld\n&quot;,ans);  return 0;}</code></pre><h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><p>我们虽然只想求 Ulem序列的某种特殊情况<code>sum(2,odd &gt;= 5,10**11)</code></p><p>但是因为资料匮乏，只能自己搜paper啃，学习了<code>s-additives</code>的定义，证明了部分性质。</p><p>这个带变量的大量“枚举”第一次这样思考，分类的时候很怕有特殊情况没有考虑到，感觉是不是要去学coq了</p><p>另外本题在证明过程中的同一个数字的不同表示法</p><p>证明用了不少次反证+最小矛盾的方法</p><p>几个引理还是挺漂亮的，利用唯一性和奇偶性和2v+2建立 充要关系</p><p>有些paper有点自顶向下证明</p><p>在证明有限偶数是这个题的核心，一旦证明了有限偶数，剩余的部分就比较容易了</p><p>感觉paper上除了有笔误，证明也不太对？没太懂几个隐含推出是为啥</p><p>上面有不少部分和题目本身无关，如s-additives在s&gt;1的情况的性质</p><p>这里的向量忽略掉偶数的建立方式和只包含首个v的建立方式，有点意思，简化了初始和边界问题（不过也依赖本身偶数只是穿插到奇数序列中，不影响奇数序列本身的递推公式的性质上，</p><p>TODO 整理表述、符号一致性和笔误修复</p><h1 id="Ulam-Sequence-延伸相关"><a href="#Ulam-Sequence-延伸相关" class="headerlink" title="Ulam Sequence 延伸相关"></a>Ulam Sequence 延伸相关</h1><p>例如数列密度猜想</p><p>cos性质</p><p>等等，都在这道题目以外，目前没有深究</p><h1 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h1><p><a href="https://oeis.org/A002858" target="_blank" rel="noopener">oeis U(a,2)</a></p><p><a href="https://mathworld.wolfram.com/UlamSequence.html" target="_blank" rel="noopener">mathworld:Ulam Sequence</a></p><p><a href="https://www.wolframalpha.com/input/?i=ulam+sequence" target="_blank" rel="noopener">WolframAlpha</a></p><p><a href="https://archive.lib.msu.edu/crcmath/math/math/u/u005.htm" target="_blank" rel="noopener">msu: Ulam Sequence</a></p><p><a href="http://oeis.org/A100730" target="_blank" rel="noopener">Fundamental difference of Ulam 1-additive sequence starting U(2,2n+1).</a></p><p><a href="https://www.sciencedirect.com/science/article/pii/0097316572900830?via%3Dihub" target="_blank" rel="noopener">1972, Sur les suites s-additives</a></p><p><a href="https://www.sciencedirect.com/science/article/pii/009731659290042S" target="_blank" rel="noopener">1990, On the regularity of certain 1-additive sequences</a></p><p><a href="http://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=A343AB3C23E3A9FD650ABB586F677247?doi=10.1.1.27.7259&amp;rep=rep1&amp;type=pdf" target="_blank" rel="noopener">1992, Patterns in 1-Additive Sequences</a></p><p><a href="https://www.sciencedirect.com/science/article/pii/0097316594900582?via%3Dihub" target="_blank" rel="noopener">1994, The regularity of some 1-additive sequences</a></p><p><a href="https://arxiv.org/pdf/1507.00267.pdf" target="_blank" rel="noopener">2016, A Hidden Signal in the Ulam sequence</a></p><p><a href="https://arxiv.org/pdf/1705.01883.pdf" target="_blank" rel="noopener">2018, ULAM SEQUENCES AND ULAM SETS</a></p><p><a href="https://arxiv.org/pdf/1804.09594.pdf" target="_blank" rel="noopener">2018, STRUCTURES IN ADDITIVE SEQUENCES</a></p>]]></content>
      
      
      <categories>
          
          <category> Project Euler </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pe </tag>
            
            <tag> project euler </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atcoder arc113 E (数学+枚举+分类讨论)</title>
      <link href="/Blog/2021-02-22-ac_arc113/"/>
      <url>/Blog/2021-02-22-ac_arc113/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://atcoder.jp/contests/arc113/tasks/arc113_e" target="_blank" rel="noopener">https://atcoder.jp/contests/arc113/tasks/arc113_e</a></p><p>题目大意</p><p>给字符串,仅由a和b组成</p><p>操作: 任意选择两个相同的字母，把它们之间的内容 颠倒顺序，删掉这两个被选择的字母</p><p>你可以操作 0 到任意次</p><p>求字典序最大的结果</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>显然，可以把a看作0,b看作1,也就是1尽量靠前且尽量多，而在满足1尽量多的时候，让0也尽量多</p><p>显然 如果0有偶数个，可以不消耗任何1,让结果以1开始</p><p>如果以0结束，也同样可以不消耗任何1,让结果以1开始</p><p>…</p><p>那么就是如何分类是这个问题的关键，怎么尽量少的分化，覆盖所有情况。</p><p>比赛里做出的人不多，有些cf红名大佬都没出 XD</p><p>我在讨论时，从 起始字符，终止字符，字符个数，连续字符个数多个方面去分类，想也不用想，没写出来,(之讨论到了部分情况)</p><hr><p>直接看看 官方答案 怎么搞的。</p><h2 id="a结束"><a href="#a结束" class="headerlink" title="a结束"></a>a结束</h2><p>显然</p><p>如果前面的a偶数个，能不删除b变成 <code>b*a+</code>的形式</p><p>如果前面的a奇数个，能不删除b变成 <code>b*a*</code>的形式</p><p>那么我们其实要求的变成了，如何尽可能的少删除a</p><p>注意到因为完全不会删除b，所以不论b有多少个，它原本连接在一起就不会被拆开。</p><p>所以把连接在一起的b看作一个b，可以看作</p><p><code>(a+)b(a+)b(a+)b(a+)b(a+)b(a+)</code> 的形式</p><p>那么我们一次 删除a至少连接 一次b，至多连接两次b。</p><p>选取一个<code>b(a{2,})b</code> 和 <code>b(a+)b</code>中的a进行删除 能连接一次b</p><p>选取两个<code>bab</code>中的a进行删除 能连接两次b</p><p>所以<code>长度为1的a</code>和<code>长度为1的a</code>先完成同时选择删除，最后处理剩余a</p><p>这样能做到总的操作次数最少 <code>= a(len=1) / 2 + a(len=1)%2 + a(len&gt;1)</code> (不包括最后的a串)</p><p>例如 <code>aaabababababaaaaaa</code> ,a的连续串有4个1和1个3,所以删除次数 = 4/2 + 0 + 1 = 3, 剩余a的个数=原始个数-2x3</p><p>至此，对于a结束的情况可以解了</p><h2 id="b-结束"><a href="#b-结束" class="headerlink" title="b 结束"></a>b 结束</h2><p><code>abb</code> 和 <code>aabb</code> 结果就很不一样，看着这些连局部性都没有的串，很难受</p><h3 id="如果a是偶数个"><a href="#如果a是偶数个" class="headerlink" title="如果a是偶数个"></a>如果a是偶数个</h3><p>那必定可以不损耗b，且损耗所有a</p><h3 id="a是奇数个"><a href="#a是奇数个" class="headerlink" title="a是奇数个"></a>a是奇数个</h3><p>现在的情况，奇数个a+结尾是b</p><p>继续讨论结尾</p><h4 id="ab结尾"><a href="#ab结尾" class="headerlink" title="ab结尾"></a>ab结尾</h4><p>奇数个a，显然a删不完，那么这个ab结尾的b肯定无法移动到前面</p><p>对于b的个数，把字符串删来剩下一个a,可以不损耗b的情况得到<code>b*ab</code></p><p>所以，前缀b最多是b的个数-1,也是可达到的。</p><p>这是可达也是最大可达的字符串，因为如果选了b，一定就变成个数-2,会比这个结果小</p><h4 id="abb结尾"><a href="#abb结尾" class="headerlink" title="abb结尾"></a>abb结尾</h4><p>同上</p><p>我们可以得到 <code>b*abb</code>, 其中不会损耗任何b，前缀b的个数=b总个数-2</p><p>那 我们任何选择b的操作 都会 导致b的个数 &lt;= 总个数-2,</p><p>所以，这也是最大可达</p><h4 id="bbb结尾"><a href="#bbb结尾" class="headerlink" title="bbb结尾"></a>bbb结尾</h4><p>（这种情况，我没有在赛内讨论到方案）</p><p>你看 <code>aaaaabbbbb</code>,<code>abaaaabbbb</code>, 就很不一样</p><h5 id="a-b"><a href="#a-b" class="headerlink" title="a+b+"></a>a+b+</h5><p>显然，其实都没了翻转只有删除，那 <code>ab+</code> 就是结果了</p><h5 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h5><p><code>a*b+a+b+</code></p><p>其中 一定有<code>ba</code></p><p>把它的b和末尾的b交换，一定能b少两个且以a结尾。(就是上面讨论过的情况)</p><p>从而 b的个数减2,以b开头是一个解</p><p>又字符串, 在不操作b的情况下，一定能变成 <code>b+ab+</code>，保留原始最后的a，这是能得到的最大的</p><p>也是比操作了b一次字典序小。（个数 小于 b的个数减2）</p><p>所以，一定要操作且仅操作一次b。</p><p>答案一定是 <code>b+a*</code> 其中b的个数少两个</p><p>那么这种情况又是讨论，如何留下尽可能多的a</p><p>首先，操作b的时候一定选的是ba的b，因为其余情况，都无法让结尾变成a，而结尾不是a的情况如上，得不到更长的b的前缀。</p><p>注意到对于a结尾我们已经有了答案，最后一个b前面x个长为1的a和y个长大于1的a，那么x/2 + x%2 + y</p><p>我们直接定义，在处理之前的状态叫做预期答案，也定义为 x/2 + x%2 + y。</p><p>那么，那一次选择两个b的操作</p><p><code>.*b[(a+)b.*bb]b</code> =&gt; <code>.*[bbb.*b(a+)]</code></p><p>如果<code>(a+)</code> 的部分长是1， 那么根据1个数的奇偶性，可能让预期答案减1或减少0</p><p>如果<code>(a+)</code> 的部分长度大于1, 那么让预期的答案减1</p><p>又如果先操作a，再操作b。</p><p>操作a时，产出和剩余预期的和为常量，且a的奇偶性不变</p><p>综上，存在<code>b(a{2,})</code> 则换它的b</p><p>否则换<code>ba</code>的b</p><p>最后和1一样计算a的个数</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>分类有点难，其实上面几种情况全都有推过，但是我在类型分化时加上了起始的 字符，这样的题解看下来，是不太需要讨论起始字符的。但是在推的过程中不知道怎么排除。</p><p>第二是我分类的时候，奇偶的分类顺序比结束字符的高，又导致了过多的分类分叉 QAQ</p><p>然后我还有想转换（从情况某某+操作转换到情况某某），这样看来这题也不太需要转换</p><p>另外其实对于代码上做分类，不太怕重复，毕竟如果两个非类方式有重复，进任何一种都可以，怕的是漏掉了分类。</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><p>分类的顺序和内容做好了，还要啥代码呢</p><p><a href="https://atcoder.jp/contests/arc113/submissions/20437840" target="_blank" rel="noopener">https://atcoder.jp/contests/arc113/submissions/20437840</a></p><h1 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h1><p><a href="https://atcoder.jp/contests/arc113/editorial/792" target="_blank" rel="noopener">https://atcoder.jp/contests/arc113/editorial/792</a></p>]]></content>
      
      
      <categories>
          
          <category> Atcoder </category>
          
          <category> ARC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 枚举 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>project euler 137 (pell 方程右侧为-4 )</title>
      <link href="/Blog/2020-12-06-project-euler137/"/>
      <url>/Blog/2020-12-06-project-euler137/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>$A(x) = 1x + 1x^2 + 2x^3+ 3x^4+5x^5+8x^6+..$</p><p>已知$A(x)$(整数) 求问,x为有理数时$A(x)$的取值序列</p><p>$xA(x) = 1x^2 + 1x^3 + 2x^4+ 3x^5+5x^6+8x^7+..$</p><p>$(1-x)A(x) = x + 1x^3 + 1x^4 + 2x^5+ 3x^6+5x^7+8x^8+..$</p><p>$(1-x)A(x) = x + x^2A(x)$</p><p>$A(x)x^2 +(1+A(x))x - A(x) = 0$</p><p>$x = \frac{\sqrt{1+2A(x)+5A(x)^2}-1-A(x) }{2A(x)}$ (只考虑正的取值)</p><p>也就是找$1+2x+5x^2=y^2$ 的解</p><p>在pe 100 里面我们讨论过变形</p><p>$5+10+25x^2=5y^2$</p><p>$4+(1+5x)^2=5y^2$</p><p>$(1+5x)^2-5y^2=-4$</p><p>形式上是个pell方程右侧换成-4</p><h1 id="pell方程"><a href="#pell方程" class="headerlink" title="pell方程"></a>pell方程</h1><p>在做过66和100以后，回顾看看</p><p>66是pell方程，解一定是渐进分数，且一定有解，所有解能由基础解的幂次生成</p><p>100是pell方程右侧改为-1的方程，解一定是渐进分数，但没有证明到一定有解(d=34时似乎真的没解)，通过连分数的递推寻找</p><p>这里</p><p>我们关心一下和佩尔方程的关系</p><p>在pe66，100中我们的步骤是这样的</p><p>$x^2-d y^2 = \pm 1$</p><p>$|\sqrt{d}-\frac{x}{y}| = |\frac{dy^2-x}{y^2(\sqrt{d}+\frac{x}{y})}| &lt; \frac{1}{2y^2}$</p><p>然后满足上面不等式的一定是连分数的渐进分数</p><p>我们假设$x^2-dy^2 = c$</p><p>$\frac{x}{y} = \sqrt{d+\frac{c}{y^2}}$</p><p>上面式子的放缩部分是 $|\frac{c}{\sqrt{d}+\frac{x}{y}}| &lt; \frac{1}{2}$</p><p>$ |\frac{4}{\sqrt{5}+\sqrt{5-\frac{4}{y^2} } }| &lt; \frac{1}{2}$</p><p>当c比较大时 例如 $x^2-10y^2=9$ 有三组解答 $(7,2)…$, $(13,4)…$,$(57,18),…$</p><h1 id="如果为正"><a href="#如果为正" class="headerlink" title="如果为正"></a>如果为正</h1><p>考虑两组满足 $x^2-5y^2=-4$的值</p><p>根据pe100的结论，$(9+4\sqrt{5})^n$ 是 其佩尔方程的基础解对应的值</p><p>$1=\frac{x_0^2-dy_0^2}{x_1^2-dy_1^2} $</p><p>$= \frac{x_0+y_0\sqrt{d}}{x_1+y_1\sqrt{d}} \cdot \frac{x_0-y_0\sqrt{d}}{x_1-y_1\sqrt{d}}$</p><p>$= \frac{(x_0+y_0\sqrt{d})(x_1-y_1\sqrt{d})}{-4} \cdot \frac{(x_0-y_0\sqrt{d})(x_1+y_1\sqrt{d})}{-4}$</p><p>$= ((\frac{x_0x_1-y_0y_1d}{4})+(\frac{x_1y_0-x_0y_1}{4})\sqrt{d})((\frac{x_0x_1-y_0y_1d}{4})-(\frac{x_1y_0-x_0y_1}{4})\sqrt{d})$</p><p>$= (\frac{x_0x_1-y_0y_1d}{4})^2-(\frac{x_1y_0-x_0y_1}{4})^2 d $</p><p>说明两个不同的<code>-4</code>的解, 如果能让$x_1y_0-x_0y_1 = 0 (\pmod 4)$,那么它们之间一定是通过乘一个<code>=1</code>的解得到的,(之考虑y是因为如果y为整数且等式成立，那么x必为整数),也就是它们有同样的基础解</p><p>如果y是偶数，$y = 2k$,显然 x也是2的倍数，直接解 $(2x)^2-5(2y)^2=-4$,$x^2-5y^2=-1$ 解之即可</p><p>如果y是奇数, x也是奇数</p><p>根据mod 4进行分类</p><p>$(4k_0+1,4k_1+1) ,(4k_0+3,4k_1+3)$ 有同样的基础解(如果有解) </p><p>$(4k_0+1,4k_1+3) ,(4k_0+3,4k_1+1)$ 有同样的基础解(如果有解)</p><p>所以最后分为3类</p><p>注意到基础解的幂次可乘性, 考虑<code>(x,y)</code>为最小全正解，$x&gt;0,y&gt;0$</p><p>$(x+y\sqrt{5})(9+4\sqrt{5})^{-1} = (x+y\sqrt{5})(9-4\sqrt{5})$</p><p>$ = ((9x-20y)+(9y-4x)\sqrt{5})$ , 因为是最小正解，所以再次乘积后 $9x-20y &lt; 0$ 或 $9y-4x&lt;0$</p><p>$ \frac{x}{y} &lt; \frac{20}{9} 或  \frac{x}{y} &gt; \frac{9}{4}$ </p><p>$ \sqrt{5-\frac{4}{y^2}} &lt; \frac{20}{9} 或  \sqrt{5-\frac{4}{y^2}} &gt; \frac{9}{4}$ </p><p>$\frac{2}{\sqrt{5}} \le y &lt; \frac{18}{\sqrt{5}} 约 8.049844718999243 $</p><p>要尝试的y有限</p><p>综上原题可解</p><h1 id="Code-1"><a href="#Code-1" class="headerlink" title="Code 1"></a>Code 1</h1><p>尝试8以内</p><pre><code class="py">def isSquare(v):    if v == 1:        return True    l = 1    r = v    while l+1 &lt; r:        m = (l+r)//2        if m*m == v:            return True        if m*m &gt; v:            r = m        else:            l = m    return Falsedef main():    for i in range(1, 9):        if isSquare(5*i*i-4):            print(i)main()</code></pre><p>运行得到基础解</p><pre><code>1 14 211 5</code></pre><h1 id="Code2"><a href="#Code2" class="headerlink" title="Code2"></a>Code2</h1><pre><code class="py">def main():    arr = [(1,1),(4,2),(11,5)]    cnt = 0    while cnt &lt; 15:        for i in range(len(arr)):            x,y = arr[i]            if x &gt; 1 and (x-1)%5==0:                cnt+=1                print((x-1)//5)            arr[i] = (9*x+20*y,9*y+4*x)main()</code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://math.stackexchange.com/questions/742181/find-all-integer-solutions-for-the-equation-5x2-y2-4" target="_blank" rel="noopener">https://math.stackexchange.com/questions/742181/find-all-integer-solutions-for-the-equation-5x2-y2-4</a></p><p><a href="https://math.stackexchange.com/questions/1088277/fermats-difference-equation-pells-equation" target="_blank" rel="noopener">https://math.stackexchange.com/questions/1088277/fermats-difference-equation-pells-equation</a></p>]]></content>
      
      
      <categories>
          
          <category> Project Euler </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pe </tag>
            
            <tag> project euler </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>project euler 066 diophantine equation(重新整理中...)</title>
      <link href="/Blog/2020-12-05-project-euler066_new/"/>
      <url>/Blog/2020-12-05-project-euler066_new/</url>
      
        <content type="html"><![CDATA[<h1 id="解pell方程"><a href="#解pell方程" class="headerlink" title="解pell方程"></a>解pell方程</h1><p>就过程进行书写，去掉自己尝试思考的中间步骤，只留下有效的过程</p><p><a href="http://yexiaorain.github.io/Blog/2020-05-29-project-euler066/">初版文章</a></p><h2 id="原题目"><a href="#原题目" class="headerlink" title="原题目"></a>原题目</h2><p><a href="https://projecteuler.net/problem=66" target="_blank" rel="noopener">https://projecteuler.net/problem=66</a></p><p>d = 1-&gt;1000，d是非平方数</p><p>对于每个d 求最小的正整数<code>x</code>使得$x^2-dy^2=1$，其中x,y都是正整数,</p><p>最后对所有这些x求最大的x</p><blockquote><p>本文针对给定的d讨论具体的方程解法</p></blockquote><h1 id="读懂本文你可能需要的前置知识"><a href="#读懂本文你可能需要的前置知识" class="headerlink" title="读懂本文你可能需要的前置知识"></a>读懂本文你可能需要的前置知识</h1><p>抽屉原理</p><p>二元一次方程</p><p>绝对值</p><p>有理数/无理数</p><p>模运算</p><p>矩阵运算</p><p>数列/递推数列</p><p>二项式展开</p><p>反证法</p><p>归纳法</p><p>不等式(缩放，三角不等式)</p><p>共轭实数(不太知道怎么翻译比较好，还是对偶实数？ 描述的就是$a+b\sqrt{m}$与$a-b\sqrt{m}$</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><img src="/Blog/img/20201205pe066.png" alt="2020 12 05 pe 066"></p><h2 id="pell方程的解"><a href="#pell方程的解" class="headerlink" title="pell方程的解"></a>pell方程的解</h2><h3 id="解的性质-基础解"><a href="#解的性质-基础解" class="headerlink" title="解的性质(基础解)"></a>解的性质(基础解)</h3><p>如果解存在</p><h4 id="任意两个解能生成新的解"><a href="#任意两个解能生成新的解" class="headerlink" title="任意两个解能生成新的解"></a>任意两个解能生成新的解</h4><p>如果$(x_0,y_0),(x_1,y_1)$ 是 $x^2-d \cdot y^2=1$ 的解</p><p>$1 = (x_0^2-d\cdot y_0^2)(x_1^2-d\cdot y_1^2)$</p><p>$= (x_0 + \sqrt{d} y_0)(x_0 - \sqrt{d} y_0)(x_1 + \sqrt{d} y_1)(x_1 - \sqrt{d} y_1)$</p><p>$= (x_0 + \sqrt{d} y_0)(x_1 + \sqrt{d} y_1)(x_0 - \sqrt{d} y_0)(x_1 - \sqrt{d} y_1)$</p><p>$= (x_0x_1 + dy_0 y_1 + \sqrt{d} (y_0x_1+y_1 x_0))(x_0x_1 + dy_0 y_1 + \sqrt{d} (y_0x_1+y_1x_0))$</p><p>$= (x_0x_1 + dy_0 y_1)^2 - d(y_0x_1+y_1 x_0)^2$</p><p>那么 这样能够生成$(x_0x_1 + dy_0y_1, y_0x_1+y_1x_0)$解</p><p>如果我们定义 $A(x,y) = x+\sqrt{d}y$,那么有 $A(x_0,y_0)\cdot A(x_1,y_1)$生成的A对应的x和y是另一组解</p><h4 id="存在一个基础解-最小解-，所有解都是由基础解生成的"><a href="#存在一个基础解-最小解-，所有解都是由基础解生成的" class="headerlink" title="存在一个基础解(最小解)，所有解都是由基础解生成的"></a>存在一个基础解(最小解)，所有解都是由基础解生成的</h4><p><strong>下面证明所有解都是最小解生成的</strong></p><p>因为y越大x越大,设$(x_1,y_1)$为最小解,$(x_k,y_k)$不是由最小解上述幂次方法生成的一个解</p><p>根据y越大x越大的性质，则存在一个整数n</p><p>$(x_1+y_1 \cdot \sqrt{d})^n &lt; (x_k+y_k \cdot \sqrt{d}) &lt; (x_1+y_1 \cdot \sqrt{d})^{n+1} $</p><p>同时乘$(x_1-y_1 \cdot \sqrt{d})^n$有</p><p>$1 &lt; (x_k+y_k \cdot \sqrt{d}) \cdot (x_1-y_1 \cdot \sqrt{d})^n &lt; (x_1+y_1 \cdot \sqrt{d}) $</p><p>注意到中间的表达式 也是满足参数形式的 也是一组解(并且因为$\frac{x_1}{y_1} = \sqrt{\frac{1}{y_1^2}+d} &gt; \sqrt{\frac{1}{y_k^2}+d} = \frac{x_k}{y_k}$,所以参数均为正数 )</p><p>这与最小解定义冲突，所以所有解都是最小解生成的</p><h3 id="解的存在性证明"><a href="#解的存在性证明" class="headerlink" title="解的存在性证明"></a>解的存在性证明</h3><h4 id="引理1，无穷多对整数满足给定不等式"><a href="#引理1，无穷多对整数满足给定不等式" class="headerlink" title="引理1，无穷多对整数满足给定不等式"></a>引理1，无穷多对整数满足给定不等式</h4><p>存在无穷多对整数(x,y)满足 $|x-y\sqrt{d}|&lt;\frac 1y$</p><p>取正整数$q_0 &gt; 1$</p><p>取$t=1,…,q_0+1$ 共计$q_0+1$个</p><p>把区间$[0,1)$等分为$q_0$部分，则每部分长度为$\frac 1{q_0}$,考虑 $t \sqrt{d}$的小数部分(t为整数)，必定有两个落在同一区间 所以存在$0\leq i&lt;j\leq q_0$使得 $| \{t_i \sqrt{d}\} - \{t_j \sqrt{d}\} | &lt;\frac 1{q_0}$</p><p>即$|x-(t_j-t_i)\sqrt{d}| =  | \{t_i \sqrt{d}\} - \{ t_j \sqrt{d}\} | &lt; \frac 1{q_0} \leq  \frac 1{t_j-t_i}$</p><p>这里要注意的是我们知道i&lt;j,和它们的小数部分落在同一个区间，所以这里应该是它们的小数部分相减的绝对值，而不是相减的绝对值的小数部分，例如q取2, 一个取0.4,一个1.3,它们都在[0,0.5)的区间里，但是如果$|1.3-0.4|$ 再取绝对值的小数部分，得到的是0.9而不是0.1,对于x来说，只要增减1就能在最终的值上切换成功.</p><p>把$t_j-t_i$ 看作y得到一个解</p><p>取$\frac 1{q_1} &lt; |x-(t_j-t_i)\sqrt{d}|$</p><p>可以得到新的解(因为同一个y最多有两种 $|x-y\sqrt{d}|$的小数部分，反复如此可生成无限个解</p><p>取$|x_3-y_3\sqrt{d}| &lt;\frac 1{q_3} &lt; |x_2-y_2 \sqrt{d}| &lt; \frac 1{q_2} &lt; |x_1-y_1\sqrt{d}| &lt;\frac 1{q_1} &lt; |x_0-y_0 \sqrt{d}| &lt; \frac 1{q_0} $</p><h4 id="基于引理1-配出pell方程的解"><a href="#基于引理1-配出pell方程的解" class="headerlink" title="基于引理1,配出pell方程的解"></a>基于引理1,配出pell方程的解</h4><p>对于这无限个解</p><p>0 &lt; $\left|x^2-dy^2\right|=\left|x+y\sqrt{d}\right|\cdot\left|x-y\sqrt{d}\right|=\left|x-y\sqrt{d}+2y\sqrt{d}\right|\cdot\left|x-y\sqrt{d}\right|\leq (\left|x-y\sqrt{d}\right|+\left|2y\sqrt{d}\right|)\cdot\left|x-y\sqrt{d}\right|&lt;\left(2y\sqrt{d}+\frac{1}{y}\right)\cdot\frac{1}{y}\le 2\sqrt{d}+\frac 1{y^2}$</p><p>说明这无限个(x,y)的取值,对$|x^2-dy^2|$的计算结果是有限范围内的整数</p><blockquote><p>如果你看下面我提供的youtube链接，你会发现证明的细节步骤会有些差别，视频里，并没有这么精细的放缩，因为最终目的只需要证明有限个取值，而在中间直接放缩道 &lt;= |3y根号d|。</p></blockquote><p>再一次根据抽屉原理，存在正整数k,使得$|x^2-dy^2|=k$的解有无限个</p><p>考虑这些解$(x \bmod k,y \bmod k)$ , 可以的方案数$\leq k^2$,也是有限的，</p><p>再根据抽屉原理，存在$(M_x,M_y)$，使得无限个i， $s.t. (x_i \bmod k, y_i \bmod k) = (M_x,M_y)$,在这无限组中取两组$(x_1,y_1),(x_2,y_2)$</p><p>令 $X=|\frac{x_1x_2-y_1y_2d}{k}|,Y=|\frac{x_2y_1-x_1y_2}{k}|$</p><p>有 $X^2-d \cdot Y^2 = \frac{(x_1^2-d \cdot y_1^2)(x_2^2-d \cdot y_2^2)}{k^2} = 1$</p><p>因为 $(x_2y_1-x_1y_2)\bmod k = (x_1y_1-x_1y_1) \bmod k = 0 \bmod k = 0$,所以Y是整数</p><p>因为$X$是有理数且满足pell方程，所以它是整数</p><p>显然$X = \sqrt{1+dY^2}$ 不为0</p><p>注意到 $x^2-dy^2$ 的取值范围为 $\pm k$ (有限个 ，2个)，但可取的$(x,y)$有无限对，再一次抽屉原理,因此存在$(x_i,y_i)\neq(x_j,y_j)$使得 $x_i^2-dy_i^2=x_j^2-dy_j^2$ 这时 $\frac{x_i}{y_i} \neq \frac{x_j}{y_j}$ (否则代入前式子得到$x_i=x_j$), 即Y不为0,Y为正整数</p><p>综上，一定存在解</p><blockquote><p>注，上面X,Y的等式看着很突兀，但在看了Youtube视频之后意识到了， 既然 基础解的幂次能有效，且证明了负幂次也有效，那么 $ x^2-dy^2 = 1 = k/k = \frac{x_1^2-dy_1^2}{x_2^2-dy_2^2}$ 然后通分化简就有了上面那个显得突兀的<code>令</code></p></blockquote><h4 id="pell方程性质小结"><a href="#pell方程性质小结" class="headerlink" title="pell方程性质小结"></a>pell方程性质小结</h4><p>关于 pell方程 ，我们现在有了 一定存在解，且存在一个最小解的基础解，两个结论，下面开始看看连分数。</p><h2 id="连分数"><a href="#连分数" class="headerlink" title="连分数"></a>连分数</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>形如</p><p>$\alpha = a_0 + \cfrac{1}{a_1 + \cfrac{1}{a_2 + \cfrac{1}{a_3 + \cfrac{1}{\ddots\,}}}} $</p><p>例如 </p><p>$ \sqrt{2} = 1 + \frac{1}{2 + \cfrac{1}{2 + \cfrac{1}{2 + \cfrac{1}{2 + \cfrac{1}{2 + \cfrac{1}{2 + \ddots}}}}}} $</p><p>展开的剩余部分是在<code>[0,1)</code>之间</p><h3 id="性质1-所有无限连分数都是无理数。"><a href="#性质1-所有无限连分数都是无理数。" class="headerlink" title="性质1 所有无限连分数都是无理数。"></a>性质1 所有无限连分数都是无理数。</h3><p>证明：如果一个数是有理数，把它写成分数的形式，再按照连分数的方式展开，你会发现这过程就是辗转相除，分子分母单调递减 所以一定有限，它的逆否命题就是要证明的性质</p><h3 id="渐进分数-分子，分母等性质"><a href="#渐进分数-分子，分母等性质" class="headerlink" title="渐进分数(分子，分母等性质)"></a>渐进分数(分子，分母等性质)</h3><h4 id="分子分母递推式"><a href="#分子分母递推式" class="headerlink" title="分子分母递推式"></a>分子分母递推式</h4><p>渐进分数，把上述表示无理数$\alpha$的连分数部分截断所得到的分数</p><p>假设h,k分别为渐进分数的分子和分母,根据简化为分数的过程</p><p>$\begin{bmatrix} h_n &amp; k_n \end{bmatrix} = \begin{bmatrix} 1 &amp; 0 \end{bmatrix} \cdot \begin{bmatrix} a_n &amp; 1 \\ 1 &amp; 0 \end{bmatrix}  \cdot \begin{bmatrix} a_{n-1} &amp; 1 \\ 1 &amp; 0 \end{bmatrix}  \cdots \begin{bmatrix} a_0 &amp; 1 \\ 1 &amp; 0 \end{bmatrix} $</p><p>然而这不好建立递推关系,稍做变形</p><p>$\begin{bmatrix} h_n &amp; k_n \\ ? &amp; ? \end{bmatrix} = \begin{bmatrix} 1 &amp; 0 \\ 0 &amp; 1 \end{bmatrix} \cdot \begin{bmatrix} a_n &amp; 1 \\ 1 &amp; 0 \end{bmatrix}  \cdot \begin{bmatrix} a_{n-1} &amp; 1 \\ 1 &amp; 0 \end{bmatrix}  \cdots \begin{bmatrix} a_0 &amp; 1 \\ 1 &amp; 0 \end{bmatrix} $</p><p>$\begin{bmatrix} h_n &amp; k_n \\ ? &amp; ? \end{bmatrix} = \begin{bmatrix} a_n &amp; 1 \\ 1 &amp; 0 \end{bmatrix}  \cdot \begin{bmatrix} a_{n-1} &amp; 1 \\ 1 &amp; 0 \end{bmatrix}  \cdots \begin{bmatrix} a_0 &amp; 1 \\ 1 &amp; 0 \end{bmatrix} $</p><p>$\begin{bmatrix} h_n &amp; k_n \\ ? &amp; ? \end{bmatrix} = \begin{bmatrix} a_n &amp; 1 \\ 1 &amp; 0 \end{bmatrix}  \cdot \begin{bmatrix} h_{n-1} &amp; k_{n-1} \\ ? &amp; ? \end{bmatrix} $</p><p>显然左式的底部可以确定</p><p>$\begin{bmatrix} h_n &amp; k_n \\ h_{n-1} &amp; k_{n-1} \end{bmatrix} = \begin{bmatrix} a_n &amp; 1 \\ 1 &amp; 0 \end{bmatrix}  \cdot \begin{bmatrix} h_{n-1} &amp; k_{n-1} \\ ? &amp; ? \end{bmatrix} $</p><p>又因为递推关系，右边式子相当于左式带入n-1</p><p>$\begin{bmatrix} h_n &amp; k_n \\ h_{n-1} &amp; k_{n-1} \end{bmatrix} = \begin{bmatrix} a_n &amp; 1 \\ 1 &amp; 0 \end{bmatrix}  \cdot \begin{bmatrix} h_{n-1} &amp; k_{n-1} \\ h_{n-2} &amp; k_{n-2} \end{bmatrix} $</p><p>综上</p><p>$h_n = a_n \cdot h_{n-1} + h_{n-2}$<br>$k_n = a_n \cdot k_{n-1} + k_{n-2}$</p><p>渐进值 $\frac{h_n}{k_n} = \frac{a_n \cdot h_{n-1} + h_{n-2}}{a_n \cdot k_{n-1} + k_{n-2}}$</p><p>且根据计算过程，可知 $h_n,k_n$互质</p><h4 id="分子分母-相关等式"><a href="#分子分母-相关等式" class="headerlink" title="分子分母 相关等式"></a>分子分母 相关等式</h4><p>由上面的递推关系再递推有</p><p>$k_nh_{n-1}-k_{n-1}h_n=-(k_{n-1}h_{n-2}-k_{n-2}h_{n-1})=(-1)^n $, </p><p>$k_nh_{n-2}-k_{n-2}h_n=a_n(k_{n-1}h_{n-2}-k_{n-2}h_{n-1})=a_n(-1)^{n-1} $, </p><p>设无理数$\alpha$ 的精确表示为$[a_0,a_1,…,a_n,x_{n+1}]$,即是最后$a_{n+1}$替换为精确的非整数值$x_{n+1}$,有$1\leq a_{n+1}&lt;x_{n+1}&lt;a_{n+1}+1,(n&gt;=1)$</p><h4 id="原无理数与渐进数的差值表达式"><a href="#原无理数与渐进数的差值表达式" class="headerlink" title="原无理数与渐进数的差值表达式"></a>原无理数与渐进数的差值表达式</h4><p>根据上方计算渐进值得到的公式，同理递推式有</p><p>$\alpha =\frac{x_{n+1}h_n+h_{n-1}}{x_{n+1}k_n+k_{n-1}}  $</p><p>$\alpha - \frac{h_n}{k_n} =\frac{x_{n+1}h_n+h_{n-1}}{x_{n+1}k_n+k_{n-1}} -\frac{h_n}{k_n} $</p><p>$=\frac{h_{n-1}k_{n}-h_nk_{n-1}}{k_n(x_{n+1}k_n+k_{n-1})}$</p><p>$=\frac{(-1)^n}{k_n(x_{n+1}k_n+k_{n-1})}$</p><p>$|\alpha -\frac{h_n}{k_n}| =\frac{1}{k_n(x_{n+1}k_n+k_{n-1})} &lt; \frac{1}{k_n(a_{n+1}k_n+k_{n-1})} = \frac{1}{k_nk_{n+1}}$</p><p>注意到k的递推式，容易发现它是单调递增的正整数,所以渐进分数真的是趋近(n趋于无限大，渐进分数趋进原无理数)</p><h4 id="原无理数与渐进数的差值绝对值单调递减"><a href="#原无理数与渐进数的差值绝对值单调递减" class="headerlink" title="原无理数与渐进数的差值绝对值单调递减"></a>原无理数与渐进数的差值绝对值单调递减</h4><p>$|k_n\alpha - h_n|$单调递减。</p><p>证明:</p><p>$|k_n\alpha - h_n| - |k_{n-1}\alpha - h_{n-1}|$</p><p>$ = |k_n(\alpha - \frac{h_n}{k_n})| - |k_{n-1}(\alpha - \frac{h_{n-1}}{k_{n-1}})|$</p><p>$ = \frac 1{x_{n+1}k_n+k_{n-1}} - \frac 1{x_{n}k_{n-1}+k_{n-2}} $</p><p>$ = \frac {(x_{n}k_{n-1}+k_{n-2})-(x_{n+1}k_n+k_{n-1})}{(x_{n+1}k_n+k_{n-1})(x_{n}k_{n-1}+k_{n-2})}$</p><p>$ = \frac {((a_n+\frac 1{x_{n+1}})k_{n-1}+k_{n-2})-(x_{n+1}k_n+k_{n-1})}{(x_{n+1}k_n+k_{n-1})(x_{n}k_{n-1}+k_{n-2})}$</p><p>$ = \frac {(x_{n+1}(a_nk_{n-1}+k_{n-2})+k_{n-1})-x_{n+1}(x_{n+1}k_n+k_{n-1})}{x_{n+1}(x_{n+1}k_n+k_{n-1})(x_{n}k_{n-1}+k_{n-2})}$</p><p>$ = \frac {(x_{n+1}k_n+k_{n-1})-x_{n+1}(x_{n+1}k_n+k_{n-1})}{x_{n+1}(x_{n+1}k_n+k_{n-1})(x_{n}k_{n-1}+k_{n-2})}$</p><p>$ = \frac {(1-x_{n+1})(x_{n+1}k_n+k_{n-1})}{x_{n+1}(x_{n+1}k_n+k_{n-1})(x_{n}k_{n-1}+k_{n-2})} &lt; 0$</p><hr><p>由此也可知$|\alpha - \frac{h_n}{k_n}|$单调递减</p><p>$|\alpha - \frac{h_n}{k_n}|-|\alpha -\frac{h_{n-1}}{k_{n-1}}|$</p><p>$=\frac {|{k_n}\alpha-{h_n}|-\frac {k_n}{k_{n-1}}|{k_{n-1}}\alpha-{h_{n-1}}|}{k_n}$</p><p>$&lt;\frac {|{k_n}\alpha-{h_n}|-|{k_{n-1}}\alpha-{h_{n-1}}|}{k_n} &lt; 0$</p><p>// 或者因为$k_n$单调递增</p><h4 id="和渐进数同分母的所有分数中，渐进数最接近原无理数"><a href="#和渐进数同分母的所有分数中，渐进数最接近原无理数" class="headerlink" title="和渐进数同分母的所有分数中，渐进数最接近原无理数"></a>和渐进数同分母的所有分数中，渐进数最接近原无理数</h4><p>若$(h_n,k_n)$是一个渐进分数，则对于分母$k_n$,分子取$h_n$时，整个分数最接近原无理数</p><p>取任意$h\neq h_n$,根据三角不等式</p><p>$|\alpha -\frac{h}{k_n}| \geq |\frac{h-h_n}{k_n}| - |\alpha - \frac{h_n}{k_n}|$</p><p>$&gt;\frac 1{k_n} - \frac 1{k_nk_{n+1}} $,因为n足够大 $k_{n+1}&gt;=3$有</p><p>$&gt; \frac 1{k_n} - \frac 1{2k_n} $</p><p>$=\frac 1{2k_n} $</p><p>$&gt;  \frac 1{k_nk_{n+1}} &gt; |\alpha -\frac{h_n}{k_n}|$</p><p>证明了$h_n$是最接近的分子</p><p>即 $|k_n\alpha - h|$在 $h=h_n$时取最小值</p><h4 id="分母小于等于渐进数的分母的所有分数中，渐进数能使-分子x原无理数-分母-取最小值"><a href="#分母小于等于渐进数的分母的所有分数中，渐进数能使-分子x原无理数-分母-取最小值" class="headerlink" title="分母小于等于渐进数的分母的所有分数中，渐进数能使|分子x原无理数-分母|取最小值"></a>分母小于等于渐进数的分母的所有分数中，渐进数能使|分子x原无理数-分母|取最小值</h4><p>下面证明在$(0&lt;k\leq k_n)$中，对于所有$(h,k)$，有$|k_n\alpha -  h_n|$为最小值</p><p>考虑任意$(h,k),(0&lt;k&lt;k_n)$，且$\frac hk$的最简分数不是渐进数，（因为已经证明了渐进数随着n增大$|k\alpha - h|$单调递减，且渐进数分子分母互质，所以如果最简分数是渐进数则对应渐进数的该表达式 更大，又是分子分母是渐进数的倍数，则该表达式的结果还要乘上倍数会更大）</p><p>// 同时它是最简分数，因为上表达式 带入分数和其最简分数得到的值刚好是其分子和其最简分数的分子的比值的倍数</p><p>设二元一次方程组</p><p>$h_nx+h_{n-1}y=h$</p><p>$k_nx+k_{n-1}y=k$</p><p>则有$(x,y)=(\frac {hk_{n-1}-kh_{n-1}}{h_nk_{n-1}-h_{n-1}k_n},\frac {hk_{n}-kh_{n}}{h_nk_{n-1}-h_{n-1}k_n}) = ((-1)^{n-1}(hk_{n-1}-kh_{n-1}),(-1)^{n-1}(hk_{n}-kh_{n}))$</p><p>因为$\frac hk$不是渐进分数，所以$x,y$都是非零整数，又因为$k&lt;k_n$和$k_nx+k_{n-1}y=k$有:$x,y$异号</p><p>因为$\alpha - \frac {h_n}{k_n}$的分子为$(-1)^n$,分母为正数,</p><p>因此$\alpha - \frac {h_n}{k_n}$和$\alpha - \frac {h_{n-1}}{k_{n-1}}$异号</p><p>$k_n\alpha - {h_n}$和$k_{n-1}\alpha - {h_{n-1}}$异号</p><p>$x(k_n\alpha - {h_n})$和$y(k_{n-1}\alpha - {h_{n-1}})$同号</p><p>$|k\alpha -h| = |(k_nx+k_{n-1}y)\alpha - (h_nx+h_{n-1}y)|$</p><p>$= |x(k_n\alpha - {h_n}) + y(k_{n-1}\alpha - {h_{n-1}})|$,因为同号：</p><p>$= |x(k_n\alpha - {h_n})|+|y(k_{n-1}\alpha - {h_{n-1}})|$，因为$x,y$非零整数:</p><p>$|k\alpha - h| &gt; |k_n\alpha - {h_n}|$且$|k\alpha -h|&gt;|k_{n-1}\alpha - {h_{n-1}}|$</p><p>内容得证</p><h4 id="连续的两个渐进数中至少有一个满足pell方程必要的不等式"><a href="#连续的两个渐进数中至少有一个满足pell方程必要的不等式" class="headerlink" title="连续的两个渐进数中至少有一个满足pell方程必要的不等式"></a>连续的两个渐进数中至少有一个满足pell方程必要的不等式</h4><p>至于为什么是这个标题 见后面的部分</p><p>连续的两个渐进数中至少有一个满足，$|\alpha - \frac hk|&lt;\frac 1{2k^2}$</p><p>证明:</p><p>假设都不满足，有</p><p>$0 \leq |\alpha-\frac{h_{n+1}}{k_{n+1}}| - \frac{1}{2k_{n+1}^2} + |\alpha-\frac{h_{n}}{k_{n}}|-\frac{1}{2k_{n}^2}$, 因为$\alpha - \frac{h_{n}}{k_{n}}$正负交替,所以</p><p>$ = |\frac{h_{n+1}}{k_{n+1}}-\frac{h_{n}}{k_{n}}|-\frac 1{2k_{n+1}^2} -\frac 1{2k_{n}^2}$</p><p>$ = |\frac{h_{n+1}k_{n}-h_{n}k_{n+1}}{k_{n+1}k_{n}}|-\frac 1{2k_{n+1}^2} -\frac 1{2k_{n}^2}$</p><p>$ = \frac 1{k_nk_{n+1}} -\frac 1{2k_{n+1}^2} -\frac 1{2k_{n}^2}$</p><p>$ = \frac 1{k_nk_{n+1}} -\frac 1{2k_{n+1}^2} -\frac 1{2k_{n}^2}$</p><p>$ = \frac {-(k_n-k_{n+1})^2}{2k_{n}^2k_{n+1}^2} &lt; 0$</p><p>矛盾</p><p>因此至少有一个大于满足 得证</p><h4 id="任何最简分数如果满足pell方程必要的不等式，那么它是一个渐进分数"><a href="#任何最简分数如果满足pell方程必要的不等式，那么它是一个渐进分数" class="headerlink" title="任何最简分数如果满足pell方程必要的不等式，那么它是一个渐进分数"></a>任何最简分数如果满足pell方程必要的不等式，那么它是一个渐进分数</h4><p>任何最简分数如果满足$|\alpha - \frac hk|&lt;\frac 1{2k^2}$，那么它是个渐进分数</p><p>证明</p><p>设$\frac hk$满足不等式$|\alpha - \frac hk|&lt;\frac 1{2k^2}$，则存在n使得渐进数分母满足 $k_{n+2}&gt;k&gt;=k_n $且$\frac {h_n}{k_n}$满足$|\alpha - \frac hk|&lt;\frac 1{2k^2}$(因为相邻渐进数必有一个满足,这里是取n和n+2之间)，根据上面的不等式 有$|k_n\alpha- h_n| &lt; |k\alpha - h|$，若$\frac hk \neq \frac{h_n}{k_n}$,即$k_n &lt; k$</p><p>$0 \leq \frac{|hk_n-h_nk|-1}{kk_n}$</p><p>$= |\frac{h}{k}-\frac{h_n}{k_n}|-\frac{1}{kk_n}$,因为三角不等式，有</p><p>$\leq |\alpha -\frac{h}{k}|+|\alpha -\frac{h_n}{k_n}|-\frac{1}{kk_n}$, 因为假设满足的不等式</p><p>$&lt; \frac 1{2k^2} + \frac 1{k_n}|k_n\alpha - h_n|-\frac{1}{kk_n}$,因为上面的最小接近</p><p>$&lt; \frac 1{2k^2} + \frac 1{k_n}|k\alpha - h|-\frac{1}{kk_n}$</p><p>$= \frac 1{2k^2} + \frac {k}{k_n}|\alpha - \frac hk|-\frac{1}{kk_n}$因为假设满足的不等式</p><p>$&lt; \frac 1{2k^2} + \frac {k}{k_n}\cdot \frac 1{2k^2}-\frac{1}{kk_n}$</p><p>$= \frac {k_n-k}{2k^2k_n} &lt; 0$</p><p>矛盾，因此$\frac hk$和某个渐进数相等</p><p><strong>注记：最开始该文的版本，的渐进分数的部分直接使用的是pell方程中$\sqrt{d}$,其中d是非平方正整数，但为了写100需要的证明，需要把它扩充到实数，（当然也是成立的），所以这部分改写了一次</strong></p><h3 id="Lagrange’s-Theorem-二次无理数与有循环节的连分数"><a href="#Lagrange’s-Theorem-二次无理数与有循环节的连分数" class="headerlink" title="Lagrange’s Theorem 二次无理数与有循环节的连分数"></a>Lagrange’s Theorem 二次无理数与有循环节的连分数</h3><p>quadratic irrational(二次无理数) : 二次整式多项式的根 $\frac{-b\pm \sqrt{b^2-4ac}}{2a}$ 或者形如$\frac{P+\sqrt{D}}{Q}$</p><p> An irrational number is quadratic irrational if and only if its continued fraction is periodic.</p><h4 id="循环连分数一定是二次无理数"><a href="#循环连分数一定是二次无理数" class="headerlink" title="循环连分数一定是二次无理数"></a>循环连分数一定是二次无理数</h4><blockquote><p>先证明简单的一侧，循环连分数一定是二次根式的根。</p></blockquote><p>按照连分数的写法，将循环节设为t</p><p>显然还原为分数,有$x=\frac{a t + b}{c t +d},t = \frac{et+f}{gt+h}$ 变换左表达式t是x的函数，带入右侧表达式得到$\frac{ix+j}{kx+l} = \frac{mx+n}{ox+p}$,其中字母$a-p$均为整数，且注意到x为无理数，所以化简后一定是二次方程</p><h4 id="二次无理数一定是循环连分数"><a href="#二次无理数一定是循环连分数" class="headerlink" title="二次无理数一定是循环连分数"></a>二次无理数一定是循环连分数</h4><blockquote><p>再证明二次根式的根一定能表达为有循环节的连分数</p></blockquote><p>定义,u对于无理数x</p><p>$f(x) = x-1 (x&gt;1)$</p><p>$f(x) = \frac{1}{\frac{1}{x}-1} , (x&lt;1)$</p><p>对应到连分展开，即是将首个数字减少1,(x&gt;1时就是a0减去1,x&lt;1时就是a1减去1)</p><p>令$x1=x,x_{n+1}=f(x_n)$,可以知道 这是一个无限数列</p><p>如果x满足$ax^2+bx+c=0$,写作$x\in[a,b,c]$</p><p>那么x-1 满足$a(x-1)^2+(2a+b)(x-1)+(a+b+c) = ax^2+b+c=0$</p><p>那么$\frac{x}{1-x}$ 满足$(a+b+c)(\frac{x}{1-x})^2+(b+2c)\frac{x}{1-x}+c = 0$</p><p>所以f(x)满足 $f(x)\in [a,2a+b,a+b+c]$ 或 $f(x)\in [a+b+c,b+2c,c]$</p><p>不失一般性，写作$x_n\in[s_n,t_n,u_n]$,有 $s_n &gt; 0$, 否则把三元组同时换号</p><p>注意到上式 $(2a+b)^2-4a(a+b+c)=b^2-4ac=(b+2c)^2-4(a+b+c)c$</p><p>说明了 $t_n^2-4s_nu_n$是和n无关的值</p><p>如果只有有限个$u&lt;0$,那么从某一处开始，$s&gt;0,u&gt;0$且$t&lt;0$(因为 x &gt; 0)</p><p>那么意味着 $-t$ 严格单调递减并且非负，(因为 t的变化关系是 t=2s+t或者 t=t+2u),矛盾</p><p>所以有无限个$s_nu_n&lt;0$</p><p>注意到 $t_n^2-4s_nu_n$是常数，所以 至少有一个三元组$[s_n,t_n,u_n]$ 出现了三次,一个二次方程有两个解，所以有满足的$x_n=x_m,m&gt;n$</p><p>得证 连分数展开有循环</p><p>Theorem 1. If x is a positive quadratic irrational then its continued fraction is eventually periodic.</p><h3 id="Galois’-Theorem-纯循环连分数与reduced二次无理数"><a href="#Galois’-Theorem-纯循环连分数与reduced二次无理数" class="headerlink" title="Galois’ Theorem 纯循环连分数与reduced二次无理数"></a>Galois’ Theorem 纯循环连分数与reduced二次无理数</h3><p>Definition 1.24. x 是二次无理数的根，$\overline{x}$ 是另一个根，那么如果 x &gt; 1 且 $-1 &lt; \overline{x} &lt; 0$.那么称 x 为 reduced</p><p>Theorem 1.25. (Galois’ Theorem) 无理数a. a是纯循环连分数（从a0开始的循环节），当且仅当 x is reduced. If $x = [\overline{a_0, a_1, a_2, . . . , a_{l−1}}]$ and $\overline{x}$ 是它共轭实数, then $-\frac{1}{x} = [\overline{a_{l−1}, . . . , a_2, a_1}].$</p><h4 id="reduced二次无理数-是-纯循环连分数"><a href="#reduced二次无理数-是-纯循环连分数" class="headerlink" title="reduced二次无理数 是 纯循环连分数"></a>reduced二次无理数 是 纯循环连分数</h4><p>设二次无理数$x=[a_0,a_1,…,a_n], x&gt;1,-1&lt;\overline{x}&lt;0$</p><p>那么有 $x_{n+1}=\frac{1}{x_n-a_n}$ // 表示 按照展开从n处向后取值</p><p>$\overline{x_{n+1}} = \frac{1}{\overline{x_n-a_n}} = \frac{1}{\overline{x_n}-a_n}$,(因为 两个形如$A+B\sqrt{C}$的无理数相乘为有理数，说明相乘后的无理数的系数为0,所以更改其中一个无理数的系数的正负，另一个无理数系数的正负更改即可)</p><p>注意到$x_1 \ge 1$有$a_0 \ge 1$,所以 $a_n \ge 1$</p><p>下面归纳证明 $-1 &lt; \overline{x_n} &lt; 0 $</p><p>若 $-1 &lt; \overline{x_n} &lt; 0$</p><p>有 $\frac{1}{\overline{x_{n+1}}} = \overline{x_n} - a_n &lt; -1$</p><p>即 $-1 &lt; \overline{x_{n+1}} &lt; 0$，得证</p><p>$-1 &lt; \overline{x_n} = \frac{1}{\overline{x_{n+1}}}+a_n &lt; 0$</p><p>$ 1 &gt; -\frac{1}{\overline{x_{n+1}}}-a_n &gt; 0$</p><p>$ a_n = [ -\frac{1}{\overline{x_{n+1}}} ] $ // 也就是$a_n$等于分式的整数部分</p><p>因为上面已经证明 如果是二次无理数，那么必定有循环节，所以存在$x_i = x_j,(i &lt; j )$</p><p>即$\overline{x_i}=\overline{x_j}$</p><p>即$a_{i-1}=[-\frac{1}{\overline{x_i}}]=[-\frac{1}{\overline{x_j}}] = a_{j-1}$</p><p>即$x_{i-1}=a_{i-1}+\frac{1}{x_i} = a_{j-1}+\frac{1}{x_j} = x_{j-1}$, 意义就是如果两个后缀相等，那么它们各向前一个 也相等，综上逐步迭代$a_0 =a_{j-i}$ </p><p>因此证明了 如果一个二次无理数是 reduced，那么它是个纯循环连分数</p><h4 id="纯循环连分数-是-reduced"><a href="#纯循环连分数-是-reduced" class="headerlink" title="纯循环连分数 是 reduced"></a>纯循环连分数 是 reduced</h4><p>首先有循环节的连分数一定是二次无理数（上面证过了)</p><p>因为是纯循环，所以$a_0 \ge 1$,所以$a_n \ge 1$,有$x &gt; 1$</p><p>假设周期为n, 有 $x_n = x = [\overline{a_0,a_1,…,a_{n-1}}]$</p><p>根据上面推过的递推式 $x = \frac{x_nh_{n-1}+h_{n-2}}{x_nk_{n-1}+k_{n-2}} = \frac{xh_{n-1}+h_{n-2}}{xk_{n-1}+k_{n-2}}$</p><p>化简 $k_{n-1}x^2+(k_{n-2}-h_{n-1})x-h_{n-2}=0$</p><p>也就是证明这个方程除了x (我们已经有 $x&gt;1$了)的另一个根$\overline{x}$满足$-1 &lt; \overline{x} &lt; 0$</p><p>$x = 0$时 原式子 $=-h_{n-2} &lt; 0$</p><p>$x = 1$时 原式子 </p><p>$= k_{n-1}+(h_{n-1}-k_{n-2})-h_{n-2}$</p><p>$= (a_{n-1}k_{n-2}+k_{n-3}) + (a_{n-1}h_{n-2}+h_{n-3}) -k_{n-2}-h_{n-2}$</p><p>$= (a_{n-1}-1)(h_{n-2}+k_{n-2}) + (h_{n-3}+k_{n-3}) $</p><p>$ &gt; 0 $</p><p>说明了另一个根$-1 &lt; \overline{x} &lt; 0$</p><p>至此我们证明了 reduced 和 纯循环之间的 充要</p><h4 id="reduced二次无理数-纯循环连分数的-原无理数与它的共轭相反倒数的连分数数值关系"><a href="#reduced二次无理数-纯循环连分数的-原无理数与它的共轭相反倒数的连分数数值关系" class="headerlink" title="reduced二次无理数 纯循环连分数的 原无理数与它的共轭相反倒数的连分数数值关系"></a>reduced二次无理数 纯循环连分数的 原无理数与它的共轭相反倒数的连分数数值关系</h4><p>最后证明 If $x = [\overline{a_0, a_1, a_2, . . . , a_{l−1}}]$ and $\overline{x}$ 是它共轭实数, then $-\frac{1}{x} = [\overline{a_{l−1}, . . . , a_2, a_1,a_0}].$</p><p>Step 1</p><p>考虑有限的连分数 $x = [a_0,a_1,…,a_n], y=[a_n,a_{n-1},…,a_0] , a_i &gt; 0$</p><p>$h_n,k_n$为x的分子分母，$h_n’,k_n’$为y的分子分母</p><p>要证明 $\frac{h_n}{h_{n-1}} = \frac{h_n’}{k_n’}$ 且 $\frac{k_n}{k_{n-1}} = \frac{h_{n-1}’}{k_{n-1}’}, n \ge 1$ 且分子分母对应相等(因为是最简分数，所以只要证明了分数相等就有对应相等了)</p><p>注意到上面 $h_n = a_n \cdot h_{n-1} + h_{n-2}$,同时除以 $h_{n-1}$</p><p>$\frac{h_n}{h_{n-1}} = a_n + \frac{1}{\frac{h_{n-1}}{h_{n-2}}}$</p><p>递归展开 可以得到 $\frac{h_n}{h_{n-1}} = [a_n,a_{n-1},…,a_0]$,</p><p>注意到 $k_n = a_n \cdot k_{n-1} + k_{n-2}$,同理 $\frac{k_n}{k_{n-1}} = [a_n,a_{n-1},…,a_1] $(注意是$a_1$不是$a_0$)</p><p>根据上面的<code>递归展开的结论</code> 和 <code>y的分子分母定义</code>有</p><p>$\frac{h_{n+1}}{h_n} = [a_{n+1},a_n,…,a_0] = \frac{h_{n+1}’}{k_{n+1}’}$</p><p>$\frac{k_{n+1}}{h_n} = [a_{n+1},a_n,…,a_1] = \frac{h_{n}’}{k_{n}’}$</p><p>且分子分母对应相等</p><p>Step 2</p><p>若x 是纯循环连分数数(即reduced 二次无理数)，那么显然$-\frac{1}{\overline{x}}$也是 reduced的二次无理数，那么它也是纯循环</p><p>假设直接取 n+1 = 两个循环节长度的最小公倍数</p><p>$k_{n}x^2+(k_{n-1}-h_{n})x-h_{n-1}=0$</p><p>令</p><p>$y = [\overline{a_n,a_{n-1},…,a_0}] = [a_n,a_{n-1},…,a_0,y]$</p><p>$y = \frac{h_n’y+h_{n-1}’}{k_n’y+k_{n-1}’}$</p><p>因为Step 1 我们证明了对应相等$h_n=h_n’,k_{n-1}=k_{n-1}’, h_{n-1}=k_{n}’,h_{n-1}’=k_n$</p><p>所以做对应替换,$y = \frac{h_ny+k_{n}}{h_{n-1}y+k_{n-1}}$</p><p>$k_{n}{(-\frac{1}{y})}^2+(k_{n-1}-h_{n})(-\frac{1}{y})-h_{n-1}=0$</p><p>$-\frac{1}{y} = \overline{x}$ 得证(y为正 所以 不可能等于x)</p><p>至此 Theorem 1.25. (Galois’ Theorem) 无理数a. a是纯循环连分数（从a0开始的循环节），当且仅当 x is reduced. If $x = [\overline{a_0, a_1, a_2, . . . , a_{l−1}}]$ and $\overline{x}$ 是它共轭实数, then $-\frac{1}{\overline{x}} = [\overline{a_{l−1}, . . . , a_2, a_1}].$ 得证</p><h4 id="根号n-的-连分数性质"><a href="#根号n-的-连分数性质" class="headerlink" title="根号n 的 连分数性质"></a>根号n 的 连分数性质</h4><p>Theorem 1.26 d是非平方数,那么$\sqrt{d} = [\lfloor \sqrt{d} \rfloor,\overline{a_1,a_2,…,a_2,a_1,2\lfloor \sqrt{d} \rfloor}]$</p><p>也就是 是从第二位开始循环节，且循环节最后一个是它的整部的2倍，且剩余部分是回文</p><p>令$x=\lfloor \sqrt{d} \rfloor + \sqrt{d}$ 则$\overline{x} = \lfloor \sqrt{d} \rfloor - \sqrt{d}$</p><p>注意它们的取值范围发现x是reduced 二次无理数</p><p>因此 $ x = \lfloor \sqrt{d} \rfloor + \sqrt{d} = [\overline{2\lfloor \sqrt{d} \rfloor,a_1,a_2,…,a_{l-1}}]$</p><p>$ = [2\lfloor \sqrt{d} \rfloor,\overline{a_1,a_2,…,a_{l-1},2\lfloor \sqrt{d} \rfloor}]$</p><p>$ \sqrt{d}= [\lfloor \sqrt{d} \rfloor,\overline{a_1,a_2,…,a_{l-1},2\lfloor \sqrt{d} \rfloor}]$</p><p>根据Galois’ Theorem我们有</p><p>$\frac{1}{\sqrt{d}-\lfloor \sqrt{d} \rfloor} = -\frac{1}{\overline{x}} = [\overline{a_{l-1},…,a_2,a_1,2\lfloor \sqrt{d} \rfloor}]$</p><p>也就是$\sqrt{d} = [\lfloor \sqrt{d} \rfloor,\frac{1}{\sqrt{d}-\lfloor \sqrt{d} \rfloor}]$</p><p>$ = [\lfloor \sqrt{d} \rfloor,\overline{a_{l-1},…,a_2,a_1,2\lfloor \sqrt{d} \rfloor}]$</p><p>因此得证 循环内容和 回文性质</p><h2 id="Solution-to-Pell’s-Equation"><a href="#Solution-to-Pell’s-Equation" class="headerlink" title="Solution to Pell’s Equation"></a>Solution to Pell’s Equation</h2><p>因为平方带来的对称性，只考虑(x&gt;0,y&gt;0)的解</p><h3 id="根号n的连分数渐进分数的性质"><a href="#根号n的连分数渐进分数的性质" class="headerlink" title="根号n的连分数渐进分数的性质"></a>根号n的连分数渐进分数的性质</h3><h4 id="一个引理"><a href="#一个引理" class="headerlink" title="一个引理"></a>一个引理</h4><p>若d为非平方数，$x=\sqrt{d}$,</p><p>则对于任意n，存在整数$Q_n,P_n$满足$ x_n=\frac{P_n+\sqrt{d}}{Q_n}$和$d-P_n^2 = 0 (\bmod Q_n)$</p><p>显然n=0时$(P_0,Q_0) = (0,1)$满足,然后归纳法，若 n时能满足上述两点性质，则</p><p>$x_{n+1} = \frac{1}{x_n-a_n}$</p><p>$=\frac{1}{\frac{P_n+\sqrt{d}}{Q_n}-a_n}$</p><p>$=\frac{Q_n}{P_n+\sqrt{d}-a_n{Q_n}}$ (通过分母有理化:</p><p>$=\frac{Q_n(P_n-a_nQ_n-\sqrt{d})}{(P_n-a_nQ_n)^2-d}$</p><p>$=\frac{a_nQ_n-P_n+\sqrt{d}}{\frac{d-(P_n-a_nQ_n)^2}{Q_n}}$</p><p>$(Q_{n+1},P_{n+1}) = (\frac{d-(P_n-a_nQ_n)^2}{Q_n},a_nQ_n-P_n)$</p><p>现在要证明的就是 它是满足$\frac{P_{n+1}+\sqrt{d}}{Q_{n+1}}$的形式,并且满足上面的取模</p><p>也就是要证明$P_{n+1}$是整数(显然) 和 $Q_{n+1}$是整数</p><p>$Q_{n+1} = \frac{d-P_n^2}{Q_n}+2a_nP_n-a_n^2Q_n$</p><p>因为n时有 $d-P_n^2 = 0 (\bmod Q_n)$所以 $Q_{n+1}$是整数</p><p>又因为$Q_nQ_{n+1}=d-P_{n+1}^2$ 所以  $d-P_{n+1}^2 = 0 (\bmod Q_{n+1})$ 得证</p><h4 id="直指pell方程左侧表达式"><a href="#直指pell方程左侧表达式" class="headerlink" title="直指pell方程左侧表达式"></a>直指pell方程左侧表达式</h4><p>对于$n \ge 2$ 要证明 $h_{n-1}^2-d k_{n-1}^2=(-1)^n Q_n$</p><p>证明:</p><p>$\sqrt{d} = \frac{x_n h_{n-1}+h_{n-2}}{x_nk_{n-1}+k_{n-2}}$</p><p>把$ x_n = \frac{P_n+\sqrt{d}}{Q_n}$带入并通分化简</p><p>$(P_nk_{n-1}+Q_nk_{n-2}-h_{n-1})\sqrt{d} = P_nh_{n-1}+h_{n-2}Q_n-k_{n-1}d$</p><p>即 $P_nk_{n-1}+Q_nk_{n-2}=h_{n-1}$ 且 $P_nh_{n-1}+h_{n-2}Q_n=k_{n-1}d$</p><p>所以有 $h_{n-1}^2-dk_{n-1}^2 = h_{n-1}(P_nk_{n-1}+Q_nk_{n-2})-k_{n-1}(P_nh_{n-1}+h_{n-2}Q_n)$</p><p>$= Q_n(h_{n-1}k_{n-2}-h_{n-2}k_{n-1})$</p><p>$= (-1)^nQ_n$</p><h3 id="最后一步-连分数和pell方程的关系"><a href="#最后一步-连分数和pell方程的关系" class="headerlink" title="最后一步 连分数和pell方程的关系"></a>最后一步 连分数和pell方程的关系</h3><p>首先假设 (x,y)是 pell方程$x^2-dy^2=1$的解$(d&gt;1,x&gt;y&gt;0)$，所以</p><p>$|\sqrt{d} - \frac{x}{y}| = |\frac{dy^2-x}{y^2(\sqrt{d}+\frac{x}{y})}| &lt; \frac{1}{2y^2}$ (从一定程度上说明了 为什么前面要去证明 小于$\frac{1}{2y^2}$</p><p>根据前面推的 我们知道满足这个表达式的一定是 渐进值</p><p>(Yang.pdf那个paper下面的部分蛮多笔误的 不过能看懂证明思路)</p><p>因为我们上面有 $h_{n-1}^2-dk_{n-1}^2=(-1)^nQ_n$ 也就是如果要满足pell方程 那么$|Q_n|=1$，分类讨论$Q_n$</p><p>假设 $\sqrt{d}$的 最小周期长度为l</p><h4 id="分类讨论-Q-1"><a href="#分类讨论-Q-1" class="headerlink" title="分类讨论 Q = -1"></a>分类讨论 Q = -1</h4><p>$Q_n \neq -1, n &gt; 0$</p><p>证明</p><p>注意到上面根据$\sqrt{d}$的表达式 证明了$n&gt;0$时，$x_n$是纯循环连分数，也就是reduced</p><p>如果$Q_n = -1$ 因为$x_n=\frac{P_n+\sqrt{d}}{Q_n}$,所以有 $x_n=-P_n-\sqrt{d} &gt; 1$,有$-1&lt;-P_n+\sqrt{d} &lt; 0$ (Galois)</p><p>有 $\sqrt{d} &lt; P_n &lt; -\sqrt{d} - 1$ 矛盾 所以$Q_n \neq -1$, 对于$Q_0 = 1$也满足,得证</p><h4 id="分类讨论-Q-1-1"><a href="#分类讨论-Q-1-1" class="headerlink" title="分类讨论 Q = 1"></a>分类讨论 Q = 1</h4><p>$Q_n = 1$当且仅当n为循环节长度的倍数才有</p><p>证明</p><p>若于$n&gt;1$若$Q_n=1$那么有$x_n=P_n+\sqrt{d}$，它的共轭 $-1 &lt; P_n-\sqrt{d} &lt; 0$ 即 $P_n=\lfloor \sqrt{d} \rfloor$所以 $x_n = \lfloor \sqrt{d} \rfloor + \sqrt{d}$</p><p>$ \lfloor \sqrt{d} \rfloor +\sqrt{d} = x_n = 2\lfloor\sqrt{d}\rfloor + \frac{1}{\frac{1}{\sqrt{d} - \lfloor \sqrt{d} \rfloor}} $ 即 $ x_{n+1} = \frac{1}{\sqrt{d} - \lfloor \sqrt{d} \rfloor}$</p><p>$ \sqrt{d} = x_0 = \lfloor \sqrt{d} \rfloor + \frac{1}{\frac{1}{\sqrt{d} - \lfloor \sqrt{d} \rfloor}}$ 即 $x_1 = \frac{1}{\sqrt{d} - \lfloor \sqrt{d} \rfloor}$</p><p>说明了 它的下一个数$x_{n+1} $和$x_1$相等, 这说明如果$Q_n = 1$ 那么n是当且仅当循环节长度的倍数(如果为1则循环节长度)</p><h4 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h4><p>最后回到这里 $h_{n-1}^2-dk_{n-1}^2=(-1)^nQ_n = (-1)^n $ 也就是再看个奇偶，最后得到了pell方程和连分数比较紧密的结论</p><p>假设 $\sqrt{d}$的 最小周期长度为l</p><p>那么对应pell 方程的最小解</p><p>$(x,y) = {h_{l-1},k_{l-1}}$ 长度为偶数</p><p>$(x,y) = {h_{2l-1},k_{2l-1}}$ 长度为奇数</p><h2 id="回顾历程"><a href="#回顾历程" class="headerlink" title="回顾历程"></a>回顾历程</h2><ol><li>pell方程基础解</li><li>pell方程解存在性</li><li>连分数分子分母递推式</li><li>连分数，分子分母相关性质(分子分母互质性,原无理数与渐进数差值表达式，差值绝对值单调递减性，连分数是最给定分母以及更小分母中最接近原无理数，任何满足“某不等式”的数字是渐进数（这个不等式是pell方程 的必要条件）)</li><li>Lagrange’s Theorem 二次无理数与有循环节的连分数</li><li>Galois’ Theorem 纯循环连分数与reduced二次无理数</li><li>根号n的连分数性质（精确的$\frac{P_n+\sqrt{d}}{Q_n}$表示 和 形如pell方程 与$Q_n$的等式）</li><li>分类讨论$Q_n$与n的取值最后的结论</li></ol><p>方法涉及</p><ol><li>二项式展开，不等式，唯一最小(有术语吗)，无理数，反证法</li><li>反复抽屉原理，绝对值，无理数，模运算</li><li>矩阵乘法，归纳法/递推关系</li><li>归纳法/递推，互质，不等式放缩，三角不等式，反证法，二元一次方程组，巧妙正负值+不等式。 很多方法都是多次</li><li>归纳，反证，单调+整数离散+有限，二次函数</li><li>共轭实数，反向推，归纳法</li><li>归纳法,上面的分子分母等式性质</li><li>-1的幂次,分类讨论，Lagrange,Galois</li></ol><p>然后还有很多整数的离散性质</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://en.wikipedia.org/wiki/Continued_fraction" target="_blank" rel="noopener">Continued fraction</a></p><p><a href="https://en.wikipedia.org/wiki/Pell%27s_equation" target="_blank" rel="noopener">Pell equation</a></p><p><a href="https://www.math.uchicago.edu/~may/VIGRE/VIGRE2008/REUPapers/Yang.pdf" target="_blank" rel="noopener">Yang.pdf</a></p><p><a href="https://crypto.stanford.edu/pbc/notes/contfrac/pell.html" target="_blank" rel="noopener">stanford crypto pell</a></p><p><a href="http://sites.millersville.edu/bikenaga/number-theory/periodic-continued-fractions/periodic-continued-fractions.html" target="_blank" rel="noopener">millersville periodic-continued-fractions</a></p><p>下面这个youtube非常推荐，他讲得很系统，并不是证明了就好，而是按照了每步都能抽象出结论的推导过程，然后和连分数相关的没讲，主要在讲pell 方程的解的性质 </p><p><a href="https://www.youtube.com/watch?v=E51GKQ1qorE" target="_blank" rel="noopener">YouTube:Number Theory:Pell’s Equation part 1</a></p><p><a href="https://dspace.sunyconnect.suny.edu/bitstream/handle/1951/69917/fulltext.pdf?sequence=1&amp;isAllowed=y" target="_blank" rel="noopener">A short proof and generalization of Lagrange’s theorem on continued fractions</a></p><p><a href="http://sites.millersville.edu/bikenaga/number-theory/purely-periodic-continued-fractions/purely-periodic-continued-fractions.html" target="_blank" rel="noopener">purely periodic continued fractions</a></p><h1 id="总结-amp-感受"><a href="#总结-amp-感受" class="headerlink" title="总结&amp;感受"></a>总结&amp;感受</h1><p>有些结论在证明过程中其实是缩小了范围，有些结论其实放大定义域之类也是成立的，但我们在证明过程中却只使用了我们所需要的部分。这类的从定义域和对应的要证明的逻辑不是“完美对应”的，但是足够，不知道是好还是不好。</p><p>证明的结论之间引用过程，感觉画成网状或者树状关系图会更好？</p><p>看youtube了上的讲解视频，会发现有一种写代码的抽取函数感觉，和我上面完全拆开证明不一样，抽函数的感觉其实在数学里大概是叫做“令”+“引理”，感觉和完全展开比较，的确能减少很多心智负担啊！如果你也能打开youtube建议去看看</p><p>另外比如有些 强结论要用的时候，即使你证出了相对弱的结论，但没有证明出强结论，其实相当于“没有用”，比如上面 基础解，的平方，的n次方，和任意另一组解能产生新的解的证明。当然如果能证明出，那些就是过程了，但不是步骤（虽然我上面有写进文中，因为要简洁整理的话，直接强结论证明，即可其它的弱的可以直接省略</p><p>虽然视频看的时候的确感觉到老师和同学的口算不如国内，但自从自己思考过十进制的意义以后，感觉数值计算都不再重要，有的是计算机，不需要人类来算。</p><p>youtuber james cook 有证明一个 同系数二元二次方程 之间的关系，可以用它来 从 不是解的东西里生成解(感觉好像不是特别行，因为一个等式的 四个值仅仅由两个变量控制而不是3个？)！(Quadradic Forms) Q(u+v)+Q(u-v)=2(Q(u)+Q(v)),然后以此建立树，考虑其中的“正负交替路线”river</p><p>多核没智力还是搞不动数学啊,</p><p>这篇文章整理了很多篇其它资料，所以在符号使用上还不够统一，之后看有空整理一下</p><p>在我快写完这一篇文章的时候发现了 一个<a href="https://chaoli.club/index.php/2756/0" target="_blank" rel="noopener">超理论坛-连分数入门</a> 注册需要一点点水平XD，这篇是带着例子讲解写的！(大自看了一下 感觉很棒 推荐), 又 有些性质证明方式不止一种，例如我本篇文章所抄来的证明 二次无理数和有循环节的充要 会感觉更漂亮一些</p><p>有些paper写到后面还是很多笔误，不过看通了也是能理解具体过程</p><p>有一个想法是 哪些结论是关键或者说证明的难点，其实可以这样想，现在，把文章中一些部分换成填空，你还能不能补全整个文章，不需要完全一样，只要能证明就行。这样想的话，就会知道所谓的难点是在哪。</p>]]></content>
      
      
      <categories>
          
          <category> Project Euler </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pe </tag>
            
            <tag> project euler </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pe 129(repunit divisibility,含证明)</title>
      <link href="/Blog/2020-12-03-pe129/"/>
      <url>/Blog/2020-12-03-pe129/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://projecteuler.net/problem=129" target="_blank" rel="noopener">https://projecteuler.net/problem=129</a></p><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给一个整数n,(gcd(n,10)=1)，找最小的 <code>111...111</code>使得是n的倍数，A(n)返回这个最小的长度</p><p><code>A(7)=6</code>,<code>A(41)=5</code></p><p>求最小的n能让<code>A(n) &gt; 1000000</code>的</p><h2 id="存在性证明"><a href="#存在性证明" class="headerlink" title="存在性证明"></a>存在性证明</h2><p>题目说始终存在</p><p>因为$\text{gcd}(n,10) = 1$所以n不包含2和5这两个质因子</p><p>考虑结尾的字符为<code>1,3,7,9</code></p><p>因为要证明的是任意n都能找到<code>111...111</code>，对于<code>3,7,9</code>结尾的，对应乘上<code>7,3,9</code>都会变成1 结尾的</p><p>那我们其实只要证明了 任何以1结尾的数，能找到<code>111...111</code>是它的倍数即可，我卡住了</p><hr><p>对于给定n要找到,考虑它的每个质数因子p</p><p>$(10^i-1)/9 = 0 \pmod p$</p><p><a href="https://artofproblemsolving.com/wiki/index.php?title=Fermat%27s_Little_Theorem#Introductory" target="_blank" rel="noopener">费马小定理</a></p><p>$a^{p-1} - 1 = 0 \pmod p$</p><p>如果$p=3$, 有111是它的倍数(不是按照上面的公式, 因为有除以9的部分)</p><p>如果$p$是非2,3,5的质数</p><p>$10^{p-1}-1=0 \pmod p$</p><p>$(10^{p-1}-1)/9=0 \pmod p$</p><p>我们只得到</p><p>$10^{(p_1-1)(p_2-1)(p_3-1)} = 1 \pmod {p_1 p_2 p_3}$</p><p>但是如果有幂次质因子还是未知</p><hr><p>和费马小定理相似但是更强劲的 <a href="https://en.wikipedia.org/wiki/Euler%27s_theorem" target="_blank" rel="noopener">欧拉定理</a></p><p>$a^{\varphi (n)} \equiv 1 \pmod{n}$</p><p>要求正好是 a和n互质</p><p>对于不含质因子3的$n$，能直接通过上式得到</p><p>$10^{\varphi (n)} \equiv 1 \pmod{n}$</p><p>$(10^{\varphi (n)} - 1)/9 \equiv 0 \pmod{n}$</p><p>对于含有3质因子的$n$,直接考虑9n</p><p>$10^{\varphi (9n)} \equiv 1 \pmod{9n}$</p><p>$10^{\varphi (9n)} - 1 \equiv 0 \pmod{9n}$</p><p>$(10^{\varphi (9n)} - 1)/9 \equiv 0 \pmod{n}$</p><p>得证</p><h2 id="证明-A-n-le-n"><a href="#证明-A-n-le-n" class="headerlink" title="证明 $A(n) \le n$"></a>证明 $A(n) \le n$</h2><p>考虑找到的$111\cdots 111$ 对应的<code>商</code> $x = 111\cdots111 / n$</p><p>因为我们上面证明了$n$能整除，所以倒过来思考乘积如何填数</p><p>$x \cdot n = 111\cdots111$</p><p>因为 n 的末位是$1,3,7,9$中的奇数，那么 对于给定的尾数能直接确定商的尾数</p><p>同样我们能唯一确定十位,考虑每次计算后的余数</p><p>这里的余数是指 $((最少的前补1(\ge 0个) + 上一次的剩余值 - 当前商位上的数码\cdot n)/10) \pmod n$,</p><p>显然，上一次的剩余值通过个位数唯一决定 当前商的数码，又 前补1要最少又能满足表达式大于0,也是唯一方案。</p><p>因此 低$i$位的余数唯一确定$i+1$位的余数 $r_{i+1} = f(r_i)$，注意多个剩余值可能对应同一个余数，但这些余数相同的剩余值推导出的 高位的剩余值唯一</p><p>因此 考虑余数的变化，因为最终余数为零，所以中途余数不能成环。综上，商的位数不会超过$n$</p><p>因此原始的$111\cdots 111 = x\cdot n$ 也不会超过$n$</p><hr><p>以7 举例, 说明上面的证明过程</p><p>$3\cdot 7=21,(111-21)/10 = 9 = 2 \pmod 7$</p><p>余数是控制链的长度，但是不影响计算 所以下面是109而不是102, 稍加理解的话是$102 - 6\cdot 7 = 109 - 7\cdot 7$</p><p>$7\cdot 7=49,(109-49)/10 = 6 = 6 \pmod 7$</p><p>$8\cdot 7=56,(106-56)/10 = 5 = 5 \pmod 7$</p><p>$5\cdot 7=35,(105-35)/10 = 7 = 0 \pmod 7$ // 同上不影响计算 </p><p>$1\cdot 7 = 7, 7 - 7 = 0$</p><p>因此$15873 \cdot 7 = 111111$</p><p>余数变化是$2 \to 6 \to 5 \to 0$</p><hr><p>对应上面唯一描述是</p><p>剩余值$11$,确定商的数码$3$,$3\cdot 7=21$,最少补充1个1,$(111-21=90)/10 = 9$,剩余值9,余数2</p><p>剩余值$ 9$,确定商的数码$7$,$7\cdot 7=49$,最少补充1个1,$(109-49=60)/10 = 6$,剩余值6,余数6</p><p>剩余值$ 6$,确定商的数码$8$,$8\cdot 7=56$,最少补充1个1,$(106-56=50)/10 = 5$,剩余值5,余数5</p><p>剩余值$ 5$,确定商的数码$5$,$5\cdot 7=35$,最少补充1个1,$(105-35=70)/10 = 7$,剩余值7,余数0</p><p>剩余值$ 7$,确定商的数码$1$,$1\cdot 7=7 $,最少补充0个1,7-7=0 结束</p><hr><p>其实上面欧拉定理，我们只用关心 n 包含质因子3的情况，A(i) 是否会超过n</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>幂次总是在小于 n的时候能模为1,这样可以从1000000开始</p><pre><code>def A(v):    p = 1    for j in range(1, 9*v+1):        p *= 10        p %= 9*v        if p % (9*v) == 1:            return jdef main():    maxAi = 0    for i in range(500000-10, 1000000):        ii = i*2+1        if ii % 10 != 5:            Ai = A(ii)            # if Ai &gt; ii:            #     print(ii, Ai)            if Ai - maxAi &gt; 10000:                maxAi = Ai                print(ii, Ai)            if Ai &gt; 1000000:                print(ii, Ai)                break    print(&quot;end&quot;)main()</code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://mathlesstraveled.com/2011/11/16/fun-with-repunit-divisors-proofs/" target="_blank" rel="noopener">https://mathlesstraveled.com/2011/11/16/fun-with-repunit-divisors-proofs/</a></p><p><a href="https://artofproblemsolving.com/wiki/index.php?title=Fermat%27s_Little_Theorem#Introductory" target="_blank" rel="noopener">https://artofproblemsolving.com/wiki/index.php?title=Fermat%27s_Little_Theorem#Introductory</a></p><p><a href="https://en.wikipedia.org/wiki/Euler%27s_theorem" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Euler%27s_theorem</a></p>]]></content>
      
      
      <categories>
          
          <category> Project Euler </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nowcoder 8996 A (找规律 或 生成函数)</title>
      <link href="/Blog/2020-11-28-nowcoder-8996A/"/>
      <url>/Blog/2020-11-28-nowcoder-8996A/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://ac.nowcoder.com/acm/contest/8996/A" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/contest/8996/A</a></p><h1 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h1><p>n 由8个整数成分组成</p><ol><li>不超过1</li><li>不超过2</li><li>不超过3</li><li>偶数个</li><li>奇数个</li><li>4的倍数</li><li>不超过1</li><li>3的倍数</li></ol><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><ol><li><p>打打表找规律直接得到公式</p></li><li><p>生成函数</p></li></ol><p>$(1+x)(1+x+x^2)(1+x+x^2+x^3)(\frac{1}{1-x^2})(\frac{x}{1-x^2})(\frac{1}{1-x^4})(1+x)(\frac{1}{1-x^3}) = \frac{x}{(1-x)^4}$</p><p>$=x(1+x+x^2+x^3…)^4$</p><p>只需要$x^N$的系数即可</p>]]></content>
      
      
      <categories>
          
          <category> NowCoder </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Generating function </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nowcoder (树状数组+贡献计数+前缀和)</title>
      <link href="/Blog/2020-11-25-nowcoder-9003D/"/>
      <url>/Blog/2020-11-25-nowcoder-9003D/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://ac.nowcoder.com/acm/contest/9033/D" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/contest/9033/D</a></p><h1 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h1><p>给数组，和整数k</p><p>每次询问一个区间，它的所有子区间出现次数最多的数正好等于k的区间数</p><p>数组长度和询问数都是3e5</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>我们要统计的是正好，</p><p>那么如果可以计算出 <code>&lt;=k</code>,那么我们可以计算出<code>&lt;=k-1</code> 然后想减少，只需要2倍时间</p><p>对于询问我们采取离线计算</p><p>下面问题变成如何计算 区间<code>[l,r]</code> 上满足 <code>&lt;=k</code> 的方案数</p><hr><p>考虑以 i 为起点，其对应的右侧<code>&lt;=k</code>的分界点split(i2)。</p><p>很容易发现，这个分界点是随着i增加，单调递增的，因为如果 <code>i1 &lt; i2</code>,那么<code>[i2,split(i2)]</code> 是最长的<code>&lt;=k</code>，也就是其最多出现次数为k,那么<code>[i1,split(i2)]</code> 的最多出现次数,大于等于k,且<code>[i1,split(i2)+1]</code> 大于等于k+1</p><p>因此<code>split(i1)&lt;=split(i2)</code></p><p>有这个单调性质，我们很容易能扫一遍在<code>O(n)</code>时间内求出，每个左侧i的点，对应的右侧分界点</p><p>再一个<code>O(n)</code> 可以在不考虑选点范围的情况下，计算出 点对的前缀和<code>presum[i] =presum[i-1]+(split(i)-i+1)</code> </p><hr><p>来看看和目标之间的差距</p><p>要求<code>[l,r]</code> 中间满足<code>&lt;=k</code> 的点对数量</p><p><code>presum[r] - presum[l-1]</code> 计算了左侧起点在<code>[l,r]</code>的满足<code>&lt;=k</code>点对数量，但是没有对点对的右侧点进行限制</p><p>也就是需要去掉 左侧断点 <code>[l,r]</code> 内，但是右侧端点 <code>&gt;r</code>的点对</p><p><code>= sum[i = l-&gt;r][  split(i) &gt; r? split(i) - r: 0 ]</code></p><p>询问很多，不可能每次去计算，想前缀和之类，却 r和i没有直接关系，因为i是原始数组下标，而r是询问中提供的</p><p>拆分一下, 这样 前面部分可以通过 前缀和的方式统计，而后面的部分，只需要统计左端点在[l,r],右端点超过r的个数，在处理具体询问的时候乘上r即可。</p><p><code>= sum[i = l-&gt;r][  split(i) &gt; r? split(i): 0 ] - sum[i = l-&gt;r][  split(i) &gt; r? r : 0 ]</code></p><p>由此r从大到小处理询问即可。 <code>O(n)</code></p><p>关于区间统计，上树状数组就行了</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code class="c++">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;n;i++)#define per(i,a,n) for (ll i=n-1;i&gt;=a;i--)#define pb push_back#define lowbit(x) ((x)&amp;(-x))#define MAXN 300010ll n,q,k;ll a[MAXN];// 树状数组void add(vector&lt;ll&gt;&amp;arr,ll x,ll y) {  for(; x &lt;= n; x += lowbit(x)){    arr[x] += y;  }}ll sum(vector&lt;ll&gt;&amp;arr,ll x) {  ll ans = 0;  for(; x &gt; 0; x -= lowbit(x)){    ans += arr[x];  }  return ans;}ll sto(vector&lt;ll&gt;&amp;arr,ll l,ll r) {  return sum(arr,r) - sum(arr,l-1);}// [值] = 下标数组vector&lt;ll&gt;v[MAXN];// 离线 询问struct ask {  ll l,r,i;}w[MAXN];ll ans[MAXN];bool cmp(ask a,ask b) {  return a.r &gt; b.r;}// &lt; kvoid solve(ll k,ll pw) {  priority_queue&lt; pair&lt;ll,ll&gt;,vector&lt;pair&lt;ll,ll&gt;&gt;, greater&lt;pair&lt;ll,ll&gt;&gt; &gt;p; // {idx,value}  rep(i,1,n+1){    if(v[i].size() &gt;= k){      // 首个超过 k个的坐标和值      p.push({v[i][k-1],i});    }  }  vector&lt;ll&gt; cnt(MAXN,0);  vector&lt;ll&gt;l2r(MAXN,0); // 以i为区间左端点，右侧端点选取(&gt;=k)范围的左侧  vector&lt; vector&lt;ll&gt; &gt; r2l(MAXN,vector&lt;ll&gt;());  rep(i,1,n+1){    while(!p.empty() &amp;&amp; (          // 之后的部分个数 小于k          cnt[p.top().second] + k-1 &gt;= v[p.top().second].size() ||          // 每次用完了头部不pop，靠这个来避免重复？          v[p.top().second][cnt[p.top().second] + k-1] != p.top().first          )){      p.pop();    }    // 扫描到当前 a[i] 出现的次数    cnt[a[i]] ++;    // 后续可出现连续 k个a[i]    if(v[a[i]].size() &gt; cnt[a[i]]+k-1){      p.push({v[a[i]][cnt[a[i]]+k-1],a[i]});    }    l2r[i] = p.empty()?n:(p.top().first - 1);    // 右侧区间的左侧坐标 -&gt; 左端点, 从i到f[i] 这一段 最大次数小于k    r2l[l2r[i]].pb(i);  }  // [0-&gt;i]为左端点不合法个数前缀和  vector&lt;ll&gt;s(MAXN,0);  rep(i,1,n+1){    // 表示&lt;k的对的方案数    s[i] = s[i-1] + l2r[i]-i+1;  }  // 树状数组  vector&lt;vector&lt;ll&gt; &gt;tr(2, vector&lt;ll&gt;(MAXN,0));  ll nn = 0;  // 询问从右向左处理  per(i,1,n+1){    while(w[nn].r &gt;= i &amp;&amp; nn &lt; q) {      ans[w[nn].i] += pw*(          // 小于k 的对数方案          (s[w[nn].r] - s[w[nn].l-1])          // 当前  大于k 的对数方案          +sto(tr[0],w[nn].l,w[nn].r)+w[nn].r*sto(tr[1],w[nn].l,w[nn].r)      );      nn ++;    }    rep(j,0,r2l[i].size()){      ll xay = r2l[i][j];      // 大于等于k的对数      add(tr[0],xay,-i);      // 次数      add(tr[1],xay,1);    }  }}int main() {  scanf(&quot;%lld %lld %lld&quot;,&amp;n,&amp;q,&amp;k);  rep(i,1,n+1){    cin &gt;&gt; a[i];    v[a[i]].pb(i);  }  rep(i,0,q){    scanf(&quot;%lld %lld&quot;,&amp;w[i].l,&amp;w[i].r);    w[i].i = i;  }  // 询问 右侧r 从大到小排列  sort(w,w+q,cmp);  solve(k+1,1);  if(k != 1){    solve(k,-1);  }  rep(i,0,q){    printf(&quot;%lld\n&quot;,ans[i]);  }  return 0;}</code></pre><h1 id="收获总结"><a href="#收获总结" class="headerlink" title="收获总结"></a>收获总结</h1><ol><li><code>=k</code>如果难算，可以变成计算<code>&lt;=k</code> 和 <code>&lt;=k-1</code> 然后进行 相减</li><li>离线处理询问</li><li>处理“不能”前缀和的部分，拆分成可前缀和的部分，和部分统计，询问时再乘积的部分分别处理，降低到O(n)</li><li>在有前缀和的代码里 用1-index比0-index方便一些</li></ol>]]></content>
      
      
      <categories>
          
          <category> NowCoder </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Binary Indexed Trees </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>project euler 106(阅读理解)</title>
      <link href="/Blog/2020-11-13-pe106/"/>
      <url>/Blog/2020-11-13-pe106/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://projecteuler.net/problem=106" target="_blank" rel="noopener">https://projecteuler.net/problem=106</a></p><p>题目说，S(集合)表示集合元素的和</p><p>集合A如果它任何不相交的两个子集B和C，同时满足</p><ol><li>S(B) != S(C)</li><li>如果 B的元素个数比 C多，那么 S(B)&gt;S(C)</li></ol><p>那么A是满足题意的</p><p>问 现在 给了一个集合，元素个数是n且满足第二条，要测试多少对 子集， 才能判定它是满足题意的</p><p>然后举例</p><p>n=4 是25中的 1对</p><p>n=7 是 966中的70对</p><p>求 n=12 时 需要判断的是261625中的多少对</p><h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><p>我是没想到，还能在ProjectEuler练习语文</p><p>注意到 一对不相交子集 如果元素个数不同，那么满足2一定不满足1,所以，如果“可能”满足1,那么元素个数相等</p><p>那么首先说 n=4时25怎么来的</p><p>假设四个元素 且排序了的 {A,B,C,D}</p><p>一个元素的比对就是 3+2+1=6, </p><p>两个元素的比对 3 种</p><p>因为不相交 所以 3个以上元素的不比对</p><p>所以哪里来的 25呢？？？？？？？？？？？？</p><hr><p>换个思路</p><p>假设比对是有序的也就是 x和y比，y和x比 算两种，那么方案数一定是2的倍数？也不会25？</p><hr><p>再说先放弃不相交的性质，只要不相等就计数？</p><pre><code>1个元素 3+2+1=62个元素 5+4+3+2+1 = 153个元素 3+2+1=6</code></pre><p>就是出不来25啊</p><hr><p>一个办法是结束吧，放弃吧，只去关心1是怎么来的</p><p>然后我甚至想到了勾股定理4x4+3x3=25 然而也不是</p><hr><p>难道是没考虑2的时候，之考虑了不相交</p><pre><code>1对比1 3+2+1=61对比2 4x3 = 121对比3 4x1 = 42对比2 3</code></pre><p>还真的是25</p><hr><p>按照这个思路，尝试一下n=7,是不是966</p><pre><code>1v1:6+5+4+3+2+1 = 211v2:7x15=1051v3:7x20=1401v4:7x15=1051v5:7x6=421v6:7x1=72v2:6x(5x4/2)+5x(4x3/2)+4x(3x2/2)+3x(2x1/2) = 1052v3:21x10=2102v4:21x5=1052v5:21x1=213v3:15x4+10*1=703v4:35x1=3521+105+140+105+42+7+105+210+105+21+70+35=966</code></pre><p>那么这样说真的就是这个值了，不过n=12时这个值并不需要我们求</p><h1 id="解"><a href="#解" class="headerlink" title="解"></a>解</h1><p>然后我们来看看 什么是可能</p><p>n=4, {A,B,C,D}</p><p>个数不相等的两个子集 一定不等</p><p>1v1 一定不等</p><p>2v2有 AB vs CD , AC vs BD, AD vs BC, 而只有<code>AD vs BC</code>是“可能”的，前面两组根据大小偏序关系一定不等</p><p>没有3v3以及以上</p><hr><p>那么对于任意n呢</p><hr><p>先看看n=7，{ABCDEFG}</p><p>1v1老样子一定不等</p><p>还剩下2v2和3v3</p><p>对于 2v2，一定是 一个的最小到最大构成的区间，包含另一个，</p><pre><code>BC为中间:1x4=4BD为中间:1x3=3BE为中间:1x2=2BF为中间:1x1=1CD为中间:2x3=6CE为中间:2x2=4CF为中间:2x1=2DE为中间:3x2=6DF为中间:3x1=3EF为中间:4x1=44+3+2+1+6+4+2+6+3+4=35</code></pre><p>对于3v3,</p><p><code>X1&lt;Y1&lt;X2&lt;Y2&lt;X3&lt;Y3</code>一定不行， 7个</p><p><code>X1&lt;X2&lt;X3&lt;Y1&lt;Y2&lt;Y3</code>一定不行， 7个</p><p><code>X1&lt;X2&lt;Y1&lt;X3&lt;Y2&lt;Y3</code>一定不行， 7个</p><p><code>X1&lt;X2&lt;Y1&lt;Y2&lt;X3&lt;Y3</code>一定不行， 7个</p><p><code>X1&lt;Y1&lt;X2&lt;X3&lt;Y2&lt;Y3</code>一定不行， 7个</p><p>所以可行的3v3是 70-5x7=35 个</p><p>总共 35+35是70个</p><hr><p>那么根据上面看到 实际上，不可能就是</p><p>两个子集排序后，对应下标位置偏序一致</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>还需要代码吗，这题核心是语文的阅读理解，猜作者的意图</p><pre><code class="c++">#include &lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;n;i++)int ia = 0;int a[20];int ib = 0;int b[20];int possible = 0;int N = 12;bool test_possible(){  if(ia != ib)return false;  int gcnt=0;  int lcnt=0;  rep(i,0,ia){    if(a[i]&lt; b[i]){      lcnt++;    }else{      gcnt++;    }  }  return lcnt != 0 &amp;&amp; gcnt != 0;}void tryidx(int index){  if(index == N){    possible += test_possible();    return;  }  a[ia++] = index;  tryidx(index+1);  ia--;  if(ia != 0){    b[ib++] = index;    tryidx(index+1);    ib--;  }  tryidx(index+1);}int main(){  cin&gt;&gt;N;  tryidx(0);  printf(&quot;%d\n&quot;,possible);  return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Project Euler </category>
          
      </categories>
      
      
        <tags>
            
            <tag> all </tag>
            
            <tag> 语文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>project euler 122(阅读理解)</title>
      <link href="/Blog/2020-11-19-pe122/"/>
      <url>/Blog/2020-11-19-pe122/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://projecteuler.net/problem=122" target="_blank" rel="noopener">https://projecteuler.net/problem=122</a></p><p><a href="https://en.wikipedia.org/wiki/Addition_chain" target="_blank" rel="noopener">Addition chain</a></p><h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><p>看起来是个描述很简洁的题目</p><p>但是 我以为能有什么 局部最优</p><p>所以想说 15=3x5,也就是做一次 变3的工作 再一次变5的工作</p><p>对于质数 = 1+它的分解</p><p>然而错了</p><hr><p>想不出什么方法，翻了翻wiki找到了上面的Addition chain</p><p>说计算addition chains目前是一个 NP-complete 的问题</p><hr><p>好像也并不能dp</p><p>于是考虑生成过程，写了一个树上爆搜。</p><p>也就是 每个节点的子节点 等于该节点和，该节点以及祖先节点的和</p><hr><p>这样就是加法过程，每次新增的数都是最大的。 但是这种情况 其实没有考虑 A-B-C-D-(D+B)-(D+C) , 这样就不是最后一个增加？</p><p>这样算法，感觉是有bug的？</p><p>虽然这样的代码过了。</p><hr><p>不过，我打出了 bfs的 元素个数，看得到仅仅200的数据。191， 已经下标达到了4053954。</p><hr><p>然后 我对拍了一下数据，最小的一个不一致是23，需要6步，而我错误的dp是7步</p><p>7步: 1+1=2,2+2=4,4+1=5,5+5=10,10+1=11,11+11=22,22+1=23</p><p>6步: 1+1=2,2+2=4,4+1=5,5+4=9,9+9=18,18+5=23</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define t3 1000+10#define t4 10000+10#define t5 100000+10#define t6 1000000+10#define MOD 1000000007#define rep(i,a,n) for (ll i=a;i&lt;n;i++)#define per(i,a,n) for (ll i=n-1;i&gt;=a;i--)#define pb push_backconst double pi = acos(-1.0);namespace X{  ll r(){ll r;scanf(&quot;%lld&quot;,&amp;r);return r;} // read  void add(ll &amp;v0,ll &amp;v1){(v0+=v1%MOD)%=MOD;} // add with MOD  ll mpow(ll v,ll mi){ll r = 1;while(mi){if(mi%2)(r*=v)%=MOD;(v*=v)%=MOD;mi&gt;&gt;=1;};return r;} // quick power with MOD  ll mod(ll v){return (v%MOD+MOD)%MOD;} // output  ll gcd(ll a,ll b){return b == 0?a:gcd(b,a%b);}};// 错误的方法 startll dp[210];int p[210];void wayWrong(){  p[1] = 1;  rep(i,2,20){    if(!p[i]){      for(int j = i*i;j&lt;=200;j+=i){        if(!p[j]){          p[j]= i;        }      }    }  }  rep(i,2,201){    if(!p[i]){      dp[i] = 1+dp[i-1];    }else{      dp[i] = dp[p[i]] + dp[i/p[i]];    }  }}// 错误的方法 endstruct Node{  int dep = 0 ;  int val = 0;  Node * fa = NULL;};const int N = 10000000;Node nodes[N+10];int leftcnt = 200 - 1 ;ll ans[210];int main(){  int st = 0;  int rear = 1;  nodes[0].val = 1;  while(st &lt; rear){    Node * p = &amp;nodes[st];    while(p != NULL){      int newval = p-&gt;val + nodes[st].val;      if(newval &lt;= 200){        if(ans[newval] == 0){          printf(&quot;%d[dep:%d][bfs idx:%d]\n&quot;,newval,nodes[st].dep,rear);          ans[newval] = nodes[st].dep + 1;          leftcnt--;          if(leftcnt == 0){            break;          }        }        nodes[rear].fa = &amp;nodes[st];        nodes[rear].dep = nodes[st].dep+1;        nodes[rear].val = newval;        rear++;        if(rear &gt; N){          printf(&quot;leftcnt:%d\n&quot;,leftcnt);          rep(i,1,201){            if(!ans[i]){              printf(&quot;noans:%lld\n&quot;,i);            }          }          return 0;        }      }      p=p-&gt;fa;    }    st++;    if(leftcnt == 0){      break;    }  }  ll count = 0;  rep(i,1,201){    count += ans[i];    // printf(&quot;%lld:%lld\n&quot;,i,ans[i]);  }  printf(&quot;%lld\n&quot;,count);  return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Project Euler </category>
          
      </categories>
      
      
        <tags>
            
            <tag> all </tag>
            
            <tag> 语文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NowCoder 8282 D(莫反)</title>
      <link href="/Blog/2020-11-07-nowcoder8282D/"/>
      <url>/Blog/2020-11-07-nowcoder8282D/</url>
      
        <content type="html"><![CDATA[<p>很久没写提解，也没打比赛了，昨天做了个题</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://ac.nowcoder.com/acm/contest/8282/D" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/contest/8282/D</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><a href="https://blog.nowcoder.net/n/aa0719c9f7d9481cb0f9f93eb5e8a866" target="_blank" rel="noopener">https://blog.nowcoder.net/n/aa0719c9f7d9481cb0f9f93eb5e8a866</a></p><h1 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h1><p>关于莫反之前写过文章了，也很容易可以预先处理所有mu[1~n]</p><p>这次根据题目总结一下莫反的思路吧。</p><p>和上次类似，其实核心两点</p><ol><li>找到 $gcd(x,y) == 1$这样对应的表达式</li><li>这样的表达式意味着我们可以用 $\sum_{i|gcd(x,y)}{\mu(i)} = [gcd(x,y)==1]$的知识</li><li>变成了 多层求和公式以后，注意求和的约数遍历值，逐个相邻的求和向前移动这个约数遍历值</li><li>最后就能得到完全没有约数只有倍数的 求和式子，可以各种前缀和之类的处理了</li></ol>]]></content>
      
      
      <categories>
          
          <category> NowCoder </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 莫比乌斯函数 </tag>
            
            <tag> mu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>莫队算法入门</title>
      <link href="/Blog/2020-08-28-mo/"/>
      <url>/Blog/2020-08-28-mo/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>啊 被牛客题目描述坑了，把关键信息藏在数据范围里，不过顺便学了一下莫队。</p><p>牛客题目<a href="https://ac.nowcoder.com/acm/contest/7079/A" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/contest/7079/A</a> ， 知道真实题意以后是个水题</p><h1 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h1><p>指莫队要解决的问题不是牛客的题。</p><p>给长n的数组，没有改动，q次询问区间的不同值的个数</p><p>q和n都1e5</p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><p>我看到mex都很慌，这玩意虽然看上去是个质朴的东西，但涉及到的都不太好搞</p><p>上面 直接暴力，就 O(q n)。</p><p>莫队实际上就是 优雅的分块，然后再暴力。</p><ol><li>离线请求。</li><li>根据请求的<code>[左端点/sqrt(n), 右端点]</code>排序</li><li>暴力求解</li></ol><p>意味着，每次对于 <code>左端点/sqrt(n)</code>相同的时候， 时间复杂度= <code>sqrt(n)*询问个数 + n</code></p><p>总时间复杂度 <code>sqrt(n)*q + n*sqrt(n)</code></p><p>一些优化，通过奇偶 来决定右端点是 正序还是逆序列。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code class="c++">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define ten5 100000+10#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define iif(c,t,f) ((c)?(t):(f))#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)const int MAXN = 30005; // 数组大小const int MAXQ = 200005; // 询问次数const int MAXM = 1000005; // 值记录int sq; // sqrt(n);struct query{ // 把询问以结构体方式保存  int l, r, id;  // 不是按照 l 第一序列，r第二序  // 而是 l/sq 第一序，r第二序列，对于相同的l/sq 其中根据l/sq的奇偶性来决定r是正向序还是逆向序  bool operator&lt;(const query &amp;o) const { // 重载&lt;运算符，奇偶化排序    // 这里只需要知道每个元素归属哪个块，而块的大小都是sqrt(n)，所以可以直接用l/sq    if (l / sq != o.l / sq)      return l &lt; o.l;    if (l / sq &amp; 1)      return r &lt; o.r;    return r &gt; o.r;  }} Q[MAXQ];int A[MAXN];// 原始数组int ans[MAXQ]; // 离线结果int Cnt[MAXM];int cur;// 总计int l = 1, r = 0; // 左右游标void add(int p) {  if (Cnt[A[p]] == 0)    cur++;  Cnt[A[p]]++;}void del(int p) {  Cnt[A[p]]--;  if (Cnt[A[p]] == 0)    cur--;}ll read(){  ll r;  scanf(&quot;%lld&quot;,&amp;r);  return r;}int main() {  int n = read();  sq = sqrt(n);  rep(i,1,n+1){    A[i] = read();  }  int q = read();  rep(i,0,q){    Q[i].l = read();    Q[i].r = read();    Q[i].id = i; // 把询问离线下来  }  sort(Q, Q + q); // 排序  // 每个 按 l/sq的区块分的区间内，r的总变化最多n, l的变化 = sqrt(n) * 个数  // 总代价 = sum 所有区块的代价 = 区块数 * r的每个区块变化 + sqrt(n) * 总个数 = n^(3/2) + q * n^(1/2);  rep(i,0,q){    while (l &lt; Q[i].l)      del(l++);    while (l &gt; Q[i].l)      add(--l);    while (r &lt; Q[i].r)      add(++r);    while (r &gt; Q[i].r)      del(r--);    ans[Q[i].id] = cur; // 储存答案  }  rep(i,0,q){    printf(&quot;%d\n&quot;, ans[i]); // 按编号顺序输出  }  return 0;}</code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>各种莫队博文</p>]]></content>
      
      
      <categories>
          
          <category> NowCoder </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>project euler 101 Optimum polynomial</title>
      <link href="/Blog/2020-07-01-project-euler101/"/>
      <url>/Blog/2020-07-01-project-euler101/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://projecteuler.net/problem=101" target="_blank" rel="noopener">https://projecteuler.net/problem=101</a></p><h1 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h1><p>给你一个多项式表达式</p><p>然后 只对前面几项 进行最小幂次拟合，拟合的函数第一个和原函数 不同的输出值的和</p><p>原题目很简单，11x11的Vandermonde矩阵求个逆矩阵，甚至都不用处理分数 就搞完了</p><h1 id="hackerrank"><a href="#hackerrank" class="headerlink" title="hackerrank"></a>hackerrank</h1><p>然后我发现了这个</p><p><a href="https://www.hackerrank.com/contests/projecteuler/challenges/euler101/problem" target="_blank" rel="noopener">https://www.hackerrank.com/contests/projecteuler/challenges/euler101/problem</a></p><p>直接把 矩阵拉到了 3000x3000,然后 多项式的系数是 传入的</p><p>首先Vandermonde就需要一个高效求逆的办法，最后再O(n^2)算算</p><h1 id="高效求逆"><a href="#高效求逆" class="headerlink" title="高效求逆?"></a>高效求逆?</h1><p>为什么要, 因为 我们有了原表达式，要去做拟合 实际就是</p><p>${\begin{pmatrix}<br>{a_0}\\<br>{a_1}\\<br>{a_2}\\<br>{\vdots}\\<br>{a_{n-1}}\\<br>\end{pmatrix}<br>}^T\begin{pmatrix}<br>{1}&amp;{1}&amp;{\cdots}&amp;{1}\\<br>{x_{0}}&amp;{x_{1}}&amp;{\cdots}&amp;{x_{n-1}}\\<br>{x_{0}^2}&amp;{x_{1}^2}&amp;{\cdots}&amp;{x_{n-1}^2}\\<br>{\vdots}&amp;{\vdots}&amp;{}&amp;{\vdots}\\<br>{x_{0}^{n-1}}&amp;{x_{1}^{n-1}}&amp;{\cdots}&amp;{x_{n-1}^{n-1}}\\<br>\end{pmatrix}={<br>\begin{pmatrix}<br>{y_0}\\<br>{y_1}\\<br>{y_2}\\<br>{\vdots}\\<br>{y_{n-1}}<br>\end{pmatrix}}^T$</p><p>要去计算 左侧的a,如果能快速求逆，那么有</p><p>${\begin{pmatrix}<br>{a_0}\\<br>{a_1}\\<br>{a_2}\\<br>{\vdots}\\<br>{a_{n-1}}\\<br>\end{pmatrix}}^T<br>={\begin{pmatrix}<br>{y_0}\\<br>{y_1}\\<br>{y_2}\\<br>{\vdots}\\<br>{y_{n-1}}<br>\end{pmatrix}}^T<br>\begin{pmatrix}<br>{1}&amp;{1}&amp;{\cdots}&amp;{1}\\<br>{x_{0}}&amp;{x_{1}}&amp;{\cdots}&amp;{x_{n-1}}\\<br>{x_{0}^2}&amp;{x_{1}^2}&amp;{\cdots}&amp;{x_{n-1}^2}\\<br>{\vdots}&amp;{\vdots}&amp;{}&amp;{\vdots}\\<br>{x_{0}^{n-1}}&amp;{x_{1}^{n-1}}&amp;{\cdots}&amp;{x_{n-1}^{n-1}}\\<br>\end{pmatrix}^{-1}$</p><p>也就是求完逆以后，只需要O(n^2)来得到a</p><p>$V(x_0,x_1,\cdots ,x_{n-1})=\begin{bmatrix} {1}&amp;{1}&amp;{\cdots}&amp;{1} \\<br>{x_{0}}&amp;{x_{1}}&amp;{\cdots}&amp;{x_{n-1}}\\<br>{x_{0}^2}&amp;{x_{1}^2}&amp;{\cdots}&amp;{x_{n-1}^2}\\<br>{\vdots}&amp;{\vdots}&amp;{}&amp;{\vdots}\\<br>{x_{0}^{n-1}}&amp;{x_{1}^{n-1}}&amp;{\cdots}&amp;{x_{n-1}^{n-1}}\\ \end{bmatrix}$</p><p>有 $ V(x_0,x_1,\cdots ,x_{n-1})=\prod _{n &gt; i &gt; j \geq 0}(x _{i}-x _{j})$</p><p>众所周知 $A^{-1} = \frac{1}{|A|} A^*$,然而 这暴力算是4次方复杂度，似乎比玩高斯消元3次方还要久</p><h1 id="换个方法-拉格朗日插值"><a href="#换个方法-拉格朗日插值" class="headerlink" title="换个方法 拉格朗日插值"></a>换个方法 拉格朗日插值</h1><p>想法很简单 比如过点 (1,1) (4,7) (9,100)的二次函数</p><p>直接表达式$f(x) = k_1(x-4)(x-9)+k_2(x-1)(x-9) + k_3(x-1)(x-4)$</p><p>注意到x取其中一个点时，求和的表达式只有一个不为0</p><p>也很明显 $k_i = y_i\prod\limits_{j\not =i}\dfrac{1}{x_i-x_j}$</p><p>$f(x)=\sum\limits_{i=0}^ky_i\prod\limits_{j\not =i}\dfrac{x-x_j}{x_i-x_j}$, 也可以知道它的逆矩阵 就是求和每一部分 的展开式的系数，(令 $y = [0 … 0 1 0 … 0]$ 即可知</p><p>回到题目$x_i = i+1, y_i = \sum\limits_{p=0}^n A_p(i+1)^p$</p><p>$f(x)=\sum\limits_{i=0}^k[y_i\prod\limits_{j\not =i}\dfrac{x-j-1}{i-j}]$</p><p>注意到 我们其实只需要求 $f(k+1)$ , 计算 所有$y_i$ O(n^2), 但是右侧看似复杂的$x_i$乘积，因为这里的取值，变成了只需要做阶乘运算即可。可类似前缀和。 再配合一点乘法逆元即可</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code class="python">N = 0A = []inv = []po = []poinv = []MOD = 1000000007def u(v):    r = 0    vi = 1    for i in range(0, N+1):        r += A[i] * vi        r %= MOD        vi *= v        vi %= MOD    return rdef init():    # init inv    global inv    inv = []    inv.append(0)    inv.append(1)    for i in range(2, N+10):        inv.append(((MOD - MOD // i) * inv[MOD%i]) % MOD)    # init power    global po    po = []    po.append(1)    for i in range(1, N+10):        po.append( (po[i-1] * i) % MOD )    global poinv    poinv = []    poinv.append(1)    for i in range(1, N+10):        poinv.append( (poinv[i-1] * inv[i]) % MOD )def fitn(y, n):    r = 0    for i in range(1, n+1):        mul = y[i-1]        # 分子        mul *= po[n] * inv[n+1-i]        # 分母乘法逆元        mul *= poinv[i-1] * poinv[n-i]        if (n - i) % 2 == 1:            mul *= -1        mul %= MOD        r += mul        r %= MOD    return (r+MOD)%MODdef work():    init()    ans = 0    y = []    for v in range(1, N+1):        arr.append(u(v))    for i in range(1, N+1):        r = fitn(y, i)        print(r, end=&#39; &#39;)        ans += r    return ansdef pe():    global N, A    N = 10    A = [1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1]    print(work())def main():    global N, A    N = int(input())    A = list(map(int, input().split()))    work()# pe()main()</code></pre><p>至此 我们通过了较难版本的hackerrank 上的pe101</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.vesnik.math.rs/vol/mv19303.pdf" target="_blank" rel="noopener">http://www.vesnik.math.rs/vol/mv19303.pdf</a></p><p><a href="https://proofwiki.org/wiki/Inverse_of_Vandermonde_Matrix" target="_blank" rel="noopener">https://proofwiki.org/wiki/Inverse_of_Vandermonde_Matrix</a></p>]]></content>
      
      
      <categories>
          
          <category> Project Euler </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pe </tag>
            
            <tag> project euler </tag>
            
            <tag> math </tag>
            
            <tag> Vandermonde </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>project euler 84 Monopoly odds 不会了 算概率是认真的吗？</title>
      <link href="/Blog/2020-06-27-project-euler084/"/>
      <url>/Blog/2020-06-27-project-euler084/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://projecteuler.net/problem=84" target="_blank" rel="noopener">https://projecteuler.net/problem=84</a></p><h1 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h1><p>玩大富翁</p><p>有一些位置会触发跳转（跳转逻辑贼复杂）</p><p>问落在哪三个位置的概率最大</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>我都不想贴代码，这玩意真是靠大量数据“算”概率的咯。</p><p>所以伪随机数还是能作为概率意义上的“随机数”是因为 题目假设赛子均匀，而随机数分布的期望是均匀，数据量大了就符合统计逻辑？</p><p>想说有不少是模拟 行走去 记录次数然后处以总步数，然而这样的操作如果把4面换到6面很大才能 收敛到题目已经告诉你的102400</p><p>所以虽然4面可以比较小的数就 得到答案，但感觉更多是因为小，所以“猜”对的。</p><p>感觉还是应该 所有点 2.5%，然后每一轮进行所有格子走一次，直接计算概率转移，而不是模拟random，从而直到收敛（这也是能判断的了，不像上面计次 难以判断是否收敛，只能靠设置大，更大，再大的步数）。</p><p>疑惑的是，很多题目都是给小数据，要求大数据，怎么这一道题是给6求4。</p><p>其实读题,题太长才是我觉得的问题。XD</p>]]></content>
      
      
      <categories>
          
          <category> Project Euler </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pe </tag>
            
            <tag> project euler </tag>
            
            <tag> math </tag>
            
            <tag> 概率统计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>project euler 100 Arranged probability</title>
      <link href="/Blog/2020-06-23-project-euler100/"/>
      <url>/Blog/2020-06-23-project-euler100/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://projecteuler.net/problem=100" target="_blank" rel="noopener">https://projecteuler.net/problem=100</a></p><h1 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h1><p>$\frac{x(x-1)}{y(y-1)} = \frac{1}{2}$,x,y均为正整数，求首个满足表达式且$x&gt;10^{12}$的x的值</p><h1 id="读懂本文你可能需要的前置知识"><a href="#读懂本文你可能需要的前置知识" class="headerlink" title="读懂本文你可能需要的前置知识"></a>读懂本文你可能需要的前置知识</h1><p><a href="/Blog/2020-05-29-project-euler066/">pell方程和连分数 project euler 66</a></p><h1 id="解"><a href="#解" class="headerlink" title="解"></a>解</h1><p>显然 通过等式变换的基本操作 有</p><p>$(2y-1)^2-2(2x-1)^2 = -1$</p><p>这不就是 project euler的66题很像的pell 方程吗！</p><p>一点比较好的是$10^{12}$,其实可以双指针暴搜,O(x)时间复杂度，O(1)空间暴力算几个小时算出来,但当然如果是暴力也就不会写这篇文章了</p><p>稍加搜索也能搜到这个 <code>https://www.alpertron.com.ar/QUAD.HTM</code> 也就是说$ax^2+bxy+cy^2+dx+ey+f=0$的等式 都能解，</p><p>当然直接用网页也不需要这篇文章了，本文还是以证明为核心</p><h2 id="简化"><a href="#简化" class="headerlink" title="简化"></a>简化</h2><p>考虑 $ax^2+bxy+cy^2+dx+ey+f=0$ 二元二次方程(以下过程中所有字母均为整数)</p><p>因为对称性，我们只考虑$a \neq 0$，否则交换x和y。</p><p>不然就是形如$axy+bx+cy+d=0$的方程了，而这类方程总能化为$(ax+b)(cy+d) = e$的形式，变为拆分e的。众所周知比较容易，本文就不涉及细节了。</p><p>$4a(ax^2+bxy+cy^2+dx+ey+f)=0$</p><p>$4a^2x^2+4abxy+4acy^2+4adx+4aey+4af=0$</p><p>$(2ax+by+d)^2 +(4ac-b^2)y^2+(4ae-2bd)y+(4af-d^2)= 0$</p><p>这形如</p><p>$x^2+ay^2+by+c=0$, 如果这里$y^2$的系数$a=0$,那么也是$x^2+ay+b=0$的简单情况，讨论$x \in [0,a)$，这里不细聊了,以下只考虑$a\neq 0$</p><p>$4a^2(x^2+ay^2+by+c) = 0$</p><p>$(2ax)^2+4a^3y^2+4a^2by+4a^2c = 0$</p><p>$(2ax)^2+a(2ay+b)^2+(4a^2c-ab^2) = 0$</p><p>这形如</p><p>$x^2+ay^2+c=0$</p><p>最终又回到了 这个式子，如果这里的a是正数，显然是一个椭圆方程，有限范围内的一些尝试,不是本次讨论的，暂时不展开了</p><p>那么最终回到了</p><p>$x^2-dy^2 = k$,其中$d &gt; 0,k \neq 0$, $d$为非平方数,否则是平方数间隔问题</p><h2 id="温故知新"><a href="#温故知新" class="headerlink" title="温故知新"></a>温故知新</h2><p>看看之前project euler 66 的证明过程</p><ol><li>pell方程基础解</li><li>pell方程解存在性</li><li>连分数分子分母递推式</li><li>连分数，分子分母相关性质(分子分母互质性,原无理数与渐进数差值表达式，差值绝对值单调递减性，连分数是最给定分母以及更小分母中最接近原无理数，任何满足“某不等式”的数字是渐进数（这个不等式是pell方程 的必要条件）)</li><li>Lagrange’s Theorem 二次无理数与有循环节的连分数</li><li>Galois’ Theorem 纯循环连分数与reduced二次有理数</li><li>根号n的连分数性质（精确的$\frac{P_n+\sqrt{d}}{Q_n}$表示 和 形如pell方程 与$Q_n$的等式）</li><li>分类讨论$Q_n$与n的取值最后的结论</li></ol><p>对比有</p><p>1&amp;2不再是一定存在的，我们会讨论如果存在，那么具有性质和基础解</p><p>3只涉及连分数的性质，之前证明可复用</p><p>4同样只涉及连分数和不等式，最终结论任何最简分数$\frac{h}{k}$如果满足 $|\sqrt{d} - \frac{h}{k}| &lt; \frac{1}{2k^2}$ 那么它是个渐进分数,同样复用</p><p>5,6都是连分数循环性质，reduced性质和二次无理数的关系，可复用</p><p>7是根号n的连分数表示性质，和$h_{n-1}^2-dk_{n-1}^2=(-1)^nQ_n$的证明，可复用</p><p>8再回到$x^2-dy^2=k$</p><h2 id="如果存在"><a href="#如果存在" class="headerlink" title="如果存在"></a>如果存在</h2><p>若存在$(x_0,y_0),x_0 &gt; 0,y_0 &gt; 0$使得 $x_0^2-dy_0^2 = k$, 因为有最小的$(x_1,y_1)$满足$x_1^2-dy_1^2=1$ (证明见pe 66的证明)</p><p>那么通过$(x_0+y_0\sqrt{d})(x_1+y_1\sqrt{d})$能得到新的解</p><p>$(x_0^2-dy_0^2)(x_1^2-dy_1^2) = (x_0x_1+dy_0y_1)^2 - d(x_0y_1+x_1y_0)^2 = k$，所以如果有解那么有无限组解</p><p>设$(x_i,y_i)$是满足$x^2-dy^2 = k$的最小解,$(x_j,y_j)$是另一个满足方程的解,有$x_i&lt;x_j,y_i&lt;y_j$</p><p>若$(x_j,y_j)$不是由最小的$(x_i,y_i)$和$(x_1,y_1)$生成的,则</p><p>$(x_i+y_i\sqrt{d})(x_1+y_1\sqrt{d})^n &lt; (x_j+y_j\sqrt{d}) &lt; (x_i+y_i\sqrt{d})(x_1+y_1\sqrt{d})^{n+1}$</p><p>同时乘$(x_1-y_1\sqrt{d})^n$</p><p>$x_i+y_i\sqrt{d} &lt; (x_j+y_j\sqrt{d})(x_1-y_1\sqrt{d})^n &lt; (x_i+y_i\sqrt{d})(x_1+y_1\sqrt{d})$</p><p>因为中间的也满足 $x+y\sqrt{d}$的形式</p><p>若$(x_j+y_j\sqrt{d})(x_1-y_1\sqrt{d})^n$ 也是一组生成的解</p><p>令$(x_j+y_j\sqrt{d})(x_1-y_1\sqrt{d})^n = x_p+y_p\sqrt{d}$</p><p>有$(x_j-y_j\sqrt{d})(x_1+y_1\sqrt{d})^n = x_p-y_p\sqrt{d}$</p><p>有$(x_j-y_j\sqrt{d})(x_1+y_1\sqrt{d})^n = x_p-y_p\sqrt{d}$</p><p><strong> TODO 不会证明了 失败 </strong></p><h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p>$1=\frac{x_0^2-dy_0^2}{x_1^2-dy_1^2} $</p><p>$= \frac{x_0+y_0\sqrt{d}}{x_1+y_1\sqrt{d}} \cdot \frac{x_0-y_0\sqrt{d}}{x_1-y_1\sqrt{d}}$</p><p>$= \frac{(x_0+y_0\sqrt{d})(x_1-y_1\sqrt{d})}{-1} \cdot \frac{(x_0-y_0\sqrt{d})(x_1+y_1\sqrt{d})}{-1}$</p><p>$= ((x_0x_1-y_0y_1d)+(x_1y_0-x_0y_1)\sqrt{d})((x_0x_1-y_0y_1d)-(x_1y_0-x_0y_1)\sqrt{d})$</p><p>$= (x_0x_1-y_0y_1d)^2-(x_1y_0-x_0y_1)^2 d $</p><p>说明两个不同的<code>-1</code>的解 一定是通过乘一个<code>=1</code>的解得到的</p><p>说明存在一个<code>=-1</code>的基础解，其它解是靠基础解乘上(<code>=1</code>的基础解的幂次)得到的</p><h2 id="主要关心-1"><a href="#主要关心-1" class="headerlink" title="主要关心 = -1"></a>主要关心 = -1</h2><p>同时我们在66证明过 $h_{n-1}^2-dk_{n-1}^2 = (-1)^nQ_n$</p><p><strong>注记：最开始66那一版本,的渐进分数的部分直接使用的是pell方程中$\sqrt{d}$,其中d是非平方正整数，但下面的部分证明和证明实际上只需要保证 其中部分的参数只要是无理数即可。所以进行了修改 </strong></p><p>若$x^2-\alpha^2 y^2 = \beta$, 且存在解，若$|\beta| &lt; \alpha $,则$\frac{x}{y}$ 一定是 $\alpha$的渐近分数。</p><p>证明</p><p>若$\beta &gt; 0$,有 $x^2-\alpha^2y^2 &gt; 0 $即$x&gt;y\alpha$</p><p>有$|\frac{x}{y} - \alpha| = \frac{\beta}{y(x+y\alpha)} &lt; \frac{\beta}{2y^2\alpha} &lt; \frac{1}{2y^2}$</p><p>前面证明过(66的6.2.3.8)满足这个表达式 的 对应的最简分数$\frac{x}{y}$ 一定是渐近连分数</p><p>若$\beta &lt; 0$ </p><p>$y^2 - \frac{1}{\alpha^2}x^2 = \frac{-\beta}{\alpha^2}$,注意到$|\frac{-\beta}{\alpha^2}| &lt; \frac{1}{ \alpha } $ 也就回到上面的情况</p><p>综上，证毕。</p><p>以上的证明说明了 如果$x^2-dy^2=-1$如果有解,那么 一定是一个最简分数</p><p>同样根据66的过程 我们 连分类讨论的内容都能复用</p><p>$h_{n-1}^2-dk_{n-1}^2=(-1)^nQ_n = (-1)^n, n = kl $,l为$\sqrt{d}$的 最小周期长度,</p><p>也就是再看个奇偶，最后得到了pell方程和连分数比较紧密的结论</p><p>$l$长度为偶数无解</p><p>$l$长度为奇数, $(x,y) = {h_{(2m+1)l-1},k_{(2m+1)l-1}}$,m为非负整数 </p><h2 id="回到题目"><a href="#回到题目" class="headerlink" title="回到题目"></a>回到题目</h2><p>$x^2-2y^2 = -1$</p><p>关于$\sqrt{2}$的连分数展开众所周知了也(66连分数开篇就是)</p><p>从前面得到的结论看 也可以通过$(x_0+\sqrt{d}y_0)(x_1+\sqrt{d}y_1)^n$来生成</p><p>$(1+\sqrt{2})(3+2\sqrt{2})^n$</p><p>$(x+y\sqrt{2})(3+2\sqrt{2})^n$</p><p>$(x_n,y_n) = (3x_{n-1}+4y_{n-1},2x_{n-1}+3y_{n-1})$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>嗯 高亮有点问题 整除识别成注释了</p><pre><code class="python">x = 1y = 1while True:    x,y = 3*x+4*y,2*x+3*y;    print(x,y);    if (x+1)//2 &gt; 1000000000000:        print((y+1)//2)        break</code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://oeis.org/A031396" target="_blank" rel="noopener">https://oeis.org/A031396</a></p><p><a href="https://en.wikipedia.org/wiki/Pell%27s_equation#The_negative_Pell_equation" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Pell%27s_equation#The_negative_Pell_equation</a></p><p><a href="https://mathworld.wolfram.com/PellEquation.html" target="_blank" rel="noopener">https://mathworld.wolfram.com/PellEquation.html</a></p><h1 id="总结-amp-感受"><a href="#总结-amp-感受" class="headerlink" title="总结&amp;感受"></a>总结&amp;感受</h1><p>有搜到有人通过枚举前面的小解，发现了增长比例有趋近于定值的趋势。哎 我连找规律也不会了吗</p><p>没聊到其它非1和非-1时的情况</p><p>似乎$x^2-34y^2=-1$不存在解,所以可能无法证明它一定有解，但是如果有解，上面证明了一定是通过连分数的渐进分数找到的,也可以通过基础解生成</p>]]></content>
      
      
      <categories>
          
          <category> Project Euler </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pe </tag>
            
            <tag> project euler </tag>
            
            <tag> math </tag>
            
            <tag> pell eq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>project euler 078 Coin partitions</title>
      <link href="/Blog/2020-06-10-project-euler078/"/>
      <url>/Blog/2020-06-10-project-euler078/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://projecteuler.net/problem=78" target="_blank" rel="noopener">https://projecteuler.net/problem=78</a></p><p><code>4 = 4 = 3+1 = 2+2 = 2+1+1=1+1+1+1,p(4)=5</code></p><p><code>5 = 5 = 4+1 = 3+2 = 3+1+1 = 2+2+1 = 2+1+1+1 = 1+1+1+1+1,p(5)=7</code></p><p>求最小的n使得 <code>p(n) % 1_000_000 = 0</code></p><h1 id="rust"><a href="#rust" class="headerlink" title="rust"></a>rust</h1><p>dp递推暴力似乎并不可解,<strong>警告 下面的代码 只要没找到答案就会一直增加vector大小，所以建议尽早掐断，不然会吃很大内存XD,可能造成系统卡死或者假卡死</strong></p><pre><code class="rust">use std::cmp;// dp[n][x] + (n-x &lt;= x?) + sum(dp[n-x][1 -&gt; min(x,n-x-1)])fn main() {    let mut dp = Vec::new();    let mut dpsum = Vec::new();    dp.push(Vec::new());    dpsum.push(Vec::new());    let mut i = 1;    loop{        dp.push(Vec::new());        dpsum.push(Vec::new());        dp[i].push(0);        dpsum[i].push(0);        let mut cnt = 0;        for j in 1..i+1 {            dp[i].push(0);            dpsum[i].push(0);            if i == j {                dp[i][j] = 1;            }else{                dp[i][j] = dpsum[i-j][cmp::min(j,i-j)];            }            cnt += dp[i][j];            cnt %= 1_000_000;            dpsum[i][j] = (dpsum[i][j-1]+dp[i][j]) % 1_000_000;        }        println!(&quot;{}=&gt;{}&quot;,i,cnt);        if cnt % 1_000_000 == 0 {            println!(&quot;{}=&gt;{}&quot;,i,cnt);            return ;        }        i+=1;    }}</code></pre><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="分拆"><a href="#分拆" class="headerlink" title="分拆"></a>分拆</h2><p>实际上可以把n看成，拆了$a_1$个1,$a_2$个2…</p><p>所以$p(n)$可以看成 $n = 1a_1+2a_2+3a_3+…+na_n$的解 $(a_1,a_2,…,a_n)$的个数</p><p>也是 $(1+x+x^2+x^3+…)(1+x^2+x^4+x^6+…)(1+x^3+x^6+x^9+…)…$ 结果中 $x^n$的系数,因为相当于从每个括号中选取了一项 假设第i个括号选取的是$x^{ij}$ 那么对应上面 $a_i = j$，也对应到相关的解</p><p>也就是 $\sum_{n=0}^{\infty} p(n)x^n = (1+x+x^2+…)(1+x^2+x^4+…)… = \frac{1}{1-x} \frac{1}{1-x^2} … = \prod_{n=1}^{\infty} \frac{1}{1-x^n} $ </p><h2 id="互异分拆"><a href="#互异分拆" class="headerlink" title="互异分拆"></a>互异分拆</h2><p>如果分拆结果要求 不能出现相同的数字(互异分拆 partitions into distinct parts)，则相当于上面$a_i$增加限制$a_i\in\{0,1\}$</p><p>也就是 $\sum_{n=0}^{\infty} q(n)x^n = (1+x)(1+x^2)… = \prod_{n=1}^{\infty} (1+x^n) $ </p><p>$p(n) = $拆分成偶数个互异的数的方案数 + 拆分成奇数个互异的数方案数</p><p>考虑一个互异分拆$n=n_1+n_2+…+n_s$ (注意这里是$n_i$不是$a_i$,实际是$a_{n_i} = 1$的那些)</p><p>$x^{n} = x^{n_1}x^{n_2}…x^{n_s}$</p><p>$(-1)^sx^{n} = (-x^{n_1})(-x^{n_2})…(-x^{n_s})$</p><p>考虑 $\sum_{n=0}^{\infty} g(n)x^n = (1-x)(1-x^2)… = \prod_{n=1}^{\infty} (1-x^n) $ 从值的构成上 它依然表示的是互异分拆 </p><p>注意到:$a_{n_i} = 0$在乘积贡献上是1,$a_{n_i}=1$在乘积贡献上是$-1$,所以 上述 每个互异分拆 对$g(n)$的贡献 是 $(-1)^s$</p><p>也就是$g(n) = $拆分成偶数个互异的数方案数 - 拆分成奇数个互异的数方案数</p><h2 id="g-n"><a href="#g-n" class="headerlink" title="g(n)"></a>g(n)</h2><p>下面我们要看看欧拉大佬的神之推导</p><p>先上 Ferrer 图</p><p>比如 $ 11 = 5+4+2$</p><pre><code>xxxxxxxxxxx</code></pre><p>只考虑互异分拆，把底部的长度记为b(上图是1),从最大递减1的长度记为s(上图是5,4 所以s=2)</p><p>如果 一个图 $s \le b$,那么可以把最下面一排移到右侧,上图变为</p><pre><code>xxxxx xxxxx x</code></pre><p>注意性质</p><ol><li><p>移动以后，因为少了一行，分拆的奇偶性变了。</p></li><li><p>b至少增加1, s = 原来的b ，所以 新的图是 s&gt;b的。</p></li></ol><p>仅有一种情况是不能移动的（因为要移动的最后一行点数比移动后剩余的行数大1） 如下,注意到需要s排满和s排满，所以对于分拆的一个n，至多出现一次，学过等差数列求和的也可以看出满足这种的n的公式。</p><p>$n = \frac{s(s+(2s-1))}{2}$</p><pre><code>xxxxxxxxxxxx</code></pre><p>以上 说明除了这特殊的以外，所有$s \le b$的 都有唯一对应的 $s &gt; b$的互异ferrer图</p><hr><p>再看 $s&gt;b$的,例如(s=3,b=2)</p><pre><code>xxxxxxxxxxxxxx</code></pre><p>我们把右侧45度的点移到下面一排，有</p><pre><code>xxxxxxxxxxxxxx</code></pre><p>同样有性质</p><ol><li>移动以后因为多了一行，分拆的奇偶性变了</li><li>新的s &gt;=旧的s，新的b = 旧的s，所以有 新的s&gt;=新的b</li></ol><p>同样有特殊的$s+1=b$的排满时，不能移动（否则移动后最下两行点数相等）</p><pre><code>xxxxxxxxxxxxxxx</code></pre><p>同样学过等差数列求和的，对于一个n最多有一个，n的表达式也呼之欲出了</p><p>$n = \frac{s((s+1)+2s)}{2}$</p><p>综上 除了两种特殊的情况，其它的 都能找到一一对应的，所以偶奇相减除了特殊的外结果为0</p><p>所以就有神奇的展开</p><p>$\prod_{n=1}^{\infty}(1-x^n) = 1+\sum_{s=1}^{\infty} (-1)^s(x^{\frac{3s^2-s}{2}}+x^{\frac{3s^2+s}{2}})$</p><h1 id="回到目标p-n"><a href="#回到目标p-n" class="headerlink" title="回到目标p(n)"></a>回到目标p(n)</h1><p>$(\sum_{n=0}^{\infty} p(n)x^n)(\cdot \prod_{n=1}^{\infty} 1-x^n) = (\prod_{n=1}^{\infty} )\cdot(\frac{1}{1-x^n} \cdot \prod_{n=1}^{\infty} 1-x^n) = 1 $ (…真的能这样乘吗。。</p><p>$(\sum_{n=0}^{\infty} p(n)x^n)(1+\sum_{s=1}^{\infty} (-1)^s(x^{\frac{3s^2-s}{2}}+x^{\frac{3s^2+s}{2}})) = 1 $ </p><p>也就意味着左边 乘以后 对于$n&gt;0$ 乘积后的系数都是$a_n = 0$</p><p>$a_n x^n = (p(n)x^n\cdot 1 + \sum_{s=1}^{\frac{3s^2-s}{2} \le n}[ p(n-\frac{3s^2-s}{2}) x^{n-\frac{3s^2-s}{2}} (-1)^s \cdot x^{\frac{3s^2-s}{2}} ]+ \sum_{s=1}^{\frac{3s^2+s}{2} \le n}[ p(n-\frac{3s^2+s}{2}) x^{n-\frac{3s^2+s}{2}} (-1)^s \cdot x^{\frac{3s^2+s}{2}} ])$</p><p>$0=a_n = p(n) + \sum_{s=1}^{\frac{3s^2-s}{2} \le n}[ p(n-\frac{3s^2-s}{2}) (-1)^s ]+ \sum_{s=1}^{\frac{3s^2+s}{2} \le n}[ p(n-\frac{3s^2+s}{2}) (-1)^s ])$</p><p>由此 我们有了$p(n)$的递推式,时间复杂度像是$n^1.5$(因为 s与n的不等式 是s平方增长 ，空间就只需要$O(n)$</p><p>$p(n) =  \sum_{s=1}^{\frac{3s^2-s}{2} \le n}[(-1)^{s+1} p(n-\frac{3s^2-s}{2})]+ \sum_{s=1}^{\frac{3s^2+s}{2} \le n}[(-1)^{s+1} p(n-\frac{3s^2+s}{2}) ])$</p><p>只需要初始化$p(0) = 1$</p><p><strong>至此就已经可以编码了</strong></p><p>有的地方会采取 $t=-s$的带入第一个求和，把上面两个求和合并成一个,也就是 s取非零的正负整数</p><p>$p(n) = \sum_{s\neq 0,s\in Z,\frac{3s^2+s}{2}\le n} [(-1)^{s+1}p(n-\frac{3s^2+s}{2})] $</p><p>然后就是五边形数相关的东西了,在这道题看来 不是必须的</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code class="rust">fn main() {    let mut ans = Vec::new();    let modnum:i32 = 1_000_000; // 注意usize范围很小 大坑    ans.push(1);    let mut i = 1;    loop{        let mut ansi:i32 = 0;        let mut s:i32 = 1;        let mut sres = ( s*(3*s-1)/2 ) as usize;        while sres &lt;= i{            ansi += ((s%2)*2-1) * ans[i - sres];            ansi %= modnum;            s+=1;            sres = ( s*(3*s-1)/2 ) as usize;        }        s = 1;        sres = (s*(3*s+1)/2) as usize;        while sres &lt;= i{            ansi += ((s%2)*2-1) * ans[i - sres];            ansi %= modnum;            s+=1;            sres = (s*(3*s+1)/2) as usize;        }        ansi+=modnum;        ansi%=modnum;        ans.push(ansi);        println!(&quot;{}=&gt;{}&quot;,i,ansi);        if ansi == 0 {            println!(&quot;ans :{}&quot;,i);            return ;        }        i+=1;    }}</code></pre><p>秒出</p><p>不过看结果和我第一遍卡爆内存的值一比，我想是不是多点内存也是暴力可行的XD。</p><h1 id="本题没有用到的-euler’s-theorem"><a href="#本题没有用到的-euler’s-theorem" class="headerlink" title="本题没有用到的 euler’s theorem"></a>本题没有用到的 euler’s theorem</h1><p>互异分拆方案数=拆分成全是奇数个的方案数 ,$(1+x+x^2+…)(1+x^3+x^6+…)(1+x^5+x^{10}+…)…$</p><p>$\prod_{n=1}^{\infty} \sum_{k=0}^{\infty} x^{k*(2n-1)}$</p><p>$= \prod_{n=1}^{\infty} \frac{1}{1-x^{2n-1}}$</p><p>$= \prod_{n=1}^{\infty} \frac{1}{1-x^{2n-1}} \frac{\prod_{n=1}^{\infty} 1-x^{2n}}{\prod_{n=1}^{\infty} 1-x^{2n}}$</p><p>$= \frac{1}{\prod_{n=1}^{\infty} 1-x^{2n-1}}\frac{\prod_{n=1}^{\infty} (1-x^n)(1+x^n)}{\prod_{n=1}^{\infty} 1-x^{2n}}$</p><p>$ = \prod_{n=1}^{\infty} (1+x^n)$ (这。。。无限项这样拆分相消科学吗</p><p>就有了wikipedia上面那个公式 $\sum _{n=0}^{\infty }q(n)x^{n}=\prod _{k=1}^{\infty }(1+x^{k})=\prod _{k=1}^{\infty }{\frac {1}{1-x^{2k-1}}}.$</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><code>https://en.wikipedia.org/wiki/Partition_(number_theory)</code></p><p><code>https://en.wikipedia.org/wiki/Pentagonal_number_theorem</code></p>]]></content>
      
      
      <categories>
          
          <category> Project Euler </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pe </tag>
            
            <tag> project euler </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>project euler 075 Singular integer right triangles</title>
      <link href="/Blog/2020-06-08-project-euler075/"/>
      <url>/Blog/2020-06-08-project-euler075/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://projecteuler.net/problem=75" target="_blank" rel="noopener">https://projecteuler.net/problem=75</a></p><p>$12=3+4+5,3^2+4^2=5^2;$</p><p>有些整数 有唯一拆分，可以拆分成直角三角形的三条边</p><h1 id="rust"><a href="#rust" class="headerlink" title="rust"></a>rust</h1><p>看上去 枚举中间长度，二分最短长度，估算一下 <code>(n*n/4 log n)</code>，</p><pre><code class="rust">use std::thread;use std::sync::mpsc;const N:usize = 1_500_000;fn f(s:usize) -&gt; usize{    let mut cnt = 0;    let mstart = if s/4 &gt; 1 {s/4}else{1};    for m in mstart..s/2+1 {    // for m in 1..s+1 {        let mut l = 1;        let mut r = m+1;        while l+1 &lt; r {            let mid = (l+r)/2;            let o = s-m-mid;            if o &lt; m  || mid*mid + m*m &gt; o*o {                r = mid;            }else if mid*mid + m*m &lt;= o*o {                l = mid;            }        }        let o = s-m-l;        if l*l+m*m == o*o {            cnt+=1;            if cnt &gt; 1{                return 0;            }        }    }    return if cnt == 1 {1}else {0};}fn main() {    let (tx, rx) = mpsc::channel();    thread::spawn(move || {        for i in 1..N+1{            let tx_clone = mpsc::Sender::clone(&amp;tx) ;             thread::spawn(move || {                tx_clone.send( (i,f(i)) ).unwrap();            });        }    });    let mut ans = 0;    for _i in 1..N+1 {        let rxr = rx.recv().unwrap();        if rxr.1 == 1 {            ans += 1;            if ans % 1000 == 0 {                println!(&quot;sum: {}&quot;, rxr.0);            }        }    }    println!(&quot;ans:{}&quot;,ans);}</code></pre><p>答案每新增1000 输出一次当前i，但运行了3min+ (x8核) 我把它掐了,准备学一学 如何数学角度优化</p><pre><code>time ./p075 sum: 8890sum: 18078sum: 27312sum: 36472sum: 45568sum: 54426sum: 63444sum: 72672sum: 81828sum: 90648sum: 99898sum: 109240sum: 118476sum: 127950sum: 137208sum: 146294sum: 155246sum: 164206sum: 173180sum: 182322sum: 191448sum: 200406sum: 209448sum: 218514sum: 227412sum: 236474sum: 245712sum: 254716sum: 263728sum: 272950sum: 282184sum: 291248sum: 300514sum: 309800sum: 319228sum: 328368sum: 337978sum: 347204sum: 356892sum: 366226sum: 375914^Creal    3m33.095suser    24m40.718ssys    0m22.575s</code></pre><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><p>如果有正整数对$(a,b,c)$满足$a^2+b^2=c^2$那么 这是一组勾股数</p><p>我们可以有$(ka,kb,kc)$也是勾股数，对于$gcd(a,b,c) = 1$的情况 称作素勾股数字</p><p>若$m&gt;n$且$gcd(m,n)=1$ , m,n一个奇一个偶。</p><p>则令 $a=m^2-n^2$,$b=2mn$,$c=m^2+n^2$ ，则$(a,b,c)$是 素勾股数 </p><p>充分性显然，上述表达满足勾股定理,且根据gcd运算规则是素勾股数</p><p>下面再证明必要，也就是所有素勾股数都能拆解成上面的<code>m</code>和<code>n</code>,</p><p>因为$gcd(a,b,c) = 1$ 说明两两$gcd = 1$(否则如果两个gcd不为1,运算过程 会导致另一个变量也是这个gcd的倍数 )</p><p>因此 必定<code>a,b</code>一个奇一个偶</p><p>根据轮换性质，不妨设 a奇 b偶 c奇</p><p>有$(c-a)(c+a)=b^2$</p><p>令  $\frac{m}{n} = \frac{c+a}{b} = \frac{b}{c-a}$</p><p>下面解 方程组$\frac{c}{b} + \frac{a}{b} = \frac{m}{n}, \frac{c}{b}-\frac{a}{b}=\frac{n}{m}$</p><p>得到$\frac{c}{b}=\frac{m^2+n^2}{2mn},\frac{a}{b}=\frac{m^2-n^2}{2mn}$</p><p>所以 素勾股数字总能写成上述m,n的形式</p><p>以上证明了 素勾股数 和 m,n 形式的充要关系</p><hr><p>注意到 $c=m^2+n^2$</p><p>所以 最大的只用枚举到 $\sqrt{\frac{l}{2}}$</p><h1 id="code"><a href="#code" class="headerlink" title="code"></a>code</h1><pre><code class="rust">use std::thread;use std::sync::mpsc;use std::collections::HashMap;const N:usize = 1_500_000;fn gcd(v1:usize,v2:usize) -&gt; usize{    return if v2 == 0 {v1} else{gcd(v2,v1%v2)}}fn f(n:usize) -&gt; HashMap&lt;usize,usize&gt;{    let mut m = n+1;    let mut ret = HashMap::new();    while 2*m*(m+n) &lt;= N{        if gcd(m*m-n*n,2*m*n) == 1 {            println!(&quot;{},{},{} =&gt; {}&quot;,m*m-n*n,2*m*n,m*m+n*n,2*m*(m+n));            let l = 2*m*(m+n);            let mut kl = l;            while kl &lt;= N{                ret.insert(kl, match ret.get(&amp;kl) {                    Some(oldcnt) =&gt; oldcnt+1,                    None =&gt; 1                });                kl+=l;            }        }        m+=1;    }    return ret;}fn main() {    let (tx, rx) = mpsc::channel();    let maxn = 1000; // N+1    thread::spawn(move || {        for i in 1..maxn{            let tx_clone = mpsc::Sender::clone(&amp;tx) ;             thread::spawn(move || {                tx_clone.send( f(i) ).unwrap();            });        }    });    let mut hash_res = HashMap::new();    for _i in 1..maxn {        let rxr = rx.recv().unwrap();        for (k,v) in rxr{            hash_res.insert(k,match hash_res.get(&amp;k){                Some(oldv) =&gt; oldv+v,                None =&gt; v            });        }    }    let mut ans = 0;    for (_k,v) in hash_res{        if v == 1{            ans += 1;        }    }    println!(&quot;ans:{}&quot;,ans);}</code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://en.wikipedia.org/wiki/Pythagorean_triple" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Pythagorean_triple</a></p><p><a href="https://en.wikipedia.org/wiki/Formulas_for_generating_Pythagorean_triples" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Formulas_for_generating_Pythagorean_triples</a></p>]]></content>
      
      
      <categories>
          
          <category> Project Euler </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pe </tag>
            
            <tag> project euler </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>project euler 066 diophantine equation</title>
      <link href="/Blog/2020-05-29-project-euler066/"/>
      <url>/Blog/2020-05-29-project-euler066/</url>
      
        <content type="html"><![CDATA[<h1 id="叹气"><a href="#叹气" class="headerlink" title="叹气"></a>叹气</h1><p>从2020 02 09 挖的坑，中间很长一段时间鸽了，终于在05 29写完了.</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://projecteuler.net/problem=66" target="_blank" rel="noopener">https://projecteuler.net/problem=66</a></p><h1 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h1><p>d = 1-&gt;1000，d是非平方数</p><p>对于每个d 求最小的正整数<code>x</code>使得$x^2-dy^2=1$，其中x,y都是正整数,</p><p>最后对所有这些x求最大的x</p><h1 id="读懂本文你可能需要的前置知识"><a href="#读懂本文你可能需要的前置知识" class="headerlink" title="读懂本文你可能需要的前置知识"></a>读懂本文你可能需要的前置知识</h1><p>抽屉原理</p><p>二元一次方程</p><p>绝对值</p><p>有理数/无理数</p><p>模运算</p><p>矩阵运算</p><p>数列/递推数列</p><p>二项式展开</p><p>反证法</p><p>归纳法</p><p>不等式(缩放，三角不等式)</p><p>共轭实数(不太知道怎么翻译比较好，还是对偶实数？ 描述的就是$a+b\sqrt{m}$与$a-b\sqrt{m}$</p><h1 id="自闭尝试"><a href="#自闭尝试" class="headerlink" title="自闭尝试"></a>自闭尝试</h1><h2 id="一些自己的数学推论"><a href="#一些自己的数学推论" class="headerlink" title="一些自己的数学推论"></a>一些自己的数学推论</h2><p>如果质数p是d的因子，那么$x^2 = 1 (\bmod p)$,由此$x = 1 (\bmod p)$ 或者$x=p-1(\bmod p)$</p><p>所以我们可以按d的最大质因子的倍数 加减1去搜，能快个常数倍</p><hr><p>显然有$(x-1)(x+1) = dy^2$</p><p>令$d=d_1 \cdot d_2$</p><p>令$y=y_1 \cdot y_2$</p><p>根据对称性必然有 $d_1 \cdot {y_1}^2 - d_2 \cdot {y_2}^2 = (x+1) - (x-1) = 2$</p><p>一定程度上能减少搜索量，优化最多也就最大质数常数倍，也是最多100倍的优化</p><blockquote><p>另外就是MOD 4的性质，用处不大，2倍左右常数优化</p></blockquote><blockquote><p>然后就是1-100内的尝试是d=61最大1766319049</p></blockquote><blockquote><p>如果d0能找到x0，那么d0和y0因子平方的组合最多是x0,也是优化不大</p></blockquote><h2 id="python3写了个-按x递增搜索"><a href="#python3写了个-按x递增搜索" class="headerlink" title="python3写了个 按x递增搜索"></a>python3写了个 按x递增搜索</h2><pre><code class="python">N = 1000arr = set()Q = set()for d in range(1,N+1):    arr.add(d)x = 1while len(arr) != 0:    Q.add(x**2)    delarr = []    for d in arr:        if x**2 - 1 &gt; 0 and (x**2-1)%d == 0 and (x**2-1)//d in Q:            print(x,&quot;^2-&quot;,d,&quot;*&quot;,(x**2-1)//d,&quot;=1,leftcnt=&quot;,len(arr))            delarr.append(d)    for d in delarr:        arr.remove(d)    x+=1&quot;&quot;&quot;2 ^2- 3 * 1 =1,leftcnt= 10003 ^2- 2 * 4 =1,leftcnt= 9993 ^2- 8 * 1 =1,leftcnt= 9994 ^2- 15 * 1 =1,leftcnt= 9975 ^2- 6 * 4 =1,leftcnt= 9965 ^2- 24 * 1 =1,leftcnt= 9966 ^2- 35 * 1 =1,leftcnt= 9947 ^2- 12 * 4 =1,leftcnt= 9937 ^2- 48 * 1 =1,leftcnt= 9938 ^2- 7 * 9 =1,leftcnt= 9918 ^2- 63 * 1 =1,leftcnt= 9919 ^2- 5 * 16 =1,leftcnt= 9899 ^2- 20 * 4 =1,leftcnt= 9899 ^2- 80 * 1 =1,leftcnt= 98910 ^2- 11 * 9 =1,leftcnt= 98610 ^2- 99 * 1 =1,leftcnt= 98611 ^2- 30 * 4 =1,leftcnt= 98411 ^2- 120 * 1 =1,leftcnt= 98412 ^2- 143 * 1 =1,leftcnt= 98213 ^2- 42 * 4 =1,leftcnt= 981.....23915529 ^2- 365 * 1566993225616 =1,leftcnt= 29124220799 ^2- 284 * 2065658817600 =1,leftcnt= 29024220799 ^2- 639 * 918070585600 =1,leftcnt= 29024248647 ^2- 172 * 3418586519364 =1,leftcnt= 28824248647 ^2- 688 * 854646629841 =1,leftcnt= 28827365201 ^2- 666 * 1124405744400 =1,leftcnt= 28630580901 ^2- 550 * 1700348192676 =1,leftcnt= 28532080051 ^2- 106 * 9708770492100 =1,leftcnt= 28432080051 ^2- 424 * 2427192623025 =1,leftcnt= 28432080051 ^2- 954 * 1078752276900 =1,leftcnt= 284^CTraceback (most recent call last):  File &quot;./p066.py&quot;, line 13, in &lt;module&gt;    if x**2 - 1 &gt; 0 and (x**2-1)%d == 0 and (x**2-1)//d in Q:KeyboardInterrupt^Creal    135m43.883suser    133m30.473ssys    0m20.102s&quot;&quot;&quot;</code></pre><p>我给它掐断了,跑了两小时，虽然是单核的，但是还有284个数没算出来</p><h2 id="go并行-每个数各算各的"><a href="#go并行-每个数各算各的" class="headerlink" title="go并行 每个数各算各的"></a>go并行 每个数各算各的</h2><p>值过大,需要big/int</p><p>写了一个可分段，可并行，可”断点”计算的</p><p>第一遍把1到1000直接跑，每次找到值都会输出剩余表</p><p>没统计计算时间，反正很久，每次运算的结果可以去替换slowv和ans</p><pre><code class="go">package main// x*x-d*y*y=1// 如果d包含质因子p// x*x mod p = 1// 所以 x mod p = 1 or p-1//import (  &quot;fmt&quot;  &quot;math/big&quot;  &quot;sync&quot;)type Xd struct {  X big.Int  d int}var prime [1010]boolconst offset = 0const VCNT = 1000var slowv = []int{};// 判断是否平方数 返回 {开根,true}或者{0,false}func getSqrt(x *big.Int) (*big.Int, bool) {  xsqrt := big.NewInt(0).Sqrt(x)  var xx big.Int  xx.Mul(xsqrt, xsqrt)  if xx.Cmp(x) == 0 {    return xsqrt, true  }  return big.NewInt(0), false}// 对每个d尝试func findx(d int, ch chan Xd) {  if _, ok := getSqrt(big.NewInt(int64(d))); ok {    ch &lt;- Xd{*big.NewInt(0), d}    return  }  // d的最大质因子  maxp := 1  for i := 2; i &lt;= d; i++ {    if prime[i] {      continue    }    if d%i == 0 &amp;&amp; i &gt; maxp {      maxp = i    }  }  for i := big.NewInt(1); ; i.Add(i, big.NewInt(1)) {    imaxp := big.NewInt(0).Mul(i, big.NewInt(int64(maxp)))    sub1 := big.NewInt(0).Sub(imaxp, big.NewInt(1))    add1 := big.NewInt(0).Add(imaxp, big.NewInt(1))    for _, x := range []*big.Int{sub1, add1} {      // x^2-1      x2s1 := big.NewInt(0).Sub(big.NewInt(0).Mul(x, x), big.NewInt(1))      x2s1mod := big.NewInt(0).Mod(x2s1, big.NewInt(int64(d)))      if x2s1mod.Cmp(big.NewInt(0)) != 0 {        continue      }      x2s1div := big.NewInt(0).Div(x2s1, big.NewInt(int64(d)))      if _, ok := getSqrt(x2s1div); ok {        ch &lt;- Xd{*x, d}        return      }    }  }}// 结果处理func waitAns(ch chan Xd, ans *Xd, wg *sync.WaitGroup) {  s := make(map[int]int)  for _,v := range slowv{    s[v]=1  }  cnt := 0  fmt.Println(s, *ans, len(s))  for v := range ch {    cnt++    delete(s,v.d)    fmt.Println(s, *ans, len(s))    if v.X.Cmp(&amp;ans.X) == 1 {      *ans = v      // fmt.Println(&quot;new&quot;,*ans, cnt)    }    wg.Done()  }}func main() {  for i := 2; i &lt; 100; i++ {    if prime[i] {      continue    }    for j := i * i; j &lt;= 1000; j += i {      prime[j] = true    }  }  ans := Xd{*big.NewInt(0), 1}  // 取消下面两行注释 从计算结果继续  // slowv = []int{739, 367, 547, 835, 457, 797, 766, 508, 931, 166, 937, 556, 989, 517, 926, 554, 834, 253, 796, 331, 976, 953, 883, 394, 977, 511, 199, 449, 661, 919, 571, 581, 814, 271, 805, 862, 277, 526, 653, 981, 664, 829, 749, 382, 956, 821, 412, 913, 596, 911, 871, 268, 941, 859, 967, 809, 214, 317, 298, 622, 974, 565, 997, 607, 649, 991, 751, 823, 358, 487, 679, 921, 501, 716, 826, 929, 853, 478, 586, 863, 309, 947, 569, 946, 778, 849, 481, 157, 553, 673, 301, 681, 244, 509, 523, 865, 754, 844, 433, 773, 634, 869, 753, 643, 669, 589, 790, 721, 614, 857, 685, 334, 521, 149, 709, 856, 694, 491, 971, 789, 549, 281, 757, 893, 907, 964, 313, 746, 454, 724, 463, 617, 109, 886, 337, 477, 489, 922, 637, 641, 877, 597, 211, 881, 409, 493, 631, 593, 599, 397, 889, 838, 610, 970, 801, 949, 628, 928, 436, 181, 719, 811, 613, 538, 604, 421, 958, 619, 972, 379, 772, 241, 769, 541, 193, 686, 601, 691, 764, 988, 652, 353, 461, 61, 787, 718,}  // ans := Xd{*big.NewInt(3832352837), 502}  var wg sync.WaitGroup  ch := make(chan Xd)  if len(slowv) == 0{    // 第一遍的时候 lowv 为空 用这个代码    for i := 1+offset; i &lt;= VCNT+offset; i++ {      slowv = append(slowv, i)      wg.Add(1)      go findx(i, ch)    }  }else{    for _,v := range slowv{      wg.Add(1)      go findx(v,ch)    }  }  go waitAns(ch, &amp;ans, &amp;wg)  wg.Wait()  fmt.Println(ans)}</code></pre><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>这时就体现出当数学家可以推出结论，而计算机拥有的只是“蛮力”。</p><h2 id="pell方程的解"><a href="#pell方程的解" class="headerlink" title="pell方程的解"></a>pell方程的解</h2><h3 id="解的性质-基础解"><a href="#解的性质-基础解" class="headerlink" title="解的性质(基础解)"></a>解的性质(基础解)</h3><h4 id="平方一个解相关的表达式能得到新的解-多余"><a href="#平方一个解相关的表达式能得到新的解-多余" class="headerlink" title="平方一个解相关的表达式能得到新的解(多余)"></a>平方一个解相关的表达式能得到新的解(多余)</h4><p>如果$x^2-d \cdot y^2=1$ 平方得 $x^4+d^2 \cdot y^4-2dx^2y^2=1$</p><p>$x^4+2dx^2y^2+d^2 \cdot y^4-d \cdot 4x^2y^2=1$</p><p>$(x^2+dy^2)^2 - d \cdot (2xy)^2=1$</p><p>即当我们有一个解时，通过平方能得到新的解</p><h4 id="一个解相关的表达式的整幂次能得到新的解-多余"><a href="#一个解相关的表达式的整幂次能得到新的解-多余" class="headerlink" title="一个解相关的表达式的整幂次能得到新的解(多余)"></a>一个解相关的表达式的整幂次能得到新的解(多余)</h4><p>又$(x+\sqrt{d} \cdot y)\cdot (x-\sqrt{d} \cdot y)=1$</p><p>可得$((x+\sqrt{d} \cdot y)\cdot (x-\sqrt{d} \cdot y))^n=1$</p><p>$(x+\sqrt{d} \cdot y)^n\cdot (x-\sqrt{d} \cdot y)^n=1$</p><p>根据二项式展开有</p><p>若 $(x+\sqrt{d} \cdot y)^n = A + B\cdot{d}$</p><p>则 $(x-\sqrt{d} \cdot y)^n = A - B\cdot{d}$ 即是 $A^2-d \cdot B^2=1$</p><p>也就是它的n次方展开的系数也是一组解</p><h4 id="任意两个解相关的表达式的乘积能得到新的解-该结论包含上述两个结论"><a href="#任意两个解相关的表达式的乘积能得到新的解-该结论包含上述两个结论" class="headerlink" title="任意两个解相关的表达式的乘积能得到新的解(该结论包含上述两个结论)"></a>任意两个解相关的表达式的乘积能得到新的解(该结论包含上述两个结论)</h4><blockquote><p>同样,假设有两组解：(x1,y1)和(x2,y2)的，它们也可以通过上述乘积方法，合成一组新的解</p></blockquote><h4 id="存在一个基础解-最小解-，所有解都是由基础解生成的"><a href="#存在一个基础解-最小解-，所有解都是由基础解生成的" class="headerlink" title="存在一个基础解(最小解)，所有解都是由基础解生成的"></a>存在一个基础解(最小解)，所有解都是由基础解生成的</h4><p><strong>下面证明所有解都是最小解生成的</strong></p><p>因为y越大x越大,设$(x_1,y_1)$为最小解,$(x_k,y_k)$不是由最小解上述幂次方法生成的一个解</p><p>根据y越大x越大的性质，则存在一个整数n</p><p>$(x_1+y_1 \cdot \sqrt{d})^n &lt; (x_k+y_k \cdot \sqrt{d}) &lt; (x_1+y_1 \cdot \sqrt{d})^{n+1} $</p><p>同时乘$(x_1-y_1 \cdot \sqrt{d})^n$有</p><p>$1 &lt; (x_k+y_k \cdot \sqrt{d}) \cdot (x_1-y_1 \cdot \sqrt{d})^n &lt; (x_1+y_1 \cdot \sqrt{d}) $</p><p>注意到中间的表达式 也是满足参数形式的 也是一组解(并且因为$\frac{x_1}{y_1} = \sqrt{\frac{1}{y_1^2}+d} &gt; \sqrt{\frac{1}{y_k^2}+d} = \frac{x_k}{y_k}$,所以参数均为正数 )</p><p>这与最小解定义冲突，所以所有解都是最小解生成的</p><h3 id="解的存在性证明"><a href="#解的存在性证明" class="headerlink" title="解的存在性证明"></a>解的存在性证明</h3><h4 id="引理1，无穷多对整数满足给定不等式"><a href="#引理1，无穷多对整数满足给定不等式" class="headerlink" title="引理1，无穷多对整数满足给定不等式"></a>引理1，无穷多对整数满足给定不等式</h4><p>存在无穷多对整数(x,y)满足 $|x-y\sqrt{d}|&lt;\frac 1y$</p><p>取正整数$q_0 &gt; 1$</p><p>取$t=1,…,q_0+1$ 共计$q_0+1$个</p><p>把区间$[0,1)$等分为$q_0$部分，则每部分长度为$\frac 1{q_0}$,考虑 $t \sqrt{d}$的小数部分(t为整数)，必定有两个落在同一区间 所以存在$0\leq i&lt;j\leq q_0$使得 $| \{t_i \sqrt{d}\} - \{t_j \sqrt{d}\} | &lt;\frac 1{q_0}$</p><p>即$|x-(t_j-t_i)\sqrt{d}| =  | \{t_i \sqrt{d}\} - \{ t_j \sqrt{d}\} | &lt; \frac 1{q_0} \leq  \frac 1{t_j-t_i}$</p><p>这里要注意的是我们知道i&lt;j,和它们的小数部分落在同一个区间，所以这里应该是它们的小数部分相减的绝对值，而不是相减的绝对值的小数部分，例如q取2, 一个取0.4,一个1.3,它们都在[0,0.5)的区间里，但是如果$|1.3-0.4|$ 再取绝对值的小数部分，得到的是0.9而不是0.1,对于x来说，只要增减1就能在最终的值上切换成功.</p><p>把$t_j-t_i$ 看作y得到一个解</p><p>取$\frac 1{q_1} &lt; |x-(t_j-t_i)\sqrt{d}|$</p><p>可以得到新的解(因为同一个y最多有两种 $|x-y\sqrt{d}|$的小数部分，反复如此可生成无限个解</p><p>取$|x_3-y_3\sqrt{d}| &lt;\frac 1{q_3} &lt; |x_2-y_2 \sqrt{d}| &lt; \frac 1{q_2} &lt; |x_1-y_1\sqrt{d}| &lt;\frac 1{q_1} &lt; |x_0-y_0 \sqrt{d}| &lt; \frac 1{q_0} $</p><h4 id="基于引理1-配出pell方程的解"><a href="#基于引理1-配出pell方程的解" class="headerlink" title="基于引理1,配出pell方程的解"></a>基于引理1,配出pell方程的解</h4><p>对于这无限个解</p><p>0 &lt; $\left|x^2-dy^2\right|=\left|x+y\sqrt{d}\right|\cdot\left|x-y\sqrt{d}\right|=\left|x-y\sqrt{d}+2y\sqrt{d}\right|\cdot\left|x-y\sqrt{d}\right|\leq (\left|x-y\sqrt{d}\right|+\left|2y\sqrt{d}\right|)\cdot\left|x-y\sqrt{d}\right|&lt;\left(2y\sqrt{d}+\frac{1}{y}\right)\cdot\frac{1}{y}\le 2\sqrt{d}+\frac 1{y^2}$</p><p>说明这无限个(x,y)的取值,对$|x^2-dy^2|$的计算结果是有限范围内的整数</p><p>再一次根据抽屉原理，存在正整数k,使得$|x^2-dy^2|=k$的解有无限个</p><p>考虑这些解$(x \bmod k,y \bmod k)$ , 可以的方案数$\leq k^2$,也是有限的，</p><p>再根据抽屉原理，存在$(M_x,M_y)$，使得无限个i， $s.t. (x_i \bmod k, y_i \bmod k) = (M_x,M_y)$,在这无限组中取两组$(x_1,y_1),(x_2,y_2)$</p><p>令 $X=|\frac{x_1x_2-y_1y_2d}{k}|,Y=|\frac{x_2y_1-x_1y_2}{k}|$</p><p>有 $X^2-d \cdot Y^2 = \frac{(x_1^2-d \cdot y_1^2)(x_2^2-d \cdot y_2^2)}{k^2} = 1$</p><p>因为 $(x_2y_1-x_1y_2)\bmod k = (x_1y_1-x_1y_1) \bmod k = 0 \bmod k = 0$,所以Y是整数</p><p>因为$X$是有理数且满足pell方程，所以它是整数</p><p>显然$X = \sqrt{1+dY^2}$ 不为0</p><p>注意到 $x^2-dy^2$ 的取值范围为 $\pm k$ (有限个 ，2个)，但可取的$(x,y)$有无限对，再一次抽屉原理,因此存在$(x_i,y_i)\neq(x_j,y_j)$使得 $x_i^2-dy_i^2=x_j^2-dy_j^2$ 这时 $\frac{x_i}{y_i} \neq \frac{x_j}{y_j}$ (否则代入前式子得到$x_i=x_j$), 即Y不为0,Y为正整数</p><p>综上，一定存在解</p><h4 id="pell方程性质小结"><a href="#pell方程性质小结" class="headerlink" title="pell方程性质小结"></a>pell方程性质小结</h4><p>关于 pell方程 ，我们现在有了 一定存在解，且存在一个最小解的基础解，两个结论，下面开始看看连分数。</p><h2 id="连分数"><a href="#连分数" class="headerlink" title="连分数"></a>连分数</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>形如</p><p>$\alpha = a_0 + \cfrac{1}{a_1 + \cfrac{1}{a_2 + \cfrac{1}{a_3 + \cfrac{1}{\ddots\,}}}} $</p><p>例如 </p><p>$ \sqrt{2} = 1 + \frac{1}{2 + \cfrac{1}{2 + \cfrac{1}{2 + \cfrac{1}{2 + \cfrac{1}{2 + \cfrac{1}{2 + \ddots}}}}}} $</p><p>展开的剩余部分是在<code>[0,1)</code>之间</p><h3 id="性质1-所有无限连分数都是无理数。"><a href="#性质1-所有无限连分数都是无理数。" class="headerlink" title="性质1 所有无限连分数都是无理数。"></a>性质1 所有无限连分数都是无理数。</h3><p>证明：如果一个数是有理数，把它写成分数的形式，再按照连分数的方式展开，你会发现这过程就是辗转相除，分子分母单调递减 所以一定有限，它的逆否命题就是要证明的性质</p><h3 id="渐进分数-分子，分母等性质"><a href="#渐进分数-分子，分母等性质" class="headerlink" title="渐进分数(分子，分母等性质)"></a>渐进分数(分子，分母等性质)</h3><h4 id="分子分母递推式"><a href="#分子分母递推式" class="headerlink" title="分子分母递推式"></a>分子分母递推式</h4><p>渐进分数，把上述表示无理数$\alpha$的连分数部分截断所得到的分数</p><p>假设h,k分别为渐进分数的分子和分母,根据简化为分数的过程</p><p>$\begin{bmatrix} h_n &amp; k_n \end{bmatrix} = \begin{bmatrix} 1 &amp; 0 \end{bmatrix} \cdot \begin{bmatrix} a_n &amp; 1 \\ 1 &amp; 0 \end{bmatrix}  \cdot \begin{bmatrix} a_{n-1} &amp; 1 \\ 1 &amp; 0 \end{bmatrix}  \cdots \begin{bmatrix} a_0 &amp; 1 \\ 1 &amp; 0 \end{bmatrix} $</p><p>然而这不好建立递推关系,稍做变形</p><p>$\begin{bmatrix} h_n &amp; k_n \\ ? &amp; ? \end{bmatrix} = \begin{bmatrix} 1 &amp; 0 \\ 0 &amp; 1 \end{bmatrix} \cdot \begin{bmatrix} a_n &amp; 1 \\ 1 &amp; 0 \end{bmatrix}  \cdot \begin{bmatrix} a_{n-1} &amp; 1 \\ 1 &amp; 0 \end{bmatrix}  \cdots \begin{bmatrix} a_0 &amp; 1 \\ 1 &amp; 0 \end{bmatrix} $</p><p>$\begin{bmatrix} h_n &amp; k_n \\ ? &amp; ? \end{bmatrix} = \begin{bmatrix} a_n &amp; 1 \\ 1 &amp; 0 \end{bmatrix}  \cdot \begin{bmatrix} a_{n-1} &amp; 1 \\ 1 &amp; 0 \end{bmatrix}  \cdots \begin{bmatrix} a_0 &amp; 1 \\ 1 &amp; 0 \end{bmatrix} $</p><p>$\begin{bmatrix} h_n &amp; k_n \\ ? &amp; ? \end{bmatrix} = \begin{bmatrix} a_n &amp; 1 \\ 1 &amp; 0 \end{bmatrix}  \cdot \begin{bmatrix} h_{n-1} &amp; k_{n-1} \\ ? &amp; ? \end{bmatrix} $</p><p>显然左式的底部可以确定</p><p>$\begin{bmatrix} h_n &amp; k_n \\ h_{n-1} &amp; k_{n-1} \end{bmatrix} = \begin{bmatrix} a_n &amp; 1 \\ 1 &amp; 0 \end{bmatrix}  \cdot \begin{bmatrix} h_{n-1} &amp; k_{n-1} \\ ? &amp; ? \end{bmatrix} $</p><p>又因为递推关系，右边式子相当于左式带入n-1</p><p>$\begin{bmatrix} h_n &amp; k_n \\ h_{n-1} &amp; k_{n-1} \end{bmatrix} = \begin{bmatrix} a_n &amp; 1 \\ 1 &amp; 0 \end{bmatrix}  \cdot \begin{bmatrix} h_{n-1} &amp; k_{n-1} \\ h_{n-2} &amp; k_{n-2} \end{bmatrix} $</p><p>综上</p><p>$h_n = a_n \cdot h_{n-1} + h_{n-2}$<br>$k_n = a_n \cdot k_{n-1} + k_{n-2}$</p><p>渐进值 $\frac{h_n}{k_n} = \frac{a_n \cdot h_{n-1} + h_{n-2}}{a_n \cdot k_{n-1} + k_{n-2}}$</p><p>且根据计算过程，可知 $h_n,k_n$互质</p><h4 id="分子分母-相关等式"><a href="#分子分母-相关等式" class="headerlink" title="分子分母 相关等式"></a>分子分母 相关等式</h4><p>由上面的递推关系再递推有</p><p>$k_nh_{n-1}-k_{n-1}h_n=-(k_{n-1}h_{n-2}-k_{n-2}h_{n-1})=(-1)^n $, </p><p>$k_nh_{n-2}-k_{n-2}h_n=a_n(k_{n-1}h_{n-2}-k_{n-2}h_{n-1})=a_n(-1)^{n-1} $, </p><p>设无理数$\alpha$ 的精确表示为$[a_0,a_1,…,a_n,x_{n+1}]$,即是最后$a_{n+1}$替换为精确的非整数值$x_{n+1}$,有$1\leq a_{n+1}&lt;x_{n+1}&lt;a_{n+1}+1,(n&gt;=1)$</p><h4 id="原无理数与渐进数的差值表达式"><a href="#原无理数与渐进数的差值表达式" class="headerlink" title="原无理数与渐进数的差值表达式"></a>原无理数与渐进数的差值表达式</h4><p>根据上方计算渐进值得到的公式，同理递推式有</p><p>$\alpha =\frac{x_{n+1}h_n+h_{n-1}}{x_{n+1}k_n+k_{n-1}}  $</p><p>$\alpha - \frac{h_n}{k_n} =\frac{x_{n+1}h_n+h_{n-1}}{x_{n+1}k_n+k_{n-1}} -\frac{h_n}{k_n} $</p><p>$=\frac{h_{n-1}k_{n}-h_nk_{n-1}}{k_n(x_{n+1}k_n+k_{n-1})}$</p><p>$=\frac{(-1)^n}{k_n(x_{n+1}k_n+k_{n-1})}$</p><p>$|\alpha -\frac{h_n}{k_n}| =\frac{1}{k_n(x_{n+1}k_n+k_{n-1})} &lt; \frac{1}{k_n(a_{n+1}k_n+k_{n-1})} = \frac{1}{k_nk_{n+1}}$</p><p>注意到k的递推式，容易发现它是单调递增的正整数,所以渐进分数真的是趋近(n趋于无限大，渐进分数趋进原无理数)</p><h4 id="原无理数与渐进数的差值绝对值单调递减"><a href="#原无理数与渐进数的差值绝对值单调递减" class="headerlink" title="原无理数与渐进数的差值绝对值单调递减"></a>原无理数与渐进数的差值绝对值单调递减</h4><p>$|k_n\alpha - h_n|$单调递减。</p><p>证明:</p><p>$|k_n\alpha - h_n| - |k_{n-1}\alpha - h_{n-1}|$</p><p>$ = |k_n(\alpha - \frac{h_n}{k_n})| - |k_{n-1}(\alpha - \frac{h_{n-1}}{k_{n-1}})|$</p><p>$ = \frac 1{x_{n+1}k_n+k_{n-1}} - \frac 1{x_{n}k_{n-1}+k_{n-2}} $</p><p>$ = \frac {(x_{n}k_{n-1}+k_{n-2})-(x_{n+1}k_n+k_{n-1})}{(x_{n+1}k_n+k_{n-1})(x_{n}k_{n-1}+k_{n-2})}$</p><p>$ = \frac {((a_n+\frac 1{x_{n+1}})k_{n-1}+k_{n-2})-(x_{n+1}k_n+k_{n-1})}{(x_{n+1}k_n+k_{n-1})(x_{n}k_{n-1}+k_{n-2})}$</p><p>$ = \frac {(x_{n+1}(a_nk_{n-1}+k_{n-2})+k_{n-1})-x_{n+1}(x_{n+1}k_n+k_{n-1})}{x_{n+1}(x_{n+1}k_n+k_{n-1})(x_{n}k_{n-1}+k_{n-2})}$</p><p>$ = \frac {(x_{n+1}k_n+k_{n-1})-x_{n+1}(x_{n+1}k_n+k_{n-1})}{x_{n+1}(x_{n+1}k_n+k_{n-1})(x_{n}k_{n-1}+k_{n-2})}$</p><p>$ = \frac {(1-x_{n+1})(x_{n+1}k_n+k_{n-1})}{x_{n+1}(x_{n+1}k_n+k_{n-1})(x_{n}k_{n-1}+k_{n-2})} &lt; 0$</p><hr><p>由此也可知$|\alpha - \frac{h_n}{k_n}|$单调递减</p><p>$|\alpha - \frac{h_n}{k_n}|-|\alpha -\frac{h_{n-1}}{k_{n-1}}|$</p><p>$=\frac {|{k_n}\alpha-{h_n}|-\frac {k_n}{k_{n-1}}|{k_{n-1}}\alpha-{h_{n-1}}|}{k_n}$</p><p>$&lt;\frac {|{k_n}\alpha-{h_n}|-|{k_{n-1}}\alpha-{h_{n-1}}|}{k_n} &lt; 0$</p><p>// 或者因为$k_n$单调递增</p><h4 id="和渐进数同分母的所有分数中，渐进数最接近原无理数"><a href="#和渐进数同分母的所有分数中，渐进数最接近原无理数" class="headerlink" title="和渐进数同分母的所有分数中，渐进数最接近原无理数"></a>和渐进数同分母的所有分数中，渐进数最接近原无理数</h4><p>若$(h_n,k_n)$是一个渐进分数，则对于分母$k_n$,分子取$h_n$时，整个分数最接近原无理数</p><p>取任意$h\neq h_n$,根据三角不等式</p><p>$|\alpha -\frac{h}{k_n}| \geq |\frac{h-h_n}{k_n}| - |\alpha - \frac{h_n}{k_n}|$</p><p>$&gt;\frac 1{k_n} - \frac 1{k_nk_{n+1}} $,因为n足够大 $k_{n+1}&gt;=3$有</p><p>$&gt; \frac 1{k_n} - \frac 1{2k_n} $</p><p>$=\frac 1{2k_n} $</p><p>$&gt;  \frac 1{k_nk_{n+1}} &gt; |\alpha -\frac{h_n}{k_n}|$</p><p>证明了$h_n$是最接近的分子</p><p>即 $|k_n\alpha - h|$在 $h=h_n$时取最小值</p><h4 id="分母小于等于渐进数的分母的所有分数中，渐进数能使-分子x原无理数-分母-取最小值"><a href="#分母小于等于渐进数的分母的所有分数中，渐进数能使-分子x原无理数-分母-取最小值" class="headerlink" title="分母小于等于渐进数的分母的所有分数中，渐进数能使|分子x原无理数-分母|取最小值"></a>分母小于等于渐进数的分母的所有分数中，渐进数能使|分子x原无理数-分母|取最小值</h4><p>下面证明在$(0&lt;k\leq k_n)$中，对于所有$(h,k)$，有$|k_n\alpha -  h_n|$为最小值</p><p>考虑任意$(h,k),(0&lt;k&lt;k_n)$，且$\frac hk$的最简分数不是渐进数，（因为已经证明了渐进数随着n增大$|k\alpha - h|$单调递减，且渐进数分子分母互质，所以如果最简分数是渐进数则对应渐进数的该表达式 更大，又是分子分母是渐进数的倍数，则该表达式的结果还要乘上倍数会更大）</p><p>// 同时它是最简分数，因为上表达式 带入分数和其最简分数得到的值刚好是其分子和其最简分数的分子的比值的倍数</p><p>设二元一次方程组</p><p>$h_nx+h_{n-1}y=h$</p><p>$k_nx+k_{n-1}y=k$</p><p>则有$(x,y)=(\frac {hk_{n-1}-kh_{n-1}}{h_nk_{n-1}-h_{n-1}k_n},\frac {hk_{n}-kh_{n}}{h_nk_{n-1}-h_{n-1}k_n}) = ((-1)^{n-1}(hk_{n-1}-kh_{n-1}),(-1)^{n-1}(hk_{n}-kh_{n}))$</p><p>因为$\frac hk$不是渐进分数，所以$x,y$都是非零整数，又因为$k&lt;k_n$和$k_nx+k_{n-1}y=k$有:$x,y$异号</p><p>因为$\alpha - \frac {h_n}{k_n}$的分子为$(-1)^n$,分母为正数,</p><p>因此$\alpha - \frac {h_n}{k_n}$和$\alpha - \frac {h_{n-1}}{k_{n-1}}$异号</p><p>$k_n\alpha - {h_n}$和$k_{n-1}\alpha - {h_{n-1}}$异号</p><p>$x(k_n\alpha - {h_n})$和$y(k_{n-1}\alpha - {h_{n-1}})$同号</p><p>$|k\alpha -h| = |(k_nx+k_{n-1}y)\alpha - (h_nx+h_{n-1}y)|$</p><p>$= |x(k_n\alpha - {h_n}) + y(k_{n-1}\alpha - {h_{n-1}})|$,因为同号：</p><p>$= |x(k_n\alpha - {h_n})|+|y(k_{n-1}\alpha - {h_{n-1}})|$，因为$x,y$非零整数:</p><p>$|k\alpha - h| &gt; |k_n\alpha - {h_n}|$且$|k\alpha -h|&gt;|k_{n-1}\alpha - {h_{n-1}}|$</p><p>内容得证</p><h4 id="连续的两个渐进数中至少有一个满足pell方程必要的不等式"><a href="#连续的两个渐进数中至少有一个满足pell方程必要的不等式" class="headerlink" title="连续的两个渐进数中至少有一个满足pell方程必要的不等式"></a>连续的两个渐进数中至少有一个满足pell方程必要的不等式</h4><p>至于为什么是这个标题 见后面的部分</p><p>连续的两个渐进数中至少有一个满足，$|\alpha - \frac hk|&lt;\frac 1{2k^2}$</p><p>证明:</p><p>假设都不满足，有</p><p>$0 \leq |\alpha-\frac{h_{n+1}}{k_{n+1}}| - \frac{1}{2k_{n+1}^2} + |\alpha-\frac{h_{n}}{k_{n}}|-\frac{1}{2k_{n}^2}$, 因为$\alpha - \frac{h_{n}}{k_{n}}$正负交替,所以</p><p>$ = |\frac{h_{n+1}}{k_{n+1}}-\frac{h_{n}}{k_{n}}|-\frac 1{2k_{n+1}^2} -\frac 1{2k_{n}^2}$</p><p>$ = |\frac{h_{n+1}k_{n}-h_{n}k_{n+1}}{k_{n+1}k_{n}}|-\frac 1{2k_{n+1}^2} -\frac 1{2k_{n}^2}$</p><p>$ = \frac 1{k_nk_{n+1}} -\frac 1{2k_{n+1}^2} -\frac 1{2k_{n}^2}$</p><p>$ = \frac 1{k_nk_{n+1}} -\frac 1{2k_{n+1}^2} -\frac 1{2k_{n}^2}$</p><p>$ = \frac {-(k_n-k_{n+1})^2}{2k_{n}^2k_{n+1}^2} &lt; 0$</p><p>矛盾</p><p>因此至少有一个大于满足 得证</p><h4 id="任何最简分数如果满足pell方程必要的不等式，那么它是一个渐进分数"><a href="#任何最简分数如果满足pell方程必要的不等式，那么它是一个渐进分数" class="headerlink" title="任何最简分数如果满足pell方程必要的不等式，那么它是一个渐进分数"></a>任何最简分数如果满足pell方程必要的不等式，那么它是一个渐进分数</h4><p>任何最简分数如果满足$|\alpha - \frac hk|&lt;\frac 1{2k^2}$，那么它是个渐进分数</p><p>证明</p><p>设$\frac hk$满足不等式$|\alpha - \frac hk|&lt;\frac 1{2k^2}$，则存在n使得渐进数分母满足 $k_{n+2}&gt;k&gt;=k_n $且$\frac {h_n}{k_n}$满足$|\alpha - \frac hk|&lt;\frac 1{2k^2}$(因为相邻渐进数必有一个满足,这里是取n和n+2之间)，根据上面的不等式 有$|k_n\alpha- h_n| &lt; |k\alpha - h|$，若$\frac hk \neq \frac{h_n}{k_n}$,即$k_n &lt; k$</p><p>$0 \leq \frac{|hk_n-h_nk|-1}{kk_n}$</p><p>$= |\frac{h}{k}-\frac{h_n}{k_n}|-\frac{1}{kk_n}$,因为三角不等式，有</p><p>$\leq |\alpha -\frac{h}{k}|+|\alpha -\frac{h_n}{k_n}|-\frac{1}{kk_n}$, 因为假设满足的不等式</p><p>$&lt; \frac 1{2k^2} + \frac 1{k_n}|k_n\alpha - h_n|-\frac{1}{kk_n}$,因为上面的最小接近</p><p>$&lt; \frac 1{2k^2} + \frac 1{k_n}|k\alpha - h|-\frac{1}{kk_n}$</p><p>$= \frac 1{2k^2} + \frac {k}{k_n}|\alpha - \frac hk|-\frac{1}{kk_n}$因为假设满足的不等式</p><p>$&lt; \frac 1{2k^2} + \frac {k}{k_n}\cdot \frac 1{2k^2}-\frac{1}{kk_n}$</p><p>$= \frac {k_n-k}{2k^2k_n} &lt; 0$</p><p>矛盾，因此$\frac hk$和某个渐进数相等</p><p><strong>注记：最开始该文的版本，的渐进分数的部分直接使用的是pell方程中$\sqrt{d}$,其中d是非平方正整数，但为了写100需要的证明，需要把它扩充到实数，（当然也是成立的），所以这部分改写了一次</strong></p><h3 id="Lagrange’s-Theorem-二次无理数与有循环节的连分数"><a href="#Lagrange’s-Theorem-二次无理数与有循环节的连分数" class="headerlink" title="Lagrange’s Theorem 二次无理数与有循环节的连分数"></a>Lagrange’s Theorem 二次无理数与有循环节的连分数</h3><p>quadratic irrational(二次无理数) : 二次整式多项式的根 $\frac{-b\pm \sqrt{b^2-4ac}}{2a}$ 或者形如$\frac{P+\sqrt{D}}{Q}$</p><p> An irrational number is quadratic irrational if and only if its continued fraction is periodic.</p><h4 id="循环连分数一定是二次无理数"><a href="#循环连分数一定是二次无理数" class="headerlink" title="循环连分数一定是二次无理数"></a>循环连分数一定是二次无理数</h4><blockquote><p>先证明简单的一侧，循环连分数一定是二次根式的根。</p></blockquote><p>按照连分数的写法，将循环节设为t</p><p>显然还原为分数,有$x=\frac{a t + b}{c t +d},t = \frac{et+f}{gt+h}$ 变换左表达式t是x的函数，带入右侧表达式得到$\frac{ix+j}{kx+l} = \frac{mx+n}{ox+p}$,其中字母$a-p$均为整数，且注意到x为无理数，所以化简后一定是二次方程</p><h4 id="二次无理数一定是循环连分数"><a href="#二次无理数一定是循环连分数" class="headerlink" title="二次无理数一定是循环连分数"></a>二次无理数一定是循环连分数</h4><blockquote><p>再证明二次根式的根一定能表达为有循环节的连分数</p></blockquote><p>定义,u对于无理数x</p><p>$f(x) = x-1 (x&gt;1)$</p><p>$f(x) = \frac{1}{\frac{1}{x}-1} , (x&lt;1)$</p><p>对应到连分展开，即是将首个数字减少1,(x&gt;1时就是a0减去1,x&lt;1时就是a1减去1)</p><p>令$x1=x,x_{n+1}=f(x_n)$,可以知道 这是一个无限数列</p><p>如果x满足$ax^2+bx+c=0$,写作$x\in[a,b,c]$</p><p>那么x-1 满足$a(x-1)^2+(2a+b)(x-1)+(a+b+c) = ax^2+b+c=0$</p><p>那么$\frac{x}{1-x}$ 满足$(a+b+c)(\frac{x}{1-x})^2+(b+2c)\frac{x}{1-x}+c = 0$</p><p>所以f(x)满足 $f(x)\in [a,2a+b,a+b+c]$ 或 $f(x)\in [a+b+c,b+2c,c]$</p><p>不失一般性，写作$x_n\in[s_n,t_n,u_n]$,有 $s_n &gt; 0$, 否则把三元组同时换号</p><p>注意到上式 $(2a+b)^2-4a(a+b+c)=b^2-4ac=(b+2c)^2-4(a+b+c)c$</p><p>说明了 $t_n^2-4s_nu_n$是和n无关的值</p><p>如果只有有限个$u&lt;0$,那么从某一处开始，$s&gt;0,u&gt;0$且$t&lt;0$(因为 x &gt; 0)</p><p>那么意味着 $-t$ 严格单调递减并且非负，(因为 t的变化关系是 t=2s+t或者 t=t+2u),矛盾</p><p>所以有无限个$s_nu_n&lt;0$</p><p>注意到 $t_n^2-4s_nu_n$是常数，所以 至少有一个三元组$[s_n,t_n,u_n]$ 出现了三次,一个二次方程有两个解，所以有满足的$x_n=x_m,m&gt;n$</p><p>得证 连分数展开有循环</p><p>Theorem 1. If x is a positive quadratic irrational then its continued fraction is eventually periodic.</p><h3 id="Galois’-Theorem-纯循环连分数与reduced二次无理数"><a href="#Galois’-Theorem-纯循环连分数与reduced二次无理数" class="headerlink" title="Galois’ Theorem 纯循环连分数与reduced二次无理数"></a>Galois’ Theorem 纯循环连分数与reduced二次无理数</h3><p>Definition 1.24. x 是二次无理数的根，$\overline{x}$ 是另一个根，那么如果 x &gt; 1 且 $-1 &lt; \overline{x} &lt; 0$.那么称 x 为 reduced</p><p>Theorem 1.25. (Galois’ Theorem) 无理数a. a是纯循环连分数（从a0开始的循环节），当且仅当 x is reduced. If $x = [\overline{a_0, a_1, a_2, . . . , a_{l−1}}]$ and $\overline{x}$ 是它共轭实数, then $-\frac{1}{x} = [\overline{a_{l−1}, . . . , a_2, a_1}].$</p><h4 id="reduced二次无理数-是-纯循环连分数"><a href="#reduced二次无理数-是-纯循环连分数" class="headerlink" title="reduced二次无理数 是 纯循环连分数"></a>reduced二次无理数 是 纯循环连分数</h4><p>设二次无理数$x=[a_0,a_1,…,a_n], x&gt;1,-1&lt;\overline{x}&lt;0$</p><p>那么有 $x_{n+1}=\frac{1}{x_n-a_n}$ // 表示 按照展开从n处向后取值</p><p>$\overline{x_{n+1}} = \frac{1}{\overline{x_n-a_n}} = \frac{1}{\overline{x_n}-a_n}$,(因为 两个形如$A+B\sqrt{C}$的无理数相乘为有理数，说明相乘后的无理数的系数为0,所以更改其中一个无理数的系数的正负，另一个无理数系数的正负更改即可)</p><p>注意到$x_1 \ge 1$有$a_0 \ge 1$,所以 $a_n \ge 1$</p><p>下面归纳证明 $-1 &lt; \overline{x_n} &lt; 0 $</p><p>若 $-1 &lt; \overline{x_n} &lt; 0$</p><p>有 $\frac{1}{\overline{x_{n+1}}} = \overline{x_n} - a_n &lt; -1$</p><p>即 $-1 &lt; \overline{x_{n+1}} &lt; 0$，得证</p><p>$-1 &lt; \overline{x_n} = \frac{1}{\overline{x_{n+1}}}+a_n &lt; 0$</p><p>$ 1 &gt; -\frac{1}{\overline{x_{n+1}}}-a_n &gt; 0$</p><p>$ a_n = [ -\frac{1}{\overline{x_{n+1}}} ] $ // 也就是$a_n$等于分式的整数部分</p><p>因为上面已经证明 如果是二次无理数，那么必定有循环节，所以存在$x_i = x_j,(i &lt; j )$</p><p>即$\overline{x_i}=\overline{x_j}$</p><p>即$a_{i-1}=[-\frac{1}{\overline{x_i}}]=[-\frac{1}{\overline{x_j}}] = a_{j-1}$</p><p>即$x_{i-1}=a_{i-1}+\frac{1}{x_i} = a_{j-1}+\frac{1}{x_j} = x_{j-1}$, 意义就是如果两个后缀相等，那么它们各向前一个 也相等，综上逐步迭代$a_0 =a_{j-i}$ </p><p>因此证明了 如果一个二次无理数是 reduced，那么它是个纯循环连分数</p><h4 id="纯循环连分数-是-reduced"><a href="#纯循环连分数-是-reduced" class="headerlink" title="纯循环连分数 是 reduced"></a>纯循环连分数 是 reduced</h4><p>首先有循环节的连分数一定是二次无理数（上面证过了)</p><p>因为是纯循环，所以$a_0 \ge 1$,所以$a_n \ge 1$,有$x &gt; 1$</p><p>假设周期为n, 有 $x_n = x = [\overline{a_0,a_1,…,a_{n-1}}]$</p><p>根据上面推过的递推式 $x = \frac{x_nh_{n-1}+h_{n-2}}{x_nk_{n-1}+k_{n-2}} = \frac{xh_{n-1}+h_{n-2}}{xk_{n-1}+k_{n-2}}$</p><p>化简 $k_{n-1}x^2+(k_{n-2}-h_{n-1})x-h_{n-2}=0$</p><p>也就是证明这个方程除了x (我们已经有 $x&gt;1$了)的另一个根$\overline{x}$满足$-1 &lt; \overline{x} &lt; 0$</p><p>$x = 0$时 原式子 $=-h_{n-2} &lt; 0$</p><p>$x = 1$时 原式子 </p><p>$= k_{n-1}+(h_{n-1}-k_{n-2})-h_{n-2}$</p><p>$= (a_{n-1}k_{n-2}+k_{n-3}) + (a_{n-1}h_{n-2}+h_{n-3}) -k_{n-2}-h_{n-2}$</p><p>$= (a_{n-1}-1)(h_{n-2}+k_{n-2}) + (h_{n-3}+k_{n-3}) $</p><p>$ &gt; 0 $</p><p>说明了另一个根$-1 &lt; \overline{x} &lt; 0$</p><p>至此我们证明了 reduced 和 纯循环之间的 充要</p><h4 id="reduced二次无理数-纯循环连分数的-原无理数与它的共轭相反倒数的连分数数值关系"><a href="#reduced二次无理数-纯循环连分数的-原无理数与它的共轭相反倒数的连分数数值关系" class="headerlink" title="reduced二次无理数 纯循环连分数的 原无理数与它的共轭相反倒数的连分数数值关系"></a>reduced二次无理数 纯循环连分数的 原无理数与它的共轭相反倒数的连分数数值关系</h4><p>最后证明 If $x = [\overline{a_0, a_1, a_2, . . . , a_{l−1}}]$ and $\overline{x}$ 是它共轭实数, then $-\frac{1}{x} = [\overline{a_{l−1}, . . . , a_2, a_1,a_0}].$</p><p>Step 1</p><p>考虑有限的连分数 $x = [a_0,a_1,…,a_n], y=[a_n,a_{n-1},…,a_0] , a_i &gt; 0$</p><p>$h_n,k_n$为x的分子分母，$h_n’,k_n’$为y的分子分母</p><p>要证明 $\frac{h_n}{h_{n-1}} = \frac{h_n’}{k_n’}$ 且 $\frac{k_n}{k_{n-1}} = \frac{h_{n-1}’}{k_{n-1}’}, n \ge 1$ 且分子分母对应相等(因为是最简分数，所以只要证明了分数相等就有对应相等了)</p><p>注意到上面 $h_n = a_n \cdot h_{n-1} + h_{n-2}$,同时除以 $h_{n-1}$</p><p>$\frac{h_n}{h_{n-1}} = a_n + \frac{1}{\frac{h_{n-1}}{h_{n-2}}}$</p><p>递归展开 可以得到 $\frac{h_n}{h_{n-1}} = [a_n,a_{n-1},…,a_0]$,</p><p>注意到 $k_n = a_n \cdot k_{n-1} + k_{n-2}$,同理 $\frac{k_n}{k_{n-1}} = [a_n,a_{n-1},…,a_1] $(注意是$a_1$不是$a_0$)</p><p>根据上面的<code>递归展开的结论</code> 和 <code>y的分子分母定义</code>有</p><p>$\frac{h_{n+1}}{h_n} = [a_{n+1},a_n,…,a_0] = \frac{h_{n+1}’}{k_{n+1}’}$</p><p>$\frac{k_{n+1}}{h_n} = [a_{n+1},a_n,…,a_1] = \frac{h_{n}’}{k_{n}’}$</p><p>且分子分母对应相等</p><p>Step 2</p><p>若x 是纯循环连分数数(即reduced 二次无理数)，那么显然$-\frac{1}{\overline{x}}$也是 reduced的二次无理数，那么它也是纯循环</p><p>假设直接取 n+1 = 两个循环节长度的最小公倍数</p><p>$k_{n}x^2+(k_{n-1}-h_{n})x-h_{n-1}=0$</p><p>令</p><p>$y = [\overline{a_n,a_{n-1},…,a_0}] = [a_n,a_{n-1},…,a_0,y]$</p><p>$y = \frac{h_n’y+h_{n-1}’}{k_n’y+k_{n-1}’}$</p><p>因为Step 1 我们证明了对应相等$h_n=h_n’,k_{n-1}=k_{n-1}’, h_{n-1}=k_{n}’,h_{n-1}’=k_n$</p><p>所以做对应替换,$y = \frac{h_ny+k_{n}}{h_{n-1}y+k_{n-1}}$</p><p>$k_{n}{(-\frac{1}{y})}^2+(k_{n-1}-h_{n})(-\frac{1}{y})-h_{n-1}=0$</p><p>$-\frac{1}{y} = \overline{x}$ 得证(y为正 所以 不可能等于x)</p><p>至此 Theorem 1.25. (Galois’ Theorem) 无理数a. a是纯循环连分数（从a0开始的循环节），当且仅当 x is reduced. If $x = [\overline{a_0, a_1, a_2, . . . , a_{l−1}}]$ and $\overline{x}$ 是它共轭实数, then $-\frac{1}{\overline{x}} = [\overline{a_{l−1}, . . . , a_2, a_1}].$ 得证</p><h4 id="根号n-的-连分数性质"><a href="#根号n-的-连分数性质" class="headerlink" title="根号n 的 连分数性质"></a>根号n 的 连分数性质</h4><p>Theorem 1.26 d是非平方数,那么$\sqrt{d} = [\lfloor \sqrt{d} \rfloor,\overline{a_1,a_2,…,a_2,a_1,2\lfloor \sqrt{d} \rfloor}]$</p><p>也就是 是从第二位开始循环节，且循环节最后一个是它的整部的2倍，且剩余部分是回文</p><p>令$x=\lfloor \sqrt{d} \rfloor + \sqrt{d}$ 则$\overline{x} = \lfloor \sqrt{d} \rfloor - \sqrt{d}$</p><p>注意它们的取值范围发现x是reduced 二次无理数</p><p>因此 $ x = \lfloor \sqrt{d} \rfloor + \sqrt{d} = [\overline{2\lfloor \sqrt{d} \rfloor,a_1,a_2,…,a_{l-1}}]$</p><p>$ = [2\lfloor \sqrt{d} \rfloor,\overline{a_1,a_2,…,a_{l-1},2\lfloor \sqrt{d} \rfloor}]$</p><p>$ \sqrt{d}= [\lfloor \sqrt{d} \rfloor,\overline{a_1,a_2,…,a_{l-1},2\lfloor \sqrt{d} \rfloor}]$</p><p>根据Galois’ Theorem我们有</p><p>$\frac{1}{\sqrt{d}-\lfloor \sqrt{d} \rfloor} = -\frac{1}{\overline{x}} = [\overline{a_{l-1},…,a_2,a_1,2\lfloor \sqrt{d} \rfloor}]$</p><p>也就是$\sqrt{d} = [\lfloor \sqrt{d} \rfloor,\frac{1}{\sqrt{d}-\lfloor \sqrt{d} \rfloor}]$</p><p>$ = [\lfloor \sqrt{d} \rfloor,\overline{a_{l-1},…,a_2,a_1,2\lfloor \sqrt{d} \rfloor}]$</p><p>因此得证 循环内容和 回文性质</p><h2 id="Solution-to-Pell’s-Equation"><a href="#Solution-to-Pell’s-Equation" class="headerlink" title="Solution to Pell’s Equation"></a>Solution to Pell’s Equation</h2><p>因为平方带来的对称性，只考虑(x&gt;0,y&gt;0)的解</p><h3 id="根号n的连分数渐进分数的性质"><a href="#根号n的连分数渐进分数的性质" class="headerlink" title="根号n的连分数渐进分数的性质"></a>根号n的连分数渐进分数的性质</h3><h4 id="一个引理"><a href="#一个引理" class="headerlink" title="一个引理"></a>一个引理</h4><p>若d为非平方数，$x=\sqrt{d}$,</p><p>则对于任意n，存在整数$Q_n,P_n$满足$ x_n=\frac{P_n+\sqrt{d}}{Q_n}$和$d-P_n^2 = 0 (\bmod Q_n)$</p><p>显然n=0时$(P_0,Q_0) = (0,1)$满足,然后归纳法，若 n时能满足上述两点性质，则</p><p>$x_{n+1} = \frac{1}{x_n-a_n}$</p><p>$=\frac{1}{\frac{P_n+\sqrt{d}}{Q_n}-a_n}$</p><p>$=\frac{Q_n}{P_n+\sqrt{d}-a_n{Q_n}}$ (通过分母有理化:</p><p>$=\frac{Q_n(P_n-a_nQ_n-\sqrt{d})}{(P_n-a_nQ_n)^2-d}$</p><p>$=\frac{a_nQ_n-P_n+\sqrt{d}}{\frac{d-(P_n-a_nQ_n)^2}{Q_n}}$</p><p>$(Q_{n+1},P_{n+1}) = (\frac{d-(P_n-a_nQ_n)^2}{Q_n},a_nQ_n-P_n)$</p><p>现在要证明的就是 它是满足$\frac{P_{n+1}+\sqrt{d}}{Q_{n+1}}$的形式,并且满足上面的取模</p><p>也就是要证明$P_{n+1}$是整数(显然) 和 $Q_{n+1}$是整数</p><p>$Q_{n+1} = \frac{d-P_n^2}{Q_n}+2a_nP_n-a_n^2Q_n$</p><p>因为n时有 $d-P_n^2 = 0 (\bmod Q_n)$所以 $Q_{n+1}$是整数</p><p>又因为$Q_nQ_{n+1}=d-P_{n+1}^2$ 所以  $d-P_{n+1}^2 = 0 (\bmod Q_{n+1})$ 得证</p><h4 id="直指pell方程左侧表达式"><a href="#直指pell方程左侧表达式" class="headerlink" title="直指pell方程左侧表达式"></a>直指pell方程左侧表达式</h4><p>对于$n \ge 2$ 要证明 $h_{n-1}^2-d k_{n-1}^2=(-1)^n Q_n$</p><p>证明:</p><p>$\sqrt{d} = \frac{x_n h_{n-1}+h_{n-2}}{x_nk_{n-1}+k_{n-2}}$</p><p>把$ x_n = \frac{P_n+\sqrt{d}}{Q_n}$带入并通分化简</p><p>$(P_nk_{n-1}+Q_nk_{n-2}-h_{n-1})\sqrt{d} = P_nh_{n-1}+h_{n-2}Q_n-k_{n-1}d$</p><p>即 $P_nk_{n-1}+Q_nk_{n-2}=h_{n-1}$ 且 $P_nh_{n-1}+h_{n-2}Q_n=k_{n-1}d$</p><p>所以有 $h_{n-1}^2-dk_{n-1}^2 = h_{n-1}(P_nk_{n-1}+Q_nk_{n-2})-k_{n-1}(P_nh_{n-1}+h_{n-2}Q_n)$</p><p>$= Q_n(h_{n-1}k_{n-2}-h_{n-2}k_{n-1})$</p><p>$= (-1)^nQ_n$</p><h3 id="最后一步-连分数和pell方程的关系"><a href="#最后一步-连分数和pell方程的关系" class="headerlink" title="最后一步 连分数和pell方程的关系"></a>最后一步 连分数和pell方程的关系</h3><p>首先假设 (x,y)是 pell方程$x^2-dy^2=1$的解$(d&gt;1,x&gt;y&gt;0)$，所以</p><p>$|\sqrt{d} - \frac{x}{y}| = |\frac{dy^2-x}{y^2(\sqrt{d}+\frac{x}{y})}| &lt; \frac{1}{2y^2}$ (从一定程度上说明了 为什么前面要去证明 小于$\frac{1}{2y^2}$</p><p>根据前面推的 我们知道满足这个表达式的一定是 渐进值</p><p>(Yang.pdf那个paper下面的部分蛮多笔误的 不过能看懂证明思路)</p><p>因为我们上面有 $h_{n-1}^2-dk_{n-1}^2=(-1)^nQ_n$ 也就是如果要满足pell方程 那么$|Q_n|=1$，分类讨论$Q_n$</p><p>假设 $\sqrt{d}$的 最小周期长度为l</p><h4 id="分类讨论-Q-1"><a href="#分类讨论-Q-1" class="headerlink" title="分类讨论 Q = -1"></a>分类讨论 Q = -1</h4><p>$Q_n \neq -1, n &gt; 0$</p><p>证明</p><p>注意到上面根据$\sqrt{d}$的表达式 证明了$n&gt;0$时，$x_n$是纯循环连分数，也就是reduced</p><p>如果$Q_n = -1$ 因为$x_n=\frac{P_n+\sqrt{d}}{Q_n}$,所以有 $x_n=-P_n-\sqrt{d} &gt; 1$,有$-1&lt;-P_n+\sqrt{d} &lt; 0$ (Galois)</p><p>有 $\sqrt{d} &lt; P_n &lt; -\sqrt{d} - 1$ 矛盾 所以$Q_n \neq -1$, 对于$Q_0 = 1$也满足,得证</p><h4 id="分类讨论-Q-1-1"><a href="#分类讨论-Q-1-1" class="headerlink" title="分类讨论 Q = 1"></a>分类讨论 Q = 1</h4><p>$Q_n = 1$当且仅当n为循环节长度的倍数才有</p><p>证明</p><p>若于$n&gt;1$若$Q_n=1$那么有$x_n=P_n+\sqrt{d}$，它的共轭 $-1 &lt; P_n-\sqrt{d} &lt; 0$ 即 $P_n=\lfloor \sqrt{d} \rfloor$所以 $x_n = \lfloor \sqrt{d} \rfloor + \sqrt{d}$</p><p>$ \lfloor \sqrt{d} \rfloor +\sqrt{d} = x_n = 2\lfloor\sqrt{d}\rfloor + \frac{1}{\frac{1}{\sqrt{d} - \lfloor \sqrt{d} \rfloor}} $ 即 $ x_{n+1} = \frac{1}{\sqrt{d} - \lfloor \sqrt{d} \rfloor}$</p><p>$ \sqrt{d} = x_0 = \lfloor \sqrt{d} \rfloor + \frac{1}{\frac{1}{\sqrt{d} - \lfloor \sqrt{d} \rfloor}}$ 即 $x_1 = \frac{1}{\sqrt{d} - \lfloor \sqrt{d} \rfloor}$</p><p>说明了 它的下一个数$x_{n+1} $和$x_1$相等, 这说明如果$Q_n = 1$ 那么n是当且仅当循环节长度的倍数(如果为1则循环节长度)</p><p>如果n是循环节倍数 有</p><p>$\frac{P_{kl}+\sqrt{d}}{Q_{kl}} = x_{kl} = [\overline{2\lfloor \sqrt{d} \rfloor,a_1,a_2,…,a_{l-1}}] = \sqrt{d}+\lfloor\sqrt{d}\rfloor,(k&gt;0)$</p><p>$(P_{kl},Q_{kl}) = (\lfloor\sqrt{d}\rfloor,1)$</p><p>对于n=0也满足，充要得证</p><h4 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h4><p>最后回到这里 $h_{n-1}^2-dk_{n-1}^2=(-1)^nQ_n = (-1)^n $ 也就是再看个奇偶，最后得到了pell方程和连分数比较紧密的结论</p><p>假设 $\sqrt{d}$的 最小周期长度为l</p><p>那么对应pell 方程的最小解</p><p>$(x,y) = {h_{l-1},k_{l-1}}$ 长度为偶数</p><p>$(x,y) = {h_{2l-1},k_{2l-1}}$ 长度为奇数</p><h2 id="回顾历程"><a href="#回顾历程" class="headerlink" title="回顾历程"></a>回顾历程</h2><ol><li>pell方程基础解</li><li>pell方程解存在性</li><li>连分数分子分母递推式</li><li>连分数，分子分母相关性质(分子分母互质性,原无理数与渐进数差值表达式，差值绝对值单调递减性，连分数是最给定分母以及更小分母中最接近原无理数，任何满足“某不等式”的数字是渐进数（这个不等式是pell方程 的必要条件）)</li><li>Lagrange’s Theorem 二次无理数与有循环节的连分数</li><li>Galois’ Theorem 纯循环连分数与reduced二次无理数</li><li>根号n的连分数性质（精确的$\frac{P_n+\sqrt{d}}{Q_n}$表示 和 形如pell方程 与$Q_n$的等式）</li><li>分类讨论$Q_n$与n的取值最后的结论</li></ol><p>方法涉及</p><ol><li>二项式展开，不等式，唯一最小(有术语吗)，无理数，反证法</li><li>反复抽屉原理，绝对值，无理数，模运算</li><li>矩阵乘法，归纳法/递推关系</li><li>归纳法/递推，互质，不等式放缩，三角不等式，反证法，二元一次方程组，巧妙正负值+不等式。 很多方法都是多次</li><li>归纳，反证，单调+整数离散+有限，二次函数</li><li>共轭实数，反向推，归纳法</li><li>归纳法,上面的分子分母等式性质</li><li>-1的幂次,分类讨论，Lagrange,Galois</li></ol><p>然后还有很多整数的离散性质</p><p>证明过程感受</p><ol><li>如果有证明方向，看上去还挺自然的思路</li><li>正过来倒过去看，不明白为什么能想到去先找那个不等式,以及中间的X,Y和取值是怎样的思想</li><li>挺自然</li><li>其实这里都是 为了那个pell方程的必要条件，但是怎么想到这一条路径。另外就是这里面二元一次方程组感觉是不是和上面X,Y是同样的思路，但是我都没有理解到思想根源，怎么能在证明之前，先去做一个分式最后证明这个分式是整数。另外就是这些反复用于后面证明的一些分子分母等式性质。还有一个我不太会的就是多级放缩，到底是原作者自己多次调整最后得出的过程，还是说有什么思路能做到多次放缩来完成目标不等式证明(或反证)</li><li>这里的充分和必要完全不是一个难度，这个三元组的设计还是很能简化描述, 我想的方向是去做精确表达式，再做范围，如果证到有限范围即可，总之自己没证明到</li><li>reduced的性质在这里我不知道怎么用，也不知道为什么要，结果是后面证明需要结论</li><li>假设给我要证明的目标，这里可能如果我自己来证明会有一个基本去做的归纳目标，但是证明过程中会衍生出额外的证明目标</li><li>难点在说要怎么想到去找$h_{n-1}^2-dk_{n-1}^2=(-1)^nQ_n$这个方向去证，而后面的分类讨论就比较自然</li></ol><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>似乎还不足以写代码?，下面的问题是 如何得到根号n的连分数呢？ 手工三元组(分母整数，有理分子整数，无理分子的系数整数)是一个办法，有没有更好的办法呢。</p><p>但我们至少说能证明了这个结论</p><p>python3</p><pre><code class="python">def gcd(a, b):    if b == 0:        return a    else:        return gcd(b, a % b)def calc(i, p):    sq = int(i**(0.5))    if sq * sq == i:        return (1, 0)    hk = ((1, 0), (0, 1))    # a, b, c =&gt; (a+b*sqrt{d})/c    cur = (0, 1, 1)    idx = 0    while cur[0] == 0 or hk[0][0]*hk[0][0] - i*hk[0][1]*hk[0][1] != 1:        if p:            print(&quot;x_&quot;, idx, &quot; = &quot;, cur)        z = int((cur[0] + cur[1] * (i**(0.5)))/cur[2])        if p:            print(&quot;a_&quot;, idx, &quot; = &quot;,  z)        idx += 1        # z 1        # 1 0        #    hk 00 01        #       10 11        newhk = (            ((hk[0])[0]*z+(hk[1])[0], (hk[0])[1]*z+(hk[1])[1]),            ((hk[0])[0], (hk[0])[1])        )        hk = newhk        if p:            print(&quot;hk = &quot;, hk)        a = cur[0]        b = cur[1]        c = cur[2]        # c/(a+b*sqrt{i}-c*z)        # c*(a-b*sqrt{i}-cz)/((a-cz)^2-b^2*i)        nv = (c*(a-c*z), -c*b, (a-c*z)*(a-c*z)-b*b*i)        cm = gcd(abs(nv[0]), abs(nv[1]))        cm = gcd(cm, abs(nv[2]))        nv = (nv[0]/cm, nv[1]/cm, nv[2]/cm)        if nv[2] &lt; 0:            nv = (-nv[0], -nv[1], -nv[2])        cur = nv    return hk[0]def main():    ans = (0, (1, 0))    for i in range(0, 1001):        newans = calc(i, False)        if newans[0] &gt; ans[1][0]:            ans = (i, newans[:])        print(i, &quot; -&gt; &quot;, newans)    print(ans)main()</code></pre><p>可以看到x的值会达到十进制的38位，暴力不可取!即使用了上面分析出的一些晓得性质最多优化661倍 依然是能有10的35次方的数量级。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://en.wikipedia.org/wiki/Continued_fraction" target="_blank" rel="noopener">Continued fraction</a></p><p><a href="https://en.wikipedia.org/wiki/Pell%27s_equation" target="_blank" rel="noopener">Pell equation</a></p><p><a href="https://www.math.uchicago.edu/~may/VIGRE/VIGRE2008/REUPapers/Yang.pdf" target="_blank" rel="noopener">Yang.pdf</a></p><p><a href="https://crypto.stanford.edu/pbc/notes/contfrac/pell.html" target="_blank" rel="noopener">stanford crypto pell</a></p><p><a href="http://sites.millersville.edu/bikenaga/number-theory/periodic-continued-fractions/periodic-continued-fractions.html" target="_blank" rel="noopener">millersville periodic-continued-fractions</a></p><p><a href="https://www.youtube.com/watch?v=E51GKQ1qorE" target="_blank" rel="noopener">YouTube:Number Theory:Pell’s Equation part 1</a></p><p><a href="https://dspace.sunyconnect.suny.edu/bitstream/handle/1951/69917/fulltext.pdf?sequence=1&amp;isAllowed=y" target="_blank" rel="noopener">A short proof and generalization of Lagrange’s theorem on continued fractions</a></p><p><a href="http://sites.millersville.edu/bikenaga/number-theory/purely-periodic-continued-fractions/purely-periodic-continued-fractions.html" target="_blank" rel="noopener">purely periodic continued fractions</a></p><h1 id="总结-amp-感受"><a href="#总结-amp-感受" class="headerlink" title="总结&amp;感受"></a>总结&amp;感受</h1><p>有些结论在证明过程中其实是缩小了范围，有些结论其实放大定义域之类也是成立的，但我们在证明过程中却只使用了我们所需要的部分。这类的从定义域和对应的要证明的逻辑不是“完美对应”的，但是足够，不知道是好还是不好。</p><p>证明的结论之间引用过程，感觉画成网状或者树状关系图会更好？</p><p>看youtube了上的讲解视频，会发现有一种写代码的抽取函数感觉，和我上面完全拆开证明不一样，抽函数的感觉其实在数学里大概是叫做“令”+“引理”，感觉和完全展开比较，的确能减少很多心智负担啊！如果你也能打开youtube建议去看看</p><p>另外比如有些 强结论要用的时候，即使你证出了相对弱的结论，但没有证明出强结论，其实相当于“没有用”，比如上面 基础解，的平方，的n次方，和任意另一组解能产生新的解的证明。当然如果能证明出，那些就是过程了，但不是步骤（虽然我上面有写进文中，因为要简洁整理的话，直接强结论证明，即可其它的弱的可以直接省略</p><p>虽然视频看的时候的确感觉到老师和同学的口算不如国内，但自从自己思考过十进制的意义以后，感觉数值计算都不再重要，有的是计算机，不需要人类来算。</p><p>youtuber james cook 有证明一个 同系数二元二次方程 之间的关系，可以用它来 从 不是解的东西里生成解(感觉好像不是特别行，因为一个等式的 四个值仅仅由两个变量控制而不是3个？)！(Quadradic Forms) Q(u+v)+Q(u-v)=2(Q(u)+Q(v)),然后以此建立树，考虑其中的“正负交替路线”river</p><p>多核没智力还是搞不动数学啊,</p><p>这篇文章整理了很多篇其它资料，所以在符号使用上还不够统一，之后看有空整理一下</p><p>在我快写完这一篇文章的时候发现了 一个<a href="https://chaoli.club/index.php/2756/0" target="_blank" rel="noopener">超理论坛-连分数入门</a> 注册需要一点点水平XD，这篇是带着例子讲解写的！(大自看了一下 感觉很棒 推荐), 又 有些性质证明方式不止一种，例如我本篇文章所抄来的证明 二次无理数和有循环节的充要 会感觉更漂亮一些</p><p>有些paper写到后面还是很多笔误，不过看通了也是能理解具体过程</p><p>有一个想法是 哪些结论是关键或者说证明的难点，其实可以这样想，现在，把文章中一些部分换成填空，你还能不能补全整个文章，不需要完全一样，只要能证明就行。这样想的话，就会知道所谓的难点是在哪。</p>]]></content>
      
      
      <categories>
          
          <category> Project Euler </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pe </tag>
            
            <tag> project euler </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tencent 04 26 C 状压dp入门</title>
      <link href="/Blog/2020-04-27-tencent042C/"/>
      <url>/Blog/2020-04-27-tencent042C/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>n张牌，正反两面都有数字，给初始序列。</p><p>一次操作交换相邻的两张牌并翻转这两张牌。</p><p>求问能否最后所有朝上的牌构成非减序列</p><p>2&lt;= n&lt;=18</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>显然数值范围没意义，因为就算很大，离散一下也就最多36个</p><p>显然根据交换规则，把i放到j后，它的正反面是确定的</p><p>所以排列的状态数是<code>n!</code>，18的阶乘就不要想枚举了</p><p>这题的边界感觉也能很难想，所以有想过的一个骗分方向是迭代加深，但是估计只能骗分答案比较小，或者n比较小的点</p><hr><p>有人贪心100%了？？ 不知道腾讯出题的人在干嘛？这样明显一堆hack点的能100%，叫那些写状压的没满的怎么想</p><hr><p>前置知识：冒泡排序操作数 = 逆序对个数。</p><p>这题目只看操作过程中坐标的变化，实际就是在进行冒泡排序，所以我们的步数也就是 最初顺序标号变成最后顺序标号的逆序对个数</p><hr><p>状态设计[前i个，使用的元素的state，第i个用的是下标j]</p><p>注意到state用0/1来表示是否选择，1的个数就是i，所以可以省略为<code>[state,j]</code></p><p>这个状态对应的值 <code>dp[state,j]</code>为 已经选出的元素的逆序对的最小值</p><p>转移方程为</p><p><code>dp[state][j] = min(dp[state 去掉 j][for剩余可选] + state剩余部分和j构成的逆序对)</code> </p><p>注意到<code>state</code>内部顺序不影响state剩余部分 和 j构成的逆序对的值</p><p><code>= min(dp[state 去掉 j][for剩余可选]) + state剩余部分和j构成的逆序对</code></p><p>所以 一个状态的最小，是从去掉最后一个的最小来的</p><p>(感觉这里局部最优/最小性证明有点绕，或者可以用归纳证？</p><p>注意保证题目限制非减序列别忘了</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><p>不是我写的，链接在下方,加了点注释</p><pre><code>作者：qin_peng链接：https://www.nowcoder.com/discuss/417957?type=0&amp;order=0&amp;pos=77&amp;page=1来源：牛客网</code></pre><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;#define me(a,x) memset(a,x,sizeof(a))#define sc scanf#define pr printf#define IN freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);#define OUT freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);typedef long long ll;typedef unsigned long long ull;const int N=1e6+6;const int mod=1e9+7;int O(){putchar(&#39;\n&#39;);return 0;}template&lt;typename T,typename... Ty&gt;int O(const T&amp; a,const Ty&amp;... b){cout&lt;&lt;a&lt;&lt;&#39; &#39;;return O(b...);}void I(){}template&lt;typename T,typename... Ty&gt;void I(T&amp; a,Ty&amp;... b){cin&gt;&gt;a;I(b...);}template&lt;typename T&gt;void db(T *bg,T *ed){while(bg!=ed)cout&lt;&lt;*bg++&lt;&lt;&#39; &#39;;pr(&quot;\n&quot;);}inline ll mul_64(ll x,ll y,ll c){return (x*y-(ll)((long double)x/c*y)*c+c)%c;}inline ll ksm(ll a,ll b,ll c){ll ans=1;for(;b;b&gt;&gt;=1,a=a*a%c)if(b&amp;1)ans=ans*a%c;return ans;}int n,a[20],b[20];int dp[1&lt;&lt;20][20];const int INF=1e9;int main(){    I(n);    for(int i=0;i&lt;n;i++)sc(&quot;%d&quot;,&amp;a[i]);    for(int i=0;i&lt;n;i++)sc(&quot;%d&quot;,&amp;b[i]);    for(int i=1;i&lt;n;i+=2)swap(a[i],b[i]);    for(int i=0;i&lt;(1&lt;&lt;n);i++){        for(int j=0;j&lt;n;j++){            dp[i][j]=INF; // 不可达        }    }    for(int i=0;i&lt;n;i++)dp[1&lt;&lt;i][i]=0; // 选单个 逆序对为0    for(int i=0;i&lt;(1&lt;&lt;n);i++){ // 保证子状态先于父状态计算        for(int j=0;j&lt;n;j++){            if(dp[i][j]==INF)continue;            for(int k=0;k&lt;n;k++){                if(i&gt;&gt;k&amp;1)continue;                int x=__builtin_popcount(i)&amp;1; // 内置计算1的个数                if(x){ // 非减 限制                    if(b[k]&lt;a[j])continue;                }else{                    if(a[k]&lt;b[j])continue;                }                int ans=0;                for(int l=k+1;l&lt;n;l++){ // 计算 state补上k以后 state与k之间新形成的逆序对                    if(i&gt;&gt;l&amp;1)ans++;                }                dp[i|1&lt;&lt;k][k]=min(dp[i|1&lt;&lt;k][k],dp[i][j]+ans); // 递推感觉局部最小性有点奇怪？只有我？但是从上向下看是没问题的。所以逻辑一致没问题            }        }    }    int ans=INF;    for(int i=0;i&lt;n;i++)ans=min(ans,dp[(1&lt;&lt;n)-1][i]);    if(ans==INF)O(-1);    else O(ans);}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>很早看到18 就条件反射的想2的n次方</p><p>看到交换两个也想到了逆序对和冒泡</p><p>但没想出最后的状态以及转移，果然设计状态有点难啊，我好菜哇</p><p>大概技术总结的话应该是 除了最简单的状态，还有一种是<code>[state][末尾选择]</code>，这样的话能保证性质就行，如这里的末尾选择就是用来保证 非减少的</p>]]></content>
      
      
      <categories>
          
          <category> tencent </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bitdp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces 1340 C, 入门bfs</title>
      <link href="/Blog/2020-04-25-cf1340c/"/>
      <url>/Blog/2020-04-25-cf1340c/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://codeforces.com/contest/1340/problem/C" target="_blank" rel="noopener">https://codeforces.com/contest/1340/problem/C</a></p><h1 id="状态设计"><a href="#状态设计" class="headerlink" title="状态设计"></a>状态设计</h1><p>应该算bfs+dp?</p><p>状态设计 <code>dist[第i个检查点][剩余步数j] = 到达的最小轮数 或 不可达</code></p><p>转移从数轴上看，只有左右关系相邻的两个点能在dist中转换，每个点最多被更新一次。</p><p>所以 O(nm)时间空间</p><p>注意的是 不能跨过g，每次转移前是<code>j&lt;g</code>,转以后的<code>j&lt;=g</code></p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><p>托爷代码：<a href="https://codeforces.com/contest/1340/submission/77808028" target="_blank" rel="noopener">https://codeforces.com/contest/1340/submission/77808028</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define INF 0x3f3f3f3f3f3f3f3f#define MOD 1000000007#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)#define pb push_back#define foreach(i, v) for (__typeof((v).begin()) i = (v).begin(); i != (v).end(); ++ i)const double pi = acos(-1.0);int main() {  ios::sync_with_stdio(false);  cin.tie(0);  int n, m;  cin &gt;&gt; n &gt;&gt; m;  vector&lt;int&gt; d(m);  for (int i = 0; i &lt; m; i++) {    cin &gt;&gt; d[i];  }  sort(d.begin(), d.end());  int g, r;  cin &gt;&gt; g &gt;&gt; r;  // dist[0-&gt;m-1][0-&gt;g] = -1; 不可达  // dist[第i个停靠点][还要走j步为g的整数倍] = 最小的完整轮数  vector&lt;vector&lt;int&gt;&gt; dist(m, vector&lt;int&gt;(g + 1, -1));  dist[0][g] = 0; // 可达的轮数为0  vector&lt;pair&lt;int, int&gt;&gt; que;  que.emplace_back(0, g);  while (!que.empty()) {    // 步数少于等于g的广搜    for (int b = 0; b &lt; (int) que.size(); b++) {      int i = que[b].first; // 位置      int j = que[b].second; // 剩余步数      if (i &gt; 0) { //        int go = d[i] - d[i - 1];        if (j &gt;= go) {          if (dist[i - 1][j - go] == -1) {            que.emplace_back(i - 1, j - go);            dist[i - 1][j - go] = dist[i][j];          }        }      }      if (i &lt; m - 1) {        int go = d[i + 1] - d[i];        if (j &gt;= go) {          if (dist[i + 1][j - go] == -1) {            que.emplace_back(i + 1, j - go);            dist[i + 1][j - go] = dist[i][j];          }        }      }    }    vector&lt;pair&lt;int, int&gt;&gt; new_que;    // 利用g表示 上一层节点，0表示新走到的节点， 产生新的一层    for (int b = 0; b &lt; (int) que.size(); b++) {      int j = que[b].second;      if (j == 0) { // 新走道德合法点        int i = que[b].first;        if (dist[i][g] == -1) {          dist[i][g] = dist[i][0] + 1; // 轮次+1          new_que.emplace_back(i, g);        }      }    }    swap(que, new_que);  }  const long long inf = (long long) 1e18;  long long ans = inf;  for (int i = 0; i &lt;= g; i++) {    if (dist[m - 1][i] != -1) { // 可达到 最后一个点一定是终点      long long cur = (long long) dist[m - 1][i] * (g + r) + (g - i); //计算总时间      ans = min(ans, cur);    }  }  cout &lt;&lt; (ans == inf ? -1 : ans) &lt;&lt; &#39;\n&#39;;  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>还真是个大水题 放在1C</p><p>自己也在想dp，状态，还有dijs,看推有人还真的过了。</p>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>后缀自动机器 SAM</title>
      <link href="/Blog/2020-04-18-sam/"/>
      <url>/Blog/2020-04-18-sam/</url>
      
        <content type="html"><![CDATA[<h1 id="最终产物"><a href="#最终产物" class="headerlink" title="最终产物"></a>最终产物</h1><p>输入一个原始字符串，产生一个自动机，能识别一个给的新字符串是否是原始字符串的后缀。</p><p>给一个初始State，每次接受一个字符，进行状态转移到新的State或失败</p><p>每个State有标记是否为后缀</p><h1 id="详细内容建议直接看oi-wiki"><a href="#详细内容建议直接看oi-wiki" class="headerlink" title="详细内容建议直接看oi-wiki"></a>详细内容建议直接看oi-wiki</h1><p>本文是，理清一些东西，和一些举例</p><p>对于一个给定的原始字符串，它所产生的自动机</p><table><thead><tr><th>描述</th><th>自己设计符号</th></tr></thead><tbody><tr><td>自动机的各个状态</td><td>State</td></tr><tr><td>一个字符</td><td>char</td></tr><tr><td>字符串</td><td>String</td></tr><tr><td>原始字符串的一个位置</td><td>Pos / typedef Pos int</td></tr><tr><td>自动机状态之间的转移边(接受一个字符)</td><td>next(State st,char ch) -&gt; State</td></tr><tr><td>状态的后缀链接</td><td>link(State st) -&gt; State</td></tr><tr><td>字符串结尾位置</td><td>endposString(String s) -&gt; Pos数组</td></tr><tr><td>状态结尾位置</td><td>endposState(State st) -&gt; Pos数组</td></tr><tr><td>字符串对应的状态</td><td>str2State(String s)-&gt; State</td></tr><tr><td>状态对应的字符串数组</td><td>state2St(State st)-&gt; String数组</td></tr></tbody></table><h2 id="性质和证明思路-不是详细证明"><a href="#性质和证明思路-不是详细证明" class="headerlink" title="性质和证明思路(不是详细证明)"></a>性质和证明思路(不是详细证明)</h2><p>给定一个字符串s，endposString(s)表示这个字符串在原始字符串中出现的结尾位置的数组</p><p>定义State:</p><p>如果两个不同的字符串s1和s2,它们的 endposString输出的数组 完全相同，则它们属于同一个State,否则它们属于不同的State</p><p>因此每个字符串对应一个State,一个State对应一个数组的字符串。（也可以把State 看作一些字符串的集合）</p><p>如果不同字符串能够结尾位置相同，那么其中一个是另一个的后缀，所以一个State中的所有字符串两两成后缀关系</p><p>因此State中最短的字符串只要在原串的任意位置出现，则State最长的也出现，所以 长度介于最短和最长之间的必定出现</p><p>所以一个State包含的是 长度递增1的,相互为后缀的一系列数组</p><p>两个State之间，如果有重复的结束位置，那么对应位置各自的两个字符串 也一定是后缀关系。注意到上面结论 一个State包含的是一个递增一的连续整数区间。所以两个State之间的关系是 max(其中一个区间) &lt; min(另一个区间)</p><p>也有了其中一个State的所有字符串是另一个区间的字符串的后缀，所以结束位置的关系一定是包含，（长的字符串出现的位置短的一定出现，长的字符串结束位置 包含于 短的)</p><p>如果两个State 的位置是包含关系，且其中一个State1最短字符串长度 + 1 = 另一个State2最长字符串长度，那么</p><p><code>link(State1) = State2</code>, 说明State1 更短,State2更长和State1相邻</p><p>满足 link(State1)=State2 的所有state1 对应的endposState 两两交集为空，它们的并集 为 endposState(State2)</p><p>注意State会表示原始字符串子串所有能达到的状态，link以树的形式连接了所有State,从结束位置数组的角度看，每一个link分支都表示把数组拆分，数组中n个元素，所以总状态O(n)</p><p>准确点是&lt;= 2n-1, 初始状态空字符串,包含所有n个下标, 每次拆分最多多出两个新集合, 最多n-1次拆分,所以最多1+2(n-1)=2n-1个节点</p><h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><p>在完全完成以前一直不会标记终止状态</p><p>每个State记录三个信息</p><ol><li>所对应的字符串最长的长度</li><li>增加一个char以后转移到的目标状态</li><li>后缀关系link指向的相邻状态</li></ol><p>具体构建过程看wiki 和下面代码及注释，这里讲一点自己的理解</p><p>首先这是一个“归纳”性质的构建过程，所以其实考虑的是 “对于字符串构建好的自动机，在该字符串右侧末尾增加一个字符所带来的变动”</p><p>以 abcbc为例</p><p><img src="https://oi-wiki.org/string/images/SAM/SA_suffix_links.svg" alt></p><p>左是next,右侧是link, 蓝色空状态, 绿色终止条件</p><h2 id="link-维护理解"><a href="#link-维护理解" class="headerlink" title="link 维护理解"></a>link 维护理解</h2><p>单独看link构成的树，考虑画一个完整的每个字符串一个节点的树和link做比较，你会发现link构成的树其实是把那些没有分支的节点的部分(存在单字符没有分叉但是单独的State)路径合并成一个节点了而已</p><p>所以从这个角度，考虑一个每个字符串一个节点的link树，新增一个字符 意味着增加了一串后缀的链到原来的树上，而接到原来的树上的位置可能是叶子/根/一个已经有分叉的节点，也可能是某个节点分叉出来。（一定不会完全重合，因为一个字符串一个节点，新增的全长字符串一定不在原始的link树中。 所以上面描述的情形再考虑缩成目标的state link树。</p><p>就会和wiki中描述的操作对应了理解。1.一定会增加一个新的节点。可能找不到和-1 state连接，也可能找到已有可用的“转移”，不在操作，也可能之前会合并成一个状态的点，现在因为多了分叉需要拆成两个,同时也能理解为什么是从last开始沿着link去找是否有 char的转移</p><p>例如考虑abcb =&gt; abcbc</p><p>原来链 c-bc-abc 是一个state</p><p>现在新插入链 c-bc-cbc-bcbc-abcbc</p><p>就会变成</p><ol><li>(c-bc)新拆出的state, 下面代码中qClone</li><li>abc(修改老的c-bc-abc得到的state), 下面代码中q变化</li><li>(cbc-bcbc-abcbc新增的state), 下面代码中newState</li></ol><h2 id="next维护理解"><a href="#next维护理解" class="headerlink" title="next维护理解"></a>next维护理解</h2><p>next 比link复杂一些，但是实际也是可以用上面的 link树来看</p><p>先考虑未进行合并的状态的影响,其实就是对所有last后缀 增加char建立边</p><p>考虑<code>abcb=&gt;abcbc</code></p><p>也就是要有边</p><pre><code>&quot;&quot;-&gt;&quot;c&quot;&quot;b&quot;-&gt;&quot;bc&quot;&quot;cb&quot;-&gt;&quot;cbc&quot;&quot;bcb&quot;-&gt;&quot;bcbc&quot;&quot;abcb&quot;-&gt;&quot;abcbc&quot;</code></pre><p>左侧出现的, 全在last的link链上</p><p>重复处理，例如”b”-&gt;”bc”其实已经有了，所以比它更短的也全有了，所以就能理解为什么wiki上的操作是last的link链上找到首个有char的边, 相当于从长到短找找最长的有的</p><p>原来link树上路径可合并的点 缩成一个state</p><p>两个有next关系的state意味着，其中一个state的所有字符串增加字符char后 的到字符串是 另一个state的子集</p><p>比如,这里之前是 state(“b”).next[“c”] = state(“bc”) == state(“c”,”bc”,”abc”)</p><p>但是 对于我们新增的state，不会有比它长的(“abc” 不期望的</p><p>但是next不像link，对结束位置并不友好，其意义是 选其中一部分下一位置是char的，在目标state中增加这些位置</p><p>但观察长度关系 也是有友好性。虽然说是集合，但是目标state中的每一个字符串 只有唯一的“上一个”字符串（也就是去掉最后一个字符的字符串），其对应的也就是唯一的state。</p><p>所以不同的相同的state中是没有重复元素的数组</p><p>next的作用就是把原来的字符串 下一个是char的部分抽出来，push到目标state的数组中</p><p>而注意到state是长度递增1的 后缀偏序数组</p><p>那么减去最后一个字符依然是长度递增1的 后缀偏序数组</p><p>state : [xxxxxxxx]c, 长度<code>l-&gt;r</code></p><p>那么它的next来源</p><p>state : [xxxxxxxx], 长度<code>l-1-&gt;len1-1</code>,<code>len1-&gt;len2-1</code>,….,<code>leni-&gt;r-1</code></p><p>每组就是一个state</p><p>所以如果wiki中描述的状态转移<code>p-&gt;q</code> 刚好最大长度差1,也就是 原来的划分很完美，只需要新建&gt;=len(q)+1的</p><p>也就是说 原来的<code>p-&gt;q</code> 转移的划分是否和 期望的划分点一致。如果不一致就拆分</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>很显然上面甚至连标记结束状态都没说，而实际上标记结束状态无非是给每个state多个字段，在完全构建以后，走一遍 link</p><p>其实这个自动机构建了以后，不只是简单的后缀判断，还能做很多字符串的事情</p><ol><li>判断是否包含子串, 从root开始沿着next指针走</li><li>不同子串个数, 相当于不同路径数, dfs, 一个节点有 len(i) - len(link(i))个子串, <a href="https://www.luogu.com.cn/problem/P3804" target="_blank" rel="noopener">luogu P3804</a></li><li>所有不同子串总长度, 同理, 在每个节点可以得到路径个数 和 对应长度 和 子串数量</li><li>字典序第k大子串, 就是字典序第k大的路径, 也可以后缀数组做</li><li>某个子串出现次数</li></ol><p>…</p><p>见 wiki</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (int i=a;i&lt;n;i++)struct State {  State * link; // 后缀父状态 指向比它短的后缀状态  unordered_map&lt;int, State *&gt; next; // 状态转移, 指向string尾部增加int后得到的State  int maxLen; // maxlen in this state  State(int _maxLen):    link(NULL),maxLen(_maxLen){      next = {};    }};class SAM{  State *root , *lastState;public:  SAM(){    root = lastState = new State(0);  }  void extend(int w){ // ???? =&gt; ????w    State *p = lastState;    State *newState = new State(p-&gt;maxLen + 1);    // find first p in lastState-&gt;link-&gt;link-&gt;link...-&gt;link    //  satisfy p-&gt;next[w] exist    //  let q = p-&gt;next[w]    //  找到有 w 转移的, 或者增加w转移    for(;p &amp;&amp; !p-&gt;next[w];p=p-&gt;link) p-&gt;next[w] = newState;    for(;;){ // 降低层级      if(!p){ // 全部原来都没有w转移, 也就是 [...??w] 唯一存在        newState -&gt; link = root;        break;      }      // state p + char w -&gt; state q      State *q = p-&gt;next[w]; // 说明 [p w] 至少两处存在      if(p-&gt;maxLen+1 == q-&gt;maxLen){ // 单独状态        newState-&gt;link = q; // newState 一定比 q 长, q是比它短的最长后缀        break;      }      // clone q next &amp; link      State * qClone = new State(p-&gt;maxLen+1); // 相当于从State q中拆出不大于p-&gt;next[w]转移的部分      qClone-&gt;next = q-&gt;next; // copy      qClone-&gt;link = q-&gt;link;      // change q &amp; newState link      for(;p &amp;&amp; p-&gt;next[w] == q;p=p-&gt;link) p-&gt;next[w] = qClone; // 更新所有单独      q-&gt;link = newState-&gt;link = qClone;      break;    }    lastState = newState;  }  bool has(string s){    State *p = root;    for(auto ch:s){      if(!p-&gt;next[ch])return false;      p = p-&gt;next[ch];    }    return true;  }};int main(){  auto sam = SAM();  string s = &quot;aabab&quot;;  for(auto ch: s){    sam.extend(ch);  }  printf(&quot;%d\n&quot;,(int)sam.has(&quot;aba&quot;));  return 0;}</code></pre><h1 id="refs"><a href="#refs" class="headerlink" title="refs"></a>refs</h1><p><a href="https://oi-wiki.org/string/sam/" target="_blank" rel="noopener">https://oi-wiki.org/string/sam/</a></p><p>陈立杰 的 ppt</p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SAM </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串hash Eowcoder 5026 E</title>
      <link href="/Blog/2020-04-11-nowcoder5026E/"/>
      <url>/Blog/2020-04-11-nowcoder5026E/</url>
      
        <content type="html"><![CDATA[<h1 id="题"><a href="#题" class="headerlink" title="题"></a>题</h1><p><a href="https://ac.nowcoder.com/acm/contest/5026/E" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/contest/5026/E</a></p><h1 id="字符串hash"><a href="#字符串hash" class="headerlink" title="字符串hash"></a>字符串hash</h1><p>遇到了无数遍了</p><p>来讲一种常见的字符串hash吧</p><p>首先给一个字符串s，假设它只有小写英文字母</p><p>根据万物皆是数的想法</p><p>我们可以把它每一位通过 <code>s[i]-&#39;a&#39;</code>变成数字</p><p>这样原字符串就变成了一个数列，因为全是字母</p><p>所以可以26为进制 <code>sum((s[i]-&#39;a&#39;)*26^i)</code>的形式把原来的数变成大的整数</p><p>如果两个字符串相等，那么这个大整数，相等，否则大整数不等。</p><p>通过取mod可以让它比较可以操作，和支持更长的长度</p><p>变成<code>sum((s[i]-&#39;a&#39;)*26^i) %p</code>的形式</p><p>当我们有一个字符串<code>s0s1...sn</code>时</p><p>增删首尾都是 可以通过考虑计算大整数的方式去处理，预处理26的幂次模p即可</p><p>这样 长度为n的字符串的所有长度为m的连续子串的hash值，我们可以只用O(n)的时间就可完成</p><h1 id="关于冲突"><a href="#关于冲突" class="headerlink" title="关于冲突"></a>关于冲突</h1><p>注意到上面的26是对于字母的情况，实际上,只要这个幂次的<code>基</code>大于<code>每一位上的最大值</code>即可，所以考虑单个字符的最大ascii</p><p>可以变成 <code>sum(s[i] * b^i) %p</code> 的形式， b 取质数重要吗迷? 然后p取尽量大的质数就行</p><p>$Hash(S) = \sum_{i=0-&gt;n-1} s[i] * b^i \mod p$</p>]]></content>
      
      
      <categories>
          
          <category> NowCoder </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces 1333D</title>
      <link href="/Blog/2020-04-09-cf1333D/"/>
      <url>/Blog/2020-04-09-cf1333D/</url>
      
        <content type="html"><![CDATA[<h1 id="题"><a href="#题" class="headerlink" title="题"></a>题</h1><p><a href="https://codeforces.com/contest/1333/problem/D" target="_blank" rel="noopener">https://codeforces.com/contest/1333/problem/D</a></p><p>n个人 向左或右</p><p>每次，可以 选若干(&gt;=1) 组人，它们相向的变为相反，即 RL 变成 LR</p><p>要正好k轮，最后所有人都不相向</p><p>求方案</p><h1 id="显然"><a href="#显然" class="headerlink" title="显然"></a>显然</h1><p>每轮能转就转，轮数最少（不知道怎么证明）</p><p>看成0，1对，每次是把10变成01,也就是 每轮只转一个，最多轮是逆序对个数</p><p>中间情况 考虑最快情况，从后向前 拆分操作即可</p>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LCA / Nowcoder 5086 C</title>
      <link href="/Blog/2020-04-07-nowcoder5086C/"/>
      <url>/Blog/2020-04-07-nowcoder5086C/</url>
      
        <content type="html"><![CDATA[<h1 id="水题"><a href="#水题" class="headerlink" title="水题"></a>水题</h1><p>调一万年，第一次就差三个地方</p><ol><li><p>忘记了<code>for work()</code></p></li><li><p>assert()里面忘记双等号，写了个单个等号…</p></li><li><p>LCA 写错了</p></li></ol><pre><code class="c++">int r(int i,int j){  if(d[i] &gt; d[j])swap(i,j);  per(off,0,20){    if(d[j]-d[i] &gt;= (1&lt;&lt;off) ){      j=f[j][off];    }  }  if(i == j)return i;  per(off,0,20){ // &lt;---------------------------- 写成 per(off,1,20) 了    if(f[i][off] != f[j][off]){      i=f[i][off];      j=f[j][off];    }  }  return f[i][0];}</code></pre><h1 id="不过"><a href="#不过" class="headerlink" title="不过"></a>不过</h1><p>感觉LCA写得比原来熟很多了</p>]]></content>
      
      
      <categories>
          
          <category> NowCoder </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LCA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces 1326D1</title>
      <link href="/Blog/2020-03-20-cfP1326D2/"/>
      <url>/Blog/2020-03-20-cfP1326D2/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="http://codeforces.com/contest/1326/problem/D2" target="_blank" rel="noopener">http://codeforces.com/contest/1326/problem/D2</a></p><p>字符串s 去掉其中连续一段，使得剩余的部分构成回文，求最长的方案</p><h1 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h1><p>|s| &lt;= 10^6</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>这个题有两个版本，easy的版本<code>|s|&lt;=5000</code></p><p>对于那个版本，先建立<code>r[i][j]</code>表示<code>s[i..j]</code>是否是回文 空间和时间都是<code>O(n^2)</code></p><p>然后枚举 首尾的 长度，和中间循环节的长度,时间复杂度<code>O(n^2)</code></p><p>对于hard版本(当前版本)这样做显然会超时。</p><hr><p>竟然是贪心。。。</p><p>果然单调性质</p><p>假设前后缀<code>最长</code>的对称部分为k，则有两种情况</p><p><code>[0...k][回文].....[k...0]</code></p><p><code>[0...k].....[回文][k...0]</code></p><p>如果有一个更优的方案<code>(t&lt;k)</code>,则它的样式为</p><p><code>[0..t][回文]....[t..0]</code></p><p><code>[0..t]....[回文][t..0]</code></p><p>因为对称关系，我们只讨论一种剩余回文在左侧的</p><p><code>[0..t][回文]...[t..0]</code></p><p>因为<code>t&lt;k</code></p><p>所以我们可以把回文部分左右减少1个，而把<code>[0..t]</code>变为<code>[0..t+1]</code>,它依然是合法的</p><p><code>[0..t+1][回文去首尾]..[t+1..0]</code></p><p>这样新的合法的依然是长度不变</p><p>反复操作，最后能得到一个<code>[0...k][回文].....[k...0]</code></p><p>所以任何<code>更优方案</code>能转换成<code>[0...k][回文].....[k...0]</code></p><p>综上,实现变为 移除首位最长对称串，再在剩余的内容中找最长前缀回文或最长后缀回文</p><p>最后在中间的找前后缀回文用点kmp之类或者hash之类的就行了</p><pre><code class="cplusplus">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define INF 0x3f3f3f3f3f3f3f3f#define MOD 1000000007#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)#define pb push_back#define foreach(i, v) for (__typeof((v).begin()) i = (v).begin(); i != (v).end(); ++ i)const double pi = acos(-1.0);// t = a+b// t = s[pre] + s[suffix]// len(t) &lt;= len(s)// ==&gt;//// [preA][...]...[~preA]// [preA]...[...][~preA]////// = s 移除连续一段 使得结果变成回文// s[....]// ~s[....]// dp[i][j] [0/1/2][0/1/2]// n^2 ?//// s[...i[ ]i...]// = max(2*i+ [i+1...]回文 ])// = max(2*i+ [ ...[...?]回文] )char s[1&#39;000&#39;010];char t1[1&#39;000&#39;010];char t2[1&#39;000&#39;010];int pre[1&#39;000&#39;010];int r(char * ch,int sz){  pre[0] = -1;  rep(i,1,sz){    int pos = i-1;    while(true){      pos = pre[pos];      if(ch[pos+1] == ch[i]){        pre[i] = pos+1;        break;      }      if(pos == -1){        pre[i] = -1;        break;      }    }  }  // rep(i,0,sz){  //   printf(&quot;%d &quot;,pre[i]);  // }  int lastans = -1;  per(i,0,sz){    // [[0..lastans]..i[..0]...]    while(true){      if(ch[i] == ch[lastans+1]){        if(lastans + 2 &gt;= i){          return lastans*2+3+ (i!=lastans+1);        }        lastans++;        break;      }      if(lastans == -1){        break;      }      lastans = pre[lastans];    }  }  return 0;}int main(){  int t;  cin&gt;&gt;t;  while(t--){    scanf(&quot;%s&quot;,s);    int n = strlen(s);    int k = -1;    rep(i,0,n){      if(i&lt;n-1-i){        if(s[i]==s[n-i-1]){          k = i;        }else{          break;        }      }    }    rep(i,k+1,n-k-1){      t1[i-k-1]=s[i];    }    int len1 = r(t1,n-2-2*k);    rep(i,k+1,n-k-1){      t2[n-k-2-i]=s[i];    }    int len2 = r(t2,n-2-2*k);    // cout&lt;&lt;&quot;?&quot;&lt;&lt;len1&lt;&lt;endl;    // cout&lt;&lt;&quot;!&quot;&lt;&lt;len2&lt;&lt;endl;    rep(i,0,k+1){      printf(&quot;%c&quot;,s[i]);    }    if(len1 &gt; len2){      rep(i,0,len1){        printf(&quot;%c&quot;,t1[i]);      }    }else{      rep(i,0,len2){        printf(&quot;%c&quot;,t2[i]);      }    }    rep(i,n-k-1,n){      printf(&quot;%c&quot;,s[i]);    }    printf(&quot;\n&quot;);  }  return 0;}</code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>官方题解 <a href="http://codeforces.com/blog/entry/74961" target="_blank" rel="noopener">http://codeforces.com/blog/entry/74961</a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>估计还是估计到了 O(n)或者O(nlog n)范围的算法，但赛内没有推出更优的性质</p>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces 1303E(DP)</title>
      <link href="/Blog/2020-02-13-cfP1303E/"/>
      <url>/Blog/2020-02-13-cfP1303E/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://codeforces.com/contest/1303/problem/E" target="_blank" rel="noopener">https://codeforces.com/contest/1303/problem/E</a></p><p>T组测试</p><p>t和s是字符串</p><p>s中能否找两个不共用下标的子序列(不要求连续)，t=concat(s1,s2)</p><h1 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h1><p>T&lt;=100</p><p>|s|,|t| &lt;= 400</p><h1 id="提解"><a href="#提解" class="headerlink" title="提解"></a>提解</h1><p>枚举t的分割位置</p><p>dfs(s中当前匹配位置i,t前段匹配位置j,t后半匹配位置k)</p><p>很明显超时。</p><p>注意到上面dfs仅返回true/false</p><p>也就是dfs(i,j,k)=1/0这种</p><p>可以改为（也有贪心关系）,<code>dp[i][j]=最多匹配的k</code></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>dfs(i,j,k)=1/0</code>可以考虑 <code>dp[i][j]=max/min(k)</code></p>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1292C - Xenon_s Attack on the Gangs(树上区间DP,mex)</title>
      <link href="/Blog/2020-01-20-1292C/"/>
      <url>/Blog/2020-01-20-1292C/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://codeforces.com/contest/1292/problem/C" target="_blank" rel="noopener">https://codeforces.com/contest/1292/problem/C</a></p><p>2300评分</p><h1 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h1><p>给树的形状，你需要把0到n-2分别填在边上。</p><p>求 sum{mex{所有简单边}}的最大期望值</p><h1 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h1><p>节点数小于3000</p><p>3s</p><p>512MB</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><a href="https://codeforces.com/blog/entry/73051" target="_blank" rel="noopener">官方题解</a></p><p>感觉对mex的题始终不会</p><p>$S = \sum_{1 \leq u &lt; v \leq n} mex(u, v) = \sum_{1 \leq x \leq n} \left( \sum_{mex(u, v) = x} mex(u,v) \right) = \sum_{1 \leq x \leq n} \left( \sum_{mex(u, v) = x} x \right) = \sum_{1 \leq x \leq n} \left( \sum_{mex(u, v) \geq x} 1 \right) = \sum_{1 \leq x \leq n} f(x)$</p><p>直接解读这个公式。</p><p>第一个等式是定义</p><p>第二个第三个等式是按照mex的值进行拆分，</p><p>第四个等式的转换是 $x = \sum_{1\leq y \leq x} 1$,也就是原来在x时增加 $sum mex$ 倍 $x$,改为 从1 到x，各增加 sum mex倍 1</p><p>最后一个等式是定义 f(x)函数</p><p>$f(x) = count(mex(u,v) \ge x) =$ 包含 [0 -&gt;x-1]的简单路径数量</p><hr><blockquote><p>证明叶子到叶子包含0到len-1</p></blockquote><p>考虑一个树的形成过程如果是从0到n-2的放置，如果当前0到x-1已经固定，准备放x，那么只有把它放在0到x-1所有都在的路径上（如果可能），才能产生更大的mex，如果不这样，那么x以及所有大于x的最后的mex都已经固定。</p><p>因此放置时如果能够放到0到x-1的路径上，则一定是放在路径上。</p><p>也就意为这 一定有一条从叶子到叶子的简单路径 放了 0到length-1, 并且剩余的无论怎么放(因为已经叶子到叶子，不可能再集齐0到i了，mex也就不会变了) 对结果都没有影响</p><hr><blockquote><p>证明这条路径上赋值山谷形状</p></blockquote><p>现在假设固定了简单路径的位置，下面要证明最优值的放置 是山谷形状，也就是 a1&gt;a2&gt;…&gt;ap&lt;…&lt;al−1&lt;al.</p><p>假设，[0-&gt;x-1]是连续的一段，x和这一段不连续 不妨设x在这一段的右侧（否则就左侧）</p><p><code>? ? ? ? [0到x-1连续的一段] vali ? ? ? ? ? x ? ? ? ?</code></p><p>我们交换 vali和x的位置</p><p>显然，对于f(0-&gt;x-1)不会变 因为 连续段的位置没有改动，也就是包含[0-&gt;x-1]的简单路径数量不变</p><p>对于f(x)变大，因为包含[0-&gt;x]的 简单路径数量 = <code>连续段</code>左侧分支数量 * <code>x</code>右侧分支数量，乘法第一个值不变，第二个值变大，总的值一定变大</p><p>对于f(&gt;x) 不减， 对于左侧点位置不变，对于右侧点不变或者有更进的右侧点，所以包含[0-&gt;(&gt;x)]的 简单路径数量 = <code>连续段</code>左侧分支数量 * <code>x</code>右侧分支数量，乘法第一个值不变，第二个值不减，总的值一定不减</p><p>总的来说，如果不满足上述状态，则一定有一个更优的摆放方法。综上，一定是山谷形</p><hr><p>然后就有了dp[u][v]  = $\sum_{1 \leq x \leq l} f(x)$的最大值，且u到v 填写的是0到l-1</p><p>定义(方便描述)</p><p>par(r,u): 以r为树的根节点，u的父节点</p><p>sub(r,u), 以r为树的根节点，u的子树的节点个数</p><p>官方题解的解释图</p><p><img src="https://espresso.codeforces.com/5e845e83910666767bba5505c6859ae17f68e48b.png" alt="官方题解解释图"></p><hr><p>计算<code>dp[u][v]</code>,根据我们的山谷原理，和dp的定义，<code>dp[u][v]</code>的最大值一定在两端的某一端</p><p>所以 剩余的部分为<code>dp[u][par(u,v)]</code> 或者 <code>dp[par(v,u)][v]</code>,又dp只关心<code>f(&lt;=l)</code>,所以剩余只有<code>f(l)</code>要计算</p><p>这显然 <code>f(l) = sub(u,v) * sub(v,u)</code></p><p>$dp[u][v] = sub(u, v) \times sub(v, u) + \max(dp[par(v, u)][v], dp[u][par(u, v)])$</p><p>一个点的所有分支子节点 直接dfs，对于父方向的= 总量-1-子分支即可，也就是每个点各个分支子节点数O(n)计算完，要计算一个具体sub时可以O(1)计算</p><p>对于par，我们可以把dp改为递推即可，</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><a href="https://codeforces.com/contest/1292/submission/69184244" target="_blank" rel="noopener">TLE14</a></p><p><a href="https://codeforces.com/contest/1292/submission/69184419" target="_blank" rel="noopener">去掉map WA17</a></p><p><a href="https://codeforces.com/contest/1292/submission/69184602" target="_blank" rel="noopener">int 改 long long Accept</a></p><pre><code class="cplusplus">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define INF 0x3f3f3f3f3f3f3f3f#define MOD 1000000007#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)#define pb push_back#define foreach(i, v) for (__typeof((v).begin()) i = (v).begin(); i != (v).end(); ++ i)const double pi = acos(-1.0);// 树,边被赋值[0,n-2]// 输入n 3000// 树状int n;vector&lt;int&gt;p2[3010];map&lt;int,int&gt;chcnt[3010];// child cnt [idx][p2] = childcntvector&lt;pair&lt;int,int&gt; &gt; cur; // [u&lt;v] = [par,par,sum]tuple&lt;int,int,ll&gt;cost[3010][3010]; // [u&lt;v] = [par,par,sum]int initchcnt(int idx,int fa){  int cnt = 1;  for(auto item:p2[idx]){    if(item == fa)continue;    cnt+= (chcnt[idx][item] = initchcnt(item,idx));  }  if(fa){    chcnt[idx][fa] = n - cnt;  }  return cnt;}ll cnt(int u,int paru){  return n-chcnt[u][paru];}ll ans = 0;// u pvu .... puv vvoid addrel(int u,int v,int pvu,int puv,ll count){  if(u &gt; v){    swap(u,v);    swap(pvu,puv);  }  ll newcount = count + cnt(u,pvu)*cnt(v,puv);  ans=max(ans,newcount);  if(get&lt;2&gt;(cost[u][v])==0){    cur.pb({u,v});  }  if(get&lt;2&gt;(cost[u][v]) &lt; newcount ){    cost[u][v] = {pvu,puv,newcount};  }}int main(){  cin&gt;&gt;n;  rep(i,0,n-1){    int u,v;    scanf(&quot;%d %d&quot;,&amp;u,&amp;v);    p2[u].pb(v);    p2[v].pb(u);  }  initchcnt(1,0);  // 减少重复运算u&lt;v  // 按照length递增 广搜  rep(i,1,n+1){    for(auto item:p2[i]){      if(item &lt; i)continue;      addrel(i,item,item,i,0);    }  }  rep(i,0,cur.size()){    auto [u,v] = cur[i];    auto [pvu,puv,count] = cost[u][v];    // u pvu .... puv v    // 扩展u    for(auto nu:p2[u]){      if(nu == pvu)continue;      addrel(nu,v,u,puv,count);    }    // 扩展v    for(auto nv:p2[v]){      if(nv == puv)continue;      addrel(u,nv,pvu,v,count);    }  }  printf(&quot;%lld\n&quot;,ans);  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>看到max，min有可能去考虑贪心或者说局部最优，比如这里的 山谷形状</p><p>mex是真的自闭</p><p>n看到了3000就算想到了n方dp，没想到上面这些证明也没卵用</p>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> 贪心 </tag>
            
            <tag> 树 </tag>
            
            <tag> 区间dp </tag>
            
            <tag> mex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NIM&#39;s GAME</title>
      <link href="/Blog/2020-01-10-nim-game/"/>
      <url>/Blog/2020-01-10-nim-game/</url>
      
        <content type="html"><![CDATA[<h1 id="入门题目-Bash-Game"><a href="#入门题目-Bash-Game" class="headerlink" title="入门题目(Bash Game)"></a>入门题目(Bash Game)</h1><p>有一堆物品，两人轮流取,每次只能$[1,a]$个，最后取空的赢/输，求对策</p><p>假设你的对手取$x$个，有$1\le x \le a$,也就有$1 \le a+1-x \le a$,保证不论对手怎么取$x$，只要你取对应的$a+1-x$个就能保证剩余的个数 对$a+1$ 取模不变</p><p>控制到了不变量(对$a+1$取模不变)也就找到了解题的关键</p><h1 id="NIM-Nim-Game"><a href="#NIM-Nim-Game" class="headerlink" title="NIM(Nim Game)"></a>NIM(Nim Game)</h1><h2 id="NIM-1"><a href="#NIM-1" class="headerlink" title="NIM 1"></a>NIM 1</h2><p>现在是两堆石头（可能相同个数，可能不同），每轮任选一堆，从该堆取任意正数个，最后取空的人赢/输</p><p>如果两堆相等，则对方任意取多少，你取相同的，总能维持一个不变<code>两堆的差值为0</code></p><h2 id="NIM-2"><a href="#NIM-2" class="headerlink" title="NIM 2"></a>NIM 2</h2><p>变为n堆石头（每堆数量独立），取法和上题一致，最后取空的人赢/输</p><p>假设有偶数堆，且成对的相等，那么用上题的结论，然而，这里我们发现，上题无论初始状态如何，我们都能通过0步或者1步达到我们的平衡的状态/不变的状态，而这里如果假设是偶数堆和成对的相等，这样的状态并不是任意可达的。</p><p>对于数据小，又想不到“数学”方法去找平衡态，可以用递归搜索去做，不过不是本文要讲的内容。</p><p>然后是枚举，发现并不是只有上面的状态是必胜/必败</p><p>例如有石堆$1 2 3$，也是能做到最后取空的控制，说明 偶数堆且成对相等 和 必胜必败没 不全等只有被包含关系。</p><p>先直接上结论</p><p>所有石头堆的异或值为$0$，显然如果当前为$0$,那么任意操作会使异或值变成非0</p><p>假设异或值为$k \neq 0$，从数量为$a$的堆中取走，最后剩下$b$个，</p><p>那么取走的个数为$a-b \ge 0$,$k \oplus a \oplus b = 0$(原来的异或 去掉a 新增b)</p><p>所以$b = a \oplus k$也就是要证明存在a使得$a \ge a \oplus k$</p><p>$k$是所有数量的异或结果，所以$k$的最高位$1$一定存在于某个$v[i]$中</p><p>$v[i]$ 和 $v[i]\oplus k$在高于$k$的最高位的位,值是相等的，在$k$的最高位$v[i]$为1,而$v[i]\oplus k$为$0$，所以存在$a = v[i]$使得$a \ge a \oplus k$,所以任意异或非$0$的$k$可以一步操作转化为$0$。</p><p>综上任意状态，能够通过0步或者1步转化为异或和为0。并且异或和为0是一个可以交替进行并被控制的平衡态。</p><p>至于为什么是想到异或和，我说不出，这个结论我也是从其它地方拿来，只会证明。</p><p>反过来再看NIM 1,会发现，虽然说是控制值相等，同时也就是控制异或和相等。</p><h1 id="SG-函数"><a href="#SG-函数" class="headerlink" title="SG 函数"></a>SG 函数</h1><p>有向无环图上</p><p>$ \operatorname{mex}(S)=\min(\{x\}) \quad (x \notin S, x \in N) $</p><p>$\operatorname{mex}(S) = $集合$S$中不包含的最小非负整数</p><p>$ \operatorname{SG}(x)=\operatorname{mex}( \{ \operatorname{SG}(y) | y是x的后继 \} ) $</p><p>边界也就是没有出度的点，$\operatorname{SG}(\emptyset)=0$</p><p>显然如果$SG(x) = 0$，那么它的所有后继$\ne 0$,如果$SG(x) \ne 0$, 那么一定存在一个后继$SG(y) = 0$</p><p>换句话说$SG(x) = 0$的任意操作走向一个$SG(y) \ne 0$ , 而$SG(x) \ne 0$ 你总可以找到一个操作$SG(y) = 0$</p><p>所以一定能控制$SG(x) = 0$ 的平衡态，也一定能通过0步，或1步达到这个平衡态。</p><p>所以如果我们用$SG(失败状态) = 0$, 然后状态之间加上有向边, 那么以此计算$SG$ 就可以知道每个状态是成功还是失败了</p><h2 id="应用在NIM-2中"><a href="#应用在NIM-2中" class="headerlink" title="应用在NIM 2中"></a>应用在NIM 2中</h2><p>考虑单个石堆游戏</p><p>有 $SG(个数) = 个数$</p><p>于是$SG(state(c_1,c_2,c_3,\cdots)) = c_1 \oplus c_2 \oplus c_3 \oplus \cdots= SG(c_1) \oplus SG(c_2) \oplus SG(c_3) \oplus \cdots$</p><h2 id="对于多个游戏的组合-n个有向图"><a href="#对于多个游戏的组合-n个有向图" class="headerlink" title="对于多个游戏的组合(n个有向图)"></a>对于多个游戏的组合(n个有向图)</h2><p>结论, 一个游戏的$SG$函数值等于各个游戏的$SG$函数值的$Nim$ 和(异或和)</p><p>$\operatorname{SG}(s_1) \oplus \operatorname{SG}(s_2) \oplus \ldots \oplus \operatorname{SG}(s_n)$</p><p>同上面证明NIM 2的过程，假设所有异或和为$k$ (总状态)，我们能得到</p><p>存在至少一个$i$满足$SG(s_i) &gt; SG(s_i)\oplus k$,对于第$i$个游戏，$SG(s_i)\oplus k$是$SG(s_i)$ 的后继状态</p><p>因为注意到$SG$ 是通过$\operatorname{mex}$定义的意味着, 如果$SG(x) = w$, 那么 它一步是可以走到$0..w-1$的任意$SG$状态的, 这就是NIM二中的一堆里面任意取个数的意义一样</p><p>所以 $SG(state(s_1,s_2,s_3, \cdots)) = SG(s_1)\oplus SG(s_2)\oplus SG(s_3)\oplus \cdots $</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://oi-wiki.org/math/game-theory/" target="_blank" rel="noopener">game theory</a></p><p><a href="https://en.wikipedia.org/wiki/Sprague%E2%80%93Grundy_theorem" target="_blank" rel="noopener">Sprague–Grundy_theorem</a></p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nim的游戏 </tag>
            
            <tag> 博弈论 </tag>
            
            <tag> sg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces 1284E (计算几何,浮点数)</title>
      <link href="/Blog/2020-01-09-cf1284E/"/>
      <url>/Blog/2020-01-09-cf1284E/</url>
      
        <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/1284/problem/E" target="_blank" rel="noopener">原题链接</a></p><p>2500评分</p><h1 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h1><p>平面上<code>n</code>个点，不存在3个共线,</p><p>对于所有<code>(点p,另外四个点)</code>,如果另外四个点能包围点p则计数+1,对于同样的p和选中的4个点，不论有几种方式，只要能包围就计数+1</p><p>求p依次取遍所有点的计数和</p><h1 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h1><p><code>5&lt;=n&lt;=2500</code>,</p><p><code>3s</code></p><p><code>1024MB</code></p><h1 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a>官方题解</h1><p><a href="https://codeforces.com/blog/entry/72804" target="_blank" rel="noopener">https://codeforces.com/blog/entry/72804</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>计算几何我就开始自闭了</p><p>最终要求的为<code>sum{是否包围(p,另外四个点)}</code>,反向问题为</p><p><code>sum{是否不包围(p,另外四个点)}</code></p><p>考虑选取总方案为</p><p>$n*C_{n-1}^4$</p><p>如果选取的4个点，对于点p在同一个半圆内，那么选取的4个点无法包围，如果不在同一个半圆内则能包围</p><p>如果选取的4个点在同一个半圆内，则它们以p为顶点，构成的夹角小于180度，则这个夹角上存在顺时针的起始和结束点</p><p>假设选取点p和起始点q1，那么剩余三个点q2,q3,q4,与p和q1构成的夹角应该在0 到180度之间(且保证方向，也就是-0到-180度是不可取的)</p><p>这样对于每一个不包围的4个点，能做到不重不漏的计算</p><p><code>O(p枚举 * 计算几何排序和遍历)</code></p><p>然后 计算几何和浮点数和test9杀我,我浮点数+计算几何 就是过不了，然后换成纯整数处理过了，自闭</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><a href="https://codeforces.com/contest/1284/submission/68477822" target="_blank" rel="noopener">accept</a></p><p><a href="https://codeforces.com/contest/1284/submission/68473398" target="_blank" rel="noopener">68473398 Wrong answer on test 9</a></p><p><a href="https://codeforces.com/contest/1284/submission/68473313" target="_blank" rel="noopener">68473313 Wrong answer on test 9</a></p><p><a href="https://codeforces.com/contest/1284/submission/68473215" target="_blank" rel="noopener">68473215 Runtime error on test 9</a></p><p><a href="https://codeforces.com/contest/1284/submission/68473189" target="_blank" rel="noopener">68473189 Runtime error on test 9</a></p><p><a href="https://codeforces.com/contest/1284/submission/68473103" target="_blank" rel="noopener">68473103 Runtime error on test 9</a></p><p><a href="https://codeforces.com/contest/1284/submission/68473021" target="_blank" rel="noopener">68473021 Runtime error on test 9</a></p><p><a href="https://codeforces.com/contest/1284/submission/68471693" target="_blank" rel="noopener">68471693 Runtime error on test 9</a></p><p><a href="https://codeforces.com/contest/1284/submission/68471651" target="_blank" rel="noopener">68471651 Runtime error on test 9</a></p><p><a href="https://codeforces.com/contest/1284/submission/68471600" target="_blank" rel="noopener">68471600 Wrong answer on test 9</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define INF 0x3f3f3f3f3f3f3f3f#define MOD 1000000007#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)#define pb push_back#define foreach(i, v) for (__typeof((v).begin()) i = (v).begin(); i != (v).end(); ++ i)const long double pi = acos(-1.0);pair&lt;ll,ll&gt;xy[3010];pair&lt;ll,ll&gt;xysort[3010];int n;template&lt;class T1, class T2&gt;inline const pair&lt;T1, T2&gt; operator-(const pair&lt;T1, T2&gt;&amp;p1, const pair&lt;T1, T2&gt;&amp;p2) {  return {    p1.first - p2.first,      p1.second - p2.second  };}ll cross(pair&lt;ll,ll&gt; vec1,pair&lt;ll,ll&gt; vec2){  auto [x1,y1] = vec1;  auto [x2,y2] = vec2;  return x1*y2-x2*y1;}int main() {  ll n;  scanf(&quot;%lld&quot;,&amp;n);  rep(i,0,n){    ll x,y;    scanf(&quot;%lld %lld&quot;,&amp;x,&amp;y);    xy[i] = {x,y};  }  ll res = n * ((n-1) * (n-2) * (n-3) * (n-4) / (1*2*3*4));  rep(i,0,n){    rep(j,0,n){      if(i == j)continue;      xysort[j&gt;i?j-1:j] = xy[j];    }    sort(xysort+1,xysort+n-1,        [i](const pair&lt;ll,ll&gt;p0,const pair&lt;ll,ll&gt;p1) -&gt; bool{        ll cross0 = cross(p0-xy[i],xysort[0]-xy[i]);        ll cross1 = cross(p1-xy[i],xysort[0]-xy[i]);        if(cross0 &gt;=0 &amp;&amp; cross1 &lt; 0){          return true;        }else if(cross0 &lt; 0 &amp;&amp; cross1 &gt;= 0){          return false;        }        ll cross01=cross(p0-xy[i],p1-xy[i]);        return cross01 &lt;= 0;        });    int index = 1;    // 四个点的起始点,首尾游标    rep(j,0,n-1){      while(index &lt; j + n-1){        ll crossij = cross(xysort[index%(n-1)]-xy[i],xysort[j]-xy[i]);        if(crossij &gt;= 0 ){          index++;        }else{          break;        }      }      // C_cnt^3      ll cnt = index - j - 1;      res -= (cnt * (cnt - 1) * (cnt - 2)) / (1*2*3);    }  }  printf(&quot;%lld\n&quot;,res);  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>1是想到反向计算，我一直在想算三角形然后带其它点，再容斥，就没想出来</p><p>2是浮点数精度，哎自闭，还是整数香</p>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算几何 </tag>
            
            <tag> 枚举 </tag>
            
            <tag> 浮点数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces 1270F (分块算法)</title>
      <link href="/Blog/2020-01-04-cfGoodBye2019F/"/>
      <url>/Blog/2020-01-04-cfGoodBye2019F/</url>
      
        <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/1270/problem/F" target="_blank" rel="noopener">原题链接</a></p><p>2600评分</p><h1 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h1><p><code>0</code>/<code>1</code>构成的字符串, 如果<code>s[l,r]</code>长度为<code>len</code>,其中<code>1</code>的个数为<code>n(n&gt;0)</code>且<code>len%n == 0</code>,那么这个子字符串为awesome</p><p>求<code>awesome</code>子字符串的个数</p><h1 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h1><p>原字符串长度<code>[1,200&#39;000]</code></p><h1 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a>官方题解</h1><p><a href="https://codeforces.com/blog/entry/72611" target="_blank" rel="noopener">https://codeforces.com/blog/entry/72611</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>首先 想到的就是前缀和+暴力</p><p>预处理<code>O(n)</code>,计算每个<code>[l-&gt;r]</code>,只需要<code>O(1)</code></p><p>总的时间代价<code>O(n^2)</code></p><p>显然过不了,然后我赛内想来想去没想到方法了</p><hr><p><code>pref</code>表示前缀和</p><p>如果 $r - l + 1 = k \cdot (pref[r] - pref[l - 1])$,那么就是awesome的</p><p>变形 $r - k \cdot pref[r] = l - 1 - k \cdot pref[l - 1]$</p><p>所以对于<code>k=1-&gt;n</code>,计算上面成立有多少对</p><p>假设取一个给定的值<code>T</code></p><p>对于 <code>k&gt;T</code>, $r - k \cdot pref[r] = l - 1 - k \cdot pref[l - 1]$ , 也就是这类成立的子字符串包含1的个数比较少,我们遍历 前缀，然后找比它1个数大的值小于等于<code>n/T</code>的，对于所有<code>k&gt;T</code>，总时间代价为<code>O(n * n/T)</code></p><p>对于 <code>k&lt;=T</code> , $-nT \le i - k \cdot pref[i] \le n$ , 对于给定<code>k</code>，遍历<code>O(n)</code> ，总时间代价<code>O(nT)</code></p><p>所以理论上 <code>T=sqrt(n)</code>时，总的时间代价为<code>O(n^(3/2))</code></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>这里T取的死值300,没有取sqrt</p><p><code>6224 ms</code></p><p>我自闭了这个TLE11: <a href="https://codeforces.com/contest/1270/submission/68136316" target="_blank" rel="noopener">https://codeforces.com/contest/1270/submission/68136316</a></p><p>然后这个过了: <a href="https://codeforces.com/contest/1270/submission/68136440" target="_blank" rel="noopener">https://codeforces.com/contest/1270/submission/68136440</a></p><p>点compare就换了一下map的位置</p><p>另外 我把T设置为450(<code>sqrt(200&#39;000)=447.21359549995793</code>)也TLE11: <a href="https://codeforces.com/contest/1270/submission/68136641" target="_blank" rel="noopener">https://codeforces.com/contest/1270/submission/68136641</a></p><p>这个慢的是后一部分，原因基本就是(map/unordered_map)的代价,优化方案 例如有 数组+pair,最后 sort一下统计(没写)</p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define INF 0x3f3f3f3f3f3f3f3f#define MOD 1000000007#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)#define pb push_back#define foreach(i, v) for (__typeof((v).begin()) i = (v).begin(); i != (v).end(); ++ i)const double pi = acos(-1.0);// len % (num of 1) == 0// fft?// 10010010// n/1 has only 1// n-1 has only 2 of 1// kmp?char s[200010]; // 0-&gt;n-1int onecnt = 0;int onepos[200010]; // 0-&gt;n-1unordered_map&lt;int,int&gt; v2cnt;int n;int main(){  scanf(&quot;%s&quot;,s);  n = strlen(s);  rep(i,0,n){    if(s[i]==&#39;1&#39;){      onepos[onecnt++]=i;    }  }  int T = 300;  if(onecnt == 0){    printf(&quot;0\n&quot;);    return 0;  }  ll ans = 0;  int stj = 0;  // ans ==15612){ // n =1000  //  // k&gt;T -&gt; precnt &lt;= n/T  rep(i,0,n){    int cnt = 0;    rep(j,stj,onecnt){      cnt++;      if(!(cnt&lt;=n/T))break; // 注意 这个是上界，不是精确范围，      // 0-index      // i 010 pos 01100 posnext      // [i -&gt; [pos -&gt; posnext-1] ]      int pos = onepos[j];      int posnext = 0;      if(j == onecnt -1){        posnext = n;      }else{        posnext = onepos[j+1];      }      // [lenst+1-&gt;lenend] = lenend/cnt-lenst/cnt      int lenst = pos-i;      int lenend = posnext-i;      // printf(&quot;%d,[%d,%d]=%d , len:[%d-&gt;%d] \n&quot;,i,pos,posnext,cnt,lenst,lenend);      if( (lenend/cnt) &gt;= T){ // 精确的范围        ans+=(lenend/cnt)- max((lenst/cnt),T);      }      // printf(&quot;ans=%lld\n&quot;,ans);    }    if(stj &lt; onecnt &amp;&amp; onepos[stj] &lt;= i){      stj++;    }  }  //  cout&lt;&lt;&quot;            ans=&quot;&lt;&lt;ans&lt;&lt;endl;  // k&lt;=T, k=1-&gt;T,i=0-&gt;n  rep(k,1,min(T,n)+1){    v2cnt.clear();    // i - k * pre[i];    v2cnt[0]++;    ll cnt = 0;    rep(i,0,n){      cnt+=(s[i] == &#39;1&#39;);      v2cnt[i+1-k*cnt]++;    }    for(auto item:v2cnt){      ll c = item.second;      ans+=c*(c-1)/2;      // if(c&gt;1){      //   printf(&quot;k=%d: [%lld,%lld]\n&quot;,k,v,c);      // }    }  }  // ans  printf(&quot;%lld\n&quot;,ans);  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这种分块 首先要看出是分块</p><p>然后分块除了实现和算法本身，一个需要注意的就是划分边界的处理，做到不重不漏,不要把理论最大最小上下界当成精确边界，另外因为实现是分块，所以理论上改变划分界限，代码应该有相同输出，可以作为测试方法。</p>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
            <tag> 暴力 </tag>
            
            <tag> 分块 </tag>
            
            <tag> strings </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces 1245F (bitdp,容斥原理)</title>
      <link href="/Blog/2019-11-03-cf1245F/"/>
      <url>/Blog/2019-11-03-cf1245F/</url>
      
        <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/1245/problem/F" target="_blank" rel="noopener">原题链接</a></p><p>2300评分</p><h1 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h1><p>t组测试数据</p><p>求 <code>l&lt;=x,y&lt;=r</code>中 满足 <code>x+y==x^y</code>的有序对(x,y)的个数</p><h1 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h1><p><code>0&lt;=l&lt;=r&lt;=10^9</code></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>如果一道题看上去像bitdp，长得像容斥原理，那么它就是 bitdp+容斥原理</p><p>假设 F(n,m)表示 a属于[0,n], b属于[0,m]</p><p>那么ans = F(r,r) - 2F(l-1,r) + F(l-1,l-1)</p><p>所以如果能计算F(n,m)即可</p><p><code>G[前i位][x 是否贴着上限][y 是否贴着上限]</code>的方案数</p><p>贡献</p><p><code>G[i][false][false]</code>:</p><p><code>x3 -&gt;  G[i+1][false][false]</code></p><p>(因为都没有贴着上限，所以x,y值无论填0/1都 依然没有贴着上限,由因为两个只能最多有一个1,所以只有(0,0),(1,0),(0,1)三种))</p><p>对于</p><p><code>G[i][false][true] / G[i][true][false] / G[i][true][true]</code></p><p>其中至少有 一个是贴着上限的，那么，贡献时注意是否上限，填写的时候不要超过上限</p><p>也注意<code>x&amp;y == 0</code> 也就是<code>x+y&lt;=1</code></p><pre><code>rep(x,0,2){  rep(y,0,2-x){    G[i][ln &amp; ( x == ((n&gt;&gt;(30-i))&amp;1) )][lm &amp; ( y == ((m&gt;&gt;(30-i))&amp;1) )] += G[i-1][ln][lm];`  }}</code></pre><p>当然可以用滚动数组进行优化</p><p><a href="https://www.cnblogs.com/LLTYYC/p/11785913.html" target="_blank" rel="noopener">代码</a></p><h1 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a>官方题解</h1><p><a href="https://codeforces.com/blog/entry/71080" target="_blank" rel="noopener">https://codeforces.com/blog/entry/71080</a></p><p>直接设<code>f(l,r)</code>是<code>l&lt;=x,y&lt;r</code>的答案，也就是真的答案是<code>f(l,r+1)</code></p><p>有<code>f(0,r)=2r-1+f(1,r)</code>, 因为 <code>(0,0),(0,1~r-1),(1~r-1,0)</code>都合法 一共(2r-1)</p><p>如果l,r都大于0那么 <code>f(2l,2r) = 3 f(l,r)</code></p><p>其实和上面的数位dp 推理很像， 这里是考虑最后一位， 只有3种可选的，且都合法，因为有2倍保证</p><p>然后再 把 l,r 不是2的倍数的 和2的倍数之间找出关联，最终可归约到 <code>f(0,?)</code> 即可</p><h1 id="问题难点分析"><a href="#问题难点分析" class="headerlink" title="问题难点分析"></a>问题难点分析</h1><p>第一个是 我有往数位dp想，但是没想到具体</p><p>一个是没有拆解成F(x,y)变成类似前缀和 或者说计算子矩阵和的样式</p><p>另外就是数位dp做的题太少，还是不够熟悉</p><p>问题还有就是 两种方法，只要在草稿纸上多画一画会变得简单很多。</p><p>虽然以前对两个的维度来做前缀，或者向下归约的题型做过，但实际操作 还是体现出了不熟练</p><p>容斥是没怎么用还是矩阵和数位dp</p>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容斥原理 </tag>
            
            <tag> dp </tag>
            
            <tag> bitdp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces 1245E (模拟,DP，概率论)</title>
      <link href="/Blog/2019-11-03-cf1245E/"/>
      <url>/Blog/2019-11-03-cf1245E/</url>
      
        <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/1245/problem/E" target="_blank" rel="noopener">原题链接</a></p><p>2300评分</p><h1 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h1><p>很难直接说 ，看原题目图片</p><p>大概就是10x10网格，从左下 横走到头，向上一层，再横走到头，再向上一层，这样走到左上角</p><p>每次步长 整数[1-&gt;6]等概率</p><p>其中有一些纵向梯子，梯子出度为0/1</p><p>只能停在 梯子下方时(立刻?)使用梯子，重叠的梯子不能切换,不能从上到下使用梯子, 不能在没有横着走的情况下连续使用梯子</p><p>如果 走的步数会导致超过终点那么他不会走</p><p>他会尽快走</p><p>求期望步数</p><h1 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h1><p>梯子数量&lt;=100</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>显然虽然我赛内 没有做出来，也知道基本知识点是 dp和概率论，然而我的概率论弱到爆炸</p><p>然后也是显然把二维降到一维</p><p><a href="https://codeforces.com/blog/entry/71080" target="_blank" rel="noopener">官方题解</a></p><p>先定义f函数 如果</p><p>i点没有梯子， f(i) = i;</p><p>i有梯子， f(i) = 梯子的目标;</p><p>i点到终点，的最小期望步数为$dp_i$</p><p>显然<code>dp_100 = 0</code></p><p>$$dp_i = 1 + \sum_{r = 1}^{6} \frac{1}{6} \cdot \min(dp_{g(i, r)}, dp_{f(g(i, r))})$$ // 这里min是必要的 因为可能因为一些小梯子错过一些大梯子，不一定爬梯子更优</p><p>从i走 r=1-&gt;6步,到 i-&gt;i+r 或者</p><p>其中 当 $i+r&lt;=100$时 $g(i, r) = i + r$ 否则 $g(i,r)=i$</p><p>作为一个 概率论弱菜，想说这里的期望步数竟然可以直接取min的咯????</p><p>以及为什么明明是 1/6 的前进概率，却可以反过来 还是按照1/6来算???</p><p>对于上面会超过终点，也就是$95 \leq i \leq 99$时</p><p>$dp_i = \frac{6}{100 - i} \cdot \left( 1 + \sum_{r = 1}^{100 - i} \frac{1}{6} \cdot \min(dp_{i + r}, dp_{f(i + r)}) \right)$</p><p>其实也是上面的式子，把其中 走 改为停在原地 $dp_i$再移项得到的</p><p><strong>这里我卡了很久很久很久</strong></p><p>大概最后能理解 的是</p><p>dp表示的是剩余期望步数,是一个最终结果值</p><p>如果考虑过程的话，每一次 i 会向 i+1~6 发送 (期望步数-1)*1/6</p><p>而计算 当计算到i时，小于i的所有都已经和最终结果相同了，所以对于dp[i]来说</p><p>dp[i][最终结果] = sum{dp[i-1~6][最终结果]-1}/6也是满足的</p><p>也就是 每次从i走1/6的概率 和反过来 看最终期望值，可以用一样的概率</p><p>然后对于尾部的思考 感觉还是没有直接思考出，但是用无穷级数得到一样的答案了XD</p><p>感觉自己概率论还是没有入门啊</p><hr><p>当然题解的另外一个方法就是 直接模拟个1000次</p><p>每次至少前进一步，那么100步以后，就只剩下 最后几个，然后就没了，每轮的量也就<code>100*6</code> 随便搞啊 精度应该不会爆吧</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define INF 0x3f3f3f3f3f3f3f3f#define MOD 1000000007#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)#define pb push_backconst double pi = acos(-1.0);// 10x10// 左下-&gt;左上// 蛇形路线//// 有纵向梯子// 不能用连续的后一个梯子int main() {  int grid[10][10]; // 输入  int arr[110]; // 可以用梯子到达的目标  int flat[10][10]; // 映射为一维数组  rep(i,0,10){    rep(j,0,10){      scanf(&quot;%d&quot;,grid[i]+j);      flat[i][j] = (9 - i) * 10 + ((i &amp; 1) ? j : 9 - j);      arr[flat[i][j]] = flat[i-grid[i][j]][j];    }  }  double dp[100];  dp[99] = 0;  per(i,0,99){    double dpi = 0;    int c = 6;    rep(r,1,7){      if (i + r &gt;= 100) continue;      dpi += min(dp[i + r], dp[arr[i + r]]) / 6;      c--;    }    dp[i] = 6 * (1+dpi) / (6 - c);  }  printf(&quot;%.10lf\n&quot;,dp[0]);  return 0;}</code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.cnblogs.com/LLTYYC/p/11782276.html" target="_blank" rel="noopener">https://www.cnblogs.com/LLTYYC/p/11782276.html</a></p><h1 id="问题难点分析"><a href="#问题难点分析" class="headerlink" title="问题难点分析"></a>问题难点分析</h1><p>为什么可以反过来使用概率,反过来用不等于反着走，而且期望的事情，可以把dp[i]改成dp[i][过程中/最终值]来加深理解</p><p>然后就是自己能到自己的理解了，依照各个题解过程意思是等价代换 推新公式即可？</p><p>然后就是题目这里的梯子，其实是一个可选择的不消耗次数的传送门，当你停在门前时才可选择，不能路过时使用。</p>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp，概率论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>未完成Codeforces 1238E (bitdp)</title>
      <link href="/Blog/2019-10-17-cf1237E/"/>
      <url>/Blog/2019-10-17-cf1237E/</url>
      
        <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/1237/problem/E" target="_blank" rel="noopener">原题链接</a></p><p>tourist出的题！</p><h1 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h1><p>二叉查找树 节点有n个且</p><p>倒数第二层满节点</p><p>每个节点和左儿子 奇偶相反</p><p>每个节点和右儿子 奇偶相同</p><p>的方案数</p><p>结果mod 998244353</p><h1 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h1><p><code>1&lt;=n&lt;=1&#39;000&#39;000</code></p><p>3s</p><p>512MB</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><a href="https://codeforces.com/blog/entry/706200" target="_blank" rel="noopener"></a></p><p>塞内没看到<code>sum of depths</code>做了个假题</p><p>第一个思路直接 树上dp, <code>dp[cnt][height][oddoreven]</code> 表示总节点cnt,高度height的,root奇偶性为oddoreven的 方案数</p><p>然后dp表达式</p><pre><code class="cpp">dp[cnt][height][root is odd?] = sum{  dp[left cnt][height -1/-2][root is odd ^ 1] *  dp[cnt-1-left cnt][height -1/-2][even] *}其中注意保证性质</code></pre><p>调完bug的代码TLE 11 见下面</p><p>因为一些编写过程的推理问题，遗留的height,其实当cnt确定，根据题目的要求，height也就唯一了，算是多设计的</p><p>因为每次计算时 计算的子来源大概有 cnt/2左右个</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><a href="https://codeforces.com/contest/1237/submission/62761746" target="_blank" rel="noopener">TLE 11</a></p><p>代码</p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define INF 0x3f3f3f3f3f3f3f3f#define MOD 998244353#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)#define pb push_backconst double pi = acos(-1.0);// 1 -&gt; 3 -&gt; 7(C(4,4)) -&gt; 15 -&gt; 31 -&gt; ...// 4(C 4,1) 5(C 4,2)//    ji// ou     ji//ji     ou      ou  ji//ou ji ji ou  ji ou ou ji// dp[cnt][height][ji/ou]// sum of depths !// sum of depths !// sum of depths !// sum of depths !// sum of depths !// sum of depths !// sum of depths !// sum of depths !// sum of depths !// sum of depths !// sum of depths !ll dp[1000010][22][2];int v2h(int v){  int ret = 0;  while(v){    ret++;    v&gt;&gt;=1;  }  return ret;}int h2v(int v){  return (1&lt;&lt;v)-1;}ll dfs(int cnt,int height,int jiou,int dep=0){  // rep(i,0,dep){  //   printf(&quot;\t&quot;);  // }  // printf(&quot;call dfs(%d,%d,%d)\n&quot;,cnt,height,jiou);  ll &amp;ret = dp[cnt][height][jiou];  if(ret != -1)return ret;  if(height == 1){    return ret = (cnt == 1 &amp;&amp; jiou == 1);  }  if(height == 0){    return ret = (cnt == 0);  }  if(cnt &gt; h2v(height) || cnt &lt;= h2v(height-1))return ret = 0;  ret = 0;  int r = h2v(height-1);  int l = cnt-1-r;  rep(i,l,r+1){    if(i%2 == jiou)continue;    int hl = v2h(i);    int hr = v2h(cnt-1-i);    if(hl != height-1){      if(hl != height-2 || hl &gt; 1)continue;    }    if(hr != height-1){      if(hr != height-2 || hr &gt; 1)continue;    }    if(!(hr == height -1 || hl == height -1))continue;    ll lcnt = dfs(i,hl,jiou^1,dep+1);    ll rcnt = dfs(cnt-i-1,hr,0,dep+1);    // rep(i,0,dep){    //   printf(&quot;\t&quot;);    // }    // printf(&quot;dfs(%d,%d,%d) %d-1-%d : {l * r}={%lld * %lld}\n&quot;,cnt,height,jiou,i,cnt-1-i,lcnt,rcnt);    (ret+=lcnt*rcnt)%=MOD;  }  // rep(i,0,dep){  //   printf(&quot;\t&quot;);  // }  // printf(&quot;ret dfs(%d,%d,%d)=%lld\n&quot;,cnt,height,jiou,ret);  return ret;}int main(){  int n;  cin&gt;&gt;n;  int h = v2h(n);  rep(i,0,1000001){    rep(j,0,22){      rep(k,0,2){        dp[i][j][k] = -1;      }    }  }  cout&lt;&lt;(dfs(n,h,0)+dfs(n,h,1))%MOD&lt;&lt;endl;  return 0;}</code></pre><p>果然tle了</p><p>AC代码 … TODO</p>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> tree </tag>
            
            <tag> treedp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atcoder agc039 D (我对平面几何一无所知)</title>
      <link href="/Blog/2019-10-10-ac_agc039D/"/>
      <url>/Blog/2019-10-10-ac_agc039D/</url>
      
        <content type="html"><![CDATA[<p><a href="https://atcoder.jp/contests/agc039/tasks/agc039_d" target="_blank" rel="noopener">原题链接</a></p><h1 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h1><p>到<code>(0,0)</code> 长度为<code>1</code>上的一系列点</p><p>随机选这些点形成的三角形的内切圆的圆心期望坐标</p><h1 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h1><p>圆上点的个数<code>&lt;=3000</code></p><p>4s</p><p>1024MB</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><a href="https://codeforces.com/blog/entry/70291" target="_blank" rel="noopener">https://codeforces.com/blog/entry/70291</a> 不少人吐槽 觉得这是 数学奥林匹克的题</p><p>假设选的三角形为$\Delta ABC$,做三个角的角平分线分别交$\Delta ABC$ 外接圆于点$A_1,B_1,C_1$</p><p>因为是角平分线所以显然，角平分线的交点就是要求的内心</p><p>$A_1,B_1,C_1$分别为$\widehat{BC},\widehat{CA},\widehat{AB}$的中点 (圆周角知识)</p><p>假设圆周上点的顺序为$A,C_1,B,A_1,C,B_1$</p><p>下面证明$\Delta ABC$的角平分线是，$\Delta A_1B_1C_1$的垂线</p><p>对称性只需要证明 $AA_1 \perp B_1C_1$</p><p>$\angle AC_1B_1+\angle A_1AC_1$</p><p>$= \angle ABB_1+\angle A_1AB+\angle BCC_1$</p><p>$= (\angle ABC+\angle CAB+\angle BCA)/2$</p><p>$= 90^\circ$</p><p>综上$\Delta ABC$的内心为 $\Delta A_1B_1C_1$的垂心</p><p>$A_1B_1C_1$的外接圆也是单位圆所以$A_1B_1C_1$的外心为$(0,0)$</p><p>假设$\Delta ABC$的 外心 垂心 重心分别为$O,H,G$</p><p>下面证明欧拉线 即 $3\cdot\vec{OG} = \vec{OH}$</p><p>即$O,H,G$三点共线且 分割线段长度为 $1:2$</p><p>注意到 $\vec {GA} = \frac{\vec {BA}+\vec {CA}}{3}$</p><p>所以有 ${\displaystyle {\vec {GA}}+{\vec {GB}}+{\vec {GC}}=0.}$</p><p>$3\cdot \vec{OG}$</p><p>$= (\vec{OA}+\vec{AG}) + (\vec{OB} + \vec{BG}) + (\vec{OC} + \vec{CG})$</p><p>$= \vec{OA}+\vec{OB} + \vec{OC} + (\vec{AG}+\vec{BG}+\vec{CG})$</p><p>$= \vec{OA}+\vec{OB}+\vec{OC}$</p><p>注意到</p><p>$(\vec{OA}+\vec{OB}+\vec{OC}-\vec{OH})\cdot \vec{BC}$</p><p>$=(\vec{OA}-\vec{OH})\cdot \vec{BC} +(\vec{OB}+\vec{OC})\cdot \vec{BC}$</p><p>$=\vec{HA}\cdot \vec{BC} +(\vec{OB}+\vec{OC})\cdot \vec{BC}$</p><p>$=0$</p><p>因为HA垂线所以前一半0</p><p>因为$O$为外心，所以$\Delta OBC$是以$BC$为底的等腰三角形 所以 后一半乘积为0</p><p>然后又因为$\vec{BC}\neq 0$ 所以有 $\vec{OA}+\vec{OB}+\vec{OC} = \vec{OH}$</p><p>综上$3\cdot\vec{OG} = \vec{OH}$ 欧拉线得证</p><p>重心坐标就没啥好说了 三角形顶点的均值</p><p>所以 内心期望 = 弧的中点 的 均值</p><p>注意这样算的是 内心 根据上面的外心 垂心关系，把内心坐标乘3就行了</p><p>要注意的是 弧的中点 不是靠优弧和劣弧来决定的 而是 弧外的第三个点不在的那条弧上</p><p>时间复杂度 <code>O(点^2)</code></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>卧槽 这还会有精度问题</p><p><a href="https://atcoder.jp/contests/agc039/submissions/7926861" target="_blank" rel="noopener">精度问题代码</a></p><p><a href="https://atcoder.jp/contests/agc039/submissions/7926890" target="_blank" rel="noopener">AC代码</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define INF 0x3f3f3f3f3f3f3f3f#define MOD 1000000007#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)#define pb push_backconst double pi = acos(-1.0);int n;int l;pair&lt;double,double&gt; twoT2P(int twoT){  double v = pi*twoT/l;  return make_pair(cos(v),sin(v));}int t[3010];int main(){  cin&gt;&gt;n&gt;&gt;l;  rep(i,0,n){    scanf(&quot;%d&quot;,t+i);  }  double cntX=0;  double cntY=0;  rep(i,0,n){    rep(j,i+1,n){      pair&lt;double,double&gt; ret = twoT2P(t[i]+t[j]);      cntX+=(n-2*(j-i))*ret.first;      cntY+=(n-2*(j-i))*ret.second;    }  }  printf(&quot;%.15lf %.15lf\n&quot;,6*cntX/n/(n-1)/(n-2),6*cntY/n/(n-1)/(n-2));  return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Atcoder </category>
          
          <category> AGC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
            <tag> geometry </tag>
            
            <tag> 平面几何 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces 1238E (bitdp)</title>
      <link href="/Blog/2019-10-09-cf1238E/"/>
      <url>/Blog/2019-10-09-cf1238E/</url>
      
        <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/1238/problem/E" target="_blank" rel="noopener">原题链接</a></p><h1 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h1><p>前m个字母的所有排列中</p><p>对于字符串s</p><p>求<code>min{sum{f(s[i-1],s[i])}}</code> ，i = [1,len(s)-1]</p><p>f(char1,char2) = 在所选排列中 这两个char的下标差的绝对值</p><h1 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h1><p><code>1&lt;=m&lt;=20</code></p><p><code>1&lt;=len(s)&lt;=100000</code></p><p>1s</p><p>256MB</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>显然把 字符串处理为统计信息一个<code>m*m</code>的表M</p><p>其中<code>M[char1][char2]</code>表示 字符<code>char1</code>和<code>char2</code>相邻的次数</p><p>然后看到 20/12都应该想一想 bitdp</p><p>dp[state] 表示前 bitcount(state)个数选择了state时的最优代价;</p><p>那么我们在 这个状态后面 添加一个未选取的数v</p><p>那么 <code>[选取的数的状态][数字v]</code></p><p>问题来了</p><p>前面的最优状态如果没有具体位置,那么 v到已经选择的数字的 距离不同，所以权重也就不同,而即使 在最优代价中加上具体状态的记录，也不满足 子最优必定父最优</p><p>怎么把 选取的数字的顺序无关化?</p><p>考虑已经完全选好的一个排列</p><p>xyzabc</p><p>那么这个贡献 也就是 <code>dis(x,y)*M[x][y]+dis(x,z)*M[x][z]+....+dis(b,c)*M[b][c]</code></p><p>如果我们画图把 这些点用线连起来</p><p>从中间切一刀，例如从xyz|abc这里切分, 会发现 a连出的线条数和 左边排列顺序无关，只和左边个数以及a相对于分割线的位置有关，</p><p>考虑 <code>xyz|abc -&gt; xyza|bc</code> ,<code>xya|zbc -&gt; xyaz|bc</code></p><p>所以上面dp[state]的描述 改为 bitcount(state)个数选择了state时，且向右连线到分界线时的最优代价</p><p>注意新的分界线 增加的值和老的分界线 没有关系 所以只需要 <code>O(m^2 * 2^m)</code>而不是 <code>m^3</code></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><a href="https://codeforces.com/contest/1238/submission/62201739" target="_blank" rel="noopener">source</a></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define INF 0x3f3f3f3f3f3f3f3f#define MOD 1000000007#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)#define pb push_backconst double pi = acos(-1.0);int n,m;char s[100010];int cnt[30][30];ll dp[(1&lt;&lt;20)+10];int main(){  cin&gt;&gt;n&gt;&gt;m;  scanf(&quot;%s&quot;,s);  rep(i,1,n){    cnt[s[i-1]-&#39;a&#39;][s[i]-&#39;a&#39;]++;    cnt[s[i]-&#39;a&#39;][s[i-1]-&#39;a&#39;]++;  }  rep(state,1,1&lt;&lt;m){    int ii = state;    dp[state] = 0x3f3f3f3f;    while(ii){      int bit = ii &amp; (-ii);      ll costbit = dp[state^bit];      dp[state]=min(dp[state],costbit);      ii^=bit;    }    // 增加切割的分界线即可    rep(i,0,m){      if(!(state &amp; (1&lt;&lt;i)))continue;      rep(j,0,m){        if(state &amp; (1&lt;&lt;j))continue;        dp[state]+=cnt[i][j];      }    }  }  cout&lt;&lt;dp[(1&lt;&lt;m)-1]&lt;&lt;endl;  return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bitdp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atcoder agc039 C (math + inclusion-exclusion)</title>
      <link href="/Blog/2019-10-08-ac_agc039C/"/>
      <url>/Blog/2019-10-08-ac_agc039C/</url>
      
        <content type="html"><![CDATA[<p><a href="https://atcoder.jp/contests/agc039/tasks/agc039_c" target="_blank" rel="noopener">原题链接</a></p><h1 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h1><p>求sum{f(x)},x取值为 [0,X]的所有</p><p>其中f(x) = x以N位二进制表示(x&lt;2^N,不足的补前导零),把最右的二进制位 取反 放到最左，这样操作?次后变回原样</p><p>结果mod 998244353</p><h1 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h1><p><code>1&lt;=N&lt;=200000</code></p><p><code>0&lt;X&lt;2^N</code></p><p>2s</p><p>1024MB</p><h1 id="例"><a href="#例" class="headerlink" title="例"></a>例</h1><p>N=5 x=3时</p><p><code>00110 -&gt; 10011 -&gt; 01001 -&gt; 00100 -&gt; 10010 -&gt; 11001 -&gt; 01100 -&gt; 10110 -&gt; 11011 -&gt; 01101 -&gt; 00110</code></p><p>f(3) = 10</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>显然2N次一定能回到原来的数</p><p>又假设 循环节最小为k，那么一定所有循环节为k的倍数，所以2N一定是k的倍数</p><p>又N次移动一定是何原来所有位取反 一定不相等</p><p>所以2N/k 一定是奇数</p><pre><code>[xxxxxxxxxxxxxxxxxx][移动k][xxxxxxxxxxxxxxxxxx][ 长度 N                ][        原字符串取反N ][ 长度 2N                                       ][长度k][长度k][长度k][长度k][长度k][长度k][长度k]       [长度k][长度k][长度k][长度k][长度k][长度k][长度k]                        |这里k是偶数 刚好对半分[长度k               ][长k后一半][长k前一半] 取反所以 [长度k] = [长度k前一半] + [长度k前一半]取反所以可行串又可以看做[串A][~串A][串A][~串A][串A][~串A]...[串A][~串A][串A]</code></pre><p>然后容斥 枚举k</p><p>时间复杂度 = <code>O(N * N因数个数+ N log(N) )</code> </p><p>我们把上面 串A 的长度 定义为循环节长度</p><p>容斥的部分</p><p>先假设所有的循环都是2n,那么 答案为<code>(X+1)*(2n)%MOD</code></p><p>假设长度len循环节有f(len)个可行方案，那么对答案的变化为 <code>+f(len)*(len-2n)%MOD</code></p><p>容斥原理 len的 权重为 = (len-2n) - ans(len的2次以上倍数)</p><p><code>h(len) = len-2n - sum{h(k * len)}</code>, <code>其中k&gt;=2且 长度k*len 可行</code></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define INF 0x3f3f3f3f3f3f3f3f#define MOD 998244353#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)#define pb push_backconst double pi = acos(-1.0);char s[200010];int n;int ans;int val[200010]; // val[i]表示以 i为循环节长度的方案数vector&lt;int&gt;divs; // 所有 2n/2divs[idx] 为奇数// 以 s[0..len-1]为 循环节 [正][取反][正]这样产生的长n的字符串的 方案数ll cnt(int len) {  int ans = 0;  rep(i,0,len){    ((ans*=2)+=s[i]-&#39;0&#39;)%=MOD;  }  // [0.........................n]  // [0...len][反0...len][0...len]  // s&gt;=t ans+1  // t&gt;s ans+1  // 因为统计了全零所以+1, 如果t比s大那么[0..len]作为循环节不行,把 [0..len] 值减1可行 所以 全零+1,再-1就是ans  rep(i,0,n){    char ti = ((s[i%len]-&#39;0&#39;)^((i/len)%2))+&#39;0&#39;;    if (s[i] &gt; ti) return ans + 1;    if (ti &gt; s[i]) return ans;  }  return ans + 1;}int main() {  cin&gt;&gt;n;  scanf(&quot;%s&quot;, s);  rep(i,1,n+1){    if (n % i == 0 &amp;&amp; (n / i) % 2 == 1){      divs.pb(i);    }  }  ll ans = cnt(n) * (2 * n) % MOD; // 全部都是2n 次  per(idx,0,divs.size()){    int i = divs[idx];    val[i] = (2*i-2*n) % MOD;    rep(j,idx+1,divs.size()){      if(divs[j] % divs[idx] == 0){        (val[i]-=val[divs[j]])%=MOD;      }    }    (ans += cnt(i) * val[i] )%=MOD;  }  cout&lt;&lt;(ans+MOD)%MOD&lt;&lt;endl;  return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Atcoder </category>
          
          <category> AGC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容斥原理 </tag>
            
            <tag> Math </tag>
            
            <tag> inclusion-exclusion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF 1229 C (graph)</title>
      <link href="/Blog/2019-09-24-cf1229C/"/>
      <url>/Blog/2019-09-24-cf1229C/</url>
      
        <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/1229/problem/C" target="_blank" rel="noopener">原题链接</a></p><h1 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h1><p><code>n</code>个人 有值<code>1~n</code></p><p>有m条无向边</p><p>求 图中 满足 <code>值i</code>&gt;<code>值j</code>&gt;<code>值k</code> 有多少对</p><p><code>q</code>次操作 每次指定一个人 使它的值<code>+n</code>,并求在新的图中有多少对</p><h1 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h1><p><code>1&lt;=n&lt;=100000, 0&lt;=m&lt;=100000,0&lt;=q&lt;=100000</code></p><p>4s</p><p>256MB</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>首先 题目的数值保证了不会有相等的值出现</p><p>显然如果根据值的大小，把无向边改成有向边 <code>多少对 =  sum{每个点 出度 * 入度}</code></p><p>那么如何处理更新</p><p>如果裸更新 可能遇到聚点 时间复杂度可能有<code>O(m * q)</code></p><p>然后 <a href="https://codeforces.com/blog/entry/70008" target="_blank" rel="noopener">官方题解</a></p><p>如果我们把点 按照 总度从大到小，从左到右排列</p><p>那么每个点和它左边点相连的个数 小于等于(根号2m)</p><p>反证， 如果存在 一个和左侧连接个数大于 (根号2m)</p><p>那么 有 左侧点个数 大于 根号2m,也有 左侧点的度 &gt; 该点的度 &gt;= 该点于左侧点的连接数 &gt; 根号2m</p><p>边 &gt;= 有左侧点度的总数 <code>(根号2m) * (根号2m) = 2m</code>矛盾</p><p>???? 怎么就 q 根号2m了 TODO 官方题解这里没有看懂</p><h1 id="cf群里的证明"><a href="#cf群里的证明" class="headerlink" title="cf群里的证明"></a>cf群里的证明</h1><p>感谢<code>RUSH_D_CAT</code> 和 <code>QAQAutoMaton</code>大佬</p><p>以下忽略等号的描述 sqrt(m)都视作非整数[因为在意的是复杂度,是否精确讨论等号 对复杂度没有影响</p><p>提供的把点分为大点和小点</p><p>大点 度&gt; sqrt(m)</p><p>小点 度&lt; sqrt(m)</p><p>同上的反证法可以得到 大点的个数 &lt; sqrt(m)</p><p>每次更新一个小点 时间复杂度 sqrt(m)</p><p>对于一个大点 总的时间复杂度 O(m+q)</p><p>因为只有第一次更新大点会达到 O(m)的复杂度</p><p>对于非第一次更新大点 最多更改的点 = 上一次更改到当前更改的点 = O(q)</p><p>所以总的时间复杂度</p><p><code>O(n*sqrt(m) + sqrt(m) * (m+q))</code></p><p>常数优秀的话能过 <code>10**^7.5 = 31622776.60168379</code></p><p>注意的是 <code>m+q</code> 这个上界 也是难达到的? (怎么证一个更小的范围)</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>这题难点不在代码 在证明</p><p>因为我看完题也就脑糊了这个算法估计能过，但不知道怎么证明</p>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
            <tag> 常数优化 </tag>
            
            <tag> 状态压缩 </tag>
            
            <tag> 状压DP </tag>
            
            <tag> 贪心 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF 1209 E (状压DP + 常数优化)</title>
      <link href="/Blog/2019-09-16-cf1209E/"/>
      <url>/Blog/2019-09-16-cf1209E/</url>
      
        <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/1209/problem/E2" target="_blank" rel="noopener">原题链接</a></p><p>2400 评分</p><h1 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h1><p><code>n*m</code>的数字矩阵</p><p>你可以对任意个列，进行列的循环移动任意次 (cyclical shifts)</p><p>问 能得到的((每行最大值之和)的最大值)是多少</p><h1 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h1><p><code>1&lt;=n&lt;=12, 1&lt;=m&lt;=2000</code></p><p><code>0&lt;=矩阵中的数字&lt;=100&#39;000</code></p><p>3s</p><p>256MB</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>其实还有题目E1,也就是n最大只有4</p><p>显然 我们按照每列最大元素 进行排序，只需要取最大的min(n,m)列，再旋转即可</p><p>那么问题来了,问题简化为 最大 <code>12*12</code>的矩阵</p><p>如果有一个<code>12*12</code>要怎么做呢</p><p>无脑枚举可以做E1,因为只有 <code>4^4</code>,而E2有 <code>12^12</code></p><p>方法是 dp, 状态<code>dp[i][state]</code></p><p>其中 state是 选取的行的状态二进制编码 O(2^n), </p><p>整个dp表示 前i列,行的选取状态为state时的最大值</p><p>那么答案为 <code>dp[m-1][(1&lt;&lt;n)-1]</code></p><p>状态转移</p><p><code>dp[i][stateX] = max(dp[i-1][stateY]+ sum{矩阵第i列,stateX-stateY选中的行的元素的值 } )</code></p><p>意义就是 前i列 选取行的状态是stateX的话</p><p>那么 它的最大期望 是 选取的一部分(stateX-stateY)来自第i列，其余(stateY)来自前i-1列</p><p>那么状态转移，对当前列 循环n次移动，每次计算 所有状态, 的所有状态来源</p><p>一次状态转移时间复杂度为 <code>O(n(shift移动当前列) * (1&lt;&lt;n)(所有状态) * n(每个状态的来源) )</code></p><p>总的一次状态转移为 <code>O( min(n,m) * n * (1&lt;&lt;n) * n )</code></p><p><code>12^3*2^12 = 7077888</code> 有注意常数的必要</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><a href="https://codeforces.com/contest/1209/submission/60667483" target="_blank" rel="noopener">Accepted Code</a></p><pre><code class="c++">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 1000000007#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)#define pb push_backconst double pi = acos(-1.0);const int MAXN = 12;const int MAXM = 2000;int a[MAXN + 10][MAXM + 10], n, m;int f[2][1&lt;&lt;MAXN]; // 滚动数组 到某列时 当前答案int g[1&lt;&lt;MAXN]; // 每轮列旋转1单位时的答案map&lt;int,int&gt;v2mi;int lowbit(int x) {  return x &amp; -x;}pair&lt;int,int&gt;arr[MAXM + 10];int tmp[MAXN+10][MAXM+10];void solve() {  scanf(&quot;%d%d&quot;, &amp;n, &amp;m);  int tot = (1&lt;&lt;n);  rep(i,0,tot){    f[1][i] = 0;  }  rep(i,0,m){    arr[i] = {0,i};  }  rep(i,0,n){    rep(j,0,m){      scanf(&quot;%d&quot;, &amp;a[i][j]);      arr[j].first = max(arr[j].first, a[i][j]);    }  }  sort(arr, arr + m);  rep(j,m-min(m,n),m){    rep(i,0,n){      tmp[i][m-1-j] = a[i][arr[j].second];    }  }  rep(i,0,n){    rep(j,0,min(m,n)){      a[i][j] = tmp[i][j];    }  }  m = min(m,n);  // f[0-&gt;i列][选的行的state] = 最大期望  // 没有旋转的情况下  // f[0-&gt;i列][选的行的state] = max(f[0-&gt;i-1列][选的行的stateA]+第i列选行stateB) 其中 stateA &amp; stateB =0 , stateA|stateB = (1&lt;&lt;min(m,n))-1  rep(i,0,m){    int itr = i%2;    rep(j,0,tot){      f[itr][j] = 0;    }    // 旋转n次    rep(j,0,n){      rep(k,0,tot){        g[k] = f[itr^1][k];      }      rep(k,0,tot){        int p = (tot - 1)^k; // p &amp; k =0, p|k = (tot-1)        while( p ) {          int x = lowbit(p);          g[k|x] = max(g[k|x], g[k] + a[v2mi[x]][i]); // 每一圈的最值          p -= x;        }      }      // 旋转1单位      int tmp = a[0][i];      rep(k,0,n-1){        a[k][i] = a[k + 1][i];      }      a[n - 1][i] = tmp;      // 对每个state统计最大值      rep(j,0,tot){        f[itr][j] = max(f[itr][j], g[j]);      }    }  }  printf(&quot;%d\n&quot;, f[(m-1)%2][tot - 1]);}int main() {  rep(i,0,MAXN){    v2mi[1&lt;&lt;i] = i;  }  int t;  scanf(&quot;%d&quot;, &amp;t);  while( t-- ){    solve();  }}</code></pre><h1 id="本题另外一个点"><a href="#本题另外一个点" class="headerlink" title="本题另外一个点"></a>本题另外一个点</h1><p><code>max(每一行取最大值的和) = max(每一行任意取一个值的和)</code></p>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
            <tag> 常数优化 </tag>
            
            <tag> 状态压缩 </tag>
            
            <tag> 状压DP </tag>
            
            <tag> 贪心 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF 1217 E (线段树 + 常数优化)</title>
      <link href="/Blog/2019-09-06-cf1217E/"/>
      <url>/Blog/2019-09-06-cf1217E/</url>
      
        <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/1217/problem/E" target="_blank" rel="noopener">原题链接</a></p><h1 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h1><p>n个数 <code>a[1-&gt;n]</code></p><p>m 个询问</p><p>询问类型1: 改动 指定下标i的值为x</p><p>询问类型2: 求下标<code>a[l-&gt;r]</code> 区间上 是否存在两个 数 ,使得 十进制表示的数 在数位上 有同时不为0的,如果有求 和最小的两个数，否则输出-1</p><p>例如 10010 和 23 在第2位 一个是1,一个是2不同时为0,他们的和 就正常加法10010+23=10033</p><p>例如 10101 和 1010 ，就不满足要找的数</p><p>求的是，满足的数的最小和</p><p><strong>注:原题没有这么直接，这是一眼看出的原体的本体</strong></p><h1 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h1><p><code>0&lt;a[i]&lt;=1&#39;000&#39;000&#39;000</code></p><p><code>0&lt;=n,m&lt;=200&#39;000</code></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>一眼题解就是</p><p>按十进制分割成 10个线段树，第i个线段树上只留 在十进制第i位不为0的</p><p>线段树修改和查询 也就 线段树日常操作</p><p><a href="https://codeforces.com/contest/1217/submission/60126721" target="_blank" rel="noopener">第一份代码</a> WA2了,问题出在 <code>++soo.begin()</code> 写成<code>soo.begin()++</code>了,用的下标<code>-1</code>记录个数有点问题改成<code>0x3f3f3f3f</code></p><p><a href="https://codeforces.com/contest/1217/submission/60148467" target="_blank" rel="noopener">第二份代码</a> MLE5，问题在不需要维护所有，只需要维护最小两个数</p><p><a href="https://codeforces.com/contest/1217/submission/60149331" target="_blank" rel="noopener">第三份代码</a> TLE5</p><p><a href="https://codeforces.com/contest/1217/submission/60150572" target="_blank" rel="noopener">第四份代码</a> 依然TLE5， 相对于第三份代码的改动</p><ol><li>我把<code>pair&lt;int,int&gt;</code>等 换成了数组，感觉这样也许更快,也许不</li><li>很重要的一个改动<code>sort()</code>调用换成冒泡,因为才4个，然后我本地生成随机数测试，就初始化线段树的时间，明显从2秒多变为1秒上下</li></ol><p><a href="https://codeforces.com/contest/1217/submission/60154995" target="_blank" rel="noopener">1762ms AC代码</a> 我对初始化进行优化 把一个一个insert改成递归build，初始化时间变到了0.1s左右然后ac</p><h1 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h1><pre><code class="c++">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 1000000007#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)#define pb push_backconst double pi = acos(-1.0);// 没有进位,其余是0// 按十进制 线段树 +multisetstruct SEGT{  int cnt;  int vs[2];}segt[12][800010];#define UNSETINF -1int a[200010];int n,q;// template&lt;typename... Args&gt;// void ptf(const char* fmt, Args... args ){//   return ;//   printf(fmt,args...);// }void mergeS(int *v1,int *v2,int *outv){  unsigned int sa[] = {    (unsigned int)v1[0],    (unsigned int)v1[1],    (unsigned int)v2[0],    (unsigned int)v2[1]  };  rep(i,0,2){    rep(j,i+1,4){      if(sa[j] &lt; sa[i]){        swap(sa[i],sa[j]);      }    }  }  // sort(sa,sa+4);  outv[0] = sa[0];  outv[1] = sa[1];}void insert(int off,int o,int l,int r,int idx,int v){  segt[off][o].cnt++;  if(l == r){    segt[off][o].vs[0] = v;    return ;  }  int mid = (l+r)/2;  if(idx &lt;= mid){    insert(off,o&lt;&lt;1,l,mid,idx,v);  }else{    insert(off,o&lt;&lt;1 | 1,mid+1,r,idx,v);  }  mergeS(segt[off][o&lt;&lt;1].vs,segt[off][o&lt;&lt;1|1].vs,segt[off][o].vs);}static int ten[]={1,10,100,1&#39;000,10&#39;000,100&#39;000,1&#39;000&#39;000,10&#39;000&#39;000,100&#39;000&#39;000,1&#39;000&#39;000&#39;000};void build(int off,int o,int l,int r){  if(l == r){    if((a[l] / ten[off])%10 != 0){      segt[off][o].vs[0] = a[l];      segt[off][o].cnt++;    }    return ;  }  int mid = (l+r)/2;  build(off,o&lt;&lt;1,l,mid);  build(off,o&lt;&lt;1|1,mid+1,r);  mergeS(segt[off][o&lt;&lt;1].vs,segt[off][o&lt;&lt;1|1].vs,segt[off][o].vs);  segt[off][o].cnt = segt[off][o&lt;&lt;1].cnt + segt[off][o&lt;&lt;1|1].cnt;}void del(int off,int o,int l,int r,int idx,int v){  // ptf(&quot;del _%d_ o[%d] [%d -&gt; %d] , [%d] = %d\n&quot;,off,o,l,r,idx,v);  segt[off][o].cnt--;  if(l == r){    segt[off][o].vs[0] = UNSETINF;    return ;  }  int mid = (l+r)/2;  if(idx &lt;= mid){    del(off,o&lt;&lt;1,l,mid,idx,v);  }else{    del(off,o&lt;&lt;1 | 1,mid+1,r,idx,v);  }  mergeS(segt[off][o&lt;&lt;1].vs,segt[off][o&lt;&lt;1|1].vs,segt[off][o].vs);}void change(int idx,int v){  int oldv = a[idx];  if(oldv == v)return;  rep(j,0,10){    if(oldv%10 != 0){      del(j,1,0,n-1,idx,a[idx]);    }    oldv/=10;  }  a[idx] = v;  rep(j,0,10){    if(v%10 != 0){      insert(j,1,0,n-1,idx,a[idx]);    }    v/=10;  }}void qtree(int off,int o,int l,int r,int ql,int qr,int *ret){  // ptf(&quot;qtree  _%d_ o[%d] [%d -&gt; %d] , [%d -&gt; %d] \n&quot;,off,o,l,r,ql,qr);  if(segt[off][o].cnt == 0){    ret[0] = UNSETINF;    ret[1] = UNSETINF;    // ptf(&quot;qtree  _%d_ o[%d] [%d -&gt; %d] , [%d -&gt; %d]&quot;,off,o,l,r,ql,qr);    // ptf(&quot;\t 1pret [%d %d]\n&quot;,ret[0],ret[1]);    return ;  }  if(l == ql &amp;&amp; r == qr){    ret[0] = segt[off][o].vs[0];    ret[1] = segt[off][o].vs[1];    // ptf(&quot;qtree  _%d_ o[%d] [%d -&gt; %d] , [%d -&gt; %d]&quot;,off,o,l,r,ql,qr);    // ptf(&quot;\t 2pret [%d %d]\n&quot;,ret[0],ret[1]);    return ;  }  int mid = (l+r)/2;  if(qr &lt;= mid){    qtree(off,o&lt;&lt;1,l,mid,ql,qr,ret);    return ;  }else if(ql &gt; mid){    qtree(off,o&lt;&lt;1 | 1,mid+1,r,ql,qr,ret);    return ;  }  int retl[2];  qtree(off,o&lt;&lt;1    ,l    ,mid,ql   ,mid,retl);  int retr[2];  qtree(off,o&lt;&lt;1 | 1,mid+1,r  ,mid+1,qr,retr);  mergeS(retl,retr,ret);}void query(int l,int r){  int ans = -1;  rep(j,0,10){    int ret[2];    qtree(j,1,0,n-1,l,r,ret);    if(ret[1] == -1){      continue;    }    if(ans == -1 || ans &gt; ret[0]+ret[1]){      ans = ret[0]+ret[1];    }  }  printf(&quot;%d\n&quot;,ans);}void init(){  rep(i,0,11){    rep(j,0,800001){      segt[i][j].vs[0] = UNSETINF;      segt[i][j].vs[1] = UNSETINF;    }  }}int main(){  init();  scanf(&quot;%d %d&quot;,&amp;n,&amp;q);  rep(i,0,n){    scanf(&quot;%d&quot;,a+i);  }  rep(off,0,10){    build(off,1,0,n-1);  }  rep(i,0,q){    int op;    scanf(&quot;%d&quot;,&amp;op);    if(op == 1){      int idx,x;      scanf(&quot;%d %d&quot;,&amp;idx,&amp;x);      change(idx-1,x);    }else{      int l,r;      scanf(&quot;%d %d&quot;,&amp;l,&amp;r);      query(l-1,r-1);    }  }  return 0;}</code></pre><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>后续优化</p><ol><li>把 冒泡改成了if</li><li>去掉了计数 和cnt =0 判断 (因为考虑到更多的情况来说 不为0 吗?)</li></ol><p><a href="https://codeforces.com/contest/1217/submission/60158689" target="_blank" rel="noopener">时间来到了1372 ms</a>, 有<code>400ms</code>左右的优化效果 但是<a href="https://codeforces.com/contest/1217/submission/60109155" target="_blank" rel="noopener">RUSH_D_CAT的代码</a>的代码只要<code>900+ms</code>,</p><p>那么感觉 可能的影响</p><ol><li>是函数传参个数,涉及到 汇编指令个数?</li><li>我看他的分段处理 是每层 都处理，而我的是 在最外层 <code>for 0-&gt;9</code>,所以 可能的是连续内存访问带来的cache 高性能?</li></ol>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
            <tag> 常数优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF 1202 E (DP + 组合数学)</title>
      <link href="/Blog/2019-08-23-cf1204E/"/>
      <url>/Blog/2019-08-23-cf1204E/</url>
      
        <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/1204/problem/E" target="_blank" rel="noopener">原题链接</a></p><p>又是一个 大家都会的组合数学，就我不会</p><p>本题目2400评分</p><h1 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h1><p>列出n个1 m个-1的所有排列</p><p>求(每个排列的最大前缀和(&gt;=0))的和</p><h1 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h1><p><code>0&lt;=n,m&lt;=2000</code></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><em>注</em>翻译自官方题解</p><p><code>k[x][y]</code> 表示由 x个1 和y个-1组成的 最大前缀和为0的 数组个数</p><p><code>k[0][y] = 1</code> 显然 只有一种情况</p><p><code>k[x][y] = 0 (if x&gt;y)</code></p><p><code>k[x][y] = k[x-1][y] + k[x][y-1]</code> </p><p>关于上面的转移</p><p>从是最后增加一个数字转移进行考虑，分别讨论最后一位是1或-1,</p><p>1的情况，由x&lt;=y得 最大前缀和不会超过0</p><p>-1的情况，明显了增加负1不会影响前缀和</p><p>然后</p><p><code>dp[x][y]</code>为方案数 则 <code>dp[n][m]</code>为答案</p><p><code>dp[0][y] = 0</code> 显然</p><p><code>dp[x][0] = x</code> 显然</p><p>否则</p><p>$d[x][y] = (\binom{x+y-1}{y}+d[x-1][y]) + (d[x][y-1] - (\binom{x+y-1}{x}-k[x][y-1]))$</p><p>解释:分类首位是1或-1讨论</p><p>首位是1 剩余部分 的方案数是如下组合数，对于每个方案的最大前缀和都+1了,除了首位的部分是<code>d[x-1][y]</code></p><p>$\binom{x+y-1}{y} + d[x-1][y]$</p><p>首位是-1, 剩余部分 的方案数是如下组合数，但并不是对于每个方案的最大前缀和都-1了，只有那些最大前缀和<code>&gt;0</code>的才会影响,所以是 <code>-1* (组合数 - (最大前缀和为0的个数))</code>,除了首位的部分是<code>d[x][y-1]</code></p><p>$d[x][y-1] - ( \binom{x+y-1}{x}-k[x][y-1])$</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>没有代码！</p><p>上面算法知道了，那么还剩下</p><ol><li>递推,for一下</li><li>MOD运算别忘了</li><li>组合数(才2k随便搞),<a href="http://yexiaorain.github.io/Blog/2018-12-30-invmul/">乘法逆元</a> <code>O(n)</code> 或者 组合数递推关系(高中知识) <code>O(n^2)</code>,不过看递推基本都要算到，直接无脑递推就好了</li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://codeforces.com/blog/entry/69244" target="_blank" rel="noopener">https://codeforces.com/blog/entry/69244</a></p>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
            <tag> 组合数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF 1202 E (Aho–Corasick automaton)</title>
      <link href="/Blog/2019-08-12-cf1202E/"/>
      <url>/Blog/2019-08-12-cf1202E/</url>
      
        <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/1202/problem/E" target="_blank" rel="noopener">原题链接</a></p><p>大家都会ac自动机就我不会，</p><p>本题目2500评分</p><p>ac自动机 是什么?</p><p>答:<del>一种算法可以自动AC所有题目</del>,多个模式同时匹配</p><h1 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h1><p>字符串 <code>t</code></p><p>和字符串列表 <code>s[]</code></p><p>求<code>s[i]+s[j]</code>在t中的出现次数，对于 所有i j</p><h1 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h1><p><code>len(t) &lt;= 200_000</code></p><p><code>列表长度&lt;=200_000</code></p><p><code>1&lt;=len(s[i])&lt;=200000</code></p><p><code>sum(len(s[i])) &lt;= 200000</code></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>显然</p><p><code>ans = sum(suffix[i] * prefix[i+1])</code> 也就是 以i结尾匹配到 的次数 乘上 i+1为开头匹配到的次数</p><p>那么问题来了，如何计算成功匹配的次数</p><h1 id="引理"><a href="#引理" class="headerlink" title="引理"></a>引理</h1><p>ac automaton</p><blockquote><p>ac自动机 从数据结构上看起来是个什么？</p></blockquote><p>是 trie tree字典树 + 匹配失败时的目标跳转指针</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/6/62/Ahocorasick.svg" alt="trie tree and fail"></p><p>A visualization of the trie for the dictionary on the right. Suffix links are in blue; dictionary suffix links in green. Nodes corresponding to dictionary entries are highlighted in blue.</p><p>图源 wikipedia</p><p>如何实现</p><ol><li>首先 建立trie树就不用说了 // 不会的左转 数据结构-树</li></ol><p>在建立过程中，结束的位置 计数cnt++</p><p>没一层记录一个深度dep</p><ol start="2"><li>然后如何 建立 fail边</li></ol><p>初始化 我们把所有fail边指向根节点</p><p>然后按深度从小到大 广搜，</p><p>第一层节点fail都指向根节点，</p><p>每个节点的子节点扩展: <code>p-&gt;child[charX] = p-&gt;fail-&gt;child[charX]</code></p><blockquote><p>如果<code>p-&gt;fail</code>的后续节点没有charX呢?</p></blockquote><p>实际上我们会递归fail,去找首个有charX的</p><ol start="3"><li>当我们建立完 fail边就可以拿来匹配字符串了</li></ol><p>每次失去匹配我们通过fail进行跳转</p><blockquote><p>问题1.递归代价</p></blockquote><blockquote><p>当每层节点较少，比如只包含所有小写字母时，可以增加每层节点优化掉这递归过程</p></blockquote><p>好像还好</p><blockquote><p>问题2.如何计数 当我们有 abba和bb的时候，如何能计数到bb</p></blockquote><p>每个节点增加一个last，指向 dep小于改节点的，存在的是该字串后缀的末节点。</p><p>如上 我们构建树</p><pre><code>root-a-b-b-a    \     b-b</code></pre><p>这样的情况下，我们需要一条last，从<code>a-b-b</code>指向<code>b-b</code>的后一个<code>b</code>,其余节点的last指向根节点</p><p>实现过程</p><p>首先所有 last默认指向根节点</p><p>要是某个后缀，那么 cnt&gt;0,又要小于该字符串的最长的，则 <code>-&gt;fail</code>(当<code>-&gt;fail-&gt;cnt &gt;0</code>) 或<code>-&gt;fail-&gt;last</code>(<code>-&gt;fail-&gt;cnt ==0</code> )</p><p>这样增加了last指针后，在匹配时，如果当前 链下是 后缀，则开始计数，如果不是则从<code>当前-&gt;last</code>开始计数</p><h1 id="没有调通的代码………………"><a href="#没有调通的代码………………" class="headerlink" title="没有调通的代码………………"></a>没有调通的代码………………</h1><pre><code class="c++">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MOD 1000000007#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)#define pb push_backconst double pi = acos(-1.0);char t[200010];int tres[200010];int revtres[200010];int n;char s[400010];int soff[200010];struct acNode{  map&lt;int,acNode *&gt; next;  acNode * fail2;  int dep;  int award;};int acnidx = 0;acNode acn[200010];acNode * newacNode(int dep){  acn[acnidx].dep = dep;  acn[acnidx].next.clear();  acn[acnidx].award = 0;  acn[acnidx].fail2 = NULL;  return &amp;acn[acnidx++];}struct acAutomaton {  acNode * root;  void init(){    acnidx = 0;    root = newacNode(0);  }  void pushchars(char * chs){    int lench = strlen(chs);    acNode * acnp = root;    rep(i,0,lench){      if(!acnp-&gt;next.count(chs[i])){        acnp-&gt;next[chs[i]] = newacNode(acnp-&gt;dep+1);      }      acnp = acnp-&gt;next[chs[i]];    }    acnp-&gt;award++;  }  void buildfail(){    queue&lt; acNode* &gt;q;    for(auto &amp; item:root-&gt;next){      item.second-&gt;fail2 = root;      q.push(item.second);    }    while(!q.empty()){      acNode * acnp = q.front();      for(auto &amp; item:acnp-&gt;next){        // fa-&gt; xxx = acnp -&gt; xxx        acNode * fa = acnp -&gt; fail2;        while(fa != root &amp;&amp;  !fa-&gt;next.count(item.first) ){          fa = fa -&gt; fail2;        }        item.second-&gt;fail2 = fa-&gt;next.count(item.first)? fa-&gt;next[item.first] : fa;        item.second-&gt;award += acnp-&gt;award;        q.push(item.second);      }      q.pop();    }  }  void print(acNode * acnp = NULL,int offset = 0,char pch = &#39;?&#39;){    if(acnp == NULL){      acnp = root;    }    rep(i,0,offset){      printf(&quot;\t&quot;);    }    printf(&quot;%c&quot;,pch);    printf(&quot;&lt;%p&gt; \t&lt;fail2:%p&gt; \t&lt;award:%d&gt;\n&quot;,acnp,acnp-&gt;fail2,acnp-&gt;award);    for(auto item:acnp-&gt;next){      print(item.second,offset+1,item.first);    }  }  void match(char *chs,int *res){    int lens = strlen(chs);    acNode * acnp = root;    assert(chs[lens] == &#39;\0&#39;);    rep(i,0,lens+1){      while(acnp != root &amp;&amp; !acnp-&gt;next.count(chs[i]) ){        // printf(&quot;fail [ %p ] .count ( %c )&quot;,acnp,chs[i]);        res[i-acnp-&gt;dep] += acnp-&gt;award;        // printf(&quot;[%d]+=%d \n&quot;,i-acnp-&gt;dep,acnp-&gt;award);        acnp = acnp-&gt;fail2;      }      if(acnp-&gt;next.count(chs[i])){        acnp=acnp-&gt;next[chs[i]];      }    }  }}ac;void rev(char *chs){  int lens = strlen(chs);  rep(i,0,lens/2){    swap(chs[i],chs[lens-1-i]);  }}int main(){  scanf(&quot;%s&quot;,t);  scanf(&quot;%d&quot;,&amp;n);  ac.init();  rep(i,0,n){    scanf(&quot;%s&quot;,s+soff[i]);    ac.pushchars(s+soff[i]);    soff[i+1] = soff[i]+strlen(s+soff[i])+1;  }  ac.buildfail();  ac.print();  ac.match(t,tres);  int lent = strlen(t);  ac.init();  rev(t);  rep(i,0,n){    rev(s+soff[i]);    ac.pushchars(s+soff[i]);  }  ac.buildfail();  // ac.print();  ac.match(t,revtres);  ll ans = 0;  rep(i,1,lent){    ans+= tres[i]*(ll)revtres[lent-i];  }  printf(&quot;%lld\n&quot;,ans);  return 0;}</code></pre><p>实现的问题是 </p><pre><code>abbabba2abbabb0</code></pre><p>这样的会报错</p><p>所以我们的AC自动机的fail跳转没有错，但是 计数工具错了</p><p>这也是我最开始实现没有last</p><blockquote><p>尝试方案，增加未处理的遍历，超时…</p></blockquote><h1 id="能过的代码"><a href="#能过的代码" class="headerlink" title="能过的代码"></a>能过的代码</h1><p>跟着 tokitsukaze 代码 魔改的</p><pre><code class="c++">#include &lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;n;i++)typedef long long ll;const int MAX = 2e5+10;struct AC_Automaton {  static const int K=26;//may need change  static const int MAX_NODE=2e5+10;  int getid(char c) {//may need change    return c-&#39;a&#39;;  }  struct AC_NODE{    AC_NODE * next[K];    AC_NODE * fail;    AC_NODE * last;    int cnt;    int dep;    void init(AC_NODE * ac_n){      rep(i,0,K){        next[i] = ac_n;      }      fail = ac_n;      last = ac_n;      cnt = 0;      dep = 0;    }  }nodes[MAX_NODE];  AC_NODE * root;  int tot;  AC_NODE * newnode() {    nodes[tot].init(&amp;nodes[0]);    return &amp;nodes[tot++];  }  void init() {    tot=0;    root=newnode();  }  void insert(char *s) {    AC_NODE * now = root;    int len=strlen(s);    rep(i,0,len){      int t=getid(s[i]);      if(now-&gt;next[t] == root) {        now-&gt;next[t] = newnode();        now-&gt;next[t]-&gt;dep = i+1;      }      now=now-&gt;next[t];    }    now-&gt;cnt++;  }  void setfail() {    queue&lt;AC_NODE *&gt;q;    rep(i,0,K){      if(root-&gt;next[i] != root){        q.push(root-&gt;next[i]);      }    }    while(!q.empty()){      AC_NODE * now=q.front();      q.pop();      //suffix link      now-&gt;last = now-&gt;fail-&gt;cnt &gt; 0 ? now-&gt;fail : now-&gt;fail-&gt;last;      rep(i,0,K){        if(now-&gt;next[i] != root) {          now-&gt;next[i]-&gt;fail=now-&gt;fail-&gt;next[i];          q.push(now-&gt;next[i]);        }else{          now-&gt;next[i]=now-&gt;fail-&gt;next[i];        }      }    }  }  ll be[MAX],en[MAX];  void work(char *s) {    int n = strlen(s);    AC_NODE * now = root;    rep(i,0,n+1){      be[i]=en[i]=0;    }    rep(i,0,n){      now=now-&gt;next[getid(s[i])];      AC_NODE * tmp = root;      if(now-&gt;cnt){        tmp=now;      }else if(now-&gt;last-&gt;cnt){        tmp=now-&gt;last;      }      while(tmp != root){        en[i]+=tmp-&gt;cnt;        if(i-tmp-&gt;dep+1&gt;=0){          be[i-tmp-&gt;dep+1]+=tmp-&gt;cnt;        }        tmp=tmp-&gt;last;      }    }    ll ans=0;    rep(i,0,n-1){      ans+=en[i]*be[i+1];    }    printf(&quot;%lld\n&quot;,ans);  }}ac;char s[MAX],tmp[MAX];int main() {  int q;  scanf(&quot;%s&quot;,s);  ac.init();  scanf(&quot;%d&quot;,&amp;q);  while(q--) {    scanf(&quot;%s&quot;,tmp);    ac.insert(tmp);  }  ac.setfail();  ac.work(s);  return 0;}</code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://en.wikipedia.org/wiki/Aho%E2%80%93Corasick_algorithm" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Aho%E2%80%93Corasick_algorithm</a></p><p><a href="https://oi-wiki.org/string/ac-automaton/" target="_blank" rel="noopener">https://oi-wiki.org/string/ac-automaton/</a></p>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Aho–Corasick automaton </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF 1198 D (DP)</title>
      <link href="/Blog/2019-07-31-cf1198D/"/>
      <url>/Blog/2019-07-31-cf1198D/</url>
      
        <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/1198/problem/D" target="_blank" rel="noopener">原题链接</a></p><h1 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h1><p><code>n*n</code>正方形 有黑有白</p><p>每次可以选择一个 矩形把它全变成白色，代价是<code>max(长,宽)</code></p><p>求吧 整个正方形  全变白 的最小代价</p><h1 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h1><p>n &lt;= 50</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>首先如果 我们刷了两个有相邻边或重叠的 白色矩形</p><p>那么 假设他们的代价分别为 x和y</p><p>那么 一定有 一个 变长为x+y的正方形 完全覆盖了这两个白色矩形</p><p><code>dis|row| &lt;= rowX+roxY &lt;= costX+costY = x+y</code></p><p><code>dis|col| &lt;= colX+roxY &lt;= costX+costY = x+y</code></p><p>所以综上所述 两两不重叠</p><p>再来，证明 如果 最优结果要么选择的单一矩形，要么一定能 垂直 或水平分化,即是 不会出现类似 弦图 这样的分化</p><p>假设存在，那么意味这有<code>n*m</code>的矩形，和对应选择多个图画方案，使得</p><ol><li>图画方案是最优的</li><li>子选择矩形个数大于1</li><li>不存在按竖着 分化,或横着分化，使得子选择被分开</li></ol><p>对于横向来看，意味着任意选择分割线 都会和最优解的选择中的矩形的横着的边冲突，</p><p>也就意味着，从min横向点 到 max横向点，所有点都有边。</p><p>即是，从横向看 最优解的 cost 横向 &gt;= (max横向点-min横向点)</p><p>由对称性，从纵向看 最优解的 cost 纵向 &gt;= (max纵向-min纵向点)</p><p>那么我们直接用 相应的大矩形(max横向点-min横向点,max纵向-min纵向点) 从面积上覆盖 最优解答</p><p>即</p><p>大矩形 cost (从覆盖关系，和最优解答定义)&gt;= 最优解答cost (根据横向和纵向边的关系)&gt;= 大矩形cost</p><p>综上</p><ol><li>没有重叠 至多相邻</li><li>要么 单一选择的矩形(如大矩形)，要么可纵向 或 可横向分割</li></ol><p>所以</p><pre><code>dp[top i0 -&gt; bottom i1][left j0 -&gt; right j1]=min(  max(i1-i0,j1-j0),  dp[i0 -&gt; k][j0-&gt;j1] + dp[k+1-&gt;i1][j0-&gt;j1],  dp[i0 -&gt; i1][j0 -&gt; k] + dp[i0-&gt;i1][k+1-&gt;j1],)</code></pre><p>时间复杂度 <code>O(枚举长 * 枚举宽 * 枚举左上角坐标 * 状态转移) = O(n * n * (n * n) * n) = O(n^5)</code></p><p>能过</p><h1 id="代码-Rust"><a href="#代码-Rust" class="headerlink" title="代码 Rust"></a>代码 Rust</h1><p>920ms/1s 强行 过了,慢应该是用Vec的原因,如果换成c++的直接数组的话，应该能快很多，// 我暂时还没玩会Rust的多维数组</p><p><a href="https://codeforces.com/contest/1198/submission/58082123" target="_blank" rel="noopener">CODE URL</a></p><pre><code class="Rust">#![allow(unused_imports)]use std::cmp::*;use std::collections::*;struct Scanner {   buffer : std::collections::VecDeque&lt;String&gt;}impl Scanner {   fn new() -&gt; Scanner {      Scanner {         buffer: std::collections::VecDeque::new()      }   }   fn next&lt;T : std::str::FromStr &gt;(&amp;mut self) -&gt; T {      if self.buffer.len() == 0 {         let mut input = String::new();         std::io::stdin().read_line(&amp;mut input).ok();         for word in input.split_whitespace() {            self.buffer.push_back(word.to_string())         }      }      let front = self.buffer.pop_front().unwrap();      front.parse::&lt;T&gt;().ok().unwrap()   }}fn main() {    let mut s = Scanner::new();    let n : usize = s.next();    // dp[top i][left j][bottom i][right j] 全部清理 需要的最小代价    let mut dp = vec![vec![vec![vec![0;n+1];n+1];n+1];n+1];    for i in 0..n {        let line:String = s.next();        for (j, ch) in line.chars().enumerate() {            if ch == &#39;#&#39; {                dp[i][j][i][j] = 1;            }        }    }    // 枚举 矩形大小从小到大    for i in 0..n {        for j in 0..n {            if i == 0 &amp;&amp; j == 0 {                continue;            }            // 枚举 矩形左上角坐标            for p in 0..n-i {                for q in 0..n-j {                    // 右下角坐标                    let (x,y) = (i+p,j+q);                    dp[p][q][x][y] = max(i,j)+1;                    for k in p..x {                        dp[p][q][x][y]=min(dp[p][q][x][y],dp[p][q][k][y]+dp[k+1][q][x][y]);                    }                    for k in q..y {                        dp[p][q][x][y]=min(dp[p][q][x][y],dp[p][q][x][k]+dp[p][k+1][x][y]);                    }                }            }        }    }    println!(&quot;{}&quot;,dp[0][0][n-1][n-1]);}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> Rust </tag>
            
            <tag> binary search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF 1197 E (dp+sort+二分)</title>
      <link href="/Blog/2019-07-29-cf1197E/"/>
      <url>/Blog/2019-07-29-cf1197E/</url>
      
        <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/1197/problem/E" target="_blank" rel="noopener">原题链接</a></p><p>2300分</p><h1 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h1><p>俄罗斯套娃，每个有内容半径in和外围半径out</p><p><code>in_i&lt;out_i</code></p><p>如果 <code>in_i &gt;= out_j</code> ,那么j可以放在i内</p><p>定义残留空间 = 一列嵌套的套娃 未使用的半径和 ,如 <code>{1,2},{2,5},{7,9}</code>,未使用的白净和为<code>(1-0)+(2-2)+(7-5) = 3</code></p><p>有效<code>残留空间</code>，如果 一列嵌套的套娃，还能从给出的套娃中选择一个加入这一列，那么原本的残留空间为无效值。如给<code>{1,2},{2,3},{2,5},{7,9}</code>,只选择<code>{1,2},{7,9}</code>是无效的嵌套列，而选择<code>{1,2},{2,3},{7,9}</code>是有效的</p><p>令M = 最小的有效<code>残留空间</code></p><p>求有效<code>残留空间</code>=M的方案数 % MOD</p><h1 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h1><p>套娃个数<code>&lt;= 200&#39;000</code></p><p>半径<code>&lt;=1&#39;000&#39;000&#39;000</code></p><p><code>MOD = 1&#39;000&#39;000&#39;007</code></p><h1 id="题解-翻译自官方题解"><a href="#题解-翻译自官方题解" class="headerlink" title="题解 翻译自官方题解"></a>题解 翻译自官方题解</h1><p>赛内我写了大概十多分钟没写出来,算法是想到n方的 但是没想到怎么优化到时间复杂度内</p><p><a href="https://codeforces.com/blog/entry/68615" target="_blank" rel="noopener">https://codeforces.com/blog/entry/68615</a></p><p>首先我们 把它们按照内半径排序<code>in_i</code>,</p><p><code>dp[i] = {x,y}</code> 从末尾到第i个，最小的有效残留空间x, 这样的情况下的方案数 y</p><p><code>dp[i] = {in_i,1}</code> 如果没有 能套在i外面的</p><p>如果有能套在i外面的j 那么</p><p><code>dp[i].x = min(d[j].x - (out_i-in_i)) = min(d[j].x) - (out_i-in_i)</code></p><p>我自己考虑漏的一点，假设 我们在尝试i了，那么<code>min[d[ all j such in_j&gt;=out_i ].x]</code> 对于&gt;=i 来说,一定是有效的,当时考虑漏了，在想怎么维护左右游标，来计算有效范围内的最小值</p><p>反证法</p><p>因为我们 要把i放在j内，如果不是有效的，</p><p>首先我们的dp定义保证了 不会插入其它在j以后</p><p>那么意味着，在i和j之间还能插入其它，假设为k</p><p>那么有<code>d[k].x &lt; d[j].x</code> 和我们刚刚假设的min矛盾</p><p>综上</p><p>读入O(n)</p><p>排序O(n log n)</p><p>维护一个<code>minx</code>数组</p><p>每次计算<code>dp[i]</code> 二分<code>&gt;=out_i</code>的坐标,计算完后更新minx 每次<code>O(log n)</code></p><p>总共<code>O(n log n)</code></p><h1 id="代码-Rust"><a href="#代码-Rust" class="headerlink" title="代码 (Rust)"></a>代码 (Rust)</h1><p><a href="https://codeforces.com/contest/1197/submission/57928269" target="_blank" rel="noopener">https://codeforces.com/contest/1197/submission/57928269</a></p><pre><code class="rust">#![allow(unused_imports)]use std::cmp::*;use std::collections::*;use std::ops::Bound::*;struct Scanner {   buffer : std::collections::VecDeque&lt;String&gt;}impl Scanner {   fn new() -&gt; Scanner {      Scanner {         buffer: std::collections::VecDeque::new()      }   }   fn next&lt;T : std::str::FromStr &gt;(&amp;mut self) -&gt; T {      if self.buffer.len() == 0 {         let mut input = String::new();         std::io::stdin().read_line(&amp;mut input).ok();         for word in input.split_whitespace() {            self.buffer.push_back(word.to_string())         }      }      let front = self.buffer.pop_front().unwrap();      front.parse::&lt;T&gt;().ok().unwrap()   }}fn main() {    const MOD:i32 = 1_000_000_007;    let mut s = Scanner::new();    let n : usize = s.next();    let mut arr:Vec&lt;(i32,i32)&gt; = Vec::new();    for _i in 0..n {        let out_i: i32 = s.next();        let in_i: i32 = s.next();        arr.push((in_i,out_i));    }    arr.sort();    let mut minx:BTreeMap&lt;i32,(i32,i32)&gt; = BTreeMap::new(); // (in&gt;=, (mincost,cnt))    let mut ans:i32 = 0;    for i in arr.iter().rev() {        let out_i = i.1;        let in_i = i.0;        // 二分找到 &gt;= out_i 的minx        //        let bin_res:(i32,i32) = match minx.range((Included(&amp;out_i), Unbounded)).next() {            Some(val) =&gt; *(val.1),            None =&gt; (out_i,1)        };        let cost = (bin_res.0 - (out_i - in_i), bin_res.1);        // 获取当前&gt;=in_i 的 minx 如果没有则是 0        let cur = match minx.range((Included(&amp;in_i), Unbounded)).next() {            Some(val) =&gt; *(val.1),            None =&gt; (cost.0,0)        };        let count = minx.entry(in_i).or_insert(cur);        if count.0 &gt; cost.0 {            ans = cost.1;            (*count) = cost;        } else if count.0 == cost.0 {            (*count).1 += cost.1;            (*count).1 %= MOD;            ans = (*count).1;        }        // println!(&quot;{:?} {:?}&quot;, i , count);    }    println!(&quot;{}&quot;,ans );}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>最近在看Rust，想说 这<code>lower_bound</code> 用range来写,写得我自闭,但是回过头来看</p><p>感觉用match比c++写 成<code>lower_bound</code> 再判断是否等于<code>.end()</code>更加清晰</p><p>再比如 下面</p><p><code>entry+or_insert</code>这里</p><p>最开始我的两个if里分别时<code>minx.insert</code>和count操作，这样 连编译都通不过，因为一个变量不允许同时 两个mutable</p><p>此外 赞美一下 <code>.0</code>,<code>.1</code>相对于 c++中的 <code>.first</code>,<code>.second</code>或者说 <code>get&lt;0&gt;(...)</code>,<code>get&lt;1&gt;(...)</code></p><p>简洁而不失去意义</p>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> Rust </tag>
            
            <tag> binary search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>USACO 6.5 章节 世界上本没有龙 屠龙的人多了也便有了</title>
      <link href="/Blog/2019-07-07-USACO-6.5/"/>
      <url>/Blog/2019-07-07-USACO-6.5/</url>
      
        <content type="html"><![CDATA[<h1 id="All-Latin-Squares"><a href="#All-Latin-Squares" class="headerlink" title="All Latin Squares"></a>All Latin Squares</h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p><code>n x n</code>矩阵(<code>n=2-&gt;7</code>)</p><p>第一行<code>1 2 3 4 5 ..N</code></p><p>每行每列，<code>1-N</code>各出现一次，求总方案数</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p><del>n最大为7 显然打表</del></p><p>写了个先数值后位置的暴搜</p><pre><code class="c++">#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)using namespace std;const string filename = &quot;latin&quot;;void usefile(){  freopen((filename+&quot;.in&quot;).c_str(),&quot;r&quot;,stdin);  freopen((filename+&quot;.out&quot;).c_str(),&quot;w&quot;,stdout);}int n;int v[10][10]; // [row][col]int vis[10][10]; // [val][col]int anscnt =0;void dfs(int val,int row){  if(val &gt; n){    anscnt++;    return ;  }  rep(j,1,n+1){    if(v[row][j] == 0 &amp;&amp; !vis[val][j]){      v[row][j] = 1;      vis[val][j] = 1;      if(row+1 &lt; n){        dfs(val,row+1);      }else{        dfs(val+1,1);      }      vis[val][j] = 0;      v[row][j] = 0;    }  }}int main(){  //  usefile();  cin&gt;&gt;n;  rep(i,1,n+1){    v[0][i]=i;    vis[i][i]=1;  }  dfs(1,1);  cout&lt;&lt;anscnt&lt;&lt;endl;  return 0;}</code></pre><p>6能搜出来，7要等好久,考虑改算法</p><p>但是数列嘛,当然先上<code>OEIS</code>看看<code>http://oeis.org/search?q=1%2C2%2C24%2C1344%2C1128960&amp;sort=&amp;language=english&amp;go=Search</code></p><p><code>7</code>的时候答案是<code>12198297600</code>,看来直接暴搜是不太可能</p><p>考虑 一个成功的方案， 把它的非首行的两行交换，也是合法的</p><p>所以考虑第一列也定为<code>1</code>到<code>N</code>,最后乘上<code>(N-1)!</code></p><p>这样计算的次数是<code>16942080</code></p><p>在我<code>i7-7700HQ</code>上跑是</p><pre><code class="c++">&gt; time echo 7 | ./6.5.112198297600real    0m17.194suser    0m17.190ssys    0m0.006s</code></pre><p>固定第一列的代码</p><pre><code class="c++">#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)using namespace std;const string filename = &quot;latin&quot;;void usefile(){  freopen((filename+&quot;.in&quot;).c_str(),&quot;r&quot;,stdin);  freopen((filename+&quot;.out&quot;).c_str(),&quot;w&quot;,stdout);}int n;int v[10][10]; // [row][col]// [0-&gt;n-1][1-&gt;n]int vis[10][10]; // [val][col]long long anscnt =0;void dfs(int val,int row){  if(val &gt; n){    anscnt++;    return ;  }  if(val == row+1){    if(row+1 &lt; n){      dfs(val,row+1);    }else{      dfs(val+1,1);    }    return ;  }  rep(j,1,n+1){    if(v[row][j] == 0 &amp;&amp; !vis[val][j]){      v[row][j] = 1;      vis[val][j] = 1;      if(row+1 &lt; n){        dfs(val,row+1);      }else{        dfs(val+1,1);      }      vis[val][j] = 0;      v[row][j] = 0;    }  }}int main(){  //  usefile();  cin&gt;&gt;n;  rep(j,1,n+1){    v[0][j]=j;    vis[j][j]=1;  }  rep(i,1,n){    v[i][1]=i+1;    vis[i+1][1]=1;  }  dfs(1,1);  rep(i,1,n){    anscnt*=i;  }  cout&lt;&lt;anscnt&lt;&lt;endl;  return 0;}</code></pre><p>网上搜了一下方法，有一种是 靠循环节 <code>置换圈</code> 大概群论相关</p><p>而我决定 放弃，打表吧XD</p><pre><code class="c++">#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)using namespace std;const string filename = &quot;latin&quot;;void usefile(){  freopen((filename+&quot;.in&quot;).c_str(),&quot;r&quot;,stdin);  freopen((filename+&quot;.out&quot;).c_str(),&quot;w&quot;,stdout);}int n;map&lt;int,long long &gt;ans;int main(){  usefile();  ans[2]= 1;  ans[3]= 2;  ans[4]= 24;  ans[5]= 1344;  ans[6]= 1128960;  ans[7]= 12198297600;  cin&gt;&gt;n;  cout&lt;&lt;ans[n]&lt;&lt;endl;  return 0;}</code></pre><h1 id="Closed-Fences"><a href="#Closed-Fences" class="headerlink" title="Closed Fences"></a>Closed Fences</h1><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>计算几何</p><p>逆时针给一系列点<code>(&lt;=200个)</code>,坐标范围<code>(| |&lt;=2^16)</code>检查 这些点是否能围成一个围栏</p><p>如果可行,再给一点 输出 从该点发出射线，能照到的线段 (只要部分能被照到 就输出整段)</p><p>如果 给的点，和一条线段共线，视作无法照到</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>看上去像是可以枚举，按照角度，200次遍历射线，每次射线遍历200条边，一共就<code>n方</code>左右的复杂度</p><p>我们先 过一边所有线段如果不相交，那么可以围成（这里没有判断顺时针还是逆时针）</p><p>然后枚举所有线段，对每一条线段1000等分，枚举从给定的点 向等分点是否与其它线段有交点</p><p>时间复杂度<code>O(n*n*1000)</code>;</p><p>[这题的核心还是说写计算几何的算法</p><pre><code class="c++">#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)using namespace std;const string filename = &quot;fence4&quot;;void usefile(){  freopen((filename+&quot;.in&quot;).c_str(),&quot;r&quot;,stdin);  freopen((filename+&quot;.out&quot;).c_str(),&quot;w&quot;,stdout);}pair&lt;int,int&gt; p;pair&lt;int,int&gt; P[210];int N;double cross(pair&lt;double,double&gt; a,pair&lt;double,double&gt; b){  return a.first*b.second-a.second*b.first;}pair&lt;double,double&gt; operator + (pair&lt;double,double&gt; a,pair&lt;double,double&gt; b)  {  return {a.first+b.first,a.second+b.second};}pair&lt;double,double&gt; operator - (pair&lt;double,double&gt; a,pair&lt;double,double&gt; b)   {  return {a.first-b.first,a.second-b.second};}bool isIntersect(pair&lt;pair&lt;double,double&gt;,pair&lt;double,double&gt;&gt; line1,pair&lt;pair&lt;double,double&gt;,pair&lt;double,double&gt;&gt; line2){  return  !(      (cross(line1.first -line2.first,line2.second-line2.first) &gt; 0) ==      (cross(line1.second-line2.first,line2.second-line2.first) &gt; 0) ||      (cross(line2.first -line1.first,line1.second-line1.first) &gt; 0) ==      (cross(line2.second-line1.first,line1.second-line1.first) &gt; 0)      );}bool isValid(){  rep(i,0,N){    rep(j,i+2,N){      if(i == 0 &amp;&amp; j == N-1)continue;      if(isIntersect({P[i],P[i+1]}, {P[j],P[(j+1)%N]})){        return false;      }    }  }  return true;}// 共线bool isColine(int idx){  return cross(P[idx]-P[(idx+1)%N],p) == cross(P[idx],P[(idx+1)%N]);}bool isSeen(int idx){  int x1 = P[idx].first;  int y1 = P[idx].second;  int nsegments = 1000;  rep(i,1,nsegments){    pair&lt;double,double&gt; point_ =  {      x1 + i * 1.0 / nsegments * (P[(idx + 1) % N].first  - x1),      y1 + i * 1.0 / nsegments * (P[(idx + 1) % N].second - y1)};    bool blocked = false;    rep(j,0,N){      if(j == idx)      {        continue;      }      if(isIntersect({p,point_}, {P[j],P[(j+1)%N]})){        blocked = true;        break;      }    }    if(!blocked)    {      return true;    }  }  return false;}vector&lt;int&gt; ans;int main(){  usefile();  scanf(&quot;%d&quot;, &amp;N);  scanf(&quot;%d %d&quot;, &amp;p.first,&amp;p.second);  rep(i,0,N){    scanf( &quot;%d %d&quot;, &amp;P[i].first, &amp;P[i].second);  }  if(!isValid())  {    printf( &quot;NOFENCE\n&quot;);    return 0;  }  rep(i,0,N){    if(!isColine(i) &amp;&amp; isSeen(i))    {      ans.push_back(i);    }  }  if(ans.size() &gt;= 2 &amp;&amp; ans[ans.size() - 2] == N - 2){    ans[ans.size() - 2] = N - 1;    ans[ans.size() - 1] = N - 2;  }  printf(&quot;%d\n&quot;, int(ans.size()));  rep(i,0,ans.size()){    if(ans[i] == N - 1)    {      printf(&quot;%d %d %d %d\n&quot;, P[0].first, P[0].second, P[ans[i]].first, P[ans[i]].second);    }else{      printf( &quot;%d %d %d %d\n&quot;, P[ans[i]].first, P[ans[i]].second, P[ans[i] + 1].first, P[ans[i] + 1].second);    }  }  return 0;}</code></pre><h1 id="Betsy’s-Tour"><a href="#Betsy’s-Tour" class="headerlink" title="Betsy’s Tour"></a>Betsy’s Tour</h1><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p><code>n x n</code>(n&lt;=7) 的矩阵，从左上走到坐下，每个格子最多经过一次的方案数</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p><del>暴搜+打表</del></p><p>插头dp ? 像是</p><p>实现了一下 果然过了，注意处理<code>n = 1</code></p><p>插头dp的话 直接百度文库 应该能搜到不少文章，我感觉我的<code>边界处理</code>和<code>状态转移</code>的代码写得好丑QAQ</p><ol><li>这里的一个技巧是，想象在左边在多出一列，把这列从上连到下，这样原题就变成确定了一部分路线的欧拉回路的插头dp了,这样 起始和终点的就也和中间的过程块，看作联通其它两个块的 来处理了</li><li>状态表示，最无脑的是，相同数字，但是 这样的话状态转移会比较难写 比如<code>100120332</code>，注意到我们会一直维持合法性,所以可以用左右括号表示<code>(__)(_())</code>,这样的化就是<code>3进制</code>即可，然后<code>4进制</code>更容易操作，比如我下面用的位运算<code>&lt;&lt;2 或 &gt;&gt;2</code></li><li>在上面两个优化下 初始状态是<code>(______)</code>这样的</li></ol><p>时间复杂度<code>O(i*j*state) = O(7*7*3^7)</code></p><pre><code class="c++">#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)using namespace std;const string filename = &quot;betsy&quot;;void usefile(){  freopen((filename+&quot;.in&quot;).c_str(),&quot;r&quot;,stdin);  freopen((filename+&quot;.out&quot;).c_str(),&quot;w&quot;,stdout);}int n;// 中间的 每个块 连接 两个方向，map&lt;pair&lt;int,long long&gt;,long long&gt; res;int get_state(long long state,int pos){  return (state &gt;&gt; (2*pos)) % 4;}int set_state(long long state,int pos){  return state &lt;&lt; (2*pos);}// ((    ) ())// block: 的2进制位 0b3210//   3//  0 2//   1long long insert_state(long long old_state,int pos,int block){  int arr[10];  // 栈计算括号对  int p[10];  int stk[10];  int stki = 0;  rep(i,0,n+1){    arr[i] = get_state(old_state,i);    if(arr[i] == 0)continue;    if(arr[i] == 1)stk[stki++]=i;    if(arr[i] == 2){      p[i] = stk[stki-1];      p[stk[stki-1]] = i;      stki--;    }  }  int cnt = 0;  rep(i,0,4){    cnt+= !!(block &amp; (1&lt;&lt;i));  }  assert(cnt == 2);  // 插入的块和 被插入的位置 同时有或没有  if( (!(block &amp; 0b1000) != !arr[pos]) || (!(block &amp; 0b0001) != !arr[pos+1]) ){    return -1;  }  // 原来为空 新建边  if( (block &amp; 0b0100) &amp;&amp; (block &amp; 0b0010)){    arr[pos] = 1;    arr[pos+1] = 2;  }else if( (block &amp; 0b0100) || (block &amp; 0b0010) ){ // 引出一条原来的边    if(block &amp; 0b0100){      arr[pos] = arr[pos]+arr[pos+1];      arr[pos+1] = 0;    }else {      arr[pos+1] = arr[pos]+arr[pos+1];      arr[pos] = 0;    }  }else{ // 把原来两段 连接起来    if(arr[pos] == 1 &amp;&amp;  arr[pos+1] == 2){      arr[pos] = 0 ;      arr[pos+1] = 0 ;    }else{      arr[pos] = 0;      arr[pos+1] = 0;      int p1 = p[pos];      int p2 = p[pos+1];      if(p1 &gt; p2)swap(p1,p2);      arr[p1] = 1;      arr[p2] = 2;    }  }  long long new_state = 0;  rep(i,0,n+1){    new_state += set_state(arr[i],i);  }  return new_state;}long long dp(int idxi,int idxj,long long state){  long long &amp;ret = res[{(idxi&lt;&lt;3)+idxj,state}];  if(ret != 0){    return ret;  }    // 右下角允许自连  if(idxj == n-1 &amp;&amp; idxi == n-1) {    return ret = (get_state(state,n-1) == 1 &amp;&amp; get_state(state,n) == 2);  }  // 过程中不允许自连  //  if (get_state(state,idxi) == 1 &amp;&amp; get_state(state,idxi+1) == 2)return 0;  rep(i,0,4){    rep(j,i+1,4){      int new_state = insert_state(state,idxi,(1&lt;&lt;i)+(1&lt;&lt;j));      if(new_state == -1)continue;      // 最后一列      if(idxj == n-1) {        if(get_state(new_state,idxi) != 0)continue;      }      // 最后一行      if(idxi == n-1){        if(get_state(new_state,idxi+1) != 0)continue;        new_state &lt;&lt;=2;        ret+=dp(0,idxj+1,new_state);      }else{        ret+=dp(idxi+1,idxj,new_state);      }    }  }  // printf(&quot;(%d,%d) {%lld,%lld,%lld} = %lld\n&quot;,idxi,idxj,(state)%4,(state&gt;&gt;2)%4,(state&gt;&gt;4)%4,ret);  return ret;}int main(){  usefile();  cin&gt;&gt;n;  if(n == 1){    cout&lt;&lt;1&lt;&lt;endl;  }else{    cout&lt;&lt;dp(0,0,set_state(1,1)+set_state(2,n))&lt;&lt;endl;  }  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>6.5章其实有5个题,但后面两题 我很久很久很就以前做了 就不想再做一次了，所以这里只写了3题</p><h1 id="本文其它链接"><a href="#本文其它链接" class="headerlink" title="本文其它链接"></a>本文其它链接</h1><p>牛客: <a href="https://blog.nowcoder.net/n/c7f0a70d69254c9180dd0b7e475d1248" target="_blank" rel="noopener">https://blog.nowcoder.net/n/c7f0a70d69254c9180dd0b7e475d1248</a></p><p>cnblogs: <a href="https://www.cnblogs.com/CroMarmot/p/11149313.html" target="_blank" rel="noopener">https://www.cnblogs.com/CroMarmot/p/11149313.html</a></p>]]></content>
      
      
      <categories>
          
          <category> USACO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 插头DP </tag>
            
            <tag> 搜索 </tag>
            
            <tag> 打表 </tag>
            
            <tag> 群论 </tag>
            
            <tag> 计算几何 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>USACO 6.4 章节</title>
      <link href="/Blog/2019-07-03-USACO-6.4/"/>
      <url>/Blog/2019-07-03-USACO-6.4/</url>
      
        <content type="html"><![CDATA[<h1 id="The-Primes"><a href="#The-Primes" class="headerlink" title="The Primes"></a>The Primes</h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p><code>5*5</code>矩阵,给定<code>左上角</code></p><p>要所有<code>行</code>，<code>列</code>，<code>从左向右看对角线</code>为质数，没有前导零，且这些质数<code>数位和</code>相等(题目给和)</p><p>按字典序输出所有方案。。。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>看上去就是个 无脑暴搜</p><p>题目条件翻译成<code>处理</code>或<code>剪枝</code></p><ol><li>按照 字典序顺序搜，</li><li>末位是奇数</li><li>和确定了，那么前4位的和的奇偶性确定了</li><li>数值是5位数，可以先生成质数表</li><li>和-前n位和 小于 9乘剩余位数</li></ol><p>也许先把第一行和第一列定下，然后按照数位和 再分组质数，搜索量会超级小?</p><p><code>17 7</code>的这组数据 超过5s (<code>i7-7700HQ</code>)</p><pre><code class="c++">#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for (long long i=a;i&lt;n;i++)#define per(i,a,n) for (long long i=n-1;i&gt;=a;i--)using namespace std;const string filename = &quot;prime3&quot;;void usefile(){  freopen((filename+&quot;.in&quot;).c_str(),&quot;r&quot;,stdin);  freopen((filename+&quot;.out&quot;).c_str(),&quot;w&quot;,stdout);}int A[10][10];int p[100010];int s;bool check(int idxi,int idxj){  {    int sum = 0;    rep(i,0,idxi+1){      sum+=A[i][idxj];    }    if(sum &gt; s){      return false;    }    if( (s-sum) &gt; (4-idxi)*9 ){      return false;    }    if(idxi == 0 &amp;&amp; sum == 0){      return false;    }    if(idxi == 4){      if(sum != s){        return false;      }      int v = 0;      rep(i,0,5){        v*=10;        v+=A[i][idxj];      }      if(p[v]){        return false;      }    }    if(idxi == 3 &amp;&amp; (s-sum)%2 == 0){      return false;    }  }  {    int sum = 0;    rep(j,0,idxj+1){      sum+=A[idxi][j];    }    if(sum &gt; s){      return false;    }    if( (s-sum) &gt; (4-idxj)*9 ){      return false;    }    if(idxj == 0 &amp;&amp; sum == 0){      return false;    }    if(idxj == 4){      if(sum != s){        return false;      }      int v = 0;      rep(j,0,5){        v*=10;        v+=A[idxi][j];      }      if(p[v]){        return false;      }    }    if(idxj == 3 &amp;&amp; (s-sum)%2 == 0){      return false;    }  }  {    // 左下到右上    if(idxi+idxj == 4){      int sum = 0;      rep(i,0,idxi+1){        sum+=A[i][4-i];      }      if(sum &gt; s){        return false;      }      if( (s-sum) &gt; (4-idxi)*9 ){        return false;      }      if(idxi == 4){        if(sum != s){          return false;        }        int v = 0;        per(i,0,5){          v*=10;          v+=A[i][4-i];        }        if(p[v]){          return false;        }      }    }  }  {    // 左上到右下    if(idxi-idxj == 0){      int sum = 0;      rep(i,0,idxi+1){        sum+=A[i][i];      }      if(sum &gt; s){        return false;      }      if( (s-sum) &gt; (4-idxi)*9 ){        return false;      }      if(idxi == 4){        if(sum != s){          return false;        }        int v = 0;        rep(i,0,5){          v*=10;          v+=A[i][i];        }        if(p[v]){          return false;        }      }      if(idxj == 3 &amp;&amp; (s-sum)%2 == 0){        return false;      }    }  }  return true;}void print(){  static bool pre_n = false;  if(pre_n){    printf(&quot;\n&quot;);  }else{    pre_n = true;  }  rep(i,0,5){    rep(j,0,5){      printf(&quot;%d&quot;,A[i][j]);    }    printf(&quot;\n&quot;);  }}void dfs(int pos){  if(pos == 25){    print();    return ;  }  int idxi = pos/5;  int idxj = pos%5;  rep(i,0,10){    A[idxi][idxj] = i;    if(check(idxi,idxj)){      dfs(pos+1);    }  }}void init(){  rep(i,2,100000){    if(!p[i]){      for(long long j = i*i;j&lt;100000;j+=i){        p[j] = 1;      }    }  }}int main(){  usefile();  init();  cin&gt;&gt;s&gt;&gt;A[0][0];  dfs(1);  return 0;}</code></pre><p>根据和来看看个数得到 <code>和:个数</code></p><pre><code>4:45:127:288:4510:9511:14313:23614:27216:41117:47919:63020:66422:74223:75725:74126:70628:58029:52831:37932:34134:20535:16637:8438:6240:3441:1343:444:2</code></pre><p>相对于原来 的搜索空间 小了很多</p><p>改完以后 第6个点超时: <code>17 1</code></p><pre><code class="c++">#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for (long long i=a;i&lt;n;i++)#define per(i,a,n) for (long long i=n-1;i&gt;=a;i--)using namespace std;const string filename = &quot;prime3&quot;;void usefile(){  freopen((filename+&quot;.in&quot;).c_str(),&quot;r&quot;,stdin);  freopen((filename+&quot;.out&quot;).c_str(),&quot;w&quot;,stdout);}int A[10][10];int p[100010];map&lt;int,vector&lt;int&gt;&gt;sum2v;set&lt;string&gt;ss;int s;void print(){  string news = &quot;&quot;;  rep(i,0,5){    rep(j,0,5){      news += (&#39;0&#39;+A[i][j]);    }    news += &#39;\n&#39;;  }  ss.insert(news);  return ;  static bool pre_n = false;  if(pre_n){    printf(&quot;\n&quot;);  }else{    pre_n = true;  }  rep(i,0,5){    rep(j,0,5){      printf(&quot;%d&quot;,A[i][j]);    }    printf(&quot;\n&quot;);  }}void check(){  int ncnt = 0;  int sum = 0;  per(i,0,5){    sum*=10;    sum+=A[i][4-i];    ncnt+=A[i][4-i];  }  if(ncnt != s)return;  if(p[sum])return;  int sum0=0;  int ncnt0=0;  rep(i,0,4){    sum0+=A[i][i];    sum0*=10;    ncnt0+=A[i][i];  }  int sum1=0;  int ncnt1=0;  rep(j,0,4){    sum1+=A[4][j];    sum1*=10;    ncnt1+=A[4][j];  }  int sum2=0;  int ncnt2=0;  rep(i,0,4){    sum2+=A[i][4];    sum2*=10;    ncnt2+=A[i][4];  }  if(ncnt0 != ncnt1 || ncnt0 != ncnt2)return;  int i = s - ncnt0;  if(i &lt; 0 || i &gt; 10 || i%2 == 0)return ;  if((!p[sum0+i]) &amp;&amp; (!p[sum1+i]) &amp;&amp; (!p[sum2+i])){    // printf(&quot;sum:%d\n&quot;,sum);    A[4][4] = i;    print();  }}void dfs(int ij){  if(ij == 4){    check();    return ;  }  int prerow = 0;  int precol = 0;  rep(j,0,ij){    prerow *=10;    prerow += A[ij][j];  }  if(ij == 0){    prerow = A[0][0];  }  rep(i,0,ij){    precol += A[i][ij];    precol *=10;  }  for(auto vrow:sum2v[prerow]){    int pre0 = false;    per(j,0,5){      // printf(&quot;[%d]%d ==&gt; vrow[%05d]A0[%d][%lld]=%d\n&quot;,ij,prerow,vrow,ij,j,vrow%10);      A[ij][j]=vrow%10;      vrow/=10;      if(ij == 0 &amp;&amp; A[ij][j] == 0){        pre0 = true;        break;      }    }    if(pre0)continue;    int pcol = precol+A[ij][ij];    for(auto vcol:sum2v[pcol]){      pre0 = false;      per(i,0,5){        // printf(&quot;\t[%d] %d ==&gt; vcol[%05d]A1[%lld][%d]=%d\n&quot;,ij,pcol,vcol,i,ij,vcol%10);        A[i][ij]=vcol%10;        vcol/=10;        if(ij == 0 &amp;&amp; A[i][ij] == 0){          pre0 = true;          break;        }      }      if(pre0)continue;      dfs(ij+1);    }  }}void init(){  rep(i,2,100000){    if(!p[i]){      if(i&gt;=10000){        int sum = 0;        int ii = i;        rep(idx,0,5){          sum+=ii%10;          ii/=10;        }        if(sum == s){          int ii = i;          rep(idx,0,5){            sum2v[ii].push_back(i);            ii/=10;          }        }      }      for(long long j = i*i;j&lt;100000;j+=i){        p[j] = 1;      }    }  }}int main(){  usefile();  cin&gt;&gt;s&gt;&gt;A[0][0];  init();  dfs(0);  for(auto item:ss){    static bool pn = false;    if(pn){      printf(&quot;\n&quot;);    }else{      pn = true;    }    printf(&quot;%s&quot;,item.c_str());  }  return 0;}</code></pre><p>再增加一个预先剪枝 依然没过 第<code>6</code>个点，在我的电脑上<code>1.893s</code></p><p>然后我对 中间的点，进行了预处理(预先判断 左下角到右上角)，<code>tle 9</code>,数据是<code>23 1</code>,虽然我的电脑上<code>1.099s</code></p><p>然后 把map换成 数组 就本地<code>0.227s</code>，USACO就过了…</p><pre><code class="c++">#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for (long long i=a;i&lt;n;i++)#define per(i,a,n) for (long long i=n-1;i&gt;=a;i--)using namespace std;const string filename = &quot;prime3&quot;;void usefile(){  freopen((filename+&quot;.in&quot;).c_str(),&quot;r&quot;,stdin);  freopen((filename+&quot;.out&quot;).c_str(),&quot;w&quot;,stdout);}int A[10][10];int p[100010];vector&lt;int&gt;sum2v[100010];set&lt;string&gt;ss;int s;void print(){  string news = &quot;&quot;;  rep(i,0,5){    rep(j,0,5){      news += (&#39;0&#39;+A[i][j]);    }    news += &#39;\n&#39;;  }  ss.insert(news);  return ;  static bool pre_n = false;  if(pre_n){    printf(&quot;\n&quot;);  }else{    pre_n = true;  }  rep(i,0,5){    rep(j,0,5){      printf(&quot;%d&quot;,A[i][j]);    }    printf(&quot;\n&quot;);  }}void check(){  int ncnt = 0;  int sum = 0;  per(i,0,5){    sum*=10;    sum+=A[i][4-i];    ncnt+=A[i][4-i];  }  if(ncnt != s)return;  if(p[sum])return;  int sum0=0;  int ncnt0=0;  rep(i,0,4){    sum0+=A[i][i];    sum0*=10;    ncnt0+=A[i][i];  }  int sum1=0;  int ncnt1=0;  rep(j,0,4){    sum1+=A[4][j];    sum1*=10;    ncnt1+=A[4][j];  }  int sum2=0;  int ncnt2=0;  rep(i,0,4){    sum2+=A[i][4];    sum2*=10;    ncnt2+=A[i][4];  }  if(ncnt0 != ncnt1 || ncnt0 != ncnt2)return;  int i = s - ncnt0;  if(i &lt; 0 || i &gt; 10 || i%2 == 0)return ;  if((!p[sum0+i]) &amp;&amp; (!p[sum1+i]) &amp;&amp; (!p[sum2+i])){    // printf(&quot;sum:%d\n&quot;,sum);    A[4][4] = i;    print();  }}bool precheck(int ij){  rep(i,ij+1,5){    int pre = 0;    rep(j,0,ij+1){      pre*=10;      pre+=A[i][j];    }    if(!sum2v[pre].size())return false;  }  rep(j,ij+1,5){    int pre = 0;    rep(i,0,ij+1){      pre*=10;      pre+=A[i][j];    }    if(!sum2v[pre].size())return false;  }  if(ij == 2){    int sum = 0;    int pre = 0;    per(i,0,5){      pre*=10;      pre+=A[i][4-i];      sum+=A[i][4-i];    }    if(s!=sum)return false;    if(p[pre])return false;  }  return true;}void dfs(int ij){  if(ij == 4){    check();    return ;  }  int prerow = 0;  int precol = 0;  rep(j,0,ij){    prerow *=10;    prerow += A[ij][j];  }  if(ij == 0){    prerow = A[0][0];  }  rep(i,0,ij){    precol += A[i][ij];    precol *=10;  }  // A[2][2]  if(ij == 2){    int mid = s- A[4][0]-A[3][1]-A[1][3]-A[0][4];    if(mid &lt; 0 || mid &gt; 9)return;    int v = A[4][0]*10000+A[3][1]*1000+mid*100+A[1][3]*10+A[0][4];    if(p[v])return;// 左下到右上    prerow = prerow*10+mid;  }  for(auto vrow:sum2v[prerow]){    int pre0 = false;    per(j,0,5){      A[ij][j]=vrow%10;      vrow/=10;      if(ij == 0 &amp;&amp; A[ij][j] == 0){        pre0 = true;        break;      }    }    if(pre0)continue;    int pcol = precol+A[ij][ij];    for(auto vcol:sum2v[pcol]){      pre0 = false;      per(i,0,5){        A[i][ij]=vcol%10;        vcol/=10;        if(ij == 0 &amp;&amp; A[i][ij] == 0){          pre0 = true;          break;        }      }      if(pre0)continue;      if(!precheck(ij))continue;      dfs(ij+1);    }  }}void init(){  rep(i,2,100000){    if(!p[i]){      if(i&gt;=10000){        int sum = 0;        int ii = i;        rep(idx,0,5){          sum+=ii%10;          ii/=10;        }        if(sum == s){          int ii = i;          rep(idx,0,5){            sum2v[ii].push_back(i);            ii/=10;          }        }      }      for(long long j = i*i;j&lt;100000;j+=i){        p[j] = 1;      }    }  }}int main(){  usefile();  cin&gt;&gt;s&gt;&gt;A[0][0];  init();  dfs(0);  for(auto item:ss){    static bool pn = false;    if(pn){      printf(&quot;\n&quot;);    }else{      pn = true;    }    printf(&quot;%s&quot;,item.c_str());  }  return 0;}</code></pre><blockquote><p>提交后测试</p></blockquote><ol><li>把precheck 去掉， 发现也能过，甚至更快XD，说明其作用 小于 其副作用</li><li>把<code>A[2][2]</code> 预处理去掉 会超时第8个点</li></ol><h1 id="Electric-Fences"><a href="#Electric-Fences" class="headerlink" title="Electric Fences"></a>Electric Fences</h1><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p><code>&lt;=150</code>条线段(和X 轴或 Y轴平行) ， 坐标 范围<code>0&lt;= x,y&lt;=100</code></p><p>求一个点(可以非整数,最多1位小数)，从这个点 向每一条线段连出一个线段，使连出的线段长度综合最小，求点坐标和 最小总长度</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>如果我们得到了一个点，那么 这个点到一条线段做垂线，如果垂线的垂点在线段上那么为这条垂线，否则为点到这条线段其中一个端点的长度</p><p><del>显然 和计算几何有关</del>因为都和坐标轴平行了，完全用不到计算几何</p><p>有什么用呢？到所有线段都刚刚是垂线段最好？</p><p>显然有反例 <code>(0,0)-(1,0)</code>,<code>(0,0)-(0,1)</code>,<code>(1,1)-(2,1)</code>, 如果是所有线段都刚刚垂线段那么显然选点<code>(1,1)</code>,然而选点<code>0,0</code>可以得到更好的线段长度总和，说明<code>(1,1)</code>不是最优点</p><ol><li>一个办法是 坐标乘10 ，然后枚举<code>O(1000*1000*150)</code></li><li>一个算法是模拟退火！！！</li><li>精度逼近法,如果 一个区域的 最大距离 小于 另一个区域的最小距离，那么显然抛弃另一个，对这个区域可以进行再划分,至于怎么划分 还没具体方法</li><li>二维三分,求助！证明 在x和y方向 ，距离值函数都是凹函数(上凸)</li></ol><p>基于未证明的 凸 假设 下的简化模拟退火, AC</p><pre><code class="c++">#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)using namespace std;const string filename = &quot;fence3&quot;;void usefile(){  freopen((filename+&quot;.in&quot;).c_str(),&quot;r&quot;,stdin);  freopen((filename+&quot;.out&quot;).c_str(),&quot;w&quot;,stdout);}double absarrow(double derx,double dery){  return sqrt(derx*derx+dery*dery);}struct re{  int x1,y1,x2,y2;}l[160];double dis(double x,double y,int idx){  if(l[idx].x1==l[idx].x2){    if(y&lt;l[idx].y1)return absarrow(x-l[idx].x1,y-l[idx].y1);    if(y&gt;l[idx].y2)return absarrow(x-l[idx].x2,y-l[idx].y2);    return fabs(x-l[idx].x1);  }else{    if(x&lt;l[idx].x1)return absarrow(x-l[idx].x1,y-l[idx].y1);    if(x&gt;l[idx].x2)return absarrow(x-l[idx].x2,y-l[idx].y2);    return fabs(y-l[idx].y1);  }}int main(){  usefile();  srand(size_t(time(NULL)));  int n=0;  cin &gt;&gt; n;  double x=rand()%100;  double y=rand()%100;  double step=100;  tuple&lt;double,double,double&gt;ans;  rep(i,0,n){    scanf(&quot;%d %d %d %d&quot;, &amp;l[i].x1,&amp;l[i].y1,&amp;l[i].x2,&amp;l[i].y2);    // 因为平行于坐标轴 所以 必定有一组相等，所以只用换一组    if(l[i].x1&gt;l[i].x2)swap(l[i].x1,l[i].x2);    if(l[i].y1&gt;l[i].y2)swap(l[i].y1,l[i].y2);    get&lt;2&gt;(ans) += dis(x,y,i);  }  int d=31;  while(step&gt;10e-3){    rep(i,0,500){      // 以任意方向 长度为step进行下降 d((x,y),(newx,newy)) = step      double newx,newy;      newx=step*(double(rand())/double(RAND_MAX))*(2*(rand()%2)-1); // [-step,step]      newy=sqrt(step*step-newx*newx)*(2*(rand()%2)-1)+y; // 保证x y变化的向量长度是 step      newx+=x;      double lencnt=0;      rep(idx,0,n){        lencnt+=dis(newx,newy,idx);      }      // 如果更优下降      if(lencnt-get&lt;2&gt;(ans)&lt;0){        x=newx;        y=newy;        ans={newx,newy,lencnt};      }    }    d++;    // 约从 1.1568910657987959 速率开始    step/=log10(d)/log10(20);  }  printf(&quot;%.1lf %.1lf %.1lf\n&quot;,get&lt;0&gt;(ans),get&lt;1&gt;(ans),get&lt;2&gt;(ans));  return 0;}</code></pre><p>延伸思考， 1.如何证明凸性质，2.如果增加线段，加一些不平行于坐标轴的线段，是否还是有凸的性质</p><h1 id="Wisconsin-Squares"><a href="#Wisconsin-Squares" class="headerlink" title="Wisconsin Squares"></a>Wisconsin Squares</h1><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p><del>考英语了 考英语了 Guernseys (A), Jerseys (B), Herefords (C), Black Angus (D), and Longhorns (E).</del></p><p><code>4*4</code> 的矩阵</p><p>原来有<code>3*A0,3*B0,4*C0,3*D0,3*E0</code> 现在需要有<code>3*A1,3*B1,3*C1,4*D1,3*E1</code></p><p>现在的操作是 每次替换一个<code>某种0</code> 为 <code>任意一种1</code>,直到把<code>4*4</code>的所有替换完</p><p>限制，每次操作后，保证 没有相邻(8向)的相同字母, 如<code>C0</code>和<code>C0</code>算相同字母， <code>A1</code>和<code>A0</code>算相同字母</p><p>输入 初始 布局</p><p>输出 字典序最小的可行的方案过程和 可行的方案过程的总数</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>一看就想暴搜啊</p><p>……然后 真的就过了，只有一个测试点</p><pre><code class="c++">#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)using namespace std;const string filename = &quot;wissqu&quot;;pair&lt;int,int&gt; v[10][10];char s[10][10];void usefile(){  freopen((filename+&quot;.in&quot;).c_str(),&quot;r&quot;,stdin);  freopen((filename+&quot;.out&quot;).c_str(),&quot;w&quot;,stdout);}int cnt[10];bool success = false;int anscnt = 0;tuple&lt;char,int,int&gt; pick[100];int di[]={-1,-1,-1,0,0,0,1,1,1};int dj[]={-1,0,1,-1,0,1,-1,0,1};void dfs(int deep){  if(deep == 16){    anscnt++;    if(!success){      success = true;      rep(i,0,16){        printf(&quot;%c %d %d\n&quot;,get&lt;0&gt;(pick[i]),get&lt;1&gt;(pick[i]),get&lt;2&gt;(pick[i]));      }    }    return ;  }  rep(k,0,5){    if(deep == 0 &amp;&amp; k != 3)continue;    if(!cnt[k])continue;    rep(i,0,4){      rep(j,0,4){        if(v[i][j].second)continue;        bool conflict = false;        rep(m,0,9){          int newi = i+di[m];          int newj = j+dj[m];          if(newi &lt; 0 || newj &lt; 0 || newi &gt; 4 || newj &gt; 4){            continue;          }          if(v[newi][newj].first == k){            conflict = true;            break;          }        }        if(conflict)continue;        auto old = v[i][j];        v[i][j] = {k,1};        pick[deep] = {&#39;A&#39;+k,i+1,j+1};        cnt[k]--;        dfs(deep+1);        cnt[k]++;        v[i][j] = old;      }    }  }}int main(){  usefile();  rep(i,0,4){    scanf(&quot;%s&quot;,s[i]);  }  cnt[0] = 3;  cnt[1] = 3;  cnt[2] = 3;  cnt[3] = 4;  cnt[4] = 3;  rep(i,0,4){    rep(j,0,4){      v[i][j] = {s[i][j]-&#39;A&#39;,0};    }  }  dfs(0);  printf(&quot;%d\n&quot;,anscnt);  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我发现 普通的题，基本是一眼算法+分析复杂度+实现</p><p>而这种搜索剪枝的是，先上暴搜，逐个尝试加剪枝看效果XD,因为只能大概猜剪枝对效率的影响，而无法很直接的估计复杂度</p><p>另外，具体实现的常数有时很重要</p><p>和上一章的各种剪枝相比，这一章真的easy</p><h1 id="本文其它博客地址"><a href="#本文其它博客地址" class="headerlink" title="本文其它博客地址"></a>本文其它博客地址</h1><p>牛客: <a href="https://blog.nowcoder.net/n/911e9688897749a888ed979a19d1cf20" target="_blank" rel="noopener">https://blog.nowcoder.net/n/911e9688897749a888ed979a19d1cf20</a></p><p>博客园: <a href="https://www.cnblogs.com/CroMarmot/p/11130744.html" target="_blank" rel="noopener">https://www.cnblogs.com/CroMarmot/p/11130744.html</a></p>]]></content>
      
      
      <categories>
          
          <category> USACO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搜索 </tag>
            
            <tag> 模拟退火 </tag>
            
            <tag> 凸函数 </tag>
            
            <tag> 暴搜 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>USACO 6.3 章节 你对搜索和剪枝一无所知QAQ</title>
      <link href="/Blog/2019-07-01-USACO-6.3/"/>
      <url>/Blog/2019-07-01-USACO-6.3/</url>
      
        <content type="html"><![CDATA[<p>emmm……..很久很久以前 把6.2过了 所以emmmmmm 直接跳过 ，从6.1到6.3吧</p><h1 id="Fence-Rails"><a href="#Fence-Rails" class="headerlink" title="Fence Rails"></a>Fence Rails</h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p><code>N&lt;=50</code>个数<code>A1,A2...</code></p><p><code>1023</code>个数,每个数<code>数值&lt;=128</code>,B</p><p>问 A 们能拆分成多少个B,求最多的个数</p><p>样例 解释</p><pre><code>A:30=3040=18+19+350=15+16+17+225=24B:15 (ok)16 (ok)17 (ok)18 (ok)19 (ok)20212524 (ok)30 (ok)</code></pre><p>所以最多7个</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先 如果对B 排序，假设最优个数为k个</p><p>显然 如果k个可行，那么排序后的B 的前k个可行</p><p>又 如果k个可行那么k-1个可行，综上又满足二分</p><p>先 sort+二分+从大到小放b （第4个点就超时了）</p><pre><code class="c++">#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)using namespace std;const string filename = &quot;fence8&quot;;void usefile(){  freopen((filename+&quot;.in&quot;).c_str(),&quot;r&quot;,stdin);  freopen((filename+&quot;.out&quot;).c_str(),&quot;w&quot;,stdout);}int n;int a[100];int la[100];int suma;int R;int r[1100];int sumr[1100];int dfs(int idx){  per(i,0,n){    if(a[i] &lt; r[idx]){      return false;    }    if(a[i] ==  a[i+1] &amp;&amp; la[i] == la[i+1]){      continue;    }    if(la[i] &lt; r[idx]){      continue;    }    if(idx == 0){      return true;    }    la[i] -= r[idx];    int ret = dfs(idx-1);    la[i] += r[idx];    if(ret){      return true;    }  }  return false;}bool test(int idx){  if(sumr[idx] &gt; suma)return false;  return dfs(idx);}int main(){  usefile();  scanf(&quot;%d&quot;,&amp;n);  rep(i,0,n){    scanf(&quot;%d&quot;,a+i);  }  rep(i,0,n){    la[i]=a[i];    suma += a[i];  }  sort(a,a+n);  scanf(&quot;%d&quot;,&amp;R);  rep(i,0,R){    scanf(&quot;%d&quot;,r+i);  }  sort(r,r+R);  if(r[0] &gt; a[n-1]){    cout&lt;&lt;0&lt;&lt;endl;    return 0;  }  sumr[0]=r[0];  rep(i,1,R){    sumr[i]=sumr[i-1]+r[i];  }  int l=0,r=R;  while(l+1&lt;r){    int mid = (l+r)/2;    if(test(mid)){      l = mid;    }else{      r = mid;    }  }  cout&lt;&lt;l+1&lt;&lt;endl;  return 0;}</code></pre><p>对B 的枚举过程加了相同长度的枚举优化 tle 5</p><pre><code class="c++">int dfs(int idx,int stn = n){  per(i,0,stn){    if(a[i] &lt; r[idx]){      return false;    }    if(a[i] ==  a[i+1] &amp;&amp; la[i] == la[i+1]){      continue;    }    if(la[i] &lt; r[idx]){      continue;    }    if(idx == 0){      return true;    }    la[i] -= r[idx];    int ret;    if(r[idx] == r[idx+1]){      ret = dfs(idx-1,i+1);    }else{      ret = dfs(idx-1);    }    la[i] += r[idx];    if(ret){      return true;    }  }  return false;}</code></pre><p>增加了 无效残余木料 AC</p><pre><code class="c++">#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)using namespace std;const string filename = &quot;fence8&quot;;void usefile(){  freopen((filename+&quot;.in&quot;).c_str(),&quot;r&quot;,stdin);  freopen((filename+&quot;.out&quot;).c_str(),&quot;w&quot;,stdout);}int n;int a[100];int la[100];int suma;int R;int r[1100];int sumr[1100];int dfs(int idx,int stn = n){  if(suma &lt; sumr[idx]){    return false;  }  per(i,0,stn){    if(a[i] &lt; r[idx]){      return false;    }    if(a[i] ==  a[i+1] &amp;&amp; la[i] == la[i+1]){      continue;    }    if(la[i] &lt; r[idx]){      continue;    }    if(idx == 0){      return true;    }    la[i] -= r[idx];    suma-=r[idx];    bool predel = la[i] &lt; r[0];    if(predel){      suma -= la[i];    }    int ret;    if(idx &gt; 0 &amp;&amp; r[idx-1] == r[idx]){      ret = dfs(idx-1,i+1);    }else{      ret = dfs(idx-1);    }    if(predel){      suma += la[i];    }    suma+=r[idx];    la[i] += r[idx];    if(ret){      return true;    }  }  return false;}bool test(int idx){  if(sumr[idx] &gt; suma)return false;  return dfs(idx);}int main(){  usefile();  scanf(&quot;%d&quot;,&amp;n);  rep(i,0,n){    scanf(&quot;%d&quot;,a+i);  }  rep(i,0,n){    la[i]=a[i];    suma += a[i];  }  sort(a,a+n);  scanf(&quot;%d&quot;,&amp;R);  rep(i,0,R){    scanf(&quot;%d&quot;,r+i);  }  sort(r,r+R);  if(r[0] &gt; a[n-1]){    cout&lt;&lt;0&lt;&lt;endl;    return 0;  }  sumr[0]=r[0];  rep(i,1,R){    sumr[i]=sumr[i-1]+r[i];  }  int l=0,r=R;  while(l+1&lt;r){    int mid = (l+r)/2;    if(test(mid)){      l = mid;    }else{      r = mid;    }  }  cout&lt;&lt;l+1&lt;&lt;endl;  return 0;}</code></pre><p>综上 二分+暴搜+减枝+处理顺序贪心</p><h1 id="Cryptcowgraphy"><a href="#Cryptcowgraphy" class="headerlink" title="Cryptcowgraphy"></a>Cryptcowgraphy</h1><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>一个字符串能否通过 正数次操作使得变为</p><p><code>Begin the Escape execution at the Break of Dawn</code></p><p>一次操作: 选取 <code>...C...O...W...</code>,把<code>C-&gt;O</code>的字符串和<code>O-&gt;W</code>的字符串交换，然后去掉这三个选中<code>C</code>,<code>O</code>,<code>W</code></p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p><del>显然 特判打表</del></p><p>我们已经知道 目标串 和 起始串</p><p>所以如果可行，那么 个数关系有<code>C=O=W =(len(起始串)-len(目标串))/3</code>,所以预先筛选的一个优化是，统计各个字符的个数，和目标串进行比较</p><p>所以 当比较是<code>可能</code>时，答案要么0 0,要么 1 字母C 的个数</p><p>我们可以优化的点</p><ol><li>字母个数统计</li><li>被C O W 分割的在任意时刻是 目标串的子串</li><li>搜索顺序先O</li><li>字符串hash [注意 这个方法 如果你是在打cf，那么很可能被hack</li></ol><p>注意输入是一行….所以不要<code>scanf %s</code></p><pre><code class="c++">#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)using namespace std;const string filename = &quot;cryptcow&quot;;void usefile(){  freopen((filename+&quot;.in&quot;).c_str(),&quot;r&quot;,stdin);  freopen((filename+&quot;.out&quot;).c_str(),&quot;w&quot;,stdout);}const char Goal[] = &quot;Begin the Escape execution at the Break of Dawn&quot;;const int Mod = 999983;char s[110];int ans, cnt;bool hsh[Mod];// 删除a b c位置上的, 交换a-&gt;b b-&gt;cvoid work(int a, int b, int c) {  static char tmp[100];  int len = strlen(s), tot = 0;  for(int i = 0; i &lt; a; ++i) {    tmp[tot++] = s[i];  }  for(int i = b + 1; i &lt; c; ++i) {    tmp[tot++] = s[i];  }  for(int i = a + 1; i &lt; b; ++i) {    tmp[tot++] = s[i];  }  for(int i = c + 1; i &lt; len; ++i) {    tmp[tot++] = s[i];  }  tmp[tot] = 0;  strcpy(s, tmp);}int getHash() {  int ret = 0, len = strlen(s);  for(int i = 0; i &lt; len; ++i) {    int num = (s[i]==&#39; &#39;)?1:(isupper(s[i]) ? s[i] - &#39;A&#39; + 2 : s[i] - &#39;a&#39; + 28);    ret = (ret * 57 + num) % Mod;  }  return ret;}bool dfs(int depth) {  if(strcmp(s, Goal) == 0) {    ans = depth;    return true;  }  int x = getHash();  if(hsh[x]) {    return false;  }  hsh[x] = true;  ++cnt;  // 被C O W 分割的 字串应该是Goal的连续子串  static char sub[100];  int len = strlen(s);  int c[20], o[20], w[20];  c[0] = o[0] = w[0] = 0;  for(int i = 0, j = 0; i &lt; len; ++i) {    if(s[i] == &#39;C&#39; || s[i] == &#39;O&#39; || s[i] == &#39;W&#39;) {      if(s[i] == &#39;C&#39;) {        c[++c[0]] = i;      }      if(s[i] == &#39;O&#39;) {        o[++o[0]] = i;      }      if(s[i] == &#39;W&#39;) {        w[++w[0]] = i;      }      sub[j] = 0;      if(!strstr(Goal, sub)) { //        return false;      }      j = 0;    }    else {      sub[j++] = s[i];    }  }  // C = W = O  if(o[0] != c[0] || o[0] != w[0] || w[0] != c[0]) {    return false;  }  char pre[100];  strcpy(pre, s); // 递归暂存  // 查找顺序 先找O  rep(j,1,o[0]+1){    per(k,1,w[0]+1){      if(w[k] &lt; o[j])break;      rep(i,1,c[0]+1){      if(c[i] &gt; o[j])break;        work(c[i], o[j], w[k]);        bool ret = dfs(depth + 1);        if(ret){          return true;        }        if(cnt &gt; 200000) { // ............................          return false;        }        strcpy(s, pre);      }    }  }  return false;}int main() {  usefile();  cin.getline(s,100);  // scanf(&quot;%s&quot;,s);  int ret = dfs(0);  printf(&quot;%d %d\n&quot;, ret, ans);  return 0;}</code></pre><h1 id="Cowcycles"><a href="#Cowcycles" class="headerlink" title="Cowcycles"></a>Cowcycles</h1><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p><code>25 &lt;= F1 &lt; F2 &lt;= 80</code></p><p>在<code>[F1,F2]</code>范围找<code>[1,5]</code>个数<code>f1,f2..</code></p><p><code>5 &lt;= R1 &lt; R2 &lt;= 40</code></p><p>在<code>[R1,R2]</code>范围找<code>[1,10]</code>个数<code>r1,r2..</code></p><p><code>ratio(i,j) = fi/rj</code></p><p>在<code>max ratio/min ratio &gt;= 3</code>的限制下</p><p>把所有<code>ratio(i,j)</code>排序，最小化 排序后数组<code>相邻值 的差 的方差</code></p><p>求具体方案</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p><code>ratio(i1,j1)/ratio(i2,j2) = i1*j2/i2*j1</code></p><p>要使这个值的最大值大于3,注意到都是正数，也就是<code>(max(i)*max(j))/(min(i)*min(j)) &gt;= 3</code></p><p>然后因为ratio要先sort，再最小化 差 的方差，就感觉 无路可推，只能暴搜</p><p>优化</p><ol start="0"><li>默认的限制减枝</li><li>个数少，运算过程相对有序 –&gt; 计算顺序+插入排序</li><li>搜一搜初中的方差变形公式，省掉最外层的<code>1/n</code> 有只用比较<code>sum{平方}+(sum{}平方)/n</code></li></ol><p><strong>注意</strong> 以下代码过了USACO 但是有潜在风险，<code>浮点数比大小！！</code> 如果是打cf，可能会被叉</p><pre><code class="c++">#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)using namespace std;const string filename = &quot;cowcycle&quot;;void usefile(){  freopen((filename+&quot;.in&quot;).c_str(),&quot;r&quot;,stdin);  freopen((filename+&quot;.out&quot;).c_str(),&quot;w&quot;,stdout);}int s1[20],s2[20];int ans1[20],ans2[20];int F,F1,F2;int R,R1,R2;int cnt;double rate[100],diff[100];double minvf=10000000;void count(){  int k=0;  double sum=0,avg,vf=0,sumf=0,p;  // 数据量小 采用插入排序  rep(i,0,F){    rep(j,0,R){      p=(double)s1[i]/s2[j];      int l=++k;      while (rate[l-1]&gt;=p) {        rate[l]=rate[l-1];        l--;      }      rate[l]=p;    }  }  rep(i,1,cnt){    diff[i]=rate[i+1]-rate[i];    sum+=diff[i];    sumf+=diff[i]*diff[i];  }  avg=sum/(cnt-1);// 相邻值的差的个数 比值的个数少1  vf=sumf-sum*avg;  if (vf&lt;minvf)  {    minvf=vf;    memcpy(ans1,s1,sizeof(int)*F);    memcpy(ans2,s2,sizeof(int)*R);  }}// 枚举后齿轮 从w 到R2-R+k+1void sc2(int k,int w){  if (k==R){    if (s1[F-1]*s2[R-1]&lt;3*s1[0]*s2[0]) // 题目限制条件剪枝      return;    count();    return;  }  rep(i,w,R2-R+k+2){    s2[k]=i;    sc2(k+1,i+1);  }}// 枚举前齿轮 从w到F2-F+k+1void sc1(int k,int w){  if (k==F)  {    sc2(0,R1);    return;  }  rep(i,w,F2-F+k+2){    s1[k]=i;    sc1(k+1,i+1);  }}int main() {  usefile();  cin&gt;&gt; F &gt;&gt; R &gt;&gt; F1 &gt;&gt; F2 &gt;&gt; R1 &gt;&gt; R2;  cnt=F*R;  sc1(0,F1);  rep(i,0,F){    cout &lt;&lt; ans1[i] &lt;&lt; &quot; \n&quot;[i==F-1];  }  rep(i,0,R){    cout &lt;&lt; ans2[i] &lt;&lt; &quot; \n&quot;[i==R-1];  }  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>搜索+剪枝，剪究竟要怎么剪</p><p>引用一个大佬的话<code>https://apps.topcoder.com/forums/?module=Thread&amp;threadID=669047&amp;start=0&amp;mc=6#1216077</code></p><p>Well, if the optimizations change the complexity of the solution asymptotically, you can quite sure.</p><p>Otherwise you can’t depend on anything, I think.</p><p>重要的是 找到 能明确改变算法 复杂度的剪枝。</p><p><strong>反过来分析</strong></p><blockquote><p>第1题</p></blockquote><p>剩余 体积 处理，应该能优化了搜索树的叶节点个数，十分关键</p><p>重复体积的搜索处理，优化了枚举体积的次数，对相同体积有多个的情况，从 <code>可放空间数</code>的<code>相同个数</code>次方，优化到了？？？，不知道怎么表示，但是 大量减少了重复枚举是肯定的</p><p>从大到小尝试，优化了末端个数？（吗）</p><blockquote><p>第2题</p></blockquote><p>对于错误的预处理 直接一边就否定掉了</p><p>目标串的子串是一个有效的大优化，当 在 去掉COW 以后，连接出了 不应该的字符串，可以立刻剪掉，对搜索空间优化大</p><p>搜索顺序 先O 还好 大概是常数倍数优化</p><p>字符串hash，除了上面的方法，还可以 用其它的 比如神奇的偏移+异或字符串等等， 优化的是很大的字符串比较代价，常数倍数</p><blockquote><p>第3题</p></blockquote><p>基本没有剪枝[题目限制的剪枝是当然</p><p>主要靠的是算法使用的性能优化</p><p>优化 排序[数量少的时候插入,在具体工程实践中，数量较少的时候 也同样会采取 数组取代map 进行遍历，冒泡取代其它排序 ]</p><p>优化 方差运算，目前这样公式变化 </p><p>默认 <code>n-1</code>次加法 1次除法，算平均数，<code>n</code>次减法,<code>n</code>次乘法,<code>n-1</code>次加法得到结果</p><p>优化后 <code>2(n-1)</code>次加法 1次除法,<code>1</code>次减法<code>n+1</code>次乘法,得到结果</p><p>假设所有 运算类型时间代价相同，那么算是优化掉了约<code>1/4</code>时间[然而一般来说减法的速度是比乘除快很多，再加上CPU的指令pipeline运算优化，可能影响有，但不大</p><h1 id="本文其它博客链接"><a href="#本文其它博客链接" class="headerlink" title="本文其它博客链接"></a>本文其它博客链接</h1><p>牛客:<a href="https://blog.nowcoder.net/n/2773db6ff811467a922070d9a5c64a39" target="_blank" rel="noopener">https://blog.nowcoder.net/n/2773db6ff811467a922070d9a5c64a39</a></p><p>博客园:<a href="https://www.cnblogs.com/CroMarmot/p/11130744.html" target="_blank" rel="noopener">https://www.cnblogs.com/CroMarmot/p/11130744.html</a></p>]]></content>
      
      
      <categories>
          
          <category> USACO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搜索 </tag>
            
            <tag> 剪枝 </tag>
            
            <tag> 二分 </tag>
            
            <tag> 字符串hash </tag>
            
            <tag> 搜索顺序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>USACO 6.1 章节</title>
      <link href="/Blog/2019-06-26-USACO-6.1/"/>
      <url>/Blog/2019-06-26-USACO-6.1/</url>
      
        <content type="html"><![CDATA[<h1 id="Postal-Vans"><a href="#Postal-Vans" class="headerlink" title="Postal Vans"></a>Postal Vans</h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p><code>4*n</code>的网格，要经过所有点的有向有环，不重复经过点的路径总数</p><p><code>n&lt;=1000</code></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>显然 插头dp</p><p>以4为切面</p><p>问题是，会发现 超精度</p><p>解决呢要么实现高精度，要么换python XD</p><p>c++实现 未+高精度，会爆掉</p><pre><code class="c++">#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)using namespace std;const string filename = &quot;vans&quot;;void usefile(){  freopen((filename+&quot;.in&quot;).c_str(),&quot;r&quot;,stdin);  freopen((filename+&quot;.out&quot;).c_str(),&quot;w&quot;,stdout);}int n;const int S1001 = 0;const int S1122 = 1;const int S1100 = 2;const int S0110 = 3;const int S0011 = 4;const int S1221 = 5;const int S0000 = 6;long long dp[1010][10];int s2[10][10];void init(){  s2[S1001][S0000] = 1;  s2[S1001][S1100] = 1;  s2[S1001][S0110] = 1;  s2[S1001][S0011] = 1;  s2[S1001][S1221] = 1;  s2[S1122][S1001] = 1;  s2[S1122][S1122] = 1;  // s2[S1122][S1100] = 1; 不应该自闭  // s2[S1122][S0011] = 1; 不应该自闭  // s2[S1122][S0000] = 1; 不应该自闭  s2[S1100][S1122] = 1;  s2[S1100][S1001] = 1;  s2[S0110][S1001] = 1;  s2[S0011][S1122] = 1;  s2[S0011][S1001] = 1;  // s2[S1221][S1001] = 1; 不应该自闭  s2[S1221][S0000] = 1;  s2[S1221][S1100] = 1;  s2[S1221][S0011] = 1;  s2[S1221][S1221] = 1;}int main(){  usefile();  init();  cin&gt;&gt;n;  dp[0][S1001] = 1;  dp[0][S1122] = 1;  rep(i,1,n){    rep(stateS,0,6){      rep(stateE,0,7){        if(s2[stateS][stateE]){          dp[i][stateE]+=dp[i-1][stateS];        }      }    }  }  // rep(i,0,n){  //   rep(state,0,7){  //     cout&lt;&lt;dp[i][state]&lt;&lt;&quot;\t&quot;;  //   }  //   cout&lt;&lt;endl;  // }  cout&lt;&lt;dp[n-1][S0000]*2&lt;&lt;endl;  return 0;}</code></pre><p>增加高精度</p><pre><code class="c++">#include &lt;bits/stdc++.h&gt;typedef long long ll;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)#define pb push_backusing namespace std;const string filename = &quot;vans&quot;;void usefile(){  freopen((filename+&quot;.in&quot;).c_str(),&quot;r&quot;,stdin);  freopen((filename+&quot;.out&quot;).c_str(),&quot;w&quot;,stdout);}class hpa{  int DIGITS = 100&#39;000&#39;000; // 08lld  vector&lt;ll&gt;vals;public:  hpa(){  }  hpa(ll v){    vals.pb(v);  }  void print(){    if(vals.size() == 0){      printf(&quot;0&quot;);      return;    }    printf(&quot;%lld&quot;,vals[vals.size()-1]);    per(i,0,vals.size()-1){      printf(&quot;%08lld&quot;,vals[i]);    }  }  hpa operator +(const hpa &amp;another) const {    hpa ret;    rep(i,0,vals.size()){      ret.vals.pb(vals[i]);    }    rep(i,0,another.vals.size()){      if(i &gt;= ret.vals.size()){        ret.vals.pb(another.vals[i]);      }else{        ret.vals[i]+=another.vals[i];        if(ret.vals[i] &gt;= DIGITS){          if(i == ret.vals.size()-1){            ret.vals.pb(0);          }          ret.vals[i+1]+=ret.vals[i]/DIGITS;          ret.vals[i]%=DIGITS;        }      }    }    return ret;  }};int n;const int S1001 = 0;const int S1122 = 1;const int S1100 = 2;const int S0110 = 3;const int S0011 = 4;const int S1221 = 5;const int S0000 = 6;hpa dp[1010][10];int s2[10][10];void init(){  s2[S1001][S0000] = 1;  s2[S1001][S1100] = 1;  s2[S1001][S0110] = 1;  s2[S1001][S0011] = 1;  s2[S1001][S1221] = 1;  s2[S1122][S1001] = 1;  s2[S1122][S1122] = 1;  // s2[S1122][S1100] = 1; 不应该自闭  // s2[S1122][S0011] = 1; 不应该自闭  // s2[S1122][S0000] = 1; 不应该自闭  s2[S1100][S1122] = 1;  s2[S1100][S1001] = 1;  s2[S0110][S1001] = 1;  s2[S0011][S1122] = 1;  s2[S0011][S1001] = 1;  // s2[S1221][S1001] = 1; 不应该自闭  s2[S1221][S0000] = 1;  s2[S1221][S1100] = 1;  s2[S1221][S0011] = 1;  s2[S1221][S1221] = 1;}int main(){  usefile();  init();  cin&gt;&gt;n;  dp[0][S1001] = 2;  dp[0][S1122] = 2;  rep(i,1,n){    rep(stateS,0,6){      rep(stateE,0,7){        if(s2[stateS][stateE]){          dp[i][stateE]=(dp[i][stateE]+dp[i-1][stateS]);        }      }    }  }  // rep(i,0,n){  //   rep(state,0,7){  //     cout&lt;&lt;dp[i][state]&lt;&lt;&quot;\t&quot;;  //   }  //   cout&lt;&lt;endl;  // }  dp[n-1][S0000].print();  printf(&quot;\n&quot;);  return 0;}</code></pre><h1 id="A-Rectangular-Barn"><a href="#A-Rectangular-Barn" class="headerlink" title="A Rectangular Barn"></a>A Rectangular Barn</h1><p>Mircea Pasoi – 2003</p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p><code>(&lt;=3000)*(&lt;=3000)</code>的矩阵</p><p>上面有<code>&lt;=30000</code> 个坏点</p><p>求 最大不含坏点的矩形面积</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>因为求的是最大矩形，那么它的四周要么是边界，要么是坏点</p><p>证明：反证明</p><p>如果存在一条边既没有邻接 边界，也没有邻接坏点。</p><p>那么对该边延伸 ，可以得到更大的矩形，矛盾</p><p>观察到这个性质后</p><p>我们考虑对任意 点<code>(i,j)</code></p><p>以 <code>i0&lt;i</code>,其中<code>(i0,j)</code>为距离<code>(i,j)</code>最远的点 且 线段<code>(i0-&gt;i,j)</code>上无坏点</p><p>线<code>(i0-&gt;i,j)</code>为高，做横向扩张，找左右两侧的最近的坏点 或边界，则有以<code>(i,j)</code>搜寻的矩形面积<code>=(i0-&gt;i,j) * 该线段左右扩张的最大宽度</code></p><ol><li>这样找到的矩形 一定是 合法矩形 所以这样找到的矩形面积小于等于 最大面积</li><li>这样一定能找到最大的矩形，因为我们证明了最大矩形 一定邻接着坏点或边界，那么该最大矩形上方边界所对应的 坏点，正下方的的点 在运算过程会计算到</li></ol><p>所以<code>O(3000*3000)</code>,以所有点计算出一个矩形，每个矩形计算复杂度为<code>O(1)</code>,即可</p><pre><code class="c++">#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)using namespace std;const string filename = &quot;rectbarn&quot;;void usefile(){  freopen((filename+&quot;.in&quot;).c_str(),&quot;r&quot;,stdin);  freopen((filename+&quot;.out&quot;).c_str(),&quot;w&quot;,stdout);}int L[3010],R[3010]; // j列当前线段 左右扩展的可行最远距离int H[3010]; // j列 当前 的线段长度bool g[3010][3010];int n,m,ans;int main(){  usefile();  freopen(&quot;rectbarn.in&quot;,&quot;r&quot;,stdin);  freopen(&quot;rectbarn.out&quot;,&quot;w&quot;,stdout);  int k;  cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;  while(k--){    int i,j;    scanf(&quot;%d%d&quot;,&amp;i,&amp;j);    g[i][j]=1;  }  rep(j,0,m+1){    H[j]=0;    L[j]=1;    R[j]=m;  }  rep(i,1,n+1){    // 处理所有 坏点    rep(j,1,m+1){      if(g[i][j]){        H[j]=0;        L[j]=1;        R[j]=m;      }    }    // 计算所有 左侧 和 右侧 最远    int lm = 1;    rep(j,1,m+1){      if(!g[i][j]){        H[j]++;        L[j]=max(L[j],lm);      } else{        lm=j+1;      }    }    int rm = m;    per(j,1,m+1){      if(!g[i][j]){        R[j]=min(R[j],rm);      }else{        rm=j-1;      }    }    // 计算面积    rep(j,1,m+1){      if(!g[i][j]){        ans=max(ans,(R[j]-L[j]+1)*H[j]);      }    }  }  printf(&quot;%d\n&quot;,ans);  return 0;}</code></pre><h1 id="Cow-XOR"><a href="#Cow-XOR" class="headerlink" title="Cow XOR"></a>Cow XOR</h1><p>Adrian Vladu – 2005</p><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p><code>n(&lt;=100,000)</code>个数,数值范围是<code>[0,2^21 - 1]</code></p><p>求连续子区间 的最大xor值，输出 最大xor值，区间起始点，区间结束点</p><p>如果有多个区间满足最大异或，返回结束点index最小的，如果还有多个，返回长度最短的。</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>首先</p><p>我们证明一下题目描述的结果唯一</p><p>如果多个 子区间 异或值相同，且结束点不同，那么 只有唯一可以选</p><p>如果两个 子区间 异或值相同，且结束点相同，那么 它们一定起始点不同，所以它们长度不同，只有最短可选</p><p>综上，题目描述结果唯一</p><p>然后</p><p>显然</p><p><code>xor[l-&gt;r] = xor[1-&gt;l-1]^xor[1-&gt;r]</code></p><p>所以 我们要找最大值，等于找两个前缀异或的最大值</p><p>从高位到低位，对所有前缀建立trie树,再for一遍贪心走trie树,贪心规则 有和当前位不同的走不同的路径，否则才走相同,（尽量在高位产生1）</p><p>空间 <code>O(n*21)</code>,时间<code>O(n*21)</code></p><p>空间节点数</p><pre><code class="python">s=0;for i in range(0,22):    s+=min(2**i,100000)print(s)</code></pre><p><code>631071</code> 个，然而 我开这么大会炸空间，开<code>500000</code>过的 （按道理讲 这样空间上看是开得有问题，开小了，不过过了测试）</p><p>我在实现过程中是找 区间左右端点靠的是 <code>lower_bound</code>二分，多用了空间,</p><p>然而，我们发现 最优区间必定有一个是 其前缀值的最小坐标</p><p>所以 如果枚举<code>i</code>去寻找 其期望的 前缀值对应的最小坐标，一定能找到最优值,可以优化</p><p>通过的，但空间开得不合理的代码,(我之前还用<code>struct</code>来写，虽然阅读上更好理解，但空间更加不够XD)</p><pre><code class="c++">#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)using namespace std;const string filename = &quot;cowxor&quot;;void usefile(){  freopen((filename+&quot;.in&quot;).c_str(),&quot;r&quot;,stdin);  freopen((filename+&quot;.out&quot;).c_str(),&quot;w&quot;,stdout);}int n;int a[100010];int p[100010];int ns[500010][2];int nsi=0;int *root = ns[nsi++];map&lt;int,vector&lt;int&gt; &gt; pv2idx; // 前缀异或 到 下表void build(int idx){  int v = p[idx];  pv2idx[v].push_back(idx); // ordered  int * po = root;  per(i,1,21){    int bit = !!(v&amp;(1&lt;&lt;i));    if(!po[bit]){      po[bit] = nsi++;    }    po=ns[po[bit]];  }  int bit = !!(v&amp;1);  po[bit] = v;}int query(int idx){  int v = p[idx];  int * po = root;  per(i,1,21){    int bit = !(v&amp;(1&lt;&lt;i));    if(!po[bit]){      po = ns[po[bit^1]];    }else{      po = ns[po[bit]];    }  }  int bit = !(v&amp;1);  return po[bit] == 0?po[bit^1]:po[bit];}int ans=-1,ansl,ansr;void setAns(int v1,int l,int r){  // cout&lt;&lt;&quot;SETANS:&quot;&lt;&lt;v1&lt;&lt;&quot; l:&quot;&lt;&lt;l&lt;&lt;&quot; r:&quot;&lt;&lt;r&lt;&lt;endl;  if(l &gt; r){    swap(l,r);  }  if(v1 &lt; ans)return;  if(v1 &gt; ans){    ans = v1;    ansl = l;    ansr = r;    return ;  }  if(r &lt; ansr){    ansl = l;    ansr = r;    return ;  }  if(r &gt; ansr){    return ;  }  if(l &gt; ansl){    ansl = l;    return ;  }}int main(){  usefile();  scanf(&quot;%d&quot;,&amp;n);  rep(i,0,n){    scanf(&quot;%d&quot;,a+i);  }  rep(i,0,n){    p[i+1]=p[i]^a[i];  }  rep(i,0,n+1){    build(i);  }  // for(auto item:pv2idx){  //   cout&lt;&lt;&quot;--------&quot;&lt;&lt;item.first&lt;&lt;endl;  //   for(auto z:item.second){  //     cout&lt;&lt;z&lt;&lt;&quot;\t&quot;&lt;&lt;endl;  //   }  //   cout&lt;&lt;endl;  // }  rep(i,0,n+1){    int ret = query(i);    int reti = lower_bound(pv2idx[ret].begin(),pv2idx[ret].end(),i)-pv2idx[ret].begin();    // cout&lt;&lt;&quot;find:&quot;&lt;&lt;i&lt;&lt;&quot;[&quot;&lt;&lt;p[i]&lt;&lt;&quot;]:&quot;&lt;&lt;ret&lt;&lt;&quot;(&quot;&lt;&lt;pv2idx[ret][reti]&lt;&lt;&quot;)&quot;&lt;&lt;endl;    if(ret == p[i]){      if(i &gt; 0){        setAns(ret^p[i],i-1,i);      }    }else if(reti &gt; 0){      setAns(ret^p[i],i,pv2idx[ret][reti-1]);    }else{      setAns(ret^p[i],i,pv2idx[ret][reti]);    }  }  printf(&quot;%d %d %d\n&quot;,ans,ansl+1,ansr);  return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> USACO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 插头DP </tag>
            
            <tag> 高精度 </tag>
            
            <tag> 高精度加法 </tag>
            
            <tag> 最大子矩阵 </tag>
            
            <tag> 模型分析 </tag>
            
            <tag> 异或前缀 </tag>
            
            <tag> trie树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>USACO 5.5 章节</title>
      <link href="/Blog/2019-06-25-USACO-5.5/"/>
      <url>/Blog/2019-06-25-USACO-5.5/</url>
      
        <content type="html"><![CDATA[<h1 id="Picture"><a href="#Picture" class="headerlink" title="Picture"></a>Picture</h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>IOI 1998</p><p>求n (&lt;=5000)个矩形 覆盖的图形 的周长(包括洞), 坐标范围<code>[-10000,10000]</code></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>一眼离散化+2维线段树，但仔细一想 空间不太够,时间勉强接受</p><p>然后目测可能1维线段树+扫描线了?</p><p>然后 竟然 裸的扫描线可以过，如下面代码</p><p>总数量级上来讲，输入<code>O(n)</code>,排序<code>O(n log n)</code>,扫描过程<code>O(sum(len周长))</code> 约<code>5000*20000*4</code>的上限[ 不过USACO给过了，</p><p>所以还是线段树好?</p><p>从实现来讲，把矩形拆分成x和y方向，靠计算每个块的累计层数 来判断边界</p><pre><code class="c++">#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)using namespace std;const string filename = &quot;picture&quot;;void usefile(){  freopen((filename+&quot;.in&quot;).c_str(),&quot;r&quot;,stdin);  freopen((filename+&quot;.out&quot;).c_str(),&quot;w&quot;,stdout);}int N,ans=0;// OX向和OY向的 线段分离处理，互不影响tuple&lt;int,bool,int,int&gt; Lx[10010],Ly[10010]; // {位置idx坐标,结束边bool?,st-&gt;end}int level[20010];void Scan(tuple&lt;int,bool,int,int&gt; *L) {  sort(L,L+N);  rep(i,0,20001)    level[i]=0;  rep(i,0,N){    rep(j,get&lt;2&gt;(L[i]),get&lt;3&gt;(L[i])){      if (!get&lt;1&gt;(L[i])){        ans += level[j+10000]==0;        level[j+10000]++;      } else {        level[j+10000]--;        ans += level[j+10000]==0;      }    }  }}int main(){  usefile();  scanf(&quot;%d&quot;,&amp;N);  rep(i,0,N){    int x1,x2,y1,y2;    scanf(&quot;%d %d %d %d&quot;,&amp;x1,&amp;y1,&amp;x2,&amp;y2);    // OX 方向边    Lx[i*2] = {y1,false,x1,x2};    Lx[i*2+1] = {y2,true,x1,x2};    // OY 方向边    Ly[i*2] = {x1,false,y1,y2};    Ly[i*2+1] = {x2,true,y1,y2};  }  N*=2;  Scan(Lx);  Scan(Ly);  printf(&quot;%d\n&quot;,ans);  return 0;}</code></pre><h1 id="Hidden-Password"><a href="#Hidden-Password" class="headerlink" title="Hidden Password"></a>Hidden Password</h1><p>ACM South Eastern Europe – 2003</p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>字符串L(长度<code>&lt;=100’000</code>)</p><p>求 以该字符串，平移后的， 所有字符串中 字典序最小的字符串的首字母在原字符串中的下标</p><p>如cba</p><p>所有字符串 acb bac cab, (排序后),第一个字符串首字母对应原来字符串位置为2 (从0计数)</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>枚举！</p><p>这样 我们首先找到最小字母 扫一遍<code>O(n)</code></p><p>然后找到这些开始的坐标</p><p>逐步增加长度</p><p>那么我们由递归关系，保证每次增加长度后，当前还剩余的坐标只有最小的留下，</p><p>因此当增加长度到<code>l</code>时，我们 的维持的起始坐标是 整个字符串里，长度从<code>1</code>到<code>l</code>都是字典序最小的</p><p>那么我们有两种长度改变方式</p><ol start="0"><li>+1</li></ol><p>假设所有点按照长度扩充 都不属于当前维护的点，那么，长度加1，保留，增加字符最小的点</p><p>例子 <code>abcabdzzzabc</code></p><p>初始所有<code>a</code>的坐标<code>[0,3,9]</code>，长度<code>1</code></p><p>扩充，扩充目标分别为<code>[1,4,10]</code>，都不是当前维护的点(<code>[0,3,9]</code>)</p><p>所以比较元素，全为b，长度<code>=1+1=2</code></p><p>接下来，扩充目标为<code>[2,5,11]</code>,也都不是维护的点</p><p>比较字符，两个<code>abc</code>,一个<code>abd</code>,所以维护的点变为<code>[0,9]</code>,长度变为<code>=2+1=3</code></p><p>再扩充，扩充目标为<code>[3,0]</code>,注意到<code>0</code>是我们当前维护的<code>[0,9]</code>中的元素，所以不采取<code>+1</code>的方案</p><ol><li>倍增</li></ol><p>假设字符aabbabbb，</p><p>那么在找完最小字符后，起始坐标还剩下<code>[0,1,4]</code>,一旦发现任意一个扩充的下一步(<code>[1,2,5]</code>) 是一个维持的点，那么长度翻倍，后一个点删除，在这种情况下，扩充的位置不是最小坐标的点直接移除。</p><p>因为我们维持的点 == 从1到该长度下，每个长度 都是字典序最小的，所以没有在维护中的点，都是非字典序最小的,所以 可以倍增</p><p>删除右边的点是因为 扩充右边的维护点的字典序一定大于等于 左边的点，等于的情况由判环处理</p><p>如上在一次扩充后发现<code>0</code>的下一个扩充是<code>1</code>，而<code>1</code>是我们维持着的点，所以长度=<code>1*2</code>,<code>1</code>点删除，<code>4</code>扩充是<code>5</code>，那么<code>5</code>没有被维持，所以<code>4</code>点也被删除，综上最后剩下<code>0</code></p><blockquote><p>以上描述存在的问题：起始点是哪个点？</p></blockquote><p>假设字符串 <code>aaazzaaza</code>,</p><p>显然在初始操作后 需要维护的点有<code>[0,1,2,5,6,8]</code></p><p>注意到，如果从左向右来处理，按照上面的算法会 变成<code>[0,6,8???]</code>,而实际 从环的性质来看，期望的应该是得到<code>[1,6,8]</code>，也就是<code>8</code>位置的看做<code>[8,0,1,2]</code>这一段的起始点。</p><p>这里加一个父节点的查找，找到环意义上该点所对应的最左的点即可，在下方函数看的话就是<code>circle</code>,</p><p>同时，<code>circle</code>这里如果发现，整个保存的点构成了环,那么也就是 这些点仅对于环上字典序的等价了，根据题目期望这种情况下最小index，就取出即是答案</p><hr><p>空间复杂度，emmmm没啥好说，看变量即可，维持在<code>O(n)</code></p><p>时间复杂度,</p><p>每一次倍增会让点数至少除以2，因为一个点要留下来，那么首先它的扩展点要在原来的维护里，并且下一次维护需要消失，所以每次要留一个点，就一定要删一个点，还有的点不会被留下，所以留下的一定小于等于上一次的一半</p><p><code>O(n+n/2+n/4) = O(2n) = O(n)</code></p><p>考虑对任意长度，都是执行+1，那么每次能执行+1的限度为</p><p><code>sum(n*(1+1/2+...1/n))</code></p><p><del>众所周知这是一个无穷级数，所以时间复杂度无穷大</del></p><p>大自也是<code>O(12n)=O(n)</code>的复杂度，</p><p>下面就是实际上，是这两种穿插 ，那么一定小于等于<code>O(2n+12n)=O(n)</code>, (数学的习惯懒得分类讨论不等的情况 能用就行，所以留一个等于)</p><p>综上 时间空间均满足</p><pre><code class="c++">char s[100010];int sz=0;bool pos[100010];vector&lt;int&gt;p;vector&lt;int&gt;q;int L;bool circle(int idx,int len,int &amp;newidx){  newidx = (idx+L-len)%L;  while(newidx != idx){    if(!pos[newidx]){      (newidx+=len)%=L;      return false;    }else{      newidx = (newidx+L-len)%L;    }  }  while(newidx - L &gt; 0){    newidx -= L;  }  printf(&quot;%d\n&quot;,newidx);  return true;}int main(){  usefile();  // 同步增长，冲突取前，倍增 其余删除(因为保证最小)  scanf(&quot;%d&quot;,&amp;L);  while(sz&lt;L){    scanf(&quot;%s&quot;,s+sz);    sz+=strlen(s+sz);  }  char minch = s[0];  rep(i,1,L){    minch = min(minch,s[i]);  }  rep(i,0,L){    if(s[i] == minch){      p.push_back(i);      pos[i]=true;    }  }  int l = 1;  while(p.size() &gt; 1){    int state = 0; // 0 for +1, 1 for *2    minch = s[(p[0]+l)%L];    for(auto idx : p){      if(pos[(idx+l)%L] == true){        state = 1;        break;      }      minch = min(minch,s[(idx+l)%L]);    }    if(state == 0){      q.clear();      for(auto idx:p){        if(!pos[idx])continue;        if(s[(idx+l)%L] == minch){          q.push_back(idx);        }else{          pos[idx]=false;        }      }      p=q;      l++;    }else{      q.clear();      int startidx ;      int ret = circle(p[0],l,startidx);      if(ret){        return 0;      }      int pidx = 0;      for(pidx=0;pidx&lt;p.size();pidx++){        if(p[pidx] == startidx){          break;        }      }      rep(i,pidx,p.size()){        int idx = p[i];        if(!pos[idx])continue;        if(pos[(idx+l)%L]){          q.push_back(idx);          pos[(idx+l)%L] = false;        }else{          pos[idx]=false;        }      }      rep(i,0,pidx){        int idx = p[i];        if(!pos[idx])continue;        if(pos[(idx+l)%L]){          q.push_back(idx);          pos[(idx+l)%L] = false;        }else{          pos[idx]=false;        }      }      p=q;      l*=2;    }  }  printf(&quot;%d\n&quot;,p[0]);  return 0;}</code></pre><h1 id="Twofive"><a href="#Twofive" class="headerlink" title="Twofive"></a>Twofive</h1><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>IOI 2001</p><p><code>A到Y</code>构成的排列，满足 把这<code>25</code>个字母排成 <code>5*5</code>矩阵后 每行每列，单调递增，则为合法的</p><p>所有合法的排列，按照字典序 排序</p><p>请编写 字典序序号 到字符串  和 字符串反向转换为字典序序号的程序</p><h2 id="尝试思路"><a href="#尝试思路" class="headerlink" title="尝试思路"></a>尝试思路</h2><p>看数据量，我自己也估计不到实际大小于是先写了一个打表，(上界 是<code>25!</code>但是有限制所以不知道是否会降低</p><pre><code class="c++">#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)using namespace std;const string filename = &quot;twofive&quot;;void usefile(){  freopen((filename+&quot;.in&quot;).c_str(),&quot;r&quot;,stdin);  freopen((filename+&quot;.out&quot;).c_str(),&quot;w&quot;,stdout);}int chars[30];int vis[30];int cnt = 0;void print(){  cout&lt;&lt;endl;  rep(i,0,5){    rep(j,0,5){      cout&lt;&lt;char(chars[i*5+j]+&#39;a&#39;)&lt;&lt;&quot; &quot;;    }    cout&lt;&lt;endl;  }}void gen(int idx){  if(idx%5==0){    rep(i,0,25){      if(vis[i] == 0){        vis[i]=1;        chars[idx] = i;        gen(idx+1);        vis[i]=0;        return ;      }    }  }  if(idx == 24){    cnt++;    chars[24]=24;    print();    return ;  }  int sti = chars[idx-1];  if(idx&gt;5){    sti=min(sti,chars[idx-5]);  }  rep(i,sti+1,26-(5-idx%5)*(5-idx/5)){    if(vis[i])continue;    vis[i]=1;    chars[idx] = i;    gen(idx+1);    vis[i]=0;  }}int main(){  // usefile();  gen(0);  cout&lt;&lt;cnt&lt;&lt;endl;  return 0;}</code></pre><p>跑了一下大概</p><pre><code>7951237a b c d e f g h l n i m k q w j p o r u s t v x y </code></pre><p>以上的改动才到<code>i</code>,说明 数量级上，不可能期望打表了</p><p>接下来，注意到，如果我们有方法从数字序号转换到 对应的单词，那么 可以2分法 找到对应的单词</p><p>同理，如果我们找到 单词映射到序号的方法，那么2分（如果可以，因为这里二分单词似乎没那么好做）也能反过来找数字，所以分析上，任何一个问题 都可以解决对应的一个</p><p>还有个思路是，简单的排序，计算被删掉的个数,那么序列= 总排序-被删掉比它小的个数</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><h3 id="记忆化-dp"><a href="#记忆化-dp" class="headerlink" title="记忆化+dp"></a>记忆化+dp</h3><p>我们如果把数从小到大填入</p><p>那么显然，新插入的数在已经插入的数的行末,也在已经插入的数的列末，如</p><pre><code class="c++">a b ec d fghi</code></pre><p><code>j</code>可插入的位置 为<code>g右侧</code>或<code>e右侧</code></p><p>所以 我们有dp</p><p><code>dp[i0][i1][i2][i3][i4]</code> 表示 第0行<code>i0</code>个，第1行<code>i1</code>个数…第<code>i4</code>行个数的情况下，剩余未填部分的期望个数</p><p>不考虑具体，仅考虑题目基本限制的情况下, 满足 <code>ij &gt;= i(j+1)</code>,因为我们按照顺序放数字，所以上面的行的个数不小于下一行</p><p>有转移方程</p><p><code>dp[i0][i1][i2][i3][i4] = dp[i0-1][...]+dp[...][i1-1][...]+dp[...][i2-1][...]+dp[...][i3-1][...]+dp[...][i4-1]</code></p><p>其中 如果在<code>-1</code>时不满足 行之间个数的大小关系，那么 对应的dp直接为<code>0</code></p><p>综上，我们有了在没有 具体求值下，能计算所有满足题目限制下的dp，<code>时间复杂度 = O(空间*状态转移)=O(6^5*5)</code>,空间<code>O(6^5)</code></p><h3 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h3><p>接下来是如何进行转换的问题求</p><p>因为所求的idx为实际的 合法twofive的字典序</p><p>那么我们可以按位逼近，<code>//延伸阅读 BROP的按位枚举攻击方法</code></p><p>假设我们求的是</p><p><code>ADEFGBHIJKC...Y</code>, 那么 它 的字典序 = <code>AB...的所有</code>+<code>AC...的所有</code>+…</p><p>简单的说，如果一个前缀小于 要求的等长前缀，那么加上该前缀的所有个数，</p><p>如果该前缀等于要求的值的等长前缀，那么前缀长度+1</p><p>外层for前缀长度，中间for字母， 时间复杂度小于 <code>O(25*25)</code></p><p>以上我们可以 从 字符串转化为index</p><p>相反</p><p>同样用逼近的方法，可以<code>O(25*25)</code>时间复杂度内 index转化为 字符串</p><pre><code class="c++">#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)using namespace std;const string filename = &quot;twofive&quot;;void usefile(){  freopen((filename+&quot;.in&quot;).c_str(),&quot;r&quot;,stdin);  freopen((filename+&quot;.out&quot;).c_str(),&quot;w&quot;,stdout);}char s[100]; // 按位逼近的char str[100]; // str2indexint dp[6][6][6][6][6];int dfs(int a=0, int b=0, int c=0, int d=0, int e=0, char ch=&#39;A&#39;) {  if(ch &gt; &#39;Y&#39;) return 1;  int &amp;ret = dp[a][b][c][d][e];  if(ret) return ret;  // 每一行 一定小于等于上一行  int w = 5;  int *v[6]={&amp;w,&amp;a,&amp;b,&amp;c,&amp;d,&amp;e};  rep(i,1,6){    // 未填过 和 已经填过(按照 字母顺序扩展)    int idx = *v[i]+(i-1)*5;    if(*v[i] &lt; *v[i-1] &amp;&amp; (s[idx] == 0 || s[idx] == ch)){      (*v[i])++;      ret+=dfs(a,b,c,d,e,ch+1);      (*v[i])--;    }  }  return ret;}void index2word(){  int n;  scanf(&quot;%d&quot;,&amp;n);  rep(i,0,25){    for(s[i] = &#39;A&#39;;; s[i]++) { // 按位逼近 时间复杂度25×25      memset(dp, 0,sizeof(dp));      int ret = dfs();      // cout&lt;&lt;i&lt;&lt;&quot; = &quot;&lt;&lt;s[i]&lt;&lt;&quot;\tret = &quot;&lt;&lt;ret&lt;&lt;endl;      if(ret &gt;= n) break;      n -= ret;    }  }  printf(&quot;%s\n&quot;, s);}void word2index(){  scanf(&quot;%s&quot;, str);  int ans = 1;  rep(i, 0, 25)  {    for(s[i] = &#39;A&#39;; s[i] &lt; str[i]; s[i]++) {      memset(dp, 0,sizeof(dp));      ans += dfs();    }  }  printf(&quot;%d\n&quot;, ans);}int main(){  usefile();  char c;  cin &gt;&gt; c;  if(c == &#39;N&#39;)  { // index 2 word    index2word();  } else if(c == &#39;W&#39;)  { // word 2 index    word2index();  }  return 0;}</code></pre><p>上面实现中 dp过程是按照字母顺序填写，由ch保证，所以在最外层枚举dp的时候，就直接从A 到Y 了</p>]]></content>
      
      
      <categories>
          
          <category> USACO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 离散化 </tag>
            
            <tag> 扫描线 </tag>
            
            <tag> 最小值性质 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 按位逼近 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>USACO 5.4 章节</title>
      <link href="/Blog/2019-06-10-USACO-5.4/"/>
      <url>/Blog/2019-06-10-USACO-5.4/</url>
      
        <content type="html"><![CDATA[<h1 id="Canada-Tour"><a href="#Canada-Tour" class="headerlink" title="Canada Tour"></a>Canada Tour</h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>双向连通图,点从左向右排列，</p><p>你需要先从最左的点到最右的点，（过程中只能从左向右走）</p><p>然后再从最右的点返回最左的点，（过程中只能从右向左走）</p><p>过程中除了最左的点，其它点都至多能经过一次</p><p>求最多能经过的点的个数</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>从右向左走反过来，就是说从左向右走，题目变成从最左两条不相交到达最右的路径，经过最多的点</p><p>一个问题是如何解决<code>没有重复的点</code></p><p>这里的解决方案是</p><p><code>dp[i][j]</code>表示没有重复的点的情况下 一条路径走到点i，一条路径走到点j，经过的点的最大的个数</p><p>在状态转移的时候需要保证新的状态有<code>i&lt;j</code>,</p><p><code>dp[i][j] = dp[i][k]+1</code> ,如果<code>k-&gt;j</code>有路径， 我们保证了除了初始点<code>dp[0][0]=1</code>以外，任何i不等于0，有<code>dp[i][i] = 0</code>,</p><p>证明一下</p><p>首先任何可达的状态不会遗漏，假设存在路径 一边到i，一边到j，（不妨设<code>i&lt;j</code>）那么有它的来源一定能从<code>[i][k]</code>来</p><p>再不重复点证明</p><p>抛开初始点</p><p>因为保证了<code>i&lt;j</code>,<code>dp[i][j]</code>的来源仅为<code>dp[i][k]</code>,我们有k一定不等于i，所以只要<code>dp[i][k]</code>是没有重复点的即可</p><p>因此递归可证明，这样的dp是不会经过重复点，</p><p>最后考虑都到达最右的点，那么发现和<code>dp[i][最右]</code>的 经过的点数一致，注意的是 注意判断点i到最右点是否有路径</p><pre><code class="c++">#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)using namespace std;const string filename = &quot;tour&quot;;void usefile(){  freopen((filename+&quot;.in&quot;).c_str(),&quot;r&quot;,stdin);  freopen((filename+&quot;.out&quot;).c_str(),&quot;w&quot;,stdout);}char s[210],t[210];map&lt;string,int&gt;str2idx;int n,m,mp[110][110],dp[110][110];int main(){  usefile();  scanf(&quot;%d%d&quot;,&amp;n,&amp;m);  rep(i,0,n){    scanf(&quot;%s&quot;,s);    str2idx[s]=i;  }  rep(i,0,m){    scanf(&quot;%s %s&quot;,s,t);    mp[str2idx[s]][str2idx[t]]=1;    mp[str2idx[t]][str2idx[s]]=1;  }  int ans=1;  dp[0][0]=1;  rep(i,0,n){    rep(j,i+1,n){      rep(k,0,j){        if(mp[j][k]&amp;&amp;dp[i][k]&amp;&amp;dp[i][k]+1&gt;dp[i][j]){          dp[i][j]=dp[j][i]=dp[i][k]+1;        }      }    }    if(mp[i][n-1]){      ans=max(ans,dp[i][n-1]);    }  }  printf(&quot;%d\n&quot;,ans);}</code></pre><h1 id="Character-Recognition"><a href="#Character-Recognition" class="headerlink" title="Character Recognition"></a>Character Recognition</h1><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>先提供空格和26个小写字母的 字符画01矩阵，每个字符都是<code>20*20</code></p><p>然后 你需要解析一段<code>n*20</code>字符矩阵，n行20列</p><p>这段矩阵和标准的差异是，</p><ol><li>对于一个字符，可能某一行被倍增了 变成21行，它紧接着倍增那行</li><li>对于一个字符，可能某一行被吞了 变成19行</li><li>0 和 1 和真实值不同</li></ol><p>上面问题可以存在的组合有，和原始完全一致，单纯1，单纯2,1+3,2+3，其中 0和1 的改变率小于等于30%</p><p>题目呢，可以说相当于 USACO帮我们建了个OCR的模型！！！我们在该模型下实现算法</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>f[i]表示从最开始到第i行最小误差</p><p>f[i] = min(f[i-19]+19行来匹配，f[i-20]+20行来匹配,f[i-21]+21行来匹配)</p><p>我们预先处理　所有字符的行(<code>27*20</code>)　和　目标匹配的行N</p><p><code>O(N*27*20)</code></p><p>然后 直接dp，<code>O(N*(20*3))</code> 理论上如果做了前缀和后缀和优化</p><p>实现如下</p><pre><code class="c++">#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)using namespace std;const string filename = &quot;charrec&quot;;void usefile(){  freopen((filename+&quot;.in&quot;).c_str(),&quot;r&quot;,stdin);  freopen((filename+&quot;.out&quot;).c_str(),&quot;w&quot;,stdout);}int n,m;char str[]=&quot; abcdefghijklmnopqrstuvwxyz&quot;;char s[30][30][30];// 标准字符集[idx][i][j]char t[1210][30]; // 目标字符串[i][j]int diff[30][30][1210]; // 预处理 [字符idx][字符的i行][目标的j行] = 01差异和tuple&lt;int,int,int&gt;dp[1210]; // {最小代价，父节点，字符}const int SUP = 1000000;// 从st行开始匹配len行，返回{最小的代价，匹配的字符};pair&lt;int,int&gt; solve(int st,int len){  pair&lt;int,int&gt;ret= {SUP,-1};  rep(i,0,27){    if(len==20){      int sum=0;      rep(k,0,20){        sum+=diff[i][k][st+k];      }      ret= min(ret,{sum,i});    }else{      // 这边重复计算了， 这里可以用前缀和 后缀和继续优化, 目测可以优化掉约10-20倍性能      // 不过因为USACO的数据比较小 这样已经是0.1s内了 就没写优化了      rep(j,0,20){ // 枚举删掉或增加的行        int p=st,sum=0;        rep(k,0,j){          sum+=diff[i][k][p++];        }        if(len==21){ // 19为删掉 21为增加          sum+=diff[i][j][p++];          sum+=diff[i][j][p++];        }        rep(k,j+1,20){          sum+=diff[i][k][p++];        }        ret= min(ret,{sum,i});      }    }  }  return ret;}int main() {  ios::sync_with_stdio(false);  freopen(&quot;font.in&quot;,&quot;r&quot;,stdin);  freopen(&quot;charrec.out&quot;,&quot;w&quot;,stdout);  scanf(&quot;%d&quot;,&amp;n);  rep(idx,0,27){    rep(i,0,20){      scanf(&quot;%s&quot;,s[idx][i]);    }  }  fclose(stdin);  freopen(&quot;charrec.in&quot;,&quot;r&quot;,stdin);  scanf(&quot;%d&quot;,&amp;m);  rep(i,0,m){    scanf(&quot;%s&quot;,t[i]);    dp[i] = {SUP,0,0};  }  // 预处理 把每个字符的每一行 都和 目标字符比  // 目标k行 和 第x个字符 的y行 比较不同的01个数  rep(idx,0,27){    rep(i,0,20){      rep(mm,0,m){        rep(j,0,20){          diff[idx][i][mm]+=s[idx][i][j]!=t[mm][j];        }      }    }  }  rep(i,18,m){    rep(len,19,22){      auto [cost,idx]=solve(i-len+1,len);      dp[i] = min(dp[i], {cost+(i-len&lt;0?0:get&lt;0&gt;(dp[i-len])),i-len,idx});    }  }  vector&lt;char&gt;ans;  int i=m-1;  do{    ans.push_back(str[get&lt;2&gt;(dp[i])]);  }while((i=get&lt;1&gt;(dp[i]))&gt;0);  per(itr,0,ans.size()){    printf(&quot;%c&quot;,ans[itr]);  }  printf(&quot;\n&quot;);  return 0;}</code></pre><h1 id="Telecowmunication"><a href="#Telecowmunication" class="headerlink" title="Telecowmunication"></a>Telecowmunication</h1><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>100点，无向图</p><p>网络流，最小字典序的最小割点</p><p>记得前不久才有一个<a href="https://yexiaorain.github.io/Blog/2018-12-05-USACO-4.4-2/">USACO的 最大流问题</a></p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>老生常谈了，=。=难道是我练题的顺序不对，感觉在刚刚学完最大流 最小割的时候，就会学到拆点啊。</p><p>然后直接最小割点就出来了，然后字典序就依次枚举 再计算？想了想编码似乎不可行 <code>1 + 100</code> vs <code>2+3</code>若都是可行的，显然前面的字典序小</p><pre><code class="c++">#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)using namespace std;const string filename = &quot;telecow&quot;;void usefile(){  freopen((filename+&quot;.in&quot;).c_str(),&quot;r&quot;,stdin);  freopen((filename+&quot;.out&quot;).c_str(),&quot;w&quot;,stdout);}int n,m,c1,c2;int p2p[210][210];int vis[210];int flow[210][210];void clearvis(){  rep(i,1,2*n+1){    vis[i]=false;  }}void dup(){  rep(i,1,2*n+1){    rep(j,1,2*n+1){      flow[i][j]=p2p[i][j];    }  }}int stk[210];int bfs(int idx,int dst){  clearvis();  int st = 0,rear=0;  stk[rear++]=idx;  vis[idx] = true;  while(st&lt;rear){    int p = stk[st];    rep(i,1,n*2+1){      if(vis[i])continue;      if(flow[p][i]){        if(i == dst){          return true;        }        stk[rear++]=i;        vis[i]=true;      }    }    st++;  }  return false;}int dfs(int idx,int dst){  if(idx == dst){    return 1;  }  vis[idx] = true;  rep(i,1,2*n+1){    if(vis[i])continue;    if(!flow[idx][i])continue;    int r = dfs(i,dst);    if(r){      flow[idx][i] -= r;      flow[i][idx] += r;      return r;    }  }  return 0;}int maxflow(){  int ret =0;  while(bfs(c1*2,c2*2-1)){    clearvis();    ret+=dfs(c1*2,c2*2-1);  }  return ret;}void addp(int p1,int p2){  int p1i=p1*2-1;  int p1o=p1*2;  int p2i=p2*2-1;  int p2o=p2*2;  if(p1!=c1 &amp;&amp; p2 != c2){    p2p[p2o][p1i] = 1;  }  if(p1!=c2 &amp;&amp; p2 != c1){    p2p[p1o][p2i] = 1;  }}int main(){  usefile();  cin&gt;&gt;n&gt;&gt;m&gt;&gt;c1&gt;&gt;c2;  rep(i,0,m){    int a,b;    scanf(&quot;%d %d&quot;,&amp;a,&amp;b);    addp(a,b);  }  rep(i,1,n+1){    p2p[i*2-1][i*2]=1;  }  dup();  int ans = maxflow();  cout&lt;&lt;ans&lt;&lt;endl;  vector&lt;int&gt;ps;  rep(i,1,n+1){    if(i== c1 || i==c2){      continue;    }    dup();    flow[i*2-1][i*2]=0;    int ret = maxflow();    if(ret == ans-1){      ps.push_back(i);      ans-=1;      p2p[i*2-1][i*2]=0;    }  }  rep(i,0,ps.size()){    printf(&quot;%d%c&quot;,ps[i],&quot; \n&quot;[i==ps.size()-1]);  }  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>第一题的DP的方法，我要是打cf没遇到，估计是想不出怎么处理路径不重复点 的 这样的状态转移</p><p>第二题的DP实现没啥好说的，但这样一个OCR模型 感觉也是很“实际”</p><p>第三题 emmmm 感觉刚学完网络流的时候 就知道拆点，好像没什么特别的。</p>]]></content>
      
      
      <categories>
          
          <category> USACO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
            <tag> 网络流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>USACO 5.3 章节</title>
      <link href="/Blog/2019-05-18-USACO-5.3/"/>
      <url>/Blog/2019-05-18-USACO-5.3/</url>
      
        <content type="html"><![CDATA[<p>相关讲解可在USACO上看原文，也可以搜索nocow找到翻译的！ (nocow上有些微翻译是有问题的，如果想看nocow翻译的建议也对着英文看)</p><p>以下记录以下 自己之前未掌握的一些要点,以及按自己的括号表述的形式来记录。</p><h1 id="USACO-Section-5-3-启发式搜索"><a href="#USACO-Section-5-3-启发式搜索" class="headerlink" title="USACO Section 5.3 启发式搜索"></a>USACO Section 5.3 启发式搜索</h1><p>启发式搜索的主要思想是通过评价一个状态有”多好”来改进对于解的搜索.</p><p><code>0&lt;= 可行的估价函数 &lt;= 实际代价</code></p><ol><li><p>启发式剪枝: 若搜到最小值，已经搜索到的最优值为C，当前的代价为A(从起始状态到这里的实际代价)，启发的期望剩余代价为B（从当前点到目标的估价），如果<code>A+B&gt;C</code>也就是期望总代价比已经搜索的还大，那么剪枝，注意到上面有提到：估价函数是小于等于实际代价，也就意味<code>实际代价&gt;=A+B&gt;C</code>,所以可以剪枝</p></li><li><p>Best-First Search最佳优先: 深搜 中，在子节点访问顺序部分做估价处理，调整搜索顺序，再结合上面的剪枝</p></li><li><p><code>A*</code> 可以和第二条相对，看做广搜中加入了顺序估价。</p></li></ol><blockquote><p>关于估价函数<br>如果为0，可以看做毫无优化的默认算法。<br>如果为实际代价，那么就直接可以最快向目标前进。</p></blockquote><h1 id="Milk-Measuring-milk4"><a href="#Milk-Measuring-milk4" class="headerlink" title="Milk Measuring - milk4"></a>Milk Measuring - milk4</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>从P个数中选 取任意个数，使得它们的整数倍数的和=Q</p><p>如P: 3,3,5,7</p><p>Q:16</p><p><code>16=3*2+5*1</code></p><p>目标，1选的数的个数尽量小，2在个数尽量小的时候，字典序最小</p><p><code>1&lt;=Q&lt;=200000</code></p><p><code>1&lt;=P&lt;=100</code></p><p><code>1&lt;=每个数&lt;=10000</code></p><p>输出选择的方案</p><h2 id="通过不了的题解"><a href="#通过不了的题解" class="headerlink" title="通过不了的题解"></a>通过不了的题解</h2><p>emmmm 我为什么一看就是个sort(从大到小)+<code>dp[当前第几个数][和的值]= {最小选取的个数,最后选择的index,选择的个数,倒数第一次选择的index}</code></p><p>空间<code>O(Q*P)</code>,时间<code>O(Q*P)</code> 能得到最小的个和方案,</p><p>dp时 优先个数(目标要求个数)，其次上一次的index(因为sort过 且目标要求字典序)，个数用来反向输出方案</p><pre><code class="c++">#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)using namespace std;const string filename = &quot;milk4&quot;;void usefile(){  freopen((filename+&quot;.in&quot;).c_str(),&quot;r&quot;,stdin);  freopen((filename+&quot;.out&quot;).c_str(),&quot;w&quot;,stdout);}tuple&lt;int,int,int,int&gt;dp[110][20010]; // {usecnt+1,lastuseidx,lastusecnt,preidx};int val[110];int Q;int P;int main(){  usefile();  cin&gt;&gt;Q;  cin&gt;&gt;P;  rep(i,0,P){    scanf(&quot;%d&quot;,val+i);  }  sort(val,val+P,greater&lt;int&gt;());  rep(p,0,P){    dp[p][0] = {1,-1,0,-1};  }  rep(p,0,P){    if(p&gt;0){      rep(q,0,Q+1){        dp[p][q]=dp[p-1][q];      }    }    rep(q,0,Q){      auto &amp; item = dp[p][q];      if(get&lt;0&gt;(item) &gt; 0){        if(q+val[p] &gt; Q)break;        auto &amp; pre = dp[p][q+val[p]];        tuple&lt;int,int,int,int&gt; now = {          get&lt;0&gt;(item)+ (p !=get&lt;1&gt;(item)),          p,          (p!=get&lt;1&gt;(item))?1:get&lt;2&gt;(item)+1,          (p!=get&lt;1&gt;(item))?get&lt;1&gt;(item):get&lt;3&gt;(item)        };        if(get&lt;0&gt;(pre) == 0 || get&lt;0&gt;(pre) &gt;= get&lt;0&gt;(now)){          pre = now;        }      }    }  }  // rep(p,0,P){  //   cout&lt;&lt;&quot;P:&quot;&lt;&lt;p&lt;&lt;endl;  //   rep(q,0,Q+1){  //     printf(&quot;[%d %d %d %d]&quot;,get&lt;0&gt;(dp[p][q]),get&lt;1&gt;(dp[p][q]),get&lt;2&gt;(dp[p][q]),get&lt;3&gt;(dp[p][q]));  //   }  //   cout&lt;&lt;endl;  // }  auto ans = dp[P-1][Q];  printf(&quot;%d&quot;,get&lt;0&gt;(ans)-1);  int qq = Q;  while(1){    printf(&quot; %d&quot;,val[get&lt;1&gt;(ans)]);    qq-= get&lt;2&gt;(ans) * val[get&lt;1&gt;(ans)];    if(get&lt;3&gt;(ans) == -1){      break;    }    ans = dp[get&lt;3&gt;(ans)][qq];  }  printf(&quot;\n&quot;);  return 0;}</code></pre><p>然而不幸的是超空间限制了</p><p><code>Execution error: Your program (</code>milk4’) exited with signal #11 (segmentation violation [maybe caused by accessing memory out of bounds, array indexing out of bounds, using a bad pointer (failed open(), failed malloc), or going over the maximum specified memory limit]). The program ran for 0.000 CPU seconds before the signal. It used 31552 KB of memory. `</p><p>优化可以优化掉p，在实现记录的时候用指针的方式，没有尝试能不能改过</p><h2 id="可通过的解"><a href="#可通过的解" class="headerlink" title="可通过的解"></a>可通过的解</h2><p>IDDFS 迭代加深搜索，使用场景，在低的层级找到解就是最优/目标解。</p><p>和广搜的区别是，广搜过程中会用内存记录，而迭代加深每次都是深搜，但是逐次增加深度。</p><p>可行性：每次加深深度，新的状态和上一层的状态是数量级差异，所以其实只和最后成功搜索到的层数的数量级相关。</p><p>综上，IDDFS有着接近广搜的性能，有着接近深搜的空间消耗。</p><p>实现pass如下</p><pre><code class="c++">#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)using namespace std;const string filename = &quot;milk4&quot;;void usefile(){  freopen((filename+&quot;.in&quot;).c_str(),&quot;r&quot;,stdin);  freopen((filename+&quot;.out&quot;).c_str(),&quot;w&quot;,stdout);}int vis[20010];int ans[110];int val[20010];int Q;int P;int dep;bool check(){  rep(i,1,Q+1){    vis[i]=0;  }  rep(i,0,dep){    rep(j,0,Q+1-ans[i]){      if(vis[j]){        vis[j+ans[i]]=true;      }    }  }  if(vis[Q]){    return true;  }  return false;}bool dfs(int idx,int cnt){  ans[cnt] = val[idx];  if(cnt+1 == dep){    return check();  }  rep(j,idx+1,P+2+cnt-dep){    if(dfs(j,cnt+1)){      return true;    }  }  return false;}void output(){  printf(&quot;%d&quot;,dep);  rep(i,0,dep){    printf(&quot; %d&quot;,ans[i]);  }  printf(&quot;\n&quot;);}int main(){  usefile();  cin&gt;&gt;Q;  cin&gt;&gt;P;  rep(i,0,P){    scanf(&quot;%d&quot;,val+i);  }  sort(val,val+P);  vis[0]=1;  for(dep=1;dep&lt;=P;dep++){    rep(i,0,P+1-dep){      if(dfs(i,0)){        output();        return 0;      }    }  }  return 0;}</code></pre><h1 id="Window-Area-window"><a href="#Window-Area-window" class="headerlink" title="Window Area - window"></a>Window Area - window</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>在电脑上窗口的操作,5种</p><ul><li>新建窗口(标识符，x1,y1,x2,y2)</li><li>置顶t(标识符)</li><li>置底b(标识符)</li><li>删除d(标识符)</li><li>输出窗体可见百分比s(I) ,询问数&lt;=500</li></ul><p>窗体个数上限<code>(2*26+10=62)</code></p><p>坐标范围<code>[1-&gt;32767]</code></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>那么显然 横纵坐标只有<code>((2×62)^2)</code>个，离线+离散+没了？</p><pre><code class="c++">#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)typedef long long ll;using namespace std;const string filename = &quot;window&quot;;void usefile(){  freopen((filename+&quot;.in&quot;).c_str(),&quot;r&quot;,stdin);  freopen((filename+&quot;.out&quot;).c_str(),&quot;w&quot;,stdout);}list&lt;int&gt;Is[240][240]; // 大小猜的vector&lt;int&gt;x;vector&lt;int&gt;y;vector&lt;tuple&lt;int,int&gt; &gt;q;int itr = 0;vector&lt;tuple&lt;int,int,int,int&gt; &gt;xys;tuple&lt;int,int,int,int&gt; xyxy[123];void rm(int ix,int iy,char I){  for (list&lt;int&gt;::iterator it=Is[ix][iy].begin(); it!=Is[ix][iy].end(); ++it){    if(*it == I){      Is[ix][iy].erase(it);      return ;    }  }}void top(int ix,int iy,char I){  rm(ix,iy,I);  Is[ix][iy].push_front(I);}void bot(int ix,int iy,char I){  rm(ix,iy,I);  Is[ix][iy].push_back(I);}int main(){  usefile();  char op;  while(~scanf(&quot;%c&quot;,&amp;op)){    if(op!=&#39;w&#39; &amp;&amp; op!=&#39;t&#39; &amp;&amp; op!=&#39;b&#39; &amp;&amp; op!=&#39;d&#39; &amp;&amp; op!=&#39;s&#39;)continue;    if(op == &#39;w&#39;){      char I;      int x1,y1;      int x2,y2;      scanf(&quot;(%c,%d,%d,%d,%d)&quot;,&amp;I,&amp;x1,&amp;y1,&amp;x2,&amp;y2);      if(x1&gt; x2){        swap(x1,x2);      }      if(y1&gt;y2){        swap(y1,y2);      }      x.push_back(x1);      x.push_back(x2);      y.push_back(y1);      y.push_back(y2);      q.push_back({op,I});      xys.push_back({x1,y1,x2,y2});    }else{      char I;      scanf(&quot;(%c)&quot;,&amp;I);      q.push_back({op,I});    }  }  sort(x.begin(),x.end());  sort(y.begin(),y.end());  for(auto item:q){    int op = get&lt;0&gt;(item);    int I = get&lt;1&gt;(item);    if(op == &#39;w&#39;){      xyxy[I] = xys[itr++];    }    int x1idx=lower_bound(x.begin(),x.end(),get&lt;0&gt;(xyxy[I]))-x.begin();    int y1idx=lower_bound(y.begin(),y.end(),get&lt;1&gt;(xyxy[I]))-y.begin();    int x2idx=lower_bound(x.begin(),x.end(),get&lt;2&gt;(xyxy[I]))-x.begin();    int y2idx=lower_bound(y.begin(),y.end(),get&lt;3&gt;(xyxy[I]))-y.begin();    switch(op){      case &#39;w&#39;:        {          rep(ix,x1idx,x2idx){            rep(iy,y1idx,y2idx){              Is[ix][iy].push_front(I);            }          }          break;        }      case &#39;t&#39;:        {          rep(ix,x1idx,x2idx){            rep(iy,y1idx,y2idx){              top(ix,iy,I);            }          }          break;        }      case &#39;b&#39;:        {          rep(ix,x1idx,x2idx){            rep(iy,y1idx,y2idx){              bot(ix,iy,I);            }          }          break;        }      case &#39;d&#39;:        {          rep(ix,x1idx,x2idx){            rep(iy,y1idx,y2idx){              rm(ix,iy,I);            }          }          break;        }      case &#39;s&#39;:        {          ll sshow = 0;          rep(ix,x1idx,x2idx){            rep(iy,y1idx,y2idx){              sshow+= ((*Is[ix][iy].begin() == I)?(x[ix+1]-x[ix])*ll(y[iy+1]-y[iy]):0);            }          }          ll scnt = (x[x2idx]-x[x1idx])*ll(y[y2idx]-y[y1idx]);          printf(&quot;%.3lf\n&quot;,sshow*100/double(scnt));          break;        }    }  }  return 0;}</code></pre><p>emmmmmm 在第11个点的时候 出现了唯一标识复用的情况，也就是说 先创建 再删除 再创建，所以期望的边数也就不只 <code>(26*2+10)*2</code>，我这里尝试的是开到<code>240*240</code>才能过</p><p>所以基本上是 离散化 <code>O(长乘宽(分化的区块个数)*62(每次操作代价)*(t+b+r操作个数)+长乘宽(分化区块个数)*1(操作代价)*(w+s操作个数))</code></p><p>以上代码还可以优化的地方:</p><ol><li><p>通过预处理 真实值到离散值，让每个这样的计算只发生一次。</p></li><li><p>再建立一个表来优化top,bot,rm到接近O1每次，额外的指针访问时间，缺点是1增加空间，2本身数据不大的情况，枚举查找的效率是不差的</p></li></ol><p>然后有一些博文有 两个矩形之间处理的优化，也就是 不分成9块，而是分成最多5块，类似旋图，然后平时只记录相对的层数(z-index)，然后在查询的时候，才自值开始向上查找。</p><h1 id="Network-of-Schools-schlnet"><a href="#Network-of-Schools-schlnet" class="headerlink" title="Network of Schools - schlnet"></a>Network of Schools - schlnet</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>有向图,(N&lt;=100)个节点</p><ol><li>求最少选取多少个点，通过这些点能够沿着有向边到达所有的点</li><li>求最少加多少边，让真个图变成全连通</li></ol><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>emmmm一眼</p><ol><li>直接求强连通，然后缩点，然后按照出度排序，从0开始删，直到为最后只剩独立点，进行统计？</li><li>把这些缩点后的 max(出度为0的点,入度为0的点)</li></ol><p>强连通直接tarjan</p><pre><code class="c++">#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)using namespace std;const string filename = &quot;schlnet&quot;;void usefile(){  freopen((filename+&quot;.in&quot;).c_str(),&quot;r&quot;,stdin);  freopen((filename+&quot;.out&quot;).c_str(),&quot;w&quot;,stdout);}int n;vector&lt;int&gt;p2[110];const int N=100;int id = 0;bool vis[N+10];int low[N+10];int dfn[N+10];vector&lt;int&gt;stk;bool instk[N+10];int incnt[N+10];int outcnt[N+10];void scc(int idx){  // cout&lt;&lt;&quot;scc&quot;&lt;&lt;idx&lt;&lt;endl;  dfn[idx] = low[idx] = ++id;  vis[idx] = true;  stk.push_back(idx);  instk[idx] = true;  for(auto item:p2[idx]){    if(!vis[item]){      scc(item);      low[idx]=min(low[idx],low[item]);    }else if(instk[item]){      low[idx]=min(low[idx],dfn[item]); // dfn-&gt;low    }  }  if(low[idx] == dfn[idx]){    // cout&lt;&lt;&quot;zip:&quot;&lt;&lt;idx&lt;&lt;endl;    // for(auto item:stk){    //   printf(&quot;\t\tstk[%d]\n&quot;,item);    // }    int u;    do{      u = *(stk.end()-1);      // cout&lt;&lt;&quot;\tu:&quot;&lt;&lt;u&lt;&lt;endl;      dfn[u] = idx;      instk[u] = false;      stk.pop_back();    }while(u != idx);  }}void tarjan(){  rep(i,1,n+1){    if(!vis[i]){      scc(i);    }  }  // rep(i,1,n+1){  //   cout&lt;&lt;&quot;dfn:&quot;&lt;&lt;i&lt;&lt;&quot; = &quot;&lt;&lt;dfn[i]&lt;&lt;endl;  // }}int main(){  usefile();  cin&gt;&gt;n;  rep(i,1,n+1){    while(1){      int v;      scanf(&quot;%d&quot;,&amp;v);      if(v == 0)break;      p2[i].push_back(v);    }  }  tarjan();  rep(i,1,n+1){    if(dfn[i]!=i){      for(auto item:p2[i]){        p2[dfn[i]].push_back(dfn[item]);      }    }else{      for(auto &amp;item:p2[i]){        item = dfn[item];      }    }  }  rep(i,1,n+1){    if(dfn[i] == i){      sort(p2[i].begin(),p2[i].end());      p2[i].erase(unique(p2[i].begin(),p2[i].end()),p2[i].end());      for(auto item:p2[i]){        if(item == i)continue;        // printf(&quot;%d -&gt; %d\n&quot;,i,item);        incnt[item]++;        outcnt[i]++;      }    }  }  int in0cnt=0,out0cnt=0;  rep(i,1,n+1){    if(dfn[i] == i){      in0cnt+=incnt[i] == 0;      out0cnt+=outcnt[i] == 0;    }  }  printf(&quot;%d\n&quot;,in0cnt);  // single check  int pcnt = 0;  rep(i,1,n+1){    pcnt+=dfn[i]==i;  }  if(pcnt == 1){    printf(&quot;0\n&quot;);  }else{    printf(&quot;%d\n&quot;,max(in0cnt,out0cnt));  }  return 0;}</code></pre><h1 id="Big-Barn-bigbrn"><a href="#Big-Barn-bigbrn" class="headerlink" title="Big Barn - bigbrn"></a>Big Barn - bigbrn</h1><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>NxN(N&lt;=1000)矩阵A点上值有0或1</p><p>1的个数&lt;=10000</p><p>求最大的全0正方形(不能斜着)</p><p>输出边长即可</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>这感觉二分答案？因为二分的话如果大的可行，那么小的必定可行</p><p>又必定正方形的左侧和上侧都有点（边界看做全是点）</p><p>假设存在一个最优解左侧没有相邻点，则可以向左平移直到有点，对上侧同理。</p><p>emm 这样想下去，暂时没想到一个时间复杂度内能完成的解法，再看又像是二维线段树,跟着2维线段树的思路联想到前缀和的类似的矩阵处理</p><p>假设当前测试的长度为len</p><p>那么用<code>B[i][j]</code>表示 <code>A[i-&gt;i+len-1][j]</code>为1的个数</p><p><code>C[i][j]</code>表示<code>A[i-&gt;i+len-1][j-&gt;j+len-1]</code>为1的个数,即是<code>C[i][j-&gt;j+len-1]</code></p><p>根据前缀和类似的算法，<code>A-&gt;B</code>可以在<code>O(N^2)</code>完成<code>B-&gt;C</code>也同理,综上<code>O(N^2*log(N))</code></p><p>然而很不幸的是 usaco给的空间是真的有限，就算换成 new 也会在第11个点挂掉,所以bit压位,然而事后发现，可以不用存储C，直接判断C的值就好了，从空间<code>O(3N^2)</code>变为<code>O(2N^2)</code>就能过</p><pre><code class="c++">#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)using namespace std;const string filename = &quot;bigbrn&quot;;void usefile(){  freopen((filename+&quot;.in&quot;).c_str(),&quot;r&quot;,stdin);  freopen((filename+&quot;.out&quot;).c_str(),&quot;w&quot;,stdout);}int n,t;// bitset&lt;8&gt; A[1010][130];// [1010][1010]; // N*N// bitset&lt;8&gt; B[1010][130];// [1010][1010]; // (N+1-len)*N// //bitset&lt;8&gt; C[1010][130];// [1010][1010]; // (N+1-len)*(N+1-len)// 如果注释掉下面两行用 上面bitset的A和B也能过int A[1010][1010];int B[1010][1010];void setv(bitset&lt;8&gt; *arr,int idx,int v){  arr[idx/8].set(idx%8,bool(v));}int getv(bitset&lt;8&gt; *arr,int idx){  return arr[idx/8][idx%8];}void setv(int *arr,int idx,int v){  arr[idx]=v;}int getv(int *arr,int idx){  return arr[idx];}bool ok(int len){  if(len == 0)return true;  // A-&gt;B  rep(j,0,n){    int cnt = 0;    rep(i,0,len){      cnt+=getv(A[i],j);    }    setv(B[0],j,cnt);    rep(i,1,n+1-len){      cnt+=getv(A[i+len-1],j)-getv(A[i-1],j);      setv(B[i],j,cnt);    }  }  // B-&gt;C  rep(i,0,n+1-len){    int cnt= 0;    rep(j,0,len)      cnt+=getv(B[i],j);    if(cnt == 0)return true;    rep(j,1,n+1-len){      cnt+=getv(B[i],j+len-1)-getv(B[i],j-1);      if(cnt == 0)return true;    }  }  return false;}bool all1(){  rep(i,0,n){    rep(j,0,n){      if(A[i][j] == 0){        return false;      }    }  }  return true;}int main(){  usefile();  cin&gt;&gt;n&gt;&gt;t;  rep(i,0,t){    int x,y;    scanf(&quot;%d %d&quot;,&amp;x,&amp;y);    setv(A[x-1],y-1,1);  }  int lenl=0,lenr=n+1;  while(lenl+1&lt;lenr){    int mid=(lenl+lenr)/2;    if(ok(mid)){      lenl=mid;    }else{      lenr=mid;    }  }  cout&lt;&lt;lenl&lt;&lt;endl;  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>emmmmm所以这些题目和标题的启发式搜索的关系是?</p>]]></content>
      
      
      <categories>
          
          <category> USACO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 离散化 </tag>
            
            <tag> Heuristic Search </tag>
            
            <tag> IDDFS </tag>
            
            <tag> scc </tag>
            
            <tag> 块状矩阵 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF 1152 D (最值可达入门)</title>
      <link href="/Blog/2019-04-30-cf1152D/"/>
      <url>/Blog/2019-04-30-cf1152D/</url>
      
        <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/1152/problem/D" target="_blank" rel="noopener">D原题</a></p><p>才2000分我自闭了</p><p>n(1&lt;=n&lt;=1000)个左括号和n个右括号组成合法括号序列</p><p>把所有合法序列来建立一个trie树</p><p>求问，给树的边上色或不上色，要求任意两个上色边不能共点，求最大上色边数</p><p>结果MOD 1e9+7</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先我想到树上dp，<code>f[当前配对数量][剩余左括号数量][是否染色边]</code></p><p>有关系</p><pre><code class="c++">f[i][j][0] = max(     f[i][j+1][1]+f[i+1][j-1][0],     f[i][j+1][0]+f[i+1][j-1][1],     );f[i][j][1] =     f[i][j+1][0]+f[i+1][j-1][0]+1;</code></pre><pre><code class="c++">ll f(ll p,ll l,int pick){  if(p==n)return pick;  if(ret[p][l][pick] != 0)return ret[p][l][pick];  if(l==0){ // 没有剩余左括号了，所以在树上的向下分之一定是左括号    return ret[p][l][pick]=f(p,l+1,1-pick)+pick; // 偏序关系?  }  if(p+l==n){ // 左括号已经达到上限只能用右括号    return ret[p][l][pick]=f(p+1,l-1,1-pick)+pick;// 偏序关系?  }  if(pick == 1){ // 当前选下面则不选    return ret[p][l][pick]=f(p,l+1,0)+f(p+1,l-1,0)+1;// 偏序关系?  }else{    return ret[p][l][pick]=      max(f(p,l+1,1)+f(p+1,l-1,0),          f(p,l+1,0)+f(p+1,l-1,1));  }}</code></pre><p>那么只要访问f(0,1,1),就可以得到答案,然后就遇到了一个问题:最大值和取模运算是冲突的</p><p>那么有什么办法可以不用比较直接直到偏序关系?</p><p>我没想出来,那么现在一个办法是偏序关系，一个办法是做高精度，还有一个办法是换方法。</p><p>来自群友梦月大佬的一句话方法:奇数层节点个数</p><p>注:按题目原型来说 最初空白节点为0层</p><p>注意每次染色一条边，如果去看树上，实际就是奇数层次的点和偶数层次的点被各染色一个，因为不同染色边不能有交点，所以边=奇数层数染色的点=偶数层数染色的点。</p><p>下面又有因为是合法对，所以从根节点到叶子节点的点数永远是偶数也就意味着每一个奇数层数的点下方一定有至少一个节点(在偶数层数)</p><p>所以边&lt;= min(奇数层数总节点数，偶数层数总结点数) =奇数层数总结点数</p><p>下面看可达性，同上述，每个奇数节点选一个下方的偶数节点染色边，即可，保证了不会共点，又达到了奇数层数的总节点数。</p><p>综上 我们找到了一个方案达到上限，那么这个上限也就是答案了。</p><p>[至于怎么算奇数节点上总个数就无脑dp了,我想没有必要赘述了吧.</p>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF 1146 D (gcd入门)</title>
      <link href="/Blog/2019-04-21-cf1146D/"/>
      <url>/Blog/2019-04-21-cf1146D/</url>
      
        <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/1146/problem/D" target="_blank" rel="noopener">D原题</a></p><p>这题分才2100 XD,没想到[a+b]是一个可行上限</p><p>大意:</p><p>青蛙在长度为i的<strong>区间内</strong>跳跃，要么向右a,要么向左b. f(i)=能跳到的不同点的个数</p><p>输入m(&lt;=1e9),(1&lt;=a&lt;=1e5),(1&lt;=b&lt;=1e5)</p><p>求<code>sum{i=0-&gt;m,f(i)}</code></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先，假设在长度为x的时候，足够长，能够通过反复横跳,跳到gcd(a,b)的位置，那么也就意味着[0,x]可以到达gcd(a,b)</p><p>从而[gcd(a,b),gcd(a,b)+x] 能跳到2gcd(a,b)</p><p>注意到存在 <code>a*n-b*m=gcd(a,b)</code> 其中n和m非负</p><p>意味着如果令x=a+b,也就是区间给[0,a+b],</p><p>那么保证了任何一个点p，</p><p>p+a(向右跳)&lt;=a+b(没有超过右边界) </p><p>和</p><p>p-b(向左跳)&gt;=0(没有超过左边界)</p><p>至少有一个成立</p><p>即是说，如果不能向右跳时一定能向左再跳一次，如果不能向左跳一定能向右再跳一次</p><p>也意味着，每向右跳一次a的系数增加，且可以在[0,a+b]中系数增加任意次数，从而达到期望的n</p><p>对应的在达到n时，任然在区间内，向左跳的次数也就可以取到m，从而在[0,a+b]中一定能跳到gcd(a,b);</p><p>同理 a+b明显是gcd(a,b)的倍数，假设k倍</p><p>那么 <code>a*(n*k)-b*(m*k)</code>也是可达的，因为保证了b的次数，也就是向左跳的次数可以从0逐个增大到无穷，所以达到<code>m*k</code>时，对应可以让a填充达到a+b。</p><p>再同理,如果给定[0,a+b]，那这区间里所有gcd的倍数都可以达到。</p><p>因此大于[a+b]的简单计算gcd个数，我们只用关心0到a+b的情况.</p><p>显然f(0-a+b)的这部分 用dijkstra</p>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF 551 Div2(D树上DP,E 简单二分)</title>
      <link href="/Blog/2019-04-16-cfR551/"/>
      <url>/Blog/2019-04-16-cfR551/</url>
      
        <content type="html"><![CDATA[<h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><p><a href="https://codeforces.com/contest/1153/problem/D" target="_blank" rel="noopener">题目</a></p><p>这题分才1800 XD,卡C卡太久了</p><p>给你一个树，树节点个数<code>n&lt;=3e5</code></p><p>有k个叶子<code>k&lt;n</code></p><p>非叶子节点有操作符f,f=0表示取子节点最小值，f=1表示取子节点最大值</p><p>你需要把<code>值1到k</code>的放到叶子上，使得根节点得到的结果最大，求这个最大值</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p><code>dp[节点] = 节点以下的叶子数量-节点以下能达到的最大值</code>，所以dp越小越好</p><p>这样答案=<code>k-dp[root]</code></p><p>举例</p><p>一个max节点i，如果它的子节点全是叶子，那么dp[i]=0</p><p>一个min节点i，如果它的子节点全是叶子，且它有m个子节点，那么dp[i]=m-1</p><p>那么更一般的</p><p>一个max节点i,<code>dp[i] = min(dp[child])</code></p><p>一个min节点i,`dp[i] = i以下叶子节点总数-max(childi以下叶子节点总数-dp[childi]) 吗 ?</p><p>并不,考虑min下两个节点，分别长度，和dp为</p><p>leni,dpi 和 lenj,dpj,比如你想 (4,2),(16,8)</p><p>那么如果我们选取i为min的取值，那么这两个节点贡献的dp最小为dpi+(dpj+1)</p><p>那么如果我们选取j为min的取值，那么这两个节点贡献的dp最小为dpj+(dpi+1)</p><p>一个min节点i,`dp[i] = dp[?] + sum 剩余dp + 直接子节点个数-1;</p><p>初始化<code>dp[叶子]=0</code></p><h2 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h2><p><a href="https://codeforces.com/contest/1153/submission/52821439" target="_blank" rel="noopener">code</a></p><pre><code class="c++">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define ten5 100000+10#define MOD 1000000007#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define iif(c,t,f) ((c)?(t):(f))#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)#define pb push_back#define mp make_pairconst double pi = acos(-1.0);int op[300010];vector&lt;int&gt;child[300010];int leafcnt[300010];int n;int dfs(int idx){  if(child[idx].size() == 0){    leafcnt[idx] = 1;    return 0;  }  if(op[idx] == 1){    int ret = 300001;    for(auto item:child[idx]){      ret=min(ret,dfs(item));      leafcnt[idx]+=leafcnt[item];    }    return ret;  }else{    int ret = 0;    for(auto item:child[idx]){      ret += dfs(item)+1;      leafcnt[idx]+=leafcnt[item];    }    return ret -1;  }}int main(){  cin&gt;&gt;n;  rep(i,0,n){    scanf(&quot;%d&quot;,op+i);  }  rep(i,1,n){    int fa;    scanf(&quot;%d&quot;,&amp;fa);    child[fa-1].pb(i);  }  int ret = dfs(0);  printf(&quot;%d&quot;,leafcnt[0]-ret);  return 0;}</code></pre><h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><p>2100分</p><p>交互题</p><p><code>n*n</code>格子 (n&lt;=1000)</p><p>里面有一条弯曲的蛇，如果碰到蛇的头和尾则会挂掉</p><p>提供一个设备，传入一个矩形，可以返回蛇身体穿过矩形边界的次数</p><p>他只能 进行2019次询问，需要得到蛇头和尾的坐标。</p><p>蛇可以<code>1x1</code>，也就是身体长度为0,头尾在一个格子里</p><p>蛇在询问过程中不会动。</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>显然 如果头和尾有且只有一个在矩形,那么返回值为0或奇数</p><p>然后就先定行或列，首先如果长度不为0，那么必定不在同一个格子里，所以x和y必定有一个不同，</p><p>所以按照1xn的列和行依次尝试一定有2个为奇数返回，再二分对应的行或列</p><p>依次尝试<code>O(2*n)</code>,二分<code>O(2*log n)</code>,注意到只有2019次机会，所以我们需要加一些细节判断(否则会wa23)</p><p>我们注意到，如果一共n列，那么前n-1列有一个奇数出现，那么最有一列一定是奇数，如果前面全是偶数，那么最后一列也一定是偶数。行同理，所以可以少掉两个依次尝试</p><p>长度为0的，我们无法检测到，无脑输出<code>! 1 1 1 1</code>即可</p><h2 id="CODE-1"><a href="#CODE-1" class="headerlink" title="CODE"></a>CODE</h2><p><a href="https://codeforces.com/contest/1153/submission/53088621" target="_blank" rel="noopener">CODE LINK</a></p><pre><code class="c++">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define ten5 100000+10#define MOD 1000000007#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define iif(c,t,f) ((c)?(t):(f))#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)#define pb push_back#define mp make_pairconst double pi = acos(-1.0);int q(int x1,int y1,int x2,int y2){  printf(&quot;? %d %d %d %d\n&quot;,x1,y1,x2,y2);  fflush(stdout);  int ret;  scanf(&quot;%d&quot;,&amp;ret);  return ret;}void ok(int x1,int y1,int x2,int y2){  printf(&quot;! %d %d %d %d\n&quot;,x1,y1,x2,y2);  fflush(stdout);}int main(){  int n;  cin&gt;&gt;n;  int ii0=-1;  int ii1=-1;  rep(i,1,n+1){    if(i == n){      if(ii0!=-1 &amp;&amp; ii1 ==-1){        ii1=n;      }      break;    }    int r = q(i,1,i,n);    if(r%2==1){      if(ii0 == -1){        ii0 = i;      }else if(ii1 == -1){        ii1 = i;        break;      }    }  }  int jj0=-1;  int jj1=-1;  if(ii0 == -1){ // samex;    rep(i,1,n+1){      if(i == n &amp;&amp; jj0!=-1 &amp;&amp; jj1 !=-1){        jj1=n;        break;      }      int r = q(1,i,n,i);      if(r%2==1){        if(jj0 == -1){          jj0 = i;        }else if(jj1 == -1){          jj1 = i;          break;        }      }    }    // er fen    int l =1,r=n;    while(l != r){      int m=(l+r)/2;      int ret = q(l,jj0,m,jj0);      if(ret%2==1){        r=m;      }else{        l=m+1;      }    }    ii0=l;    l = 1;    r = n;    while(l != r){      int m=(l+r)/2;      int ret = q(l,jj1,m,jj1);      if(ret%2==1){        r=m;      }else{        l=m+1;      }    }    ii1=l;  }else{ // specific i0 &amp; i1    int l =1,r=n;    while(l != r){      int m=(l+r)/2;      int ret = q(ii0,l,ii0,m);      if(ret%2==1){        r=m;      }else{        l=m+1;      }    }    jj0 = l;    l =1;    r=n;    while(l != r){      int m=(l+r)/2;      int ret = q(ii1,l,ii1,m);      if(ret%2==1){        r=m;      }else{        l=m+1;      }    }    jj1 = l;  }  if(ii0 == -1){    ok(1,1,1,1);    return 0;  }  ok(ii0,jj0,ii1,jj1);  return 0;}</code></pre><h1 id="F"><a href="#F" class="headerlink" title="F"></a>F</h1><p>这篇文章鸽了这么久买就是因为这道题，我现在还是没有完全理解到，所以可以忽略下面所写TODO,因为下面只写了我能理解到的部分</p><p>CF 评分2800</p><p>长度l线段</p><p>随机取n个子线段,线段端点随机,可以非整数</p><p>求被这n条线段覆盖次数&gt;=k的线段期望长度</p><p><code>l&lt;=1e9</code></p><p><code>n,k&lt;=2000</code></p><p>除法使用乘法逆元,结果模998244353 </p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p><a href="https://codeforces.com/blog/entry/66539" target="_blank" rel="noopener">官方</a></p><p>首先放缩原理,期望与l正相关，所以l就是个倍数，所以只用考虑长度为1的情况.</p><p><del>根据实分析</del></p><p>贡献累计</p><p>考虑这n个线段的2n个端点，分割出的2n+1条线段，</p><p>计算每条线段被覆盖至少k次区间的期望数量 *期望长度</p><p>首先这2n个点是相互独立的</p><p>期望数量 = <code>(&gt;=k)概率</code></p><p>现在假设我们的到了一个已经生成好的点列，我们并不知道它们的连接情况。</p><p><code>f(i,j,0/1 )</code>表示以上点列 前i个点中 剩余j个点未匹配(线段左端)，满足(&gt;=k覆盖)的段的数量,P点是否出现(0,1)</p><p>P在i点的时候,f(i,j,1) = f(i-1,j,0) // j&gt;=k</p><p>新的线段<code>i+j+x &lt; 2n</code>, f(i-1,j-1,x)-&gt;f(i,j,x)</p><p>匹配开始idea线段:<code>f(i-1,j+1,x)*(j+1)-&gt;f(i,j,x)</code></p><p>所有的<code>arrangements</code>一共有<code>(2n+1)!</code>条</p>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF 愚人节赛题目鉴赏</title>
      <link href="/Blog/2019-04-02-cfaprilfool/"/>
      <url>/Blog/2019-04-02-cfaprilfool/</url>
      
        <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/1145/problems" target="_blank" rel="noopener">题目</a></p><h1 id="A-Thanos-Sort"><a href="#A-Thanos-Sort" class="headerlink" title="A Thanos Sort"></a>A Thanos Sort</h1><p>没啥讲的，阅读理解，模拟实现</p><h1 id="B-Kanban-Numbers"><a href="#B-Kanban-Numbers" class="headerlink" title="B Kanban Numbers"></a>B Kanban Numbers</h1><p>我的解题过程：<code>搜索kanban-&gt;signboard-&gt;led number</code>,尝试和led显示相关，未果</p><p>你群群友，有暴力枚举过B题的orz</p><p>实际解法是 标题+英语, <code>kanban number = &#39;k&#39; &#39;a&#39; &#39;n&#39; ban number</code>,也就是 英文不含字母<code>k</code> <code>a</code> <code>n</code>的</p><h1 id="C-Mystery-Circuit"><a href="#C-Mystery-Circuit" class="headerlink" title="C Mystery Circuit"></a>C Mystery Circuit</h1><p>量子计算相关(实际没有到量子)</p><p>有工具<a href="https://algassert.com/quirk" target="_blank" rel="noopener">Quirk</a></p><p>1) 4位2进制表示<br>2) 前后倒序<br>3) 按工具上面的按钮<br>4) 前后倒序<br>5) 再转换为10进制数</p><p><code>3-&gt;0011-&gt;1100-&gt;1011-&gt;1101-&gt;13</code></p><p><a href="https://en.wikipedia.org/wiki/Quantum_logic_gate" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Quantum_logic_gate</a></p><p>首先<code>十字+圆圈</code> 表示的是一个<code>非门</code></p><p>然后 竖着看，黑色的点是控制点，也就是竖着一条线上黑点 传入的数据 全是1时，非门才工作</p><p>这就是工具的运作原理，因为数也只有15个，你可以枚举打表，也可以实现这个控制逻辑</p><h1 id="D-Pigeon-d’Or"><a href="#D-Pigeon-d’Or" class="headerlink" title="D Pigeon d’Or"></a>D Pigeon d’Or</h1><p>我也发现是错误单词了，<a href="https://www.grammarcheck.net/editor/" target="_blank" rel="noopener">https://www.grammarcheck.net/editor/</a> 可以检查拼写错误,但是ai的范围是误导XD..我还在想 1 2 3 4 5的样例数据是怎么解释。</p><p>正确的解法是，把错的字母连接起来，变成一个句话,这句话就是一个英文描述的公式,66666</p><h1 id="E-Fourier-Doodles"><a href="#E-Fourier-Doodles" class="headerlink" title="E Fourier Doodles"></a>E Fourier Doodles</h1><p>这是近年的机器学习识数梗</p><p>我已经发现的有:前20张图size很大[指文件大小，不是图片尺寸]</p><p>正确解法就是 标题+压缩包，如题名 的傅里叶，把前20个图做傅里叶，然后拼出表达式，即可</p><p>请把下面程序放到和图片同目录下，然后运行(自行用pip install安装依赖包)</p><pre><code class="python">#!/usr/bin/python2from PIL import Imageimport numpy as npfrom scipy import fftpackimport matplotlib.pyplot as pltif __name__ == &#39;__main__&#39;:    plt.figure(figsize=(5, 5)) # 画布大小    for i in range(1, 21): # 20张图片        img = Image.open(str(i) + &#39;.png&#39;).convert(&#39;L&#39;)  # 灰度 多色应该也可以，但是还要加更多处理        imgout = fftpack.fftshift(fftpack.fft2(img)) # 2维傅里叶        psd2D = np.log(np.abs(imgout))  # (256,256) 取log        plt.subplot(4, 5, i) # 把它们依次显示在画布上        plt.axis(&#39;off&#39;)        plt.imshow(psd2D, cmap=&#39;Greys_r&#39;)    plt.show()</code></pre><p>官方题解给的在线工具 <a href="http://www.ejectamenta.com/Imaging-Experiments/fourierimagefiltering.html" target="_blank" rel="noopener">http://www.ejectamenta.com/Imaging-Experiments/fourierimagefiltering.html</a></p><h1 id="F-Neat-Numbers"><a href="#F-Neat-Numbers" class="headerlink" title="F Neat Numbers"></a>F Neat Numbers</h1><p>嗯。。我去google查了单词，但。。。。 google的翻译并不能成功的帮助我</p><p>正确解法是 标题+英文单词理解+样例，neat words要的是所有大写字母 都是<code>直线段</code>组成的 即可<code>AEFHIKLMNTVWXYZ</code>，相对来说其它字母是带有<code>弯</code>的</p><h1 id="G-AI-Takeover"><a href="#G-AI-Takeover" class="headerlink" title="G AI Takeover"></a>G AI Takeover</h1><p>和机器人石头剪刀布，它有6个测试，6种策略，对你是未知的，你需要自行猜测</p><p>如果你们出一样的，算机器人赢</p><p>机器人不会peeking你的选择（就是理论上同时）</p><p>R石头P布S剪刀</p><p>你需要的是20场内赢至少10场</p><p>题解:关键在于成功的猜到机器人的6种方法</p><p>题透: 机器人的方案</p><ol><li>全R</li><li>全P</li><li>全S，</li><li>循环R-P-S</li><li>从R开始，然后总是扮演人类玩家的最后一步，</li><li>从R开始，然后总是发挥击败人类玩家最后一步的动作。</li></ol><p>赛内建议的探测方法，用memory allocation ，或者sleep time，也就是可以读到的cf输出，来编码你直接看不到的结果，从而探测，机器人的方案</p><h1 id="综上"><a href="#综上" class="headerlink" title="综上"></a>综上</h1><p>真好玩+只会签到,题目都有实际的背景，出题不是乱出….总结逐渐开花</p>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AprilFool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF 548 Div2 E 网络流</title>
      <link href="/Blog/2019-03-29-cfP1139E/"/>
      <url>/Blog/2019-03-29-cfP1139E/</url>
      
        <content type="html"><![CDATA[<h1 id="题目HERE"><a href="#题目HERE" class="headerlink" title="题目HERE"></a><a href="https://codeforces.com/contest/1139/problem/E" target="_blank" rel="noopener">题目HERE</a></h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>n个人 最大5000</p><p>m个组 最大5000</p><p>每个人有潜力值最大 5000</p><p>每个人仅属于一个组</p><p>每一轮删除一个指定的人<code>index_i</code>(输入提供)</p><p>一共d轮，最大n</p><p>每一轮，从各组中选一个人构成数组，选出后放回原来的组，求每一轮的最大mex</p><p>mex:{数组中未出现的最小自然数},如 mex{0,1,2,3,6,7} = 4</p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><p>先倒转顺序，离线处理，把删除人变为向组中加人</p><p>网络流</p><p>起始节点到各个组节点建一条边，</p><p>各组的人向他的潜力值节点建立边</p><p>潜力值0 向end建立边</p><hr><p>当潜力值i 连接到end后，总流量等于i+1时(因为从0开始)，把潜力值i+1也连接到end</p><p><code>O(轮数*网络流复杂度) &lt;= O(d*(m+n+mex))</code></p><h1 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h1><pre><code class="c++">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define ten5 100000+10#define MOD 1000000007#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define iif(c,t,f) ((c)?(t):(f))#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)#define pb push_back#define mp make_pairconst double pi = acos(-1.0);#define ST 0#define END 10005#define POT(v) (v+5001)// 0 ,   1-5000 , 5001-10002 10005// st-&gt;1 -&gt; group-&gt;1 -&gt; potential(5001+mex+1) -&gt;1(dynamic add) -&gt; end// reverse ordermap&lt;int,int&gt;flow[10010];int n,m,d;int p[10010];int c[10010];bool notin[10010];int order[10010];int ans[10010];int mex = 0;int vis[100010];int dfs(int i,int load){  if(i == END)return load;  vis[i] = true;  for(auto item:flow[i]){    if(vis[item.first])continue;    if(item.second != 0){      int ret = dfs(item.first,min(load,item.second));      if(ret != 0){        flow[i][item.first] -= ret;        flow[item.first][i] += ret;        return ret;      }    }  }  return 0;}int getflow(){  int ret = dfs(ST,1);  rep(i,0,m+1){    vis[i]=false;  }  rep(i,0,5000){    vis[POT(i)] = false;  }  return ret;}int main(){  cin&gt;&gt;n&gt;&gt;m;  rep(i,1,n+1){    scanf(&quot;%d&quot;,p+i);  }  rep(i,1,n+1){    scanf(&quot;%d&quot;,c+i);  }  scanf(&quot;%d&quot;,&amp;d);  rep(i,0,d){    scanf(&quot;%d&quot;,order+i);    notin[order[i]] = true;  }  // built  // ST-&gt;group  rep(i,1,m+1){    flow[ST][i] = 1;  }  // group-&gt;mex  rep(i,1,n+1){    if(notin[i])continue;    flow[c[i]][POT(p[i])] = 1;  }  // mex 0 -&gt; end  flow[POT(mex)][END] = 1;  per(i,0,d){    while(getflow()){      flow[POT(++mex)][END] = 1;    }    ans[i] = mex;    // [order]-&gt;mex    flow[c[order[i]]][POT(p[order[i]])]+=1;  }  rep(i,0,d){    printf(&quot;%d\n&quot;,ans[i]);  }  return 0;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><a href="https://codeforces.com/contest/1139/submission/51956586" target="_blank" rel="noopener">CODE</a></p>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CF 548 Div2 D 莫反</title>
      <link href="/Blog/2019-03-23-cfP1139D/"/>
      <url>/Blog/2019-03-23-cfP1139D/</url>
      
        <content type="html"><![CDATA[<h1 id="题目HERE"><a href="#题目HERE" class="headerlink" title="题目HERE"></a><a href="https://codeforces.com/problemset/problem/1139/D" target="_blank" rel="noopener">题目HERE</a></h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p><code>1&lt;=m&lt;=100&#39;000</code></p><p>$ dp[x] =1 + \sum_{j=1}^{m}\frac{dp[gcd(j,x)]}{m} $</p><p>求$ans=\sum_{i=1}^{m}\frac{dp[i]}{m}$</p><p>上面公式怎么来的呢，一眼可见</p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><p>我做的时候卡在变形上了</p><p>首先，我们观察到右侧的dp中是j与x的gcd，那么也就是取值范围都是 x的约数，那么变形有</p><p>$f[n]=1+\sum_{d|n}\frac{f[d]\cdot g(n, d)}{m}$</p><p>其中<code>g(n,d)</code>表示 从1到m，和n gcd后结果为d的 数 的个数，也就是</p><p>$ g(n, d) = \sum_{i=1}^m[gcd(n, i)=d] $</p><p>同时乘上m，并把右侧 的f[n]的部分移到左侧</p><p>$(m-\lfloor\frac{m}{n}\rfloor)f[n]=m+\sum_{d|n,d\neq n}f[d]\cdot g(n, d)$</p><p>现在问题还有怎么计算g</p><p>观察g的表达式，说明i一定是d的倍数，所以可以变成<code>d*?</code></p><p>$ g(n, d) = \sum_{i=1}^{\lfloor\frac{m}{d}\rfloor}[gcd(n,i*d)=d] $</p><p>$ g(n, d) = \sum_{i=1}^{\lfloor\frac{m}{d}\rfloor}[gcd(\frac{n}{d},i)=1]$</p><p>注意到右侧的 求和部分实际是要gcd=1时，返回1，其它情况返回0，这和</p><p>$\mu * 1 = \epsilon$对应，也就是莫比乌斯，$\mu$函数 的因子和的性质，详细内容见下方<code>我之前的莫反总结</code>中写到的性质和证明</p><p>$\sum_{i=1}^{\lfloor\frac{m}{d}\rfloor}\sum_{t|gcd(\frac{n}{d},i)}\mu(t)$</p><p>$=\sum_{i=1}^{\lfloor\frac{m}{d}\rfloor}\sum_{t|\frac{n}{d},t|i}\mu(t)$</p><p>$=\sum_{t|\frac{n}{d}}\mu(t)\cdot \lfloor \frac {\lfloor \frac{m}{d} \rfloor} {t} \rfloor$</p><p>$=\sum_{t|\frac{n}{d}}\mu(t)\cdot \lfloor \frac{m}{dt} \rfloor$</p><p>综上</p><p>$(m-\lfloor\frac{m}{n}\rfloor)f[n]=m+\sum_{d|n,d\neq n}f[d]\sum_{t|\frac{n}{d}}\mu(t)\cdot \lfloor \frac{m}{dt} \rfloor$</p><h1 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a>官方题解</h1><p><a href="https://codeforces.com/blog/entry/66101" target="_blank" rel="noopener">官方题解</a></p><p>[题解1]</p><p>没有看懂后面的变形，怎么突然1就没了，m的系数移动后也没了??</p><p>方法也是讲如何计算<code>g(n,d)</code>，计算多少个<code>p=1-&gt;m 使得 gcd(p,n)=d</code></p><p>假设用乘法表示n和p，<code>n=d*a,p=d*b</code>, 有<code>1&lt;=p&lt;=m,gcd(a,b)=1</code>,也就是<code>1&lt;=b&lt;=m/d</code></p><p>然后对a因数分解，因此b不能含有a的任何因子，然后用 容斥算，因为n很小最多6个不同的质因子，所以简单dp</p><p>[题解2 就是莫反了]</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><a href="https://yexiaorain.github.io/Blog/2019-01-06-MobiusInversionFormula/">我之前的莫反总结</a></p><p><a href="https://www.cnblogs.com/zyt1253679098/p/10584706.html" target="_blank" rel="noopener">参考</a></p><p><a href="https://codeforces.com/contest/1139/submission/51899861" target="_blank" rel="noopener">CODE</a> 代码很丑见谅XD</p>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 莫比乌斯反演 </tag>
            
            <tag> 莫比乌斯 </tag>
            
            <tag> 莫比乌斯函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF EDU 61 E 数学题未知数表示法</title>
      <link href="/Blog/2019-03-09-cfEDU61E/"/>
      <url>/Blog/2019-03-09-cfEDU61E/</url>
      
        <content type="html"><![CDATA[<h1 id="题目HERE"><a href="#题目HERE" class="headerlink" title="题目HERE"></a><a href="https://codeforces.com/contest/1132/problem/E" target="_blank" rel="noopener">题目HERE</a></h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你</p><p>a1 个1</p><p>a2 个2</p><p>…</p><p>a8 个8</p><p>求用这些数中的一部分相加，得到的 最大的 不大于W的 数为多少</p><p>其中</p><p><code>1&lt;=ai&lt;=10^16</code></p><p><code>0&lt;=W&lt;=10^18</code></p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><p>翻译自<a href="https://codeforces.com/blog/entry/65752" target="_blank" rel="noopener">官方题解</a></p><p>假设在未知的最优解中 i 取<code>c_i</code>个</p><p>L = lcm(1,,,,8) = 840</p><p>那么<code>c_i</code>可以表示为</p><p><code>c_i= (L/i)*P_i+q_i</code> 根据除法余数性质可以让q满足 <code>0&lt;=q&lt;L/i</code></p><p><code>(L/i)*P_i</code>个i是L的倍数(且是1,2,3,4…倍 占满)（小学未知数乘法?）</p><p>所以只用枚举<code>q_i</code>的部分</p><p>然而这样 所有方案<code>840**8/8/7/6/5/4/3/2/1=6147715553280000000</code>时间内肯定过不了</p><p><code>dp[1-&gt;x types of items][weight] =  把构成weight的部分去除后 还能最多有多少个L</code> 这里的构成</p><p>空间<code>O(8*8L)</code></p><p>时间<code>O(8L*sum(L/1+L/2+...+L/8))</code></p><p><code>ans = max{ weight + L * min(dp[0][weight],(W-j)/L) (0&lt;=weight&lt;=8L)</code></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code class="c++">#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 9;const int L = 840;typedef long long li;li dp[N][L * N];li W;li cnt[N];int main(){  cin &gt;&gt; W;  for(int i = 0; i &lt; 8; i++)    cin &gt;&gt; cnt[i];  for(int i = 0; i &lt; N; i++) for(int j = 0; j &lt; L * N; j++) dp[i][j] = -1;  dp[0][0] = 0;  for(int i = 0; i &lt; 8; i++)  {    for(int j = 0; j &lt; L * N; j++)    {      if(dp[i][j] == -1) continue;      int b = L / (i + 1);      if(cnt[i] &lt; b)        b = cnt[i];      for(int k = 0; k &lt;= b; k++)      {        li&amp; d = dp[i + 1][j + k * (i + 1)];        d = max(d, dp[i][j] + (cnt[i] - k) / (L / (i + 1)));      }    }  }  li ans = 0;  for(int j = 0; j &lt; L * N; j++)  {    if(j &gt; W || dp[8][j] == -1)      continue;    ans = max(ans, j + L * (min(dp[8][j], (W - j) / L)));  }  cout &lt;&lt; ans &lt;&lt; endl;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CF EDU 61 E</title>
      <link href="/Blog/2019-03-11-CFP1137C/"/>
      <url>/Blog/2019-03-11-CFP1137C/</url>
      
        <content type="html"><![CDATA[<h1 id="题目HERE"><a href="#题目HERE" class="headerlink" title="题目HERE"></a><a href="https://codeforces.com/contest/1137/problem/C" target="_blank" rel="noopener">题目HERE</a></h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>n 个点 (<code>1&lt;=n&lt;=100000</code>)</p><p>m 条边 (<code>1&lt;=m&lt;=100000</code>)</p><p>有向图</p><p>从端点1出发，总共走d (<code>1&lt;=d&lt;=50</code>)天，每天能走一条边，能访问多少个不同的开放的点</p><p>开放时间表 <code>n*d</code>,0表示N号点 在D天关闭，1表示开放</p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><p>翻译自<a href="https://codeforces.com/blog/entry/65825" target="_blank" rel="noopener">官方题解</a></p><p>新建一个图</p><p>图上的点为 <code>([1-&gt;n],[0-&gt;d-1])</code> O(nd)</p><p>如果原来题目图上有(u,v)</p><p>建立边 <code>(u,t) -&gt; (v,(t+1)%d)</code> , O(m d d)</p><p>然后算 新图 的强连通分量，对每一个强连通分量缩点，计算 不同的开放的点的个数 = cost</p><p>在新的DAG上求最长路</p><p>假设一个点u 在新图中拆成 (u,j1)和(u,j2),也就是u 能通过某些边走到j1，注意到，新图里的边只和原图是否连通有关，所以 (u,j2) 能走到(u,(j2+(j2-j1))%d) 沿着<code>j1-&gt;j2</code>的路径，沿着这条路径走d-1次，那么走到<code>(u,(j2+(d-1)(j2-j1))%d) = (u,j1+d*(j2-j1)%d) = (u,j1)</code> 所以如果(u,j1)和(u,j2)弱连通，则它们强连通</p><p>在新的DAG(缩点后的)上 不会存在2个 u</p><p>在DAG有向无环图上 做dp</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>待补</p>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CF 546 Div2 E 线段树</title>
      <link href="/Blog/2019-03-13-cfP1136E/"/>
      <url>/Blog/2019-03-13-cfP1136E/</url>
      
        <content type="html"><![CDATA[<h1 id="题目HERE"><a href="#题目HERE" class="headerlink" title="题目HERE"></a><a href="https://codeforces.com/contest/1136/problem/E" target="_blank" rel="noopener">题目HERE</a></h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>数组<code>a[n]</code>, 其中<code>2&lt;=n&lt;=100&#39;000</code>,<code>-1&#39;000&#39;000&#39;000&lt;=a[i]&lt;=1&#39;000&#39;000&#39;000</code></p><p><code>a[i+1]-a[i] &gt;= k[i]</code> ,其中<code>-1&#39;000&#39;000&lt;=k[i]&lt;=1&#39;000&#39;000</code></p><p>q个操作<code>1&lt;=q&lt;=100&#39;000</code></p><p>操作类型1，对<code>a[i]</code> 增加<code>x</code>，其中<code>0&lt;=x&lt;=1&#39;000&#39;000</code>,如果操作后无法满足上面与k的关系，则调整<code>a[i+1]=a[i]+k[i]</code> 直到所有 的值都满足</p><p>操作类型2，求<code>sum of a[l-&gt;r]</code></p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><p>一眼就是个线段树，但是比以往遇到的线段树，要难维护一些，注意一下需要维护的状态</p><h2 id="limiaomiao的解法"><a href="#limiaomiao的解法" class="headerlink" title="limiaomiao的解法"></a>limiaomiao的解法</h2><ol><li><code>[l-&gt;r]</code> 实际的 差: der</li><li><code>[l-&gt;r]</code> 的差前缀和的和 :<code>sum[l-&gt;r] = (der[l])+(der[l]+der[l+1])+...+(der[l]+...+der[r])</code></li></ol><h3 id="build-tree"><a href="#build-tree" class="headerlink" title="build tree"></a>build tree</h3><p><code>der[o]= der[o&lt;&lt;1] + der[o&lt;&lt;1 | 1]</code> 记录的是<code>a[r]-a[l]</code>的实际差值</p><p><code>sum[o]= sum[o&lt;&lt;1] + sum[o&lt;&lt;1 | 1] + der[o&lt;&lt;1] * length of (o&lt;&lt;1 | 1)</code></p><h3 id="add-val"><a href="#add-val" class="headerlink" title="add val"></a>add val</h3><p>对a[i]增加x的操作</p><p>实际是对 a[i-1]和a[i]的差 增加，以及 对a[i]和a[i+1]的差 的减少x</p><p>这样，线段树上操作，[这样感觉会被卡，但看limiaomiao的代码 有个神奇操作，加了一个set来记录，哪些的差值和k不同] 这样每次改变值，最多能产生1个 新的和k不同的差，那么每次的时间消耗=1+消耗的不同于k的值</p><p>所以总时间 = 操作数+ 总消耗 &lt;= 操作数+ 初始不同的个数+过程中产生的不同的个数，是线性关系</p><h3 id="询问"><a href="#询问" class="headerlink" title="询问"></a>询问</h3><p><code>ans_sum[l-&gt;r]</code></p><p><code>=a[l]+...+a[r]</code></p><p><code>= a[l]*(r-l+1)+ ((der[l])+(der[l]+der[l+1])+...+(der[l]+...+der[r]))</code></p><p><code>= getval(a[l])×(r-l+1)+query_sum(l-&gt;r)</code></p><h2 id="我这里的思路"><a href="#我这里的思路" class="headerlink" title="我这里的思路"></a>我这里的思路</h2><p>注意到实际维护的是<code>a[i+1]-a[i]-k[i] &gt;= 0</code></p><p>那么线段树，可以是在数组<code>b[i]=a[i+1]-a[i]-k[i]</code>上面建立</p><p><code>b[i]</code>所以要全非负</p><h3 id="build-tree-1"><a href="#build-tree-1" class="headerlink" title="build tree"></a>build tree</h3><p><code>der[o]= der[o&lt;&lt;1] + der[o&lt;&lt;1 | 1]</code> 记录的是<code>a[l-&gt;r]的差值再减去这一段k的差值</code>保证非负</p><p><code>sum[o]= sum[o&lt;&lt;1] + sum[o&lt;&lt;1 | 1] + der[o&lt;&lt;1] * length of (o&lt;&lt;1 | 1)</code></p><h3 id="add-val-1"><a href="#add-val-1" class="headerlink" title="add val"></a>add val</h3><p>同样 对a[i]增加x的操作</p><p>实际是对 a[i-1]和a[i]的差 增加，以及 对a[i]和a[i+1]的差 的减少x</p><p>注意到这样的话，增加x的部分就可以先lazy掉，</p><p>在减少的部分，如果 <code>der[l-&gt;r] &lt; x</code> 那么这一段整个der都是0，可以lazy掉，保证了每次的log级别的操作</p><p>除此以外，每次可能访问的时候，把lazy的部分向下分发一下</p><h3 id="询问-1"><a href="#询问-1" class="headerlink" title="询问"></a>询问</h3><p><code>ans_sum[l-&gt;r]</code></p><p><code>=a[l]+...+a[r]</code></p><p><code>= a[l]*(r-l+1)+ ((der[l]+k[l])+(der[l]+k[l]+der[l+1]+k[l+1])+...+(der[l]+k[l]+...+der[r]+k[r]))</code></p><p><code>= getval(a[l])×(r-l+1)+query_sum(l-&gt;r)+sum_der_k(l-&gt;r)</code></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>相比之下 我这样写，线段树的lazytag的多两个lazytag,而且 对于k也要维护一个sum的线段树,更难写</p>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CF 545 Div1 D Floyd判环</title>
      <link href="/Blog/2019-03-08-cfP1137D/"/>
      <url>/Blog/2019-03-08-cfP1137D/</url>
      
        <content type="html"><![CDATA[<h1 id="题目HERE"><a href="#题目HERE" class="headerlink" title="题目HERE"></a><a href="https://codeforces.com/contest/1137/problem/D" target="_blank" rel="noopener">题目HERE</a></h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><blockquote><p>交互题</p></blockquote><p><code>1&lt;= t,c,(t+c)&lt;=1000</code></p><p>有一条链表，这个链表上有一个环，其中环的部分长度为c，非环的部分长度为t</p><p>从非环的部分开始走，目的地是 环和非环的交界处，也就是环的入口(环上)</p><p>不知道t和c</p><p>一共有10个单位可以用来走</p><p>交互次数应当&lt;=3(t+c)</p><blockquote><p>交互:</p></blockquote><p>每次提供 需要移动的单位列表，比如<code>2 4 5</code>，那么意味着 2号 4号 5号 沿着链表跳向下一个节点</p><p>每次操作返回 哪些单位在同一个点上,如<code>129 3745 680</code> 表示，1号2号9号在一个点上，3.7.4.5在一个点上..</p><p>当你认为所有点都走到入口上的时候，输出done</p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><p>分成 甲 乙 丙</p><p>甲1步<br>乙2步</p><p>甲<code>t</code>步，乙<code>2*t</code>步在环上，变成环上追击问题，距离为 <code>(c-(2t-t)%c)%c = (c-t%c)%c</code></p><p>然后，甲乙丙，都走1步</p><p>当丙进入环时，步数为<code>t</code></p><p>甲和乙相遇后一起走，所以位置相同，甲的步数这时候为 <code>(t+ (c-t%c)%c)+t</code></p><p>注意到<code>(t+ (c-t%c)%c)</code>是c的倍数，也就是，丙刚进入时，甲和乙也同时走到了环的入口</p><p>总耗时<code>2(t+(c-t%c)%c)+t = 3t + 2(c-t%c)%c &lt; 3t+3c = 3(t+c)</code></p><p>解了</p>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CF EDU 59 E 看似n方，实则O(n)的三分dp</title>
      <link href="/Blog/2019-02-03-cf1107E/"/>
      <url>/Blog/2019-02-03-cf1107E/</url>
      
        <content type="html"><![CDATA[<h1 id="题目HERE"><a href="#题目HERE" class="headerlink" title="题目HERE"></a><a href="https://codeforces.com/contest/1107/problem/E" target="_blank" rel="noopener">题目HERE</a></h1><p>题目大意给</p><p>01串 长度&lt;=100</p><p>每次可以任选一段连续的相同数字的串删掉，删掉的代价为cost[长度]，删掉后 原来的串两端相连，求这样操作直到删空，cost和的最大值</p><p>如 0011100 删掉中间连续3个1 变成0000，并且获得cost[3] </p><p>样例</p><pre><code>711010013 4 9 100 1 2 3</code></pre><p>输出109</p><p>1101001 → 111001 → 11101 → 1111 → ∅.</p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><p>状态 dp[开始index][结束index(不包括)][?-&gt;开始index 相同的数字的长度len]</p><p><code>[开始index,结束index)</code>且开始的左边还有 len-1个和s[开始index]相同的数字</p><p>状态转移</p><p>dp[start][end][len] = max(A[len]+dp[start+1][end][1],max(dp[start+1][itr][1]+dp[itr][end][len+1])), 其中s[itr] == s[start]</p><p>举例解释</p><pre><code>11111100001111011yyyy   s             e          i   4=len    xxxxxx</code></pre><p>上面假设在求 dp[s][e][len]</p><p>那么A[len]+dp[s+1][end][1]表示先一次处理掉yyyy对应部分 再处理s以后的部分</p><p>那么dp[s+1][i][1]表示把xxxxx对应部分处理掉的代价,dp[i][e][len+1]表示的是 处理掉xxxxx这部分后，在处理剩余部分的代价</p><p>所以最终，答案就是dp[0][N][1]</p><p>状态O(n^3)状态转移O(N)所以总时间复杂度 O(N^4)</p><p><a href="https://codeforces.com/contest/1107/submission/49036191" target="_blank" rel="noopener">code</a></p>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CF Round 530 Div1 B 数学题 简单反证</title>
      <link href="/Blog/2019-01-08-cf1099E/"/>
      <url>/Blog/2019-01-08-cf1099E/</url>
      
        <content type="html"><![CDATA[<h1 id="题目HERE"><a href="#题目HERE" class="headerlink" title="题目HERE"></a><a href="https://codeforces.com/contest/1098/problem/B" target="_blank" rel="noopener">题目HERE</a></h1><p>求一个<code>n x m &lt;= 300 000</code>的二维字符数组</p><p>满足任何<code>2x2</code>的字符都包含A T G C</p><p>并且和给你的 数组不同的字符尽量少</p><h1 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h1><p>我有发现如果已经有</p><pre><code>AGTC</code></pre><p>那么右侧一列,一定是AT,顺序不定</p><p>下面两个一定是AG顺序不定,</p><hr><p>又发现如果对于任意<code>2*3</code></p><pre><code>XYZ???</code></pre><p>如果XYZ出现了3个字母</p><p>那么???下方的一定是XYZ且顺序不变</p><p>因为如果Y不在中间,那么会变成</p><pre><code>XYZ???Y?Y</code></pre><p>第3行填X 或 Z都是不行的</p><hr><p>又发现<code>2x3</code>如果XYZ 3个字母不同,具有性质,</p><pre><code>XYZ???</code></pre><p>下面的??? 是确定的,因为X列和Z列是相等的,所以一定是,其中O表示第4个字母</p><pre><code>XYZZOX</code></pre><p>然后我就现在想如何构造 去找,因为找到3个不同,那么整列都确定了</p><hr><p><strong>然后就自闭了</strong></p><p>其实可以把上面的事实展开</p><pre><code>XYZZOXXYZZOXXYZZOXXYZZOX</code></pre><p>有结论,如果 某<code>行</code>中出现连续3个不同字符,那么这3个字符对应的<code>列</code>,每<code>列</code>包含且仅包含两个字符,且任意行 包含连续这3个不同字符</p><p>交换行列有,如果 某<code>列</code>中出现连续3个不同字符,那么这3个字符对应的<code>行</code>,每<code>行</code>包含且仅包含两个字符,且任意列 包含连续这3个不同字符</p><p>注意到上面两条是事实,但是是互斥的</p><p>那么 目前有3种情况</p><ol><li>所有行列,的每一个行列,仅仅包含两个字符[且两两交替.废话]</li><li>存在一列 包含3个不同字符,那么所有列都包含这3个不同字符,所有行的每一行仅仅包含两个字符,</li><li>和2把 行列换一下</li></ol><p>综上↓</p><h1 id="以下是一句话题解"><a href="#以下是一句话题解" class="headerlink" title="以下是一句话题解"></a>以下是一句话题解</h1><p>如果你发现了事实:</p><p>要么每一行 只有两种字母</p><p>或</p><p>要么每一列 只有两种字母</p><hr><p>没了 然后暴力枚举就完了 这个题评分果然有2300,感觉这种题又是需要多枚举几个比如能枚举到<code>5*5</code>的能看出规律就好了</p>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Möbius inversion formula</title>
      <link href="/Blog/2019-01-06-MobiusInversionFormula/"/>
      <url>/Blog/2019-01-06-MobiusInversionFormula/</url>
      
        <content type="html"><![CDATA[<h1 id="Mobius-function"><a href="#Mobius-function" class="headerlink" title="Möbius function"></a>Möbius function</h1><p>${\displaystyle \mu (n)=\delta _{\omega (n)}^{\Omega (n)}\lambda (n)}$</p><p>${\displaystyle \delta }$  是 Kronecker delta, λ(n) 是 Liouville 函数, ω(n) 是n的不同的质因数个数，Ω(n) 是质因子个数</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>μ(n) = 0 如果n的质因子有幂次大于1的</p><p>μ(n) = 1 如果n由偶数个不同质数相乘</p><p>μ(n) = −1 如果n由奇数个不同质数相乘</p><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>${\displaystyle \sum _{d\mid n}\mu (d)={\begin{cases}1&amp;{\text{if }}n=1,\\0&amp;{\text{if }}n&gt;1.\end{cases}}}$</p><p>有的地方写作</p><p>$\mu * 1 = \epsilon$ 其中星号表示<a href="https://en.wikipedia.org/wiki/Dirichlet_convolution" target="_blank" rel="noopener">狄利克雷卷积</a>,正好对应的是 所求和的d都是n的因子</p><h3 id="性质的证明"><a href="#性质的证明" class="headerlink" title="性质的证明"></a>性质的证明</h3><p>首先 要<code>μ(x) != 0</code></p><p>需要x的各个质因子次数恰好为1</p><p>假设n的所有质因子有t个,既 $n = p_1^{a_1} * p_2^{a_2}…p_t^{a_t}$</p><p>那么 所有是n的因子的x 且$\mu(x) \neq 0$ 的x,则为这t个质因子的组合</p><p>注意到 不包含平方数的 Möbius function也可以写成</p><p>$\mu(n) = (-1)^{t}$, 其中n不包含平方数,t为其质因子个数</p><p>${\displaystyle \sum _{d\mid n}\mu (d) = \sum _ {k=0}^t {t \choose k}(-1)^{k} = (1-1)^t = 0 }$</p><p>证毕</p><h2 id="积性函数"><a href="#积性函数" class="headerlink" title="积性函数"></a>积性函数</h2><p>Möbius function 是 积性函数!! 根据积性函数定义 如果gcd(a,b) == 1 有 f(ab)=f(a)*f(b)</p><p>$\mu(ab) = \mu(a) \mu(b)$ ,当 a和b互质</p><p>wikipedia上,还有写些其它性质</p><p>不过和本文的关系不大,就没有 copy paste过来</p><h1 id="Mobius-inversion-formula"><a href="#Mobius-inversion-formula" class="headerlink" title="Möbius inversion formula"></a>Möbius inversion formula</h1><p>如果 f和g都是算数函数,且</p><p>$g(n)=\sum_{d\,\mid \,n}f(d)\quad\text{对所有整数 }n\ge 1$</p><p>g(n)表示它所有因子对应的f的和,所以一旦有题目F(x) = sum 所有f(y),y是x的因子，就可以联想到反演</p><p>那么有</p><p>${\displaystyle f(n)=\sum _{d\,\mid \,n}\mu (d)g\left({\frac {n}{d}}\right)\quad {\text{对所有整数 }}n\geq 1}$</p><blockquote><p>证明</p></blockquote><p>${\displaystyle \sum _{n\mid x}\mu (n)g\left({\frac {x}{n}}\right)}$</p><p>${\displaystyle =\sum _{n\mid x}\mu (n)\sum _{m\mid {\frac {x}{n}}}f\left(m\right)}$</p><p>${\displaystyle=\sum _{m\mid x}f\left(m\right)\sum _{n\mid \frac{x}{m}}\mu (n)}$ (n能取到所有x的因子,m也能取到,且满足n,m其中一个确定时,另一个取值使得n*m为x的因子)</p><p>${\displaystyle=f(x)}$</p><p>见上面Möbius function的性质,也就是仅在m=x时 右侧的sum 才不为0,且为1</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>线性筛</p><pre><code class="c++">const int maxn = 100000000;int prime[maxn], tot, mu[maxn];bool check[maxn];void calmu(){  mu[1] = 1;  rep(i,2,maxn){    if (!check[i]){      prime[tot++] = i;      mu[i] = -1;    }    rep(j,0,tot){      if (i * prime[j] &gt;= maxn) break;      check[i * prime[j]] = true;      if (i % prime[j] == 0){        mu[i * prime[j]] = 0;        break;      }else        mu[i * prime[j]] = -mu[i];    }  }}</code></pre><h1 id="练习题目"><a href="#练习题目" class="headerlink" title="练习题目"></a>练习题目</h1><p><a href="https://codeforces.com/contest/1097/problem/F" target="_blank" rel="noopener">CF Hello 2019 F</a></p><p><a href="https://codeforces.com/problemset/problem/1139/D" target="_blank" rel="noopener">CF 548 Div2 D </a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://en.wikipedia.org/wiki/M%C3%B6bius_inversion_formula" target="_blank" rel="noopener">Möbius inversion formula</a></p><p><a href="https://en.wikipedia.org/wiki/M%C3%B6bius_function" target="_blank" rel="noopener">Möbius function</a></p><p><a href="https://oeis.org/A008683" target="_blank" rel="noopener">OEIS A008683</a></p><p><a href="https://mathlesstraveled.com/2016/11/29/the-mobius-function-proof-part-1/" target="_blank" rel="noopener">https://mathlesstraveled.com/2016/11/29/the-mobius-function-proof-part-1/</a></p><p><a href="https://mathlesstraveled.com/2016/09/08/post-without-words-11/" target="_blank" rel="noopener">https://mathlesstraveled.com/2016/09/08/post-without-words-11/</a></p><p><a href="http://2000clicks.com/MathHelp/NumberTh06MobiusFunction.aspx" target="_blank" rel="noopener">http://2000clicks.com/MathHelp/NumberTh06MobiusFunction.aspx</a></p><p><a href="https://www.youtube.com/watch?v=XKjQcPNWMo0" target="_blank" rel="noopener">https://www.youtube.com/watch?v=XKjQcPNWMo0</a></p><p><a href="https://www.youtube.com/watch?v=-blqpqbgu0Q" target="_blank" rel="noopener">https://www.youtube.com/watch?v=-blqpqbgu0Q</a></p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Möbius function </tag>
            
            <tag> 莫比乌斯反演 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FFT大数乘法(DFT,IDFT)</title>
      <link href="/Blog/2019-01-02-fftmul/"/>
      <url>/Blog/2019-01-02-fftmul/</url>
      
        <content type="html"><![CDATA[<h1 id="FFT-大数乘法"><a href="#FFT-大数乘法" class="headerlink" title="FFT 大数乘法"></a>FFT 大数乘法</h1><p>不论FFT还是FFT大数乘法,网上都有”大量”的资料</p><p>但很多都看得云里雾里,不太能真正的理解</p><p>有几篇快要讲清了,但实际靠的 举例 来描述其可行性,</p><p>本篇希望从个人理解以及偏数学的角度来解释</p><h1 id="FFT-大数乘法要解决的问题"><a href="#FFT-大数乘法要解决的问题" class="headerlink" title="FFT 大数乘法要解决的问题"></a>FFT 大数乘法要解决的问题</h1><p>小学生都知道,乘法就是列竖式,然后进行一个数字一个数字的乘法再相加</p><p>那么对于一个<code>长度a</code>和<code>长度b</code>的两个数字相乘,进行了$O(ab)$次的运算,为了描述简便,假设 两个数字的长度都为$n=max(a,b)$,不足的补零,也就是$O(n^2)$的时间复杂度</p><p>那么如果题目是 长$50000$乘长$50000$的运算,那么用原始的乘法是无法在1s内解出的,</p><p>FFT可以做到$O(n \cdot log(n))$时间复杂度</p><h1 id="计算逻辑总览"><a href="#计算逻辑总览" class="headerlink" title="计算逻辑总览"></a>计算逻辑总览</h1><p>要计算 $a \cdot b$</p><p>且存在 函数$f:x \to X$,能使</p><ol><li>$f:x \to X$ 的时间复杂度 $\le O(n \cdot log (n))$</li><li>$f^{-1}:X \to x$ 的时间复杂度 $\le O(n \cdot log (n))$, 注:是逆运算不是$-1$次方</li><li>$f^{-1}(g(f(a),f(b))) = a\cdot b$, 其中$g$的时间复杂度 $\le O (n \cdot log(n))$</li></ol><p>用文字描述,大自为</p><blockquote><p>如果$a,b$可以通过$f$函数变为$A,B$<br>且$A,B$通过$g$的运算变为$C$<br>$C$再通过$f$的逆函数变为$c$<br>且$c == a \cdot b$的<br>那么原本$O(n^2)$的乘法,就可以用这样的方法替代,变为$O(n \cdot log(n))$</p></blockquote><p>观察上面的式子,可以发现,如果有以下两个映射也可以实现</p><ol><li>$f:x \to X$ 的时间复杂度 $\le O(n \cdot log (n))$</li><li>$g(f(a),f(b)) = a\cdot b$, 其中$g$的时间复杂度 $\le O(n \cdot log (n))$</li></ol><p>之所以写成3条是因为我们具体用得方法, 和3条对应</p><p>所以简单的理解,为如果把$a,b$进行<code>低时间复杂度</code>的变形,再进行某种<code>低时间复杂度</code>的运算能变为$a\cdot b$,那么即可在<code>低时间复杂度</code>内算出$a\cdot b$</p><h1 id="先抛开时间复杂度谈方法"><a href="#先抛开时间复杂度谈方法" class="headerlink" title="先抛开时间复杂度谈方法"></a>先抛开时间复杂度谈方法</h1><p>$ f * g= \mathcal{F}^{-1} \{ \mathcal{F} \{ f \} \cdot \mathcal{F} \{ g \} \}$</p><p>以上就是整个FFT大数乘法的所有数学公式,实际问题是离散傅立叶变换</p><p>分别解释符号</p><ol><li>$*$ 卷积 不是乘号</li><li>$\mathcal{F}$傅里叶变换</li><li>$\cdot$ 乘</li><li>$f,g$ 这里看作$n$元向量</li></ol><h2 id="卷积-连续的"><a href="#卷积-连续的" class="headerlink" title="卷积(连续的)"></a>卷积(连续的)</h2><p>定义</p><p>${\displaystyle (f * g)(t){\stackrel {\mathrm {def} }{=}}\ \int_{-\infty }^{\infty }f(\tau )g(t-\tau )\,d\tau }$</p><p>简单讲,卷积的结果$(f * g)(t)$ 等于 $f(r)\cdot g(t-r)$的积分</p><p>这里就和乘法$a \cdot b = c$ 对应上了,在乘法过程中,不考虑进位, 每一位的取值都是所有整数</p><p>结果的第$t$位的原始值 = 所有$a$的$i$位 乘上 $b$的$t-i$位的和</p><p>$c_t = \sum_{i=0}^t a_i\cdot b_{t-i}$</p><h2 id="傅里叶变换-连续的"><a href="#傅里叶变换-连续的" class="headerlink" title="傅里叶变换(连续的)"></a>傅里叶变换(连续的)</h2><p>也就是上面的$\mathcal{F}$</p><p>${\displaystyle {\hat {f}}(\xi )=\int_{-\infty }^{\infty }f(x)\ e^{-2\pi ix\xi }\,dx,}$ (定义)</p><p>逆变换</p><p>${\displaystyle f(x)=\int_{-\infty }^{\infty }{\hat {f}}(\xi )\ e^{2\pi ix\xi }\,d\xi ,}$ (由正向定义推导)</p><h2 id="证明-卷积的等式"><a href="#证明-卷积的等式" class="headerlink" title="证明 卷积的等式"></a>证明 卷积的等式</h2><p>要证明 $f * g= \mathcal{F}^{-1} \{ \mathcal{F} \{ f \} \cdot \mathcal{F} \{ g \} \}$</p><p>抄写自wiki</p><p>$\mathcal{F}\{f * g\}(\nu ) $</p><p>$= \int_{\mathbb{R}^n} \{f * g\} (z) \, e^{-2 \pi i z\cdot \nu}\, dz$ (傅立叶定义)</p><p>$= \int_{\mathbb{R}^n} \int_{\mathbb{R}^n} f(x) g(z-x)\, dx\, e^{-2 \pi i z\cdot \nu}\, dz.$ (卷积定义)</p><p>$= \int_{\mathbb{R}^n} f(x)\left(\int_{\mathbb{R}^n} g(z-x)e^{-2 \pi i z\cdot \nu}\,dz\right)\,dx.$(积分顺序)</p><p>$= \int_{\mathbb{R}^n} f(x) \left( \int_{\mathbb{R}^n} g(y) e^{-2 \pi i (y+x)\cdot\nu}\,dy \right) \,dx$,(换元$z=x+y$)</p><p>$= \int_{\mathbb{R}^n} f(x)e^{-2\pi i x\cdot \nu} \left( \int_{\mathbb{R}^n} g(y) e^{-2 \pi i y\cdot\nu}\,dy \right) \,dx$ (提取与$y$无关乘法因式)</p><p>$= \int_{\mathbb{R}^n} f(x)e^{-2\pi i x\cdot \nu}\,dx \int_{\mathbb{R}^n} g(y) e^{-2 \pi i y\cdot\nu}\,dy.$</p><p>$= {\mathcal {F}}\{f\}(\nu ) \cdot {\mathcal {F}}\{f\}(\nu)$</p><p>得证</p><h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><p>至此,我们有了</p><ol><li>乘法 中按位 表示 和卷积对应</li><li>上面要找的f,和傅里叶变换对应,$f^{-1}$和傅里叶逆变换对应</li><li>有 $ f * g $ 等式</li></ol><p>所以</p><p>乘法按位表示 $\to$ 卷积 $\to$ ((函数的傅里叶变换)的 积)的傅里叶逆变换</p><p>当然这里证明的是连续的傅立叶和卷积,而我们下面用的是离散傅立叶(讲道理还是要单独证明的,这里并没有证明</p><h1 id="接下来谈一谈-如何实现-并且能在时间复杂度内"><a href="#接下来谈一谈-如何实现-并且能在时间复杂度内" class="headerlink" title="接下来谈一谈,如何实现,并且能在时间复杂度内"></a>接下来谈一谈,如何实现,并且能在时间复杂度内</h1><p>先处理傅里叶变换的部分,首先离散傅里叶变换DFT的定义为 $x \to X$</p><p>$X_{k}=\sum _ {n=0}^{N-1}x _ {n}e^{-\frac{2 \pi i}{N}kn}\qquad k=0,\dots ,N-1.$ </p><p>IDFT</p><p>$X_{k}=\frac{1}{N} \sum _ {n=0}^{N-1}x _ {n}e^{\frac{2 \pi i}{N}kn}\qquad k=0,\dots ,N-1.$ </p><p><strong>注: 有的地方系数不是$1$和$\frac{1}{N}$,是两个 $\frac{1}{\sqrt{N}}$</strong>, 本质上没有区别,也不影响后面的推导的核心内容</p><blockquote><p>其中$i,\pi,e$为意义,单位虚数,元周率,自然对数, 这里主要是复平面的单位向量的知识点</p></blockquote><blockquote><p>$N$取$2^{\lceil log_2n \rceil}$ 也就是长度取到2的幂次, 不足的补零</p></blockquote><p>把这个式子用矩阵表示$X = Wx$,发现其实是一个”系数矩阵$W$”</p><p>${\displaystyle W=\left(\omega^{jk}\right)_ {j,k=0,\ldots ,N-1}}$</p><p>${\displaystyle W={\begin{bmatrix}<br>1&amp;1&amp;1&amp;1&amp;\cdots &amp;1\\<br>1&amp;\omega &amp;\omega ^{2}&amp;\omega ^{3}&amp;\cdots &amp;\omega ^{N-1}\\<br>1&amp;\omega ^{2}&amp;\omega ^{4}&amp;\omega ^{6}&amp;\cdots &amp;\omega ^{2(N-1)}\\<br>1&amp;\omega ^{3}&amp;\omega ^{6}&amp;\omega ^{9}&amp;\cdots &amp;\omega ^{3(N-1)}\\<br>\vdots &amp;\vdots &amp;\vdots &amp;\vdots &amp;\ddots &amp;\vdots \\<br>1&amp;\omega ^{N-1}&amp;\omega ^{2(N-1)}&amp;\omega ^{3(N-1)}&amp;\cdots &amp;\omega ^{(N-1)(N-1)}<br>\end{bmatrix}},{\displaystyle \omega =e^{-\frac{2\pi i}{N}}}}$</p><p>目标是求向量$X$,虽然求这个矩阵需要$O(n^2)$的时间,但可以不求矩阵,直接求向量$X$</p><p>希望能$O(n\cdot log(n))$求出列向量$X$</p><p><strong>行列按照$0$-index作为下标</strong>, 那么有</p><ul><li><p>矩阵的 $上一列_ i \cdot \omega^i = 下一列_ i$</p></li><li><p>在偶数列向量中,列上$i$和$i+\frac{n}{2}$互为相反数, 因为$\omega^{\frac{N}{2}} = -1$ (或见<a href="https://www.youtube.com/watch?v=EsJGuI7e_ZQ&amp;t=330s" target="_blank" rel="noopener">youtube</a></p></li></ul><p>因此有递推式</p><p>$f(x,N,idx)$ = 初始向量为$x$, 大小为$N$(即要乘上$N$阶矩阵), 结果的第<code>idx</code> 个的值</p><p>对于 $idx &lt; \frac{N}{2}$</p><p>$odd(x)$  表示 $x$的奇数位置上的值构成的长度$\frac{N}{2}$的向量</p><p>$even(x)$ 表示 $x$的偶数位置上的值构成的长度$\frac{N}{2}$的向量</p><p>$f(x,N,idx) = f(even(x),\frac{N}{2},idx) + w^k \cdot f(odd(x),\frac{N}{2},idx)$</p><p>$f(x,N,idx+\frac{N}{2}) = f(even(x),\frac{N}{2},idx) - w^k \cdot f(odd(x),\frac{N}{2},idx)$</p><p>函数是折半的,复杂度显然</p><p>至此傅里叶变换可以在$O(n\cdot log(n))$时间复杂度内实现</p><hr><p>为了帮助理解上面这个递归式, 这里举个例子, 比如$N=8, idx = 2$ 求$f(x,8,2)$</p><p>$X_2 = 1\cdot x_0 + w^2\cdot x_1 + w^4 \cdot x_2 + w^6 \cdot x_3 + w^8 \cdot x_4 + w^{10}\cdot x_5 + w^{12} \cdot x_6 + w^{14} \cdot x_7 $</p><p>$X_{2+\frac{8}{2}} = X_{6} = 1\cdot x_0 + w^6\cdot x_1 + w^{12} \cdot x_2 + w^{18} \cdot x_3 + w^{24} \cdot x_4 + w^{30}\cdot x_5 + w^{36} \cdot x_6 + w^{42} \cdot x_7 $</p><p>注意到在$N=8$时,$w^4 = -1$, 所以</p><p>$X_{2+4} = 1\cdot x_0 - w^2\cdot x_1 + w^4 \cdot x_2 - w^6 \cdot x_3 + w^8 \cdot x_4 - w^{10}\cdot x_5 + w^{12} \cdot x_6 - w^{14} \cdot x_7 $</p><p>这不就是</p><p>$X_2 = (w^0 \cdot x_0 + w^4 \cdot x_2 + w^8 \cdot x_4 + w^{12} \cdot x_6) + w^2 (w^0 \cdot x_1 + w^4 \cdot x_3 + w^8\cdot x_5 + w^{12} \cdot x_7 ) $</p><p>$X_{2+4} = (w^0 \cdot x_0 + w^4 \cdot x_2 + w^8 \cdot x_4 + w^{12} \cdot x_6) - w^2 (w^0 \cdot x_1 + w^4 \cdot x_3 + w^8\cdot x_5 + w^{12} \cdot x_7 ) $</p><p>注意到$w_{2N}^{2k} = w_{N}^k$</p><p>而其中的 $w^0 \cdot x_0 + w^4 \cdot x_2 + w^8 \cdot x_4 + w^{12} \cdot x_6$ 正是$x$的偶数项 在 $N=4$ 时的$X_2$, 即$f(even(x), 4, 2)$</p><p>$w^0 \cdot x_1 + w^4 \cdot x_3 + w^8\cdot x_5 + w^{12} \cdot x_7 $ 正是$x$的奇数项 在 $N=4$ 时的$X_2$,即$f(odd(x), 4, 2)$</p><hr><p>那么$g$也就是其中的 按位乘 也就是简单的$O(n)$</p><p>最后 傅里叶逆变换, 可以注意到上面的公式只在 系数上多了一个负号,所以同理可以在$O(n \cdot log (n))$时间复杂度内实现</p><h2 id="递归-原地"><a href="#递归-原地" class="headerlink" title="递归+原地"></a>递归+原地</h2><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;const double pi = acos(-1.0);void FFT(complex&lt;double&gt; * A, int n /* size */, int flag /* 1:FFT,-1:IFFT*/) {    if (n == 1) return;    // assert((n &amp; (n-1)) == 0); 一定要是2的幂次    // e^(i*x) = cos(x)+i*sin(x)    complex&lt;double&gt; Wm(cos(2 * pi / n), -sin(2 * pi / n) * flag);    vector&lt;complex&lt;double&gt; &gt; tmp(n);    int u = 0;    for (int k = 1; k &lt; n; k += 2, u++) tmp[u] = A[k]; // 奇数列    for (int k = 0; k &lt; n; k += 2) A[k / 2] = A[k]; // 偶数列    for (int k = u, i = 0; k &lt; n &amp;&amp; i &lt; u; k++, i++) A[k] = tmp[i];    FFT(A        , n / 2, flag);    FFT(A + n / 2, n / 2, flag);    complex&lt;double&gt; W(1, 0); // 运算中是 Wm 的i 次方    for (int i = 0; i &lt; n / 2 ; i++){        int j = n / 2 + i;        auto U = A[i];        auto T = W * A[j];        A[i] = U + T;        A[j] = U - T;        W *= Wm;    }}int main(){  // 123*456 = 56088  const int SIZE = 8; // 一定要是2的幂次  complex&lt;double&gt; * a = new complex&lt;double&gt;[SIZE]{3,2,1,0,0,0,0,0};  complex&lt;double&gt; * b = new complex&lt;double&gt;[SIZE]{6,5,4,0,0,0,0,0};  FFT(a, SIZE, 1);  FFT(b, SIZE, 1);  complex&lt;double&gt; * c = new complex&lt;double&gt;[SIZE]{0,0,0,0,0,0,0,0};  for(int i = 0;i &lt; SIZE;i++) c[i] = a[i] * b[i];  FFT(c, SIZE, -1);  for(int i = 0;i &lt; SIZE;i++) c[i] /= SIZE;  // print  for(int i = 0;i &lt; SIZE;i++) printf(&quot;(%.3lf,%.3lf)&quot;, c[i].real(), c[i].imag());  printf(&quot;\n&quot;);  for(int i = 0;i &lt; SIZE-1;i++) { // 进位    c[i+1] += int(c[i].real() / 10);    c[i] -= int(c[i].real() / 10) * 10;  }  for(int i = 0;i &lt; SIZE;i++) printf(&quot;(%d)&quot;, int(c[i].real()));  printf(&quot;\n&quot;);  return 0;}</code></pre><h2 id="递推-原地"><a href="#递推-原地" class="headerlink" title="递推+原地"></a>递推+原地</h2><p>注意,以下代码其中 for m 的部分应该是从2 开始直到n,仅仅是看上去简便,这里处理的时候 把所有对应位置都乘上了2,所以对应cos,sin等等与m相关的都变了</p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for (int i=a;i &lt; n;i++)const double pi = acos(-1.0);// bit 翻转int rev(int x, int len) {  int ans = 0;  while(len -- ){    ans &lt;&lt;= 1;    ans |= x &amp; 1;    x &gt;&gt;= 1;  }  return ans;}int getlog2(int n){  return 31 - __builtin_clz(n);}void FFT(vector&lt;complex&lt;double&gt; &gt; &amp;A, int flag /* 1:FFT,-1:IFFT */) {  int n = A.size();  if(n == 1) return ;  assert((n &amp; (n-1)) == 0); // 2 的幂次  int lgn = getlog2(n);  // 相当于 上面 多次递归每个位置放到的最终位置, 直接计算位置, 而神奇的是刚好 位置 = 原位置的按照长度lgn的bit翻转  rep(i, 0, n) {    int j = rev(i, lgn);    if (j &gt; i) swap(A[i], A[j]);  }  // 逻辑和递归里一样了, 区别是 这里不像递归里下标连续, 需要计算下标, 好在还是顺序的  rep(pwr, 0, lgn){    int m = 1 &lt;&lt; pwr;    complex&lt;double&gt; Wm(cos(pi / m), -sin(pi / m) * flag);    for (int k = 0; k &lt; n; k += (m&lt;&lt;1)) {      complex&lt;double&gt; W(1, 0);      rep(j, 0, m) {        auto U = A[k + j];        auto T = W * A[k + j + m];        A[k + j] = U + T;        A[k + j + m] = U - T;        W *= Wm;      }    }  }}int main(){  // 123*456 = 56088  const int SIZE = 8; // 一定要是2的幂次  auto a = vector&lt;complex&lt;double&gt; &gt;{3,2,1,0,0,0,0,0};  auto b = vector&lt;complex&lt;double&gt; &gt;{6,5,4,0,0,0,0,0};  FFT(a, 1);  FFT(b, 1);  auto c = vector&lt;complex&lt;double&gt; &gt;(8,0);  for(int i = 0;i &lt; SIZE;i++) c[i] = a[i] * b[i];  FFT(c,-1);  for(int i = 0;i &lt; SIZE;i++) c[i] /= SIZE;  // print  for(int i = 0;i &lt; SIZE;i++) printf(&quot;(%.3lf,%.3lf)&quot;, c[i].real(), c[i].imag());  printf(&quot;\n&quot;);  for(int i = 0;i &lt; SIZE-1;i++) { // 进位    c[i+1] += int(c[i].real() / 10);    c[i] -= int(c[i].real() / 10) * 10;  }  for(int i = 0;i &lt; SIZE;i++) printf(&quot;(%d)&quot;, int(c[i].real()));  printf(&quot;\n&quot;);  return 0;}</code></pre><h1 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h1><p><a href="https://codeforces.com/contest/993/submission/47860243" target="_blank" rel="noopener">CF R488 Div1 E ACCEPTED</a></p><h1 id="相关延伸"><a href="#相关延伸" class="headerlink" title="相关延伸"></a>相关延伸</h1><p>有没有觉得double这种东西用起来就感觉很危险,那么也的确有叫做NTT <code>https://en.wikipedia.org/wiki/Discrete_Fourier_transform_(general)#Number-theoretic_transform</code>的方法来 实现大数乘法,但没有精度的问题需要担心.</p><p>另外建议 PI取 <code>const double pi = acos(-1.0);</code> 而不要手动输入</p><p>比如下面的R488 的第43个点 就因为我前面采用手动输入一直过不了</p><h1 id="练习题目"><a href="#练习题目" class="headerlink" title="练习题目"></a>练习题目</h1><p><a href="https://codeforces.com/contest/1096/problem/G" target="_blank" rel="noopener">CF EDU57 G</a></p><p><a href="https://codeforces.com/problemset/problem/993/E" target="_blank" rel="noopener">CF R488 Div1 E</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://en.wikipedia.org/wiki/Convolution" target="_blank" rel="noopener">Convolution</a></p><p><a href="https://en.wikipedia.org/wiki/Convolution_theorem" target="_blank" rel="noopener">Convolution theorem</a></p><p><a href="https://en.wikipedia.org/wiki/Multiplication_algorithm" target="_blank" rel="noopener">Multiplication</a></p><p><a href="https://en.wikipedia.org/wiki/Fourier_transform" target="_blank" rel="noopener">Fourier transform</a></p><p><a href="https://en.wikipedia.org/wiki/Discrete_Fourier_transform" target="_blank" rel="noopener">DFT</a></p><p><a href="https://en.wikipedia.org/wiki/Fast_Fourier_transform" target="_blank" rel="noopener">FFT</a></p><p><a href="https://en.wikipedia.org/wiki/DFT_matrix" target="_blank" rel="noopener">DFT matrix</a></p><p><a href="https://www.youtube.com/watch?v=EsJGuI7e_ZQ" target="_blank" rel="noopener">YouTube - The Fast Fourier Transform Algorithm</a></p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fft </tag>
            
            <tag> ifft </tag>
            
            <tag> dft </tag>
            
            <tag> idft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模逆元/乘法逆元(CF 入门算法)</title>
      <link href="/Blog/2018-12-30-invmul/"/>
      <url>/Blog/2018-12-30-invmul/</url>
      
        <content type="html"><![CDATA[<h1 id="模逆元-乘法逆元"><a href="#模逆元-乘法逆元" class="headerlink" title="模逆元/乘法逆元"></a>模逆元/乘法逆元</h1><p>众所周知,如同线段树/FFT一样,乘法逆元是CF的入门必会算法,然而我只能凭空写线段树</p><p>每次遇到需要用乘法逆元,我都是快速搜一个函数代码,复制进来用</p><p>之前也反复学懂了三四遍,始终没记住(毕竟用的频率不算高)</p><p>以下大自整理总结一下</p><h1 id="什么是乘法逆元"><a href="#什么是乘法逆元" class="headerlink" title="什么是乘法逆元"></a>什么是乘法逆元</h1><p>已知a和p求b, 其中<code>gcd(a,p)=1</code></p><p>$a^{ -1 } \equiv b{\pmod {n}}$</p><h1 id="求法"><a href="#求法" class="headerlink" title="求法"></a>求法</h1><h1 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h1><p>当p是质数时</p><p>$a^{p-2} \mod p $</p><h1 id="扩展欧几里得"><a href="#扩展欧几里得" class="headerlink" title="扩展欧几里得"></a>扩展欧几里得</h1><p>既解$\gcd=1$的扩展欧几里得方程, 已知$(a,p)$求一个$(b,k)$</p><p>$a\cdot b+p\cdot k = 1$, 其中$k$为某未知整数</p><p>把正常计算$\gcd$的过程的细节 写出来<code>int gcd(int a,int b){return b==0?a:gcd(b,a%b);}</code></p><p>$a \cdot b+p\cdot k = 1$,</p><p>初始为$(a,p)$</p><p>把$(d_i,d_{i+1})$ 变为 $(d_{i+1},d_{i+2})$</p><p>$d_1 = a + p\cdot c_1$ 分解 式子1 ($c_1 = - a / p, d_1 = a \mod p$)</p><p>$d_2 = p + d_1\cdot c_2$ 分解 式子2($c_2 = - p / d_1, d_2 = p \mod d_1$)</p><p>$d_3 = d_1 + d_2\cdot c_3$ 分解 式子3</p><p>直到$d_i == 0$, 也就是$d_{i+1} = d_{i-1} + d_2 \cdot c_{i+1}$</p><p>$gcd(a,p) = gcd(a,p) \cdot 1 + 0 cdot 0$</p><p>在算法实现上也就是再分解, 然后反过来把<code>式子i</code>带入<code>式子i+1</code></p><p>$d_n = d_{n-2} + d_{n-1} \cdot c_n$</p><p>$d_n = d_{n-2} + (d_{n-3}+d_{n-2} \cdot c_{n-1}) \cdot c_n$</p><p>然后我们只需要记录的是 $d_{n-2}, d_{n-1}$的系数 $gcd(a,p) = d_{n-2} \cdot k_0 + d_{n-1} \cdot k_1$ </p><p>$gcd(a,p) = d_{n-2} \cdot k_0 + (d_{n-3} \cdot 1 + d_{n-2} \cdot c_{n-1}) \cdot k_1$ , 这个 $c_i = - a_i/b_i$ 在回溯过程中 可以得到</p><p>$gcd(a,p) = d_{n-3} \cdot k_1 + d_{n-2} \cdot (k_0 - k_1 \cdot a_i / b_i )$</p><p>如此展开到最初的a和p即可</p><pre><code class="c++">// 返回的 [x,y,z] 满足 a*x+b*y=ztuple&lt;int,int,int&gt; exgcd(int a,int b){  if(b==0)    return {1,0,a};  auto [x,y,z] = exgcd(b,a%b);  return  {y,x-(a/b)*y,z};}</code></pre><p><strong>以上代码需要C++17</strong></p><p>要注意的是如果 原来的数据有负数,零,需要在外部处理</p><h1 id="扩展欧几里得-的矩阵理解"><a href="#扩展欧几里得-的矩阵理解" class="headerlink" title="扩展欧几里得 的矩阵理解"></a>扩展欧几里得 的矩阵理解</h1><p>${\begin{pmatrix} a &amp; p \\ 1 &amp; 0 \\ 0 &amp; 1 \end{pmatrix} } {\begin{pmatrix}x \\ y\end{pmatrix}} \Rightarrow {\begin{pmatrix}{a \cdot x + b \cdot y = gcd(x,y) } \\ x \\ y \end{pmatrix}}$</p><p>所以可以建立 <code>2*3</code>矩阵,然后对它做列变换,直到 得到<code>gcd(a,p)</code>, 这时的 列向量上的 第二第三个值就是<code>(x,y)</code></p><h1 id="批量求-lt-p-的-模逆元"><a href="#批量求-lt-p-的-模逆元" class="headerlink" title="批量求 $&lt; p $ 的 模逆元"></a>批量求 $&lt; p $ 的 模逆元</h1><h2 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h2><p>妇孺皆知,质数的欧拉筛法,又 模逆元 有 可乘性,</p><p>所以 如果 <code>a=p1*p2</code>,那么 a的模逆元 = <code>p1的模逆元*p2的模逆元</code> mod p</p><p>只需要 <code>O(p+ exgcd平均时间 * ~n/ln n )</code></p><h2 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h2><p>线性递推</p><p>$x = p/a$ (整除)</p><p>$y = p \mod a &lt; a$</p><p>有 $a \cdot x + y = p$</p><p>所以 $y = - a \cdot x (\bmod p)$</p><p>两边同时乘 逆元 $inv_a \cdot inv_y$</p><p>$inv_a \cdot inv_y \cdot y = - a \cdot inv_a \cdot inv_y \cdot x (\bmod p)$</p><p>即 $inv_a = - x \cdot inv_y = - (p/a) \cdot inv_{p \bmod a} (\bmod p)$</p><p>注意到$ y = p \bmod a &lt; a$,所以 在计算$inv_a$时,$inv_y$ 已经计算好了</p><p>又注意处理负号,在mod p的意义下</p><p>$- (p/a) \cdot inv_{p \bmod a} = (p - (p/a)) \cdot inv_{p \bmod a} (\bmod p)$</p><p>综上</p><pre><code class="c++">inv[1] = 1;rep(i,2,p)  inv[i] = ((p-p/i)*inv[p%i])%p;</code></pre><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p><a href="https://codeforces.com/contest/1096/problem/F" target="_blank" rel="noopener">CF EDU57 F</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://en.wikipedia.org/wiki/Modular_multiplicative_inverse" target="_blank" rel="noopener">wikipedia</a></p><p><a href="https://baike.baidu.com/item/%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83/5831857?fr=aladdin" target="_blank" rel="noopener">baidu百科</a></p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> exgcd </tag>
            
            <tag> gcd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>USACO 5.1.1 凸包 模板题</title>
      <link href="/Blog/2018-12-14-USACO-5.1.1/"/>
      <url>/Blog/2018-12-14-USACO-5.1.1/</url>
      
        <content type="html"><![CDATA[<h1 id="USACO-5-1-1"><a href="#USACO-5-1-1" class="headerlink" title="USACO 5.1.1"></a><a href="http://train.usaco.org/usacoprob2?S=fc&amp;a=g2SIibF0nAf" target="_blank" rel="noopener">USACO 5.1.1</a></h1><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>给你<code>n</code>(<code>0&lt;=n&lt;=10000</code>)个平面上点,求凸包的周长</p><p>坐标范围<code>(-1&#39;000&#39;000&lt;=x,y&lt;=1&#39;000&#39;000)</code></p><blockquote><p>解法</p></blockquote><p>用<a href="http://train.usaco.org/usacotext2?a=p3yCGYNnqEI&amp;S=chtext" target="_blank" rel="noopener">官网介绍的方法</a></p><h1 id="关于此题"><a href="#关于此题" class="headerlink" title="关于此题"></a>关于此题</h1><blockquote><p>实现和介绍方法的差异</p></blockquote><p>首先USACO介绍的方法选取的一个中间的点,然后对周围的点排序,</p><p>关于这个,我这里实现是选取y最小(同理可以选取任何一个斜率上的边界点(因为它必定属于凸包(或位于凸包边上 共线(也是属于啦))))</p><p>这就会导致所用的排序不太相同[我这样也可以用角度直接比]</p><p>因为是某斜率边界点,那么 剩余的其它点必定在0至180度内,可以直接用叉乘比较,因此又需要注意,0和180度的比较上为了避免对称点的 不定偏序关系,需要选取 所选斜率上边界点上的边界点</p><p>有点拗口,具体举例,如果我选择y最小的点,假设有3个</p><p><code>A(-4,0),B(0,0),C(4,0)</code>,如果我选取<code>B(0,0)</code>,作为比较的点的话,那么根据叉乘来排序,<code>A(-4,0)</code>和<code>C(4,0)</code>之间的左右关系是可颠倒的<code>BA×BC=0=BC×BA</code></p><p>所以这种情况,建议选择y最小时,x最小或x最大的.[不过幸运的是USACO数据 向来很弱,没有加处理仅仅取边界点也能AC]</p><p>而对于USACO介绍这种方法选中心点的时候,注意不应该用叉乘来作为比较函数,因为可能存在石头剪刀布的情况,(上面的0和180度也会发生)</p><p>举例有4个点<code>A(-1,0),B(1,1),C(0,-1),O(0,0)</code>,当我们采取USACO介绍的方法进行排序时,假设选取<code>O</code>为中心的比较点,那么会有 剩下3个点 都在某另一个点左侧,也就没有偏序关系,无法排序,这种情况该用,计算角度进行排序</p><hr><p>在选比较的点/中心点时,USACO还需要解决,绕了一圈以后,处理最初的点是否属于凸包的问题,而选取某一斜率边界点的话,不会有这个问题,因为该点一定在凸包边界上</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>选取某斜率下的边界点(简单起见就y最小)</p><p>以该点为基础,排序(下面代码用逆时针排序),如果有多点共线,选取距离近的</p><p>for排序后的数组</p><ul><li><p>逐个尝试push加入点</p></li><li><p>如果当前点已经有&gt;1个点,且栈顶的两个点<code>A=p[i-1],B=p[i]</code>,与新点<code>Q</code>,满足AB 不在 AQ右侧,(依赖 前面的排序和 距离从近到远),那么去掉栈顶也就是B,重新尝试push该Q</p></li></ul><p>最后求周长就没啥说的了..</p><hr><p>一点点正确性怀疑[都是被cf逼的],因为USACO要求的是 精度到小数点后2位,所以我有点想知道,这么多浮点数运算 损失了多少23333</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>(没有处理上面说的0和180可能存在的问题,没有HACK的感觉真轻松,向CF日常200+测试数据低头)</p><pre><code class="c++">/*ID: 10157591PROG: fcLANG: C++*/#include &lt;bits/stdc++.h&gt;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)using namespace std;const string filename = &quot;fc&quot;;void usefile(){  freopen((filename+&quot;.in&quot;).c_str(),&quot;r&quot;,stdin);  freopen((filename+&quot;.out&quot;).c_str(),&quot;w&quot;,stdout);}int n;pair&lt;double,double&gt; base = {0,0};pair&lt;double,double&gt;p[10010];// 右手定则, v1在v2右侧 为正, v1在v2左侧为负double cross(const pair&lt;double,double&gt;&amp; v1,const pair&lt;double,double&gt;&amp; v2){  return v1.first * v2.second - v1.second * v2.first;}pair&lt;double,double&gt; operator - (const pair&lt;double,double&gt;&amp; p1,const pair&lt;double,double&gt;&amp; p2){  return {p1.first-p2.first,p1.second-p2.second};}double abs(const pair&lt;double,double&gt; &amp; p){  return sqrt(p.first*p.first + p.second*p.second);}// 逆时针 ,共线从近到远bool cmp(const pair&lt;double,double&gt;&amp; p1,const pair&lt;double,double&gt;&amp; p2){  double c = cross(p1-base,p2-base);  if(c != 0) return c&gt;0;  return abs(p1-base) &lt; abs(p2-base);}pair&lt;double,double&gt; ans[10010];int main(){  usefile();  cin&gt;&gt;n;  if(n &lt; 2){    cout&lt;&lt;0&lt;&lt;endl;    return 0;  }  rep(i,0,n){    scanf(&quot;%lf %lf&quot;,&amp;p[i].first,&amp;p[i].second);  }  base = p[0];  rep(i,0,n){    if(base.second &gt; p[i].second){      base = p[i];    }  }  sort(p,p+n,cmp);  ans[0] = p[0];  int cnt = 1;  rep(i,1,n){    while(cnt&gt;1 &amp;&amp; cross(ans[cnt-1]-ans[cnt-2],p[i]-ans[cnt-1]) &lt;= 0){ // 新加的点应该在最后一条射线左侧      cnt--;    }    ans[cnt++] = p[i];  }  double output = 0;  rep(i,0,cnt){    output+=abs(ans[(i+1)%cnt]-ans[(i)%cnt]);  }  printf(&quot;%.2lf\n&quot;,output);  return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> USACO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 凸包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF Round526 Div1 C (线段树+LCA-&gt;树上链状合并+MEX)</title>
      <link href="/Blog/2018-12-12-cf1083C/"/>
      <url>/Blog/2018-12-12-cf1083C/</url>
      
        <content type="html"><![CDATA[<h1 id="CF-526-Div1-C-Max-Mex"><a href="#CF-526-Div1-C-Max-Mex" class="headerlink" title="CF #526 Div1 C Max Mex"></a><a href="https://codeforces.com/contest/1083/problem/C" target="_blank" rel="noopener">CF #526 Div1 C Max Mex</a></h1><h2 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h2><p>给一个n个点的树,树上的点上带有值,这些值为0到n-1的排列</p><p>Q个询问:</p><p>询问1.(参数点的坐标) 交换两个点上的值</p><p>询问2.(无参数) 在树上找一条简单路径,使该简单路径上MEX最大,输出该最大值</p><p>(<code>2&lt;=n&lt;=200&#39;000</code>)</p><p>(<code>1&lt;=q&lt;=200&#39;000</code>)</p><p>MEX: 返回集合中最小未出现的自然数 如MEX({0,1,2,4,8,16}) = 3</p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>线段树维护<code>值</code>[v1 -&gt; vn] 这一段是否可能 在一条简单路径上,如果可能,那么记录这条简单路径的端点坐标</p><p>保存和更新,利用线段树更新的log级别,和LCA 来进行树上线段的合并</p><hr><p>关于合并 举例解释:</p><p>如果我们的线段树要合并<code>[l1-&gt;r1][l2-&gt;r2]</code> , 其中<code>l2=r1+1</code></p><p>通过递归处理先得到</p><p><code>[l1-&gt;r1]</code>这一段值,对应在树上的简单路径的端点坐标为<code>vl1</code>和<code>vr1</code></p><p><code>[l2-&gt;r2]</code>这一段值,对应在树上的简单路径的端点坐标为<code>vl2</code>和<code>vr2</code></p><p>注意到 前序遍历 和 后续遍历的特征,如果 点A是B的祖先,那么前序遍历<code>A&lt;B</code>, 且后序遍历<code>A&gt;B</code></p><p>那么有如果这4个端点,在从根到某个叶子的一条链上(当且仅当),则这四个端点的 前序遍历的偏序关系 正好 和后续遍历相反.</p><p>所以 我们可以通过对这4个点排序, 前序最小值对应的点 是否和 后续最大值对应的点 相同.如果相同,那么这4个点在一个链上返回[找到的最深点,最潜点] O(1)</p><p>以上是 存在从根下来的链经过4个端点.</p><p>下面考虑是否存在一个跨某节点连接 该节点两个子链的简单路径,经过4个端点</p><p>(假设dfs的子节点枚举从左向右,便于描述)</p><p>注意到,如果有祖先关系,那么前序的最大值为深度最深的点,如果是非祖先关系,那么 前序的最大值为最右侧的点,也就有了 前序最大是最右侧最深的点(假设叫RV)</p><p>对称的,后序遍历最小为最左侧最深的一个点.(假设叫LV)</p><p>那么 实际要考察的就是四个端点是否都在从LV到RV的这样一条简单路径上,</p><p>那么也就是LCA+判断点是否在链上,走一波O(log 树的深度)</p><p>如果失败,则用记录不可合并[any way -1也好 额外字段也好]</p><hr><p>线段树更新,就日常更新就好了</p><p>查询,0是必定可以进链的</p><p>那么 尝试把0 和 (0-n/2) 左半合并(因为链合并有幂等性 不用考虑0和0自己冲突)</p><p>如果可以合并,就把合并后的和右半合并</p><p>如果不行,则 合并目标 = 合并目标的左半; O(log n)</p><h2 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h2><p>线段树(建立&amp;更新&amp;查询),老生常谈了[CF 入门必会],[相对于后缀数组,相对更难写,但能维护更多的状态]</p><p>合并树上的链(LCA,dfs 前序 后序遍历 特点,求一个点是否在一个树中的一条链上(类似LCA))</p><p>LCA, 求树上点的最近公共祖先:(基于fa[点i][幂次k] = 点i的2^k祖先),实现O(log(树高的))的时间复杂度</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><a href="https://codeforces.com/contest/1083/submission/46940044" target="_blank" rel="noopener">code</a></p><pre><code class="c++">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define ten5 100000+10#define MOD 1000000007#define rep(i, a, n) for (int i=a;i&lt;n;i++)#define iif(c, t, f) ((c)?(t):(f))#define per(i, a, n) for (int i=n-1;i&gt;=a;i--)#define pb push_back#define mp make_pair#define fi first#define se secondconst int N = 200010;int n;struct vertex {  int dep;  int v;  int _in;  int _out;} i2v[N];int v2i[N];const int Log = 22;int fa[N][Log + 1]; // fa[0][any] = 0 的性质很好vector&lt;int&gt; child[N];pair&lt;int, int&gt; T[N &lt;&lt; 2];void dfs(int i, int dep, int &amp;idx) {  i2v[i].dep = dep;  i2v[i]._in = idx++;  for (auto item:child[i])    dfs(item, dep + 1, idx);  i2v[i]._out = idx++;}int Jump(int x, int d) {  if (d &lt; 0)    return x;  per(i, 0, Log + 1){    if ((d &gt;&gt; i) &amp; 1)      x = fa[x][i];  }  return x;}int LCA(int l, int r) {  int d = i2v[l].dep - i2v[r].dep;  if (d &lt; 0) {    swap(l, r);    d = -d;  }  l = Jump(l, d);  if (l == r)    return l;  per(i, 0, Log + 1){    if (fa[l][i] != fa[r][i]) {      l = fa[l][i];      r = fa[r][i];    }  }  return fa[l][0];}bool onpath(int idx, int l_idx, int r_idx) {  int anc = LCA(l_idx, r_idx);  if (i2v[anc].dep &gt; i2v[idx].dep)    return false;  return    Jump(l_idx, i2v[l_idx].dep - i2v[idx].dep) == idx ||    Jump(r_idx, i2v[r_idx].dep - i2v[idx].dep) == idx;}pair&lt;int, int&gt; mergeT(const pair&lt;int, int&gt; &amp;v1, const pair&lt;int, int&gt; &amp;v2) {  int arr[] = {v1.fi, v1.se, v2.fi, v2.se};  rep(i, 0, 4){    if (arr[i] == -1)      return {-1, -1};  }  int l_leaf = arr[0];  rep(i, 0, 4) {    if (i2v[arr[i]]._out &lt; i2v[l_leaf]._out)      l_leaf = arr[i];  }  int r_leaf = arr[0];  rep(i, 0, 4) {    if (i2v[arr[i]]._in &gt; i2v[r_leaf]._in)      r_leaf = arr[i];  }  if (l_leaf == r_leaf) { // 所有点在从根向下的一条链上    int rt = arr[0];    rep(i, 0, 4) {      if (i2v[arr[i]].dep &lt; i2v[rt].dep)        rt = arr[i];    }    return {l_leaf, rt};  } else { // 链跨过了某节点连接某节点的两个子链    rep(i, 0, 4) {      if (!onpath(arr[i], l_leaf, r_leaf))        return {-1,-1};    }  }  return {l_leaf, r_leaf};}pair&lt;int, int&gt; initSeg(int o, int l, int r) {  if (l == r)    return T[o] = {v2i[l], v2i[r]};  int mid = (l + r) / 2;  return T[o] = mergeT(      initSeg(o &lt;&lt; 1, l, mid),      initSeg(o &lt;&lt; 1 | 1, mid + 1, r));}void updateSeg(int o, int l, int r, const int &amp;val) {  if (l == r) {    T[o] = {v2i[val], v2i[val]};    return;  }  int mid = (l + r) / 2;  if (val &lt;= mid)    updateSeg(o &lt;&lt; 1, l, mid, val);  else    updateSeg(o &lt;&lt; 1 | 1, mid + 1, r, val);  T[o] = mergeT(T[o &lt;&lt; 1], T[o &lt;&lt; 1 | 1]);}int query(int o, int l, int r, const pair&lt;int, int&gt; &amp;now) {  if (l == r)    return mergeT(now, T[o]).fi == -1 ? l : l + 1;  int mid = (l + r) / 2;  auto tmp = mergeT(now, T[o &lt;&lt; 1]);  if (tmp.fi == -1)    return query(o &lt;&lt; 1, l, mid, now);  else    return query(o &lt;&lt; 1 | 1, mid + 1, r, tmp);}int main() {  cin &gt;&gt; n;  rep(i, 1, n + 1) {    scanf(&quot;%d&quot;, &amp;i2v[i].v);    v2i[i2v[i].v] = i;  }  rep(i, 2, n + 1) {    scanf(&quot;%d&quot;, &amp;fa[i][0]);    child[fa[i][0]].pb(i);  }  rep(j, 1, Log + 1) {    rep(i, 1, n + 1) {      fa[i][j] = fa[fa[i][j - 1]][j - 1];    }  }  int idx = 1;  dfs(1, 1, idx);  initSeg(1, 0, n - 1);  int Q;  cin &gt;&gt; Q;  while (Q--) {    int t;    scanf(&quot;%d&quot;, &amp;t);    if (t == 1) {      int i, j;      scanf(&quot;%d %d&quot;, &amp;i, &amp;j);      swap(v2i[i2v[i].v], v2i[i2v[j].v]);      swap(i2v[i].v, i2v[j].v);      updateSeg(1, 0, n - 1, i2v[i].v);      updateSeg(1, 0, n - 1, i2v[j].v);    } else {      pair&lt;int, int&gt; st = {v2i[0], v2i[0]};      printf(&quot;%d\n&quot;, query(1, 0, n - 1, st));    }  }  return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
            <tag> LCA </tag>
            
            <tag> 树的遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>USACO 4.4.1最大流 最小割(最小数量下字典序最小割)</title>
      <link href="/Blog/2018-12-05-USACO-4.4-2/"/>
      <url>/Blog/2018-12-05-USACO-4.4-2/</url>
      
        <content type="html"><![CDATA[<h1 id="USACO4-4-1"><a href="#USACO4-4-1" class="headerlink" title="USACO4.4.1"></a><a href="http://train.usaco.org/usacoprob2?a=1dvqL35PdJZ&amp;S=milk6" target="_blank" rel="noopener">USACO4.4.1</a></h1><blockquote><p>输入</p></blockquote><p>给你<code>n</code>(<code>2&lt;=n&lt;=32</code>)个点,<code>m</code>(<code>0&lt;=m&lt;=1&#39;000</code>)条边,可包含重边,每条边权重<code>c</code>(<code>0&lt;=c&lt;=2&#39;000&#39;000</code>)</p><blockquote><p>求/输出</p></blockquote><p>最大流</p><p>让最小割被割的边数量最小,求该最小值</p><p>求在该最小值下,求字典序最小的最小割</p><blockquote><p>解法</p></blockquote><p>忽略0边[如果不忽略,可能在后面的问产生问题]</p><p>第一问最大流:最大流就增广路径</p><p>第二问:因为要求,让最小割的被割边的数量也最小,在进行最大流后,对所有满载且原始边不为0的边容量改为1,残余改为inf,再进行一次求最大流</p><p>第三问:在第二问基础上枚举删边,检查可能性,标记边.在原图上采取枚举删边,</p><h1 id="关于此题"><a href="#关于此题" class="headerlink" title="关于此题"></a>关于此题</h1><p>有看到<a href="https://github.com/perfect28/USACO/blob/a6d3ebbb0f9a31c58383bdb03bb62c436f3990c8/4.4/milk6/main.cpp" target="_blank" rel="noopener">这样</a>的解法来处理二三问,把所有边按容量降序排列依次删边尝试,据说能过USACO,然而有反例[USACO数据真弱2333]</p><pre><code class="c++">3 51 2 11 2 11 2 42 3 32 3 3</code></pre><p>很明显总流量是6,要让最小割的数量最小是点2到点3 的两条流量为3的边</p><hr><p><a href="http://train.usaco.org/usacoanal2?a=1dvqL35PdJZ&amp;S=milk6" target="_blank" rel="noopener">据说</a>,有人的方案是把边容量乘1001再加上边index来做为新容量,从而最小边取%1001,最大流取/1001</p><hr><p>测试数据里似乎没有c=0的时候</p><hr><p>第二问的操作inf,必要性,简单的反例解释</p><pre><code>4 71 2 72 3 71 3 23 4 23 4 23 4 23 4 2</code></pre><p>明显1到3的流量可以达到9,而3到4的流量只有8</p><p>所以最小割一定是3到4,但如果耗尽改为1的话,且1到2,2到3都被耗尽,则有1到2,2到3都改为流量1,进行做第二问</p><p>如果不把1到3的2 改为inf,则会 认为最少的割边数量为3,而不是4</p><hr><p>同样第二问结果并不能直接用于第三问,进行尝试删边,样例</p><pre><code>4 51 2 42 3 22 4 21 3 1003 4 2</code></pre><p>最小割应该为 2-&gt;4 和3-&gt;4,如果1-&gt;2耗尽,在第二问变更后的图做尝试删边操作,则会发现1-&gt;2会影响流量,认为1-&gt;2属于割边</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><a href="https://github.com/CroMarmot/MyOICode/blob/master/USACO/Section4/4.4_Pollutant_Control.cpp" target="_blank" rel="noopener">code</a></p>]]></content>
      
      
      <categories>
          
          <category> USACO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最大流 最小割 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单三分(CF EDU 55E)</title>
      <link href="/Blog/2018-11-29-divide-to-tree/"/>
      <url>/Blog/2018-11-29-divide-to-tree/</url>
      
        <content type="html"><![CDATA[<h1 id="EDU55E"><a href="#EDU55E" class="headerlink" title="EDU55E"></a><a href="https://codeforces.com/contest/1082/problem/E" target="_blank" rel="noopener">EDU55E</a></h1><blockquote><p>输入</p></blockquote><p>给你<code>n</code>(<code>1&lt;=n&lt;=500&#39;000</code>)个数字(<code>1&lt;=a[i]&lt;=500&#39;000</code>)和 一个目标值 <code>c</code>(<code>1&lt;=c&lt;=500&#39;000</code>)</p><blockquote><p>要求</p></blockquote><p>任选连续一段加上任意值,使最后的c的出现次数最多,</p><blockquote><p>输出</p></blockquote><p>c最多出现的次数</p><blockquote><p>解法</p></blockquote><p>假设选的区间[l,r]是顶着头,或者 抵着尾的,那么和明显</p><p><code>ans= min(max{[0,i)出现k数字的次数}+[i,n)出现c的次数,max{[i,n)出现k数字的次数}+[0,i)出现c的次数)</code></p><p>用前缀和,可以O(n)做出,问题是无法解决 原数组<code>1 2 1</code> 目标是<code>1</code>的这种,只需要改中间的部分的.</p><hr><p>想法1是 做分治</p><p><code>f(l,r) = max(fl(l,mid)+fr(mid,r),max(f(l,mid),f(mid,r)))</code></p><p><code>fl: c...c?...?</code></p><p><code>fr: ?...?c...c</code></p><p>也就是划分的mid是否 在选取的区间[l,r]内,问题是 看似分治了,但<code>fl(l,mid)+fr(mid,r)</code> 无法处理替换段是一样的情况,如果要处理时间复杂度不会够</p><hr><p>之后想法是dp</p><p>因为可以观察到如果选取的值为v,那么整个数组上统计出现个数的时候采取的是形如</p><p>c…cv…vc…c的形状(其中每个形状均可以长度为0),那么也就是可以dp[state][i]来做,state分为第一段 第二段 第三段,</p><p>这样看上去是<code>n*m</code>的,但是 实际上当我们走到i的时候,只有a[i]的dp需要更改,所以是O(n)的</p><hr><p>dp的整理</p><p>既然上面也观察到进行到i,只会影响到a[i]相关,那么可以把不同数字的都整合到一起,因为只会有当前a[i]对i位置的进行写和读(==c的会有其它读)</p><p>考虑形状 </p><pre><code>c...c?...?c...c         i</code></pre><p>那么有 <code>ans = max{ [0,i] 中前部分选c后部分选a[i]的最大次数+[i+1,n-1]c出现的次数 }</code></p><pre><code>[0,i]中前部分选c后部分选a[i]的最大次数= [0,i]中a[i]的次数 + max{[0,j]选c相对于选a[i]的增量} 其中0&lt;=j&lt;=i= [0,i]中a[i]的次数 + max{[0,j]选c-[0,j]选a[i]} 其中0&lt;=j&lt;=i</code></pre><p>至此上面皆可前缀和</p><pre><code>  i = 1 -&gt; n:    sumc[i] = sumc[i-1] + (a[i] == c); // 前缀和,求到i个 有多少个c    sumci[i] = sumci[pre[a[i]]]+1; // 前缀和,求到i个 有多少个a[i]    maxder[i]=max(maxder[pre[a[i]]],sumc[i-1]-sumv[i]+1); // [0-&gt;j] 计算a[i] -&gt; c变化的最大增量    pre[a[i]]=i; // pre记录a[i]上一次出现的位置  }  ans &lt;- 0;  i = 0 -&gt; n;    ans=max(ans,maxder[i]+sumci[i]+(sumc[n]-sumc[i])); // 增量+[0,i]中a[i]的个数+[i+1,n-1]中c的个数</code></pre><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><a href="https://codeforces.com/contest/1082/submission/46343863" target="_blank" rel="noopener">code</a></p>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>我可能根本不会容斥原理(493D1C,497D1B)</title>
      <link href="/Blog/2018-07-14-inclusion-exclusion/"/>
      <url>/Blog/2018-07-14-inclusion-exclusion/</url>
      
        <content type="html"><![CDATA[<h1 id="493D1C"><a href="#493D1C" class="headerlink" title="493D1C"></a><a href="http://codeforces.com/contest/997/problem/C" target="_blank" rel="noopener">493D1C</a></h1><blockquote><p>输入</p></blockquote><p>给你<code>n*n</code>(<code>1&lt;=n&lt;=1&#39;000&#39;000</code>)的格子</p><blockquote><p>要求</p></blockquote><p>每个格子 图上 有3种颜色可以选择，</p><p>如果所有格子都上完色后， 存在一列或一行的颜色全部相同，则称作lucky</p><blockquote><p>输出</p></blockquote><p>求 所有lucky的方案数 modulo 998244353</p><blockquote><p>解法</p></blockquote><p>翻译自官方</p><p>A{i}表示 有i 行 颜色相同<br>B{i}表示 有i 列 颜色相同</p><p>然后直接 容斥原理公式(搜索一下就能找到的公式) 计算 $A_1 \cup A_2 \ldots A_n \cup B_1 \cup B_2 \ldots B_n$</p><p>然后因为 这些行列在哪里和我们的计算无关，所以对于A{i}可以看成选i行，让这i行每行内颜色相同，也就是C(n,i)倍的 方案数</p><p>所以有那个公式$ans = \sum_{i=0 \ldots n, j=0 \ldots n, i + j &gt; 0} C_n^i C_n^j (-1)^{i + j + 1} f(i, j)]$</p><p>f(i,j)表示前i行j列 lucky的方案数</p><p>然后 具体表示f(i,j)</p><p>i,j其中一个有0的情况，这种情况，以行举例来说，同色的行 之间是可以不同色的，所以是$3^k$</p><p>$f(k, 0) = f(0, k) = 3^k \cdot 3^{n (n - k)}$</p><p>其它情况，这样的话 因为 如果至少有1行+1列是同色的，那么所有的同色的行列 都是同色的，这样就是<code>3</code></p><p>$f(i, j) = 3 \cdot 3^{(n - i)(n - j)}$</p><p>很明显 这个n，肯定不是能做出来的</p><p>那么 分两块，ij带<code>0</code>的 <code>O(n)</code>时间内算出</p><p>其它部分 看数学操作了,首先 带入f(i,j)</p><p>$ans=\sum_{i=1}^{n}\sum_{j=1}^{n}C_n^iC_n^j(-1)^{i+j+1}3\cdot3^{(n-i)(n-j)}$</p><p>换元 $i \to n-i, j \to n - j$</p><p>$ans = 3 \sum_{i=0}^{n - 1}\sum_{j = 0}^{n - 1} C_n^{n - i} C_n^{n - j} (-1)^{n - i + n - j + 1} \cdot 3^{ij}$</p><p>等价化简</p><p>$ans = 3 \sum_{i=0}^{n - 1} \sum_{j = 0}^{n - 1} C_n^i C_n^j (-1)^{i + j + 1} \cdot 3^{ij}$</p><p>分离</p><p>$ans = 3 \sum_{i=0}^{n - 1} C_n^i (-1)^{i+1} \sum_{j = 0}^{n - 1} C_n^j (-1)^{j} \cdot (3^i)^j$</p><p>乘法分配率</p><p>$ans = 3 \sum_{i=0}^{n - 1} C_n^i (-1)^{i+1} \sum_{j = 0}^{n - 1} C_n^j (- 3^i)^j$</p><p>考虑对后面的求和简化，考虑下面式子</p><p>$(a + b)^n = \sum_{i = 0}^{n} C_n^i a^i b^{n - i}$</p><p>这里 我们把a取1，b取$-3^i$，再注意到求和到n不是n-1，进行一个加减消除，最后可以把ans化简为</p><p>$ans = 3 \sum_{i=0}^{n - 1} C_n^i (-1)^{i+1} [(1 + (-3^i))^n - (-3^i)^n]$</p><p>这个式子，可以累加求和在O(n)时间内做出了</p><p>众所周知的 模逆元 快速幂 取模什么的就不说了</p><hr><p>感觉这里分类是我的问题，我自己想 始终把三个颜色分开想怎么计算，这里合在一起了。</p><h1 id="497D1B"><a href="#497D1B" class="headerlink" title="497D1B"></a><a href="http://codeforces.com/contest/1007/problem/B" target="_blank" rel="noopener">497D1B</a></h1><blockquote><p>输入</p></blockquote><p>t个询问(<code>1&lt;=t&lt;=100&#39;000</code>)</p><p>每个询问A,B,C (<code>1&lt;=A,B,C&lt;=100&#39;000</code>)</p><blockquote><p>要求</p></blockquote><p>若a是A的因子，b是B的因子，c是C的因子，则(a,b,c)记为1种方案</p><p><code>(a,b,c),(a,c,b),(b,a,c),(b,c,a),(c,a,b),(c,b,a)</code>视作同一种方案</p><blockquote><p>输出</p></blockquote><p>求总方案数</p><blockquote><p>解法</p></blockquote><p>看了别人超级宽的代码后 才看懂解法，虽然我第一眼也知道是个容斥</p><p>首先众所周知，预处理每个数的因子个数。</p><p>然后把A的因子个数 分为{A独有的因子的个数，仅AB共有的因子的个数，仅CA共有的因子的个数，ABC共有的因子的个数}</p><p>对B和C同样的处理，然后 就会发现，不过是个<code>4*4*4</code>的排列组合(因为不同的分化之间相互不重叠)，注意去重,就随便写都过了，毕竟O(<code>4*4*4*100&#39;000</code>)</p><p><img src="/Blog/img/497D1B.png" alt="497D1B"></p><pre><code class="c++">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (int i=a;i&lt;n;i++)int yzcnt[100010];void init(){  rep(i,1,100001)    yzcnt[i]++;  rep(i,2,100001){    rep(j,1,100000/i+1){      if(i*j&lt;100001){        yzcnt[i*j]++;      }    }  }}int gcd(int a,int b){  return b==0?a:gcd(b,a%b);}ll calc(ll *v1,ll *v2,ll *v3){  if(v1 == v2 &amp;&amp; v2 == v3){    return (*v1)*(*v1+1)*(*v1+2)/6;  }  if(v1 == v2){    return (*v3)*((*v1+1)*(*v1)/2);  }  if(v2 == v3){    return (*v1)*((*v2+1)*(*v2)/2);  }  if(v3 == v1){    return (*v2)*((*v3+1)*(*v3)/2);  }  return (*v1)*(*v2)*(*v3);}int ec(int a,int b,int c){  return c+7*(b+7*a);}int main(){  init();  int t;  cin&gt;&gt;t;  while(t--&gt;0){    int v[3];    scanf(&quot;%d %d %d&quot;,v,v+1,v+2);    int gab= gcd(v[0],v[1]);    int gbc= gcd(v[1],v[2]);    int gca= gcd(v[2],v[0]);    int gabc= gcd(gab,v[2]);    // 计算每一个的仅有的部分    /*0*/ll a = yzcnt[v[0]] - yzcnt[gab] - yzcnt[gca] + yzcnt[gabc];    /*1*/ll b = yzcnt[v[1]] - yzcnt[gbc] - yzcnt[gab] + yzcnt[gabc];    /*2*/ll c = yzcnt[v[2]] - yzcnt[gca] - yzcnt[gbc] + yzcnt[gabc];    /*3*/ll ab = yzcnt[gab] - yzcnt[gabc];    /*4*/ll bc = yzcnt[gbc] - yzcnt[gabc];    /*5*/ll ca = yzcnt[gca] - yzcnt[gabc];    /*6*/ll abc = yzcnt[gabc];    // 用于4*4*4的枚举    ll *slotA[] = {&amp;a,&amp;ab,&amp;ca,&amp;abc};    ll *slotB[] = {&amp;b,&amp;bc,&amp;ab,&amp;abc};    ll *slotC[] = {&amp;c,&amp;ca,&amp;bc,&amp;abc};    // 用于上面枚举的去重    int slotMaskA[] = {0,3,5,6};    int slotMaskB[] = {1,4,3,6};    int slotMaskC[] = {2,5,4,6};    bool masks[7*7*7];    rep(i,0,7*7*7){      masks[i] = false;    }    // 枚举    ll ans = 0;    rep(i,0,4){      rep(j,0,4){        rep(k,0,4){          int maskarr[] = {slotMaskA[i],slotMaskB[j],slotMaskC[k]};          sort(maskarr,maskarr+3);          int code = ec(maskarr[0],maskarr[1],maskarr[2]);          if(!masks[code]){// 去重            masks[code] = true;            ans +=calc(slotA[i],slotB[j],slotC[k]);          }        }      }    }    printf(&quot;%lld\n&quot;,ans);  }  return 0;}</code></pre><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><a href="https://codeforces.com/contest/1007/submission/40314815" target="_blank" rel="noopener">497D1B</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://codeforces.com/blog/entry/60357" target="_blank" rel="noopener">493D1C 官方题解</a></p><p><a href="http://codeforces.com/contest/997/submission/39830108" target="_blank" rel="noopener">493D1C Petr的代码</a></p><p><a href="https://codeforces.com/contest/1007/submission/40290969" target="_blank" rel="noopener">497D1B wavator超级宽的代码</a></p>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容斥原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tarjan 强连通分量 缩点</title>
      <link href="/Blog/2018-06-24-tarjan/"/>
      <url>/Blog/2018-06-24-tarjan/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关于 强连通分量 缩点 tarjan是什么 自行搜索，这里只是封了一个板子</p></blockquote><p><a href="http://codeforces.com/contest/999/problem/E" target="_blank" rel="noopener">Codeforces Round #490 (Div. 3) E题</a></p><p>题目一眼可得tarjan 也不是一次两次了 封了板子，最开始还想做个模板类，但仔细一想，时间复杂度导致点个数不会超int，所以如果点序号大于int先离散化再做</p><p><a href="http://codeforces.com/contest/999/submission/39589245" target="_blank" rel="noopener">E题 AC CODE</a></p><p>板子如下</p><pre><code class="c++">/* construct: vertexsize *    auto tarjan = new Tarjan(vertex_size) *  * addpath // 1&lt;=from_vertex,to_vertex&lt;= vertex_size *    tarjan.addpath(from_vertex,to_vertex) * * prepare an result array,and work *    int res[vertex_size+1]; *    tarjan.work(res); * * return: *    res[vertex_id]  ===== after_tarjan_vertex_group_id */class Tarjan{  int *low;// lowest node  int *dfn;// deep first node  int *stk;// stack  bool *instk;  bool *visited;  vector&lt;int&gt; * p; // one-way road  int stki;  int id;  int n;  // strongly connected components强联通分量  void scc(int v) {    low[v] = dfn[v] = ++id;    stk[stki++] = v;    instk[v] = true;    visited[v] = true;    for(auto w:p[v]){      if(!visited[w]){        scc(w);        low[v] = min(low[v],low[w]);  //v或v的子树能够追溯到的最早的栈中节点的次序编号      } else if(instk[w]){ //v-&gt;w后向边        low[v] = min(low[v],dfn[w]);      }    }    int u;    if(low[v] == dfn[v])  {      do{        u = stk[--stki];        dfn[u] = v;  //缩点        instk[u] = false;    //出栈解除标记      }while(u != v);    }  }public:  Tarjan(int SZ){    n = SZ;    low =  new int[n+1];    stk =  new int[n+1];    dfn =  new int[n+1];    instk = new bool[n+1];    visited = new bool[n+1];    p = new vector&lt;int&gt;[n+1];    rep(i,0,n+1){        visited[i] = false;    }    id = 0;    stki = 0;  }  ~Tarjan(){    delete [] low;    delete [] stk;    delete [] dfn;    delete [] instk;    delete [] visited;    delete [] p;  }  void work(int *ret){    rep(i,1,n+1){      if(!visited[i]){        scc(i);      }    }    rep(i,1,n+1)      ret[i]=dfn[i];  }  void addpath(int i,int j){    p[i].pb(j);  }};</code></pre><p>基本上 使用分3个步骤就好</p><ol><li>根据size初始化</li><li>给它加单向边<code>.addpath(from,to)</code></li><li>准备一个结果数组a，调用<code>.work(a)</code></li><li><p>得到的结果数组<code>a[原来的点序号]=缩点后的点序号</code></p></li><li><p>emmm 需要加两个宏使用 <code>#define rep(i,a,n) for (int i=a;i&lt;n;i++)</code> 和 <code>#define pb push_back</code></p></li></ol><h2 id="增强复用-简化"><a href="#增强复用-简化" class="headerlink" title="增强复用+简化"></a>增强复用+简化</h2><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define rep(i,a,n) for (ll i=a;i&lt;n;i++)#define pb push_backclass Tarjan{  vector&lt;int&gt; low;  vector&lt;int&gt; dfn;  stack&lt;int&gt; stk;  vector&lt;int&gt; res;  vector&lt;vector&lt;int&gt; &gt; p;  int n;  void scc(int v) {    static int id = 0;    low[v] = dfn[v] = ++id;    stk.push(v);    for(auto w:p[v]){      if(!dfn[w]){ // 未访问过        scc(w);        low[v] = min(low[v],low[w]);      } else if(!res[w]){ // 访问过但没有结果(在栈中)        low[v] = min(low[v],dfn[w]);      }    }    int u;    if(low[v] == dfn[v])  {      do{        res[u = stk.top()] = v;        stk.pop();      }while(u != v);    }  }public:  Tarjan(int SZ):n(SZ){    low = vector&lt;int&gt;(n+1);    stk = {};    vector&lt;int&gt;(n+1);    dfn = vector&lt;int&gt;(n+1);    res = vector&lt;int&gt; (n+1);    p = vector&lt;vector&lt;int&gt; &gt;(n+1);  }  vector&lt;int&gt; calc(){    rep(i,1,n+1){      if(!res[i]){        scc(i);      }    }    return res;  }  void p2(int i,int j){    p[i].pb(j);  }};int main(){  int n,m;  // 点,有向边,  cin&gt;&gt;n&gt;&gt;m;  Tarjan tarjan(n);  rep(i,0,m){    int u,v;    scanf(&quot;%d %d&quot;,&amp;u,&amp;v);    tarjan.p2(u,v);  }  vector&lt;int&gt; num = tarjan.calc(); // scc 联通分量 标识  rep(i,1,n+1){    printf(&quot;%lld: %d\n&quot;,i,num[i]);  }  return 0;}/**1-&gt;2-&gt;3-&gt;13-&gt;4-&gt;55 51 22 33 13 44 5 */</code></pre><h3 id="简述操作"><a href="#简述操作" class="headerlink" title="简述操作"></a>简述操作</h3><p>tarjan(u)</p><ol start="0"><li>深搜: 标记序号, 到达最小, u进栈</li><li>子点v未访问(dfn[v] == 0), 递归tarjan(v), low[u] = min(low[u],low[v])</li><li>子点v在栈中(result[v] == 0), low[u] = min(low[u],深搜序号[v])</li><li>当low[u] == dfn[u]时, 逐个出栈直到遇到u, 这些出栈的都是属于u这个联通分量 result[i] = u</li></ol>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 强联通分量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>离散化</title>
      <link href="/Blog/2018-05-11-lisanhua/"/>
      <url>/Blog/2018-05-11-lisanhua/</url>
      
        <content type="html"><![CDATA[<p>难过的是 D 题的 算法<code>细节</code>已经对了，然而还是超时</p><p>通过 学习红名大佬的代码，发现是我们共同的n平方的算法的常数不同，我的常数是map查找 hash的速度+stl的效率，而它通过离散化，真的就只有个位数常数，，，，然而仔细想想，离散化的化我也不是遇到一次两次了，感觉不该再栽倒在同一个地方。 </p><p>拷贝 提取 并修改了 红名大佬代码中做离散化的部分。</p><pre><code class="c++">  sort(li.begin(), li.end());  li.resize(unique(li.begin(), li.end())-li.begin());  for(int i=0; i&lt;n; i++)    newv[i]=lower_bound(li.begin(), li.end(), sourcev[i])-li.begin();</code></pre><p>解释一下内容，sourcev中存的原始数据</p><p>li是 vector，把原始数据放进去</p><p>然后 通过排序 和 去重</p><p>再对每一个 原始数据找到所离散化出的新结果</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://codeforces.com/contest/980/submission/38031597" target="_blank" rel="noopener">大佬的代码</a></p>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 离散化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stanford Machine Learning 科普</title>
      <link href="/Blog/2018-04-18-Stanford_Machine_Learning_with_graph/"/>
      <url>/Blog/2018-04-18-Stanford_Machine_Learning_with_graph/</url>
      
        <content type="html"><![CDATA[<p><a href="https://yexiaorain.github.io/Blog/2018-04-17-Stanford_Machine_Learning/">表格整理</a></p><p><strong>图片主要来源于官方的讲义PDF以及Wikipedia</strong></p><h1 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h1><h2 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h2><p>将输入数据，如图中的红点，求得一条直线表示数据中的线性关系，并且这条直线在概率期望上达到最佳(后面算法省略这句)。</p><p><img src="/Blog/img/ML/xxhg.png" alt="线性回归"></p><h2 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h2><p>找函数极值小值点，图中相同颜色线为等高线，越靠近中心高度越低，运用高数的梯度运算和梯度下降能够得到如图中蓝色x标记的逐步逼近的极值点。</p><p><img src="/Blog/img/ML/tdxj.png" alt="梯度下降"></p><h2 id="Normal-Equation"><a href="#Normal-Equation" class="headerlink" title="Normal Equation"></a>Normal Equation</h2><p>同样是解决线性回归问题，和梯度下降不同的是，运用矩阵运算，直接得到参数的表达式</p><p><img src="/Blog/img/ML/NormalEquations.png" alt="Normal Equations"></p><h2 id="Logistics-回归"><a href="#Logistics-回归" class="headerlink" title="Logistics 回归"></a>Logistics 回归</h2><p>分类算法，对一侧数据0，另一侧数据1的训练数据建立分类器，图中的点是 训练输入，线是得到的logistics函数</p><p><img src="/Blog/img/ML/logistics.png" alt="logistics"></p><h2 id="高斯切线法"><a href="#高斯切线法" class="headerlink" title="高斯切线法"></a>高斯切线法</h2><p>高数知识，二次收敛，加速点的收敛，如图 通过计算切线与坐标轴的交点作为下一次的迭代起始值。</p><p><img src="/Blog/img/ML/gsqx.png" alt="gao si qie xian"></p><h2 id="广义线性模型GLM"><a href="#广义线性模型GLM" class="headerlink" title="广义线性模型GLM"></a>广义线性模型GLM</h2><p>按照所提出的假设模型，能够<code>直接</code>得到所需要的 拟合函数，可以用来证明上面 的线性回归中最小二乘法是最优，以及Logistics 回归中的函数选取。</p><p><img src="/Blog/img/ML/GLM.png" alt="GLM"></p><h2 id="softmax-回归"><a href="#softmax-回归" class="headerlink" title="softmax 回归"></a>softmax 回归</h2><p>分类到对互斥的k个类别,公式推导采用带入GLM</p><p><img src="/Blog/img/ML/softmax.png" alt="softmax"></p><h2 id="高斯判别分析GDA"><a href="#高斯判别分析GDA" class="headerlink" title="高斯判别分析GDA"></a>高斯判别分析GDA</h2><p>对0分布满足高斯分布，1分布也满足高斯分布的分布进行线性分类。</p><p><img src="/Blog/img/ML/GDA.png" alt="GDA"></p><h2 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h2><p>整体与特征来判断整体的分类，如垃圾邮件根据出现的词汇进行分类，很暴力直接计算概率</p><p><img src="/Blog/img/ML/bayes.png" alt="bayes"></p><h2 id="拉普拉斯平滑"><a href="#拉普拉斯平滑" class="headerlink" title="拉普拉斯平滑"></a>拉普拉斯平滑</h2><p>解决朴素贝叶斯中可能出现的0除以0的情况，分子+1，分母+可分的种类数k</p><p><img src="/Blog/img/ML/Laplace.png" alt="laplace"></p><h2 id="最优线性分类器"><a href="#最优线性分类器" class="headerlink" title="最优线性分类器"></a>最优线性分类器</h2><p>如图能够找到将 数据分开，并且离分割线最近的点的距离值最大的分类器。</p><p><img src="/Blog/img/ML/geometricmargins.png" alt="jihejuli"></p><h2 id="拉格朗日对偶、KKT"><a href="#拉格朗日对偶、KKT" class="headerlink" title="拉格朗日对偶、KKT"></a>拉格朗日对偶、KKT</h2><p>用于具体解决 最优线性分类器的支撑方法</p><p><img src="/Blog/img/ML/KKT.png" alt="KKT"></p><h2 id="核函数"><a href="#核函数" class="headerlink" title="核函数"></a>核函数</h2><p>将变量非线性变化映射到高维空间，减小计算量，表示量，配合其它算法使用能获得高维空间性质。</p><p><img src="/Blog/img/ML/Kernel.png" alt="Kernel"></p><h2 id="支持向量机SVM"><a href="#支持向量机SVM" class="headerlink" title="支持向量机SVM"></a>支持向量机SVM</h2><p>将低维不可线性分割的 通过核函数映射到高维度，再在高维中进行最优线性分割</p><p><img src="/Blog/img/ML/SVM.png" alt="SVM"></p><h2 id="L1-Regularization"><a href="#L1-Regularization" class="headerlink" title="L1 Regularization"></a>L1 Regularization</h2><p>在有部分异常点时的分割,通过添加惩罚项解决如下图异常点导致变化过大的问题。</p><p><img src="/Blog/img/ML/L1regularization.png" alt="L1regularization"></p><h2 id="SMO"><a href="#SMO" class="headerlink" title="SMO"></a>SMO</h2><p>对于多个参数 每次选一个参数进行取极值点，SMO能在带等式与不等式的约束限定情况下，每次两个参数逐步逼近。</p><p><img src="/Blog/img/ML/SMO.png" alt="SMO"></p><h2 id="均方误差MSE"><a href="#均方误差MSE" class="headerlink" title="均方误差MSE"></a>均方误差MSE</h2><p>能够用于分析 过拟合 还是 欠拟合</p><p><img src="/Blog/img/ML/MSE.png" alt="mse"></p><h2 id="错误分析"><a href="#错误分析" class="headerlink" title="错误分析"></a>错误分析</h2><p>按步骤替代/隔离分析，逐个增加或逐个减少。按训练误差 方差，实验 误差方差分析。</p><p><img src="/Blog/img/ML/Error.png" alt="error"></p><h2 id="VC维、hoeffding不定式"><a href="#VC维、hoeffding不定式" class="headerlink" title="VC维、hoeffding不定式"></a>VC维、hoeffding不定式</h2><p>用于证明概率下训练集和误差的上下界存在性。</p><h2 id="验证方式、模型选择"><a href="#验证方式、模型选择" class="headerlink" title="验证方式、模型选择"></a>验证方式、模型选择</h2><p>将部分的训练数据不用于训练而用于检验模型</p><h2 id="感知器"><a href="#感知器" class="headerlink" title="感知器"></a>感知器</h2><p>感知器：转换后的值小于0输出-1，大于等于0输出</p><h1 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h1><h2 id="k-means"><a href="#k-means" class="headerlink" title="k-means"></a>k-means</h2><p>对无标记的点进行分类(寻找分类的中心)</p><p><img src="/Blog/img/ML/kmeans.png" alt="kmeans"></p><h2 id="高斯混合模型GMM"><a href="#高斯混合模型GMM" class="headerlink" title="高斯混合模型GMM"></a>高斯混合模型GMM</h2><p>可以看作类似前面的高斯判别模型GDA，但是现在的输入数据是无标记的</p><p><img src="/Blog/img/ML/GMM.png" alt="GMM"></p><h2 id="EM算法"><a href="#EM算法" class="headerlink" title="EM算法"></a>EM算法</h2><p>用于GMM等无标记的混合模型的分离，先假设隐含变量Z以及它的分布Q，和k-means的思想类似，E-step优化Q，M-step优化参数，重复直到收敛 [使用Jensen不等式],分离效果见上图</p><p><img src="/Blog/img/ML/EM.png" alt="EM"></p><h2 id="因子分析"><a href="#因子分析" class="headerlink" title="因子分析"></a>因子分析</h2><p>对训练集量少，维数大，分类的类别少的分布进行分类，思想是建立隐含低维度变量z，通过矩阵转化投影到高维，再加上高斯扰动误差</p><p><img src="/Blog/img/ML/Factor.png" alt="Factor"></p><h2 id="主成分分析PCA"><a href="#主成分分析PCA" class="headerlink" title="主成分分析PCA"></a>主成分分析PCA</h2><p>对于高维空间的数据，找到其前k个相互正交的关键维度的向量，可用线性代数奇异值分解SVD进行快速计算。可以用于降维度，作为其它算法的预处理步骤，或找到关系的主要方面。</p><p><img src="/Blog/img/ML/PCA.png" alt="PCA"></p><h2 id="独立成分分析ICA"><a href="#独立成分分析ICA" class="headerlink" title="独立成分分析ICA"></a>独立成分分析ICA</h2><p>对于多维度，相互独立的非高斯分布成分，找到每个成分的轴，并将所有轴转换为正交轴。可用于特征提取，特征分离，如音频分离，计算人脸识别面部特征向量，对脑电波数据分离预处理去除眨眼和心跳信号。</p><p><img src="/Blog/img/ML/ICA.png" alt="ICA"></p><h1 id="马尔科夫模型"><a href="#马尔科夫模型" class="headerlink" title="马尔科夫模型"></a>马尔科夫模型</h1><h2 id="马尔科夫决策过程-MDP"><a href="#马尔科夫决策过程-MDP" class="headerlink" title="马尔科夫决策过程 MDP"></a>马尔科夫决策过程 MDP</h2><p>能够学习带有状态，和基于状态动作的一类事情，学出一个策略集，如自动驾驶，需要设置奖励函数，概率函数等参数函数。策略迭代和值迭代</p><p><img src="/Blog/img/ML/MDP.png" alt="MDP"></p><h2 id="离散化连续状态的MDP"><a href="#离散化连续状态的MDP" class="headerlink" title="离散化连续状态的MDP"></a>离散化连续状态的MDP</h2><p>也就是字面意思离散化，在2维下工作一般不错，高维度后无论是维数灾难还是离散化难度，以及模型最终产物都难以普遍满意</p><p><img src="/Blog/img/ML/MDPlsh.png" alt="MDPlsh"></p><h2 id="MDP中的模型模拟器"><a href="#MDP中的模型模拟器" class="headerlink" title="MDP中的模型模拟器"></a>MDP中的模型模拟器</h2><p>用于概率状态未知时，用实验+拟合得到模型，从而代替概率函数的位置</p><p><img src="/Blog/img/ML/simulator.png" alt="simulator"></p><h2 id="线性二次型调节控制LQR"><a href="#线性二次型调节控制LQR" class="headerlink" title="线性二次型调节控制LQR"></a>线性二次型调节控制LQR</h2><p>解决状态依赖于前一个状态前一个动作以及时间的策略选择，在有限时间内用动规(倒着递推)，多次实验线性拟合基于时间的。对于非线性函数仅能取较近的输入值，用近似的切线做近似的线性处理。通过加强奖励函数，初始值(时间T)矩阵，等限定。得出结论，动作与状态的线性相关，且计算过程中可以省去无关迭代</p><p><img src="/Blog/img/ML/LQR.png" alt="LQR"></p><h2 id="kalman滤波"><a href="#kalman滤波" class="headerlink" title="kalman滤波"></a>kalman滤波</h2><p>将<code>观测值</code>转化为概率上的<code>真实值</code></p><p><img src="/Blog/img/ML/kalman.jpg" alt="kalman"></p><h2 id="LQG"><a href="#LQG" class="headerlink" title="LQG"></a>LQG</h2><p>LQG=LQR+kalman滤波</p><h2 id="微分动规DDP"><a href="#微分动规DDP" class="headerlink" title="微分动规DDP"></a>微分动规DDP</h2><p>根据当前决策选定轨迹，做LQR，更新决策，重复。从函数上理解是函数逐步靠近，即使是一个不那么好的模拟器</p><p><img src="/Blog/img/ML/DDP.png" alt="DDP"></p><h2 id="pegasus策略搜索"><a href="#pegasus策略搜索" class="headerlink" title="pegasus策略搜索"></a>pegasus策略搜索</h2><p>处理非线性模型函数的情况。选取随机序列并重复使用于模型训练，在模型选择时选取非线性的模型(如logistics 函数)，用极大似然去找该模型下的最优策略。</p><p><img src="/Blog/img/ML/policysearch.png" alt="policy"></p>]]></content>
      
      
      <categories>
          
          <category> Machine learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stanford Machine Learning 学习笔记、个人整理</title>
      <link href="/Blog/2018-04-17-Stanford_Machine_Learning/"/>
      <url>/Blog/2018-04-17-Stanford_Machine_Learning/</url>
      
        <content type="html"><![CDATA[<h1 id="课程相关链接"><a href="#课程相关链接" class="headerlink" title="课程相关链接"></a>课程相关链接</h1><p><a href="https://open.163.com/movie/2008/1/M/C/M6SGF6VB4_M6SGHFBMC.html" target="_blank" rel="noopener">网易Stanford机器学习</a></p><p><a href="http://cs229.stanford.edu" target="_blank" rel="noopener">官方网站</a></p><p><a href="https://github.com/Kivy-CN/Stanford-CS-229-CN" target="_blank" rel="noopener">Github整理</a></p><p><a href="https://github.com/econti/cs229" target="_blank" rel="noopener">部分课件</a></p><p><a href="https://github.com/zyxue/stanford-cs229" target="_blank" rel="noopener">练习</a></p><p><a href="https://github.com/HuangCongQing/MachineLearning_Ng" target="_blank" rel="noopener">笔记和练习</a></p><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><blockquote><p>该课程能学到什么？</p></blockquote><p>基于统计模型，概率公式的不同学习方法，不涉及神经网络。</p><blockquote><p>本文档不按照课的分化记录，而按照内容的分化记录。</p></blockquote><p>省去具体实现，毕竟已经有足够的他人整理的资料，以及我也在pad上手写过了，没有这个重复工作的必要了。不过我会尽量把知识点依赖写清，如果心情不错的话，再提供一个相关的优秀的讲解链接。这里还是以框架和思想为主。其中部分公式省略了取值限制，具体原公式请参照讲义</p><h1 id="依赖知识"><a href="#依赖知识" class="headerlink" title="依赖知识"></a>依赖知识</h1><ul><li><p>高等数学</p><ul><li>积分</li><li>微分</li><li>偏导数，梯度</li><li>拉格朗日乘子法、KKT条件(拉格朗日对偶)</li><li>牛顿切线</li></ul></li><li><p>线性代数</p><ul><li>矩阵 乘法 转置 逆 秩 迹</li><li>SVD</li></ul></li><li><p>概率统计</p><ul><li>贝叶斯</li><li>高斯分布 多纬高斯分布</li><li>0-1分布 泊松分布 等等常见分布</li><li>极大似然估计</li></ul></li><li><p>算法</p><ul><li>动态规划</li></ul></li></ul><h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><h2 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h2><ul><li>提供样例(输入，输出(类别))数据进行训练，从而学习出一个分类器/学成一个带有功能的程序。</li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><table><thead><tr><th>名称</th><th>功能</th><th>对应的期望</th><th>实现</th><th>理解</th><th>知识依赖</th><th>课程集数</th></tr></thead><tbody><tr><td>线性回归</td><td>拟合出一条自变量与因变量的关系直线</td><td>平方和最小</td><td>梯度下降</td><td>局部极值</td><td>高数梯度</td><td>2</td></tr><tr><td></td><td></td><td></td><td>Normal equations</td><td>极值点梯度=0</td><td>矩阵运算 对矩阵求梯度</td><td>2</td></tr><tr><td>线性回归(数据量大)</td><td></td><td></td><td>随机梯度下降</td><td></td><td></td><td>2</td></tr><tr><td>logistics分类</td><td>对一侧全0，另一侧全1的训练数据集建立分类器</td><td>计算对应最优参数的logistics function</td><td>梯度上升</td><td>概率期望最大</td><td>极大似然</td><td>3</td></tr><tr><td>softmax回归(logistics 可以看做k=2时的特例)</td><td>分为k类</td><td>找到对应的拟合函数 并且拟合出参数</td><td>找拟合函数带入GLM 拟合参数老方法了</td><td>满足GLM的假设所以可以带入GLM</td><td>GLM 和 极大似然</td><td>4</td></tr><tr><td>高斯判别分析GDA</td><td>在n维多项高斯分布中找<code>一条线</code>分割训练集合</td><td>计算假设分布中对应参数</td><td>假设伯努利以及高斯分布运用极大似然算参数值</td><td>根据测试集带入模型得出的可能性的值来判断所属于的分类</td><td>n维高斯的分布矩阵形式的协方差 极大似然 贝叶斯 生成学习方法</td><td>5</td></tr><tr><td>朴素贝叶斯</td><td>直接概率公式计算可能性，如垃圾邮件根据词的出现进行分类</td><td>能够对含有大量特征与非特征的整体进行分类</td><td>直接算概率</td><td>通过可能性来判断是否是</td><td>贝叶斯 极大似然 生成学习方法</td><td>5</td></tr><tr><td>神经网络(只是提到没有深入讲)</td><td>非线性分类器</td><td>对非线性进行分类</td><td>极大似然，反向传播，梯度下降</td><td></td><td></td><td>6</td></tr><tr><td>最优边界分类器</td><td>也就是要找到最大几何间隔的分类器</td><td>期望在满足约束的情况下，表达式最大</td><td>在限定条件下的线性规划用对偶的方式求极值</td><td>期望在满足约束的情况下，使所有点到超平面距离的最小值最大</td><td>拉格朗日乘子法、KKT条件、拉格朗日对偶性</td><td>7</td></tr><tr><td>支持向量机SVM</td><td>对非线性可分割的分布进行分割</td><td>非线性分类器</td><td>说实话SVM以及SVM所依赖的知识的细节理解得还不够清晰 已经放入下面的TODO</td><td>把训练集转换到高维去，在高纬度中进行线性分割</td><td>核函数+最优边界分类器+对偶问题</td><td>6 7 8</td></tr><tr><td>L1 norm soft margin SVM</td><td>对于有错误分类</td><td>让带有惩罚项的表达式期望最小</td><td>数学推导</td><td>个别的错误项可以破坏支撑点 但仅仅算做惩罚</td><td>svm 极大似然</td><td>8</td></tr><tr><td>特征选择</td><td>例如文本分类</td><td>选取真正对文本类别有影响的特征</td><td>通过交叉验证 逐个插入检测对预测值的影响</td><td>运用实验获得模糊的相关性</td><td>贝叶斯</td><td>10</td></tr></tbody></table><h3 id="辅助方法-定义"><a href="#辅助方法-定义" class="headerlink" title="辅助方法/定义"></a>辅助方法/定义</h3><table><thead><tr><th>方法</th><th>功能</th><th>章节</th></tr></thead><tbody><tr><td>牛顿切线法</td><td>加快求极值点的收敛速度、二次收敛</td><td>4</td></tr><tr><td>GLM广义线性模型</td><td>对满足广义线性模型下的回归问题进行分析 直接得到所需要的拟合模型</td><td>4</td></tr><tr><td>拉普拉斯平滑</td><td>对于 处理例如朴素贝叶斯中可能出现的0/0的概率 分子+1 分母+可分的类别数k</td><td>5</td></tr><tr><td>函数间隔</td><td>定义，当超平面的参数等比例缩放时超平面不会变但函数间隔会变化</td><td>6 7</td></tr><tr><td>几何间隔</td><td>同上，区别是 几何间隔=函数间隔/超平面法向量w的模,也就是当(w,b)等比例变化时，几何间隔不变 表示到超平面的距离</td><td>6 7</td></tr><tr><td>核函数</td><td>在最右边界分类器中出现了<code>&lt;X,X&gt;</code> 核函数能够降低计算代价,转换特征，同时选取高纬映射的核函数就够转化为SVM问题</td><td>7 8</td></tr><tr><td>SMO</td><td>每次修正一个参数逐步逼近，如果有等式约束每次修正两个</td><td>8</td></tr><tr><td>VC维</td><td>配合训练集 概率 错误率建立 误差上下界关系</td><td>10</td></tr><tr><td>交叉验证等多种验证</td><td>整体思想是把训练集的部分数据不用于训练而用于检验 进行模型筛选</td><td>10</td></tr><tr><td>规范化 正则化</td><td>防止过拟合</td><td>11</td></tr><tr><td>在线学习</td><td>边学习边预测 能收敛到分界线</td><td>11</td></tr><tr><td>检测机器学习算法的问题</td><td>通过 误差 方差 偏差 收敛性 值函数在更优秀的数据下的表现 综合判断问题所在</td><td>11</td></tr></tbody></table><h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><table><thead><tr><th>证明</th><th>方法</th><th>课程集数</th></tr></thead><tbody><tr><td>线性回归中用最小二乘法最好</td><td>概率分布假设+极大似然</td><td>3</td></tr><tr><td>线性回归 和 logistics分类对应的 拟合函数</td><td>按照GLM的方式对应带入</td><td>4</td></tr><tr><td>过拟合 欠拟合 经验风险的上下界</td><td>hoeffding不等式 同时能够提供定量分析误差</td><td>9 10</td></tr></tbody></table><h2 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h2><ul><li>无样例(输入，输出)样本进行学习，直接根据未分类数据的分布特征，对数据进行分类/建立带有功能的程序。</li></ul><h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><table><thead><tr><th>名称</th><th>功能</th><th>对应的期望</th><th>实现</th><th>理解</th><th>知识依赖</th><th>课程集数</th></tr></thead><tbody><tr><td>k-means</td><td>对无标记的点进行分类</td><td>找到分类的中心，使(按照每个分类的中心所得到的分类)的中心都是分类的中心</td><td>平面随机选中心，以这些点进行分类，对每个分好的类进行重新计算中心，重复直到收敛</td><td>分类的中心=分类的中心 在概率上可能最大</td><td>不等式递推</td><td>12</td></tr><tr><td>最大期望算法EM</td><td>对无标记训练数据根据所假设的模型进行分类</td><td>在所对应假设的模型下找到最好的参数</td><td>通过假设隐藏已知中间变量计算中间变量的</td><td>E假设 概率可以看做优化Q，M步在这种情况下的分布带回去看作优化参数，再E再M直到收敛，可以说k-means也有点思路类似，也可以通过图形理解 坐标上升</td><td>贝叶斯 极大似然</td><td>12 13</td></tr><tr><td>因子分析模型</td><td>因子多 分类少，直接对角矩阵会丢失其它维度，用来进行分类</td><td>对无标示样本分类</td><td>加入低维隐含变量Z 猜测分布 进行升高维度加上高斯噪声再用EM</td><td>高维数据被分到低纬度的类中 可以反过来进行 映射+噪声的假设</td><td>EM 高斯 矩阵乘法</td><td>13 14</td></tr><tr><td>PCA主成分分析</td><td>降维投影提取真正关键的维度信息 例如LSI潜在语义索引</td><td>找多组让数据尽量分散的正交投影法向量</td><td>线性代数 matlab的SVD进行奇异值分解</td><td>找低前k个最大的向量</td><td>SVD 线性代数</td><td>14 15</td></tr><tr><td>ICA独立成分分析</td><td>提取分离独立成分 如音频分离</td><td>需要分布本身独立 且非高斯</td><td>数学推导</td><td>高位的平行四边形 找到轴 并把轴转换到正交轴</td><td>独立概率+sigmoid+极大似然</td><td>15</td></tr></tbody></table><h3 id="辅助方法-定义-1"><a href="#辅助方法-定义-1" class="headerlink" title="辅助方法/定义"></a>辅助方法/定义</h3><table><thead><tr><th>方法</th><th>功能</th><th>课程集数</th></tr></thead><tbody><tr><td>混合高斯分布GMM</td><td>无标记的空间上有多组服从独立的高斯分布的数据，用于作为EM算法的试例</td><td>12</td></tr><tr><td>Jensen不等式</td><td>如果f是凸函数 E[f(x)]&gt;=f(EX)</td><td>12</td></tr></tbody></table><h2 id="强化学习RL-马尔科夫模型MDP"><a href="#强化学习RL-马尔科夫模型MDP" class="headerlink" title="强化学习RL/马尔科夫模型MDP"></a>强化学习RL/马尔科夫模型MDP</h2><p>上面的都是分类模型，强化学习要强行分类也可以说是无监督分类，或者半监督分类。</p><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><table><thead><tr><th>名称</th><th>功能</th><th>对应的期望</th><th>实现</th><th>理解</th><th>知识依赖</th><th>课程集数</th></tr></thead><tbody><tr><td>马尔科夫决策过程<code>MDP(状态S，动作A，{概率P(S,A)},折扣因子r,{奖励函数R(S)})</code></td><td>对于给定的模型 能够根据当前状态做出模型下最优决策 如讲师所做的自动驾驶倒飞直升机XD</td><td><code>E(R(S0)+rR(S1)+r^2 *R(S2)+...)</code></td><td>值迭代/策略迭代</td><td>值迭代是计算每个S下的期望最大值，再根据得到的期望得到决策；决策迭代是在过程中 决策和值共同更新，计算代价更大 小数据相对快</td><td>动态规划 期望</td><td>16</td></tr></tbody></table><h3 id="马尔科夫决策过程-变形-问题"><a href="#马尔科夫决策过程-变形-问题" class="headerlink" title="马尔科夫决策过程 变形/问题"></a>马尔科夫决策过程 变形/问题</h3><table><thead><tr><th>?</th><th>!</th><th>课程集数</th></tr></thead><tbody><tr><td>未知概率函数P</td><td>用实验所得尽心均值估计</td><td>16</td></tr><tr><td>对于维度高数量级大的 离散化难解决(数量级大 需要非均匀离散) 状态&gt;=动作</td><td>通过建造模拟器<code>S(t+1)=S(t)+S&#39;(t)*dt</code>和实验数据进行线性拟合 从而取代P的作用，同时 需要多次多步骤实验</td><td>17</td></tr><tr><td>R(S)变为R(S,A)</td><td>依然用期望就好</td><td>18</td></tr><tr><td>从无限边界变为有限边界T，去掉折扣因子r，R和决策都还需要依赖时间</td><td>线性二次调节控制LQR 通过强假设 结束的S(T) A(T),进行反向递推(动规)，根据矩阵运算可以省去 噪音项</td><td>18 19</td></tr><tr><td>非线性函数</td><td>采用局部的 值点</td><td>19</td></tr><tr><td>模拟器不够好+非线性函数</td><td>局部切线值的点+LRQ -&gt;变为 微分动态规划DDP</td><td>19</td></tr><tr><td>无法获得真实值，只能获得观测值</td><td>Kalman滤波，非指数级别增长 通过概率估计推得可能的真实值/极大似然</td><td>19</td></tr><tr><td>无法真实值的线性二次调节控制</td><td>LQG=LQR+kalman滤波</td><td>19</td></tr><tr><td>LQG虽然能用但效果不是最佳，目标策略非线性策略</td><td>策略搜索:随机序列+带参数策略如logistics函数+梯度上升，找所假设的策略函数的最优参数</td><td>20</td></tr><tr><td>随机的序列 同样输入可能不同的值 拟合较难</td><td>Pegasus 序列依然随机生成，但生成后固定反复使用于训练</td><td>20</td></tr></tbody></table><h3 id="Debug-19"><a href="#Debug-19" class="headerlink" title="Debug 19"></a>Debug 19</h3><table><thead><tr><th>症状</th><th>方案</th></tr></thead><tbody><tr><td>模拟器可以 真实不行</td><td>改模拟器</td></tr><tr><td>人比RL好 但值函数人的低</td><td>改值函数</td></tr><tr><td>没有上述问题</td><td>改奖励函数</td></tr></tbody></table><h1 id="一句话能回答的知识点-TODO"><a href="#一句话能回答的知识点-TODO" class="headerlink" title="一句话能回答的知识点 TODO"></a>一句话能回答的知识点 TODO</h1><blockquote><p>梯度下降和梯度上升有什么区别？3</p></blockquote><p>画三维图形，求它的梯度，从图像上看，梯度是指向上方的。所以梯度下降用减法，实际是逼近极小值，而梯度上升用加法，逼近极大值。</p><blockquote><p>欠拟合与过拟合分别是什么？4</p></blockquote><p>欠拟合：模型复杂度不够 训练数据少，未能真正获取主要内在关系，训练数据和测试数据得分都低。过拟合，模型过于复杂，训练数据方差小得分高，但是测试数据偏差大 方差大</p><blockquote><p>判别学习法 和 生成学习方法 的区别？5</p></blockquote><p>判别学习法直接对P(y|x)进行建模；生成学习方法对P(x|y) 和 p(y)进行建模 然后，y = 贝叶斯公式转换后最大的y 例如 隐马尔可夫模型HMM、朴素贝叶斯模型、高斯混合模型GMM、LDA。</p><blockquote><p>GDA与Logistics模型比较？5</p></blockquote><p>GDA按照概率转化的曲线和sigmoid,很相似。GDA更强的假设，对于正确的训练集，GDA效率更高 更好，但对于不正确的模型，logistic的健壮性robust更好</p><h1 id="其它知识点-细节-TODO"><a href="#其它知识点-细节-TODO" class="headerlink" title="其它知识点 细节 TODO"></a>其它知识点 细节 TODO</h1><p>LGM</p><p>对偶问题</p><p><a href="https://blog.csdn.net/johnnyconstantine/article/details/46335763" target="_blank" rel="noopener">KKT条件</a></p><p>核函数定义 证明 应用 具体核(高斯核)</p><p>SVM</p><p><a href="https://blog.csdn.net/zouxy09/article/details/8537620" target="_blank" rel="noopener">EM</a></p><p>EM:<code>Do, C. B., &amp; Batzoglou, S. (2008). What is the expectation maximization algorithm?. Nature biotechnology, 26(8), 897.</code></p><h1 id="其它TODO"><a href="#其它TODO" class="headerlink" title="其它TODO"></a>其它TODO</h1><p>添加配图</p><p>李航的《统计学习方法》刚翻了个开头，这本书先讲的泛的再具体的顺序不同，不过瞄了目录，似乎有新内容还是换了个名字？不懂2333，目前计划是先不看它，去看CSP，之后再看<code>_(:з」∠)_</code>。</p><blockquote><p>老师建议把 证明过程盖住 自己再证明</p></blockquote><p>2讲矩阵梯度公式</p>]]></content>
      
      
      <categories>
          
          <category> Machine learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF Goodbye2017 D(math:series + extended Euclidean + dp)</title>
      <link href="/Blog/2017-12-30-Goodbye2017D/"/>
      <url>/Blog/2017-12-30-Goodbye2017D/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a><a href="http://codeforces.com/contest/908/problem/D" target="_blank" rel="noopener">题目</a></h1><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>输入 k pa pb</p><p>最初空字符串，每次增加一个字符 a 或者 b, 当子串ab的个数&gt;=k就停止,求停止时 子串ab的个数的期望。 </p><p>子串的不需要连续 比如aab 是有两个ab子串</p><p>产生a的概率为 pa/(pa+pb), 产生b的概率为 pb/(pa+pb)</p><p>期望 计算过程中 不使用小数，而是用 逆模</p><p>所有值模1000 000 007</p><h1 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h1><p><code>1&lt;=pa pb&lt;=1 000 000</code></p><p><code>1&lt;=k&lt;=1 000</code></p><h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><p><a href="http://codeforces.com/blog/entry/56713" target="_blank" rel="noopener">官方题解</a></p><p>意思是用<code>dp[i][j]</code> 表示前缀 中 有i个a ，j个ab子串的<code>子串个数的期望值</code></p><p>用的是从长的推短的 反过来，首先如果 j&gt;=k 那么 dp[i][j] = j</p><p>递推表达式 <code>dp[i][j] = (pa * dp[i+1][j] + pb * dp[i][i+j])/(pa+pb)</code></p><p>也就是 根据最后一个字符来进行分化</p><p>所以最后的结果就是<code>dp[0][0] = dp[1][0]</code></p><h1 id="其中一些问题"><a href="#其中一些问题" class="headerlink" title="其中一些问题"></a>其中一些问题</h1><p>虽然j&gt;=k已经解决了 但是 i还是可以无限大，根据递推表达式 和 级数 的办法 可以求得<code>dp[k][j]</code> <a href="http://codeforces.com/blog/entry/56713?#comment-404349" target="_blank" rel="noopener">here</a></p><p>不用小数用逆模运算 <a href="https://zh.wikipedia.org/wiki/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">wiki的最后一条</a></p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p><a href="http://codeforces.com/contest/908/submission/33810418" target="_blank" rel="noopener">我的代码</a></p><pre><code class="c++">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define ten5 100000+10#define MOD 1000000007#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define iif(c,t,f) ((c)?(t):(f))#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)#define pb push_back#define mp make_pairint intcmp(const void *v1,const void *v2){return *(int *)v1-*(int *)v2;}long long minn(long long v1,long long v2){return v1&lt;v2?v1:v2;}long long maxx(long long v1,long long v2){return v1&gt;v2?v1:v2;}//https://zh.wikipedia.org/wiki/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95//https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm// [a p]       1// [1 0] ---&gt;  ret(x1)// [0 1]       x2ll mul_inv(ll a,ll b=MOD ){  ll matrix[3][2]={{a,b},{1,0},{0,1}};  int itr = 0;  while(matrix[0][itr^1] != 1){    ll t = matrix[0][itr]/matrix[0][1^itr] ;    rep(i,0,3)      matrix[i][itr] -= t * matrix[i][1^itr];    itr^=1;  }  return (matrix[1][itr^1] % b + b )%b;}int k;// http://codeforces.com/blog/entry/56713ll dp[1010][1010] = {0};ll getdp(int i,int j){  return j &gt;= k? j : dp[i][j];}int main(){  ll a,b;  cin&gt;&gt;k&gt;&gt;a&gt;&gt;b;  //http://codeforces.com/blog/entry/56713?#comment-404349  rep(i,0,k)    dp[k][i] = (i + k + a * mul_inv(b)) % MOD;  int i,j;  for(i=k-1;i&gt;=1;i--)    for(j=k-1;j&gt;=0;j--){      dp[i][j] = (a*getdp(i+1,j) + b * getdp(i,i+j))%MOD;      dp[i][j] = (dp[i][j] * mul_inv(a+b))%MOD;    }  cout&lt;&lt;getdp(1,0)&lt;&lt;endl;  return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 期望 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2017-11-20-CF_R446_D2_E(MST + Disjoint Set)</title>
      <link href="/Blog/2017-11-20-cf-R446-D2-E-cpp/"/>
      <url>/Blog/2017-11-20-cf-R446-D2-E-cpp/</url>
      
        <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给一个有权无向图。进行q次询问，第i次询问ki个边，问所提到的ki个边能否同时出现在图的最小生成树上，返回YES或NO。</p><h1 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h1><p>图的边和点<code>&lt;=500&#39;000</code></p><p>询问数<code>q&lt;=500&#39;000</code>,所有询问的边数的和<code>sum(ki)&lt;=500&#39;000</code></p><p>时间空间(2s/256MB)</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>  不知道如果当时继续想下去，会不会想出解法，当时已经想到 并查集 和 边+未选取的边形成的环，已选取的 不能 大于max(未选取的)。感觉和正解的具体实现还差很远，但基础结论已经有了</p><p>  标答说成那样，我也是没啥办法，我也想到了，没想到下一步。然后观摩了moejy0viiiiiv大佬的代码。 下面用举例来说明</p><p>  首先，不要用官方的样例来想，想象图有且只有一个环，环上的边长是1,1,2,2,2</p><p>  很直接可以知道只要不是选了所有的2，那么 都是可以同时存在于一个MST上的，那么选三个2的情况发生了什么，也就是上面说的选了三个2以后，在这个环上，未选取的最大只是1了。然后换一个角度看，如果我们已经先把图上所有的长度为1的链接好了，那么在新增加2的时候，就不应该形成环。</p><p>  同样可以想象环上是1,1,2,2,2,3的情况，现在 尝试添加2的时候，就算全添加了，也不会直接形成环，和结论全选了2也能同时存在于一个MST是一样的。</p><p>  其中要注意的是对于第一种情况，就算 询问中没有1 1，也不能选取 所有的2</p><p>  因此把上述方法转化为伪代码</p><pre><code>  首先读入,所有边和询问，将询问 每个拆分，按长度第一序，询问号第二序 排序  从空开始，分别处理每一个询问中的1，将它们连接(并查集) 检验是否成环，如果成环该询问不可行  将所有的1相连接(并查集)不论在不在查询中，分别处理每一个询问中的2，将它们连接(并查集) 检验是否成环，如果成环该询问不可行  将所有的1 2相连接(并查集)不论在不在查询中，分别处理每一个询问中的3，将它们连接(并查集) 检验是否成环，如果成环该询问不可行  ...  将所有的1 2...499&#39;999相连接(并查集)不论在不在查询中，分别处理每一个询问中的500&#39;000，将它们连接(并查集) 检验是否成环，如果成环该询问不可行</code></pre><p>整理上面成循环就是</p><pre><code>  i=0  S(i) 表示连接完小于等于i的边的并查集  for(length=1~500&#39;000):    遍历每一查询      选中一个包含该length的一个查询Q      将Q中所有长length的边 和 S(length-1)相连 检查是否成环    将所有长为length的边连入S(length-1)也就变成了S(length)</code></pre><p>上面代码中 一个是既要利用已经连接的小于length的并查集，又要在每次 进行成环检测时 并查集能够复用，具体实现见下面moejy0viiiiiv大佬的代码，他用f来实现 可以逐渐增加利用的并查集，用p和mt来实现可复用 的每次检测。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>  <a href="http://codeforces.com/contest/891/submission/32396218" target="_blank" rel="noopener">moejy0viiiiiv 的代码</a></p><pre><code>#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cassert&gt;  using namespace std;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)#define pb push_back#define mp make_pair#define all(x) (x).begin(),(x).end()#define fi first#define se second#define SZ(x) ((int)(x).size())typedef vector&lt;int&gt; VI;typedef long long ll;typedef pair&lt;int,int&gt; PII;const ll mod=1000000007;ll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b&gt;=0); for(;b;b&gt;&gt;=1){if(b&amp;1)res=res*a%mod;a=a*a%mod;}return res;}// headconst int N=501000;int n,m,u[N],v[N],w[N],f[N],p[N],mt[N],T,wa[N];int Q,k,id;vector&lt;int&gt; eg[N];vector&lt;PII&gt; qw[N];int find(int x) {  if (f[x]!=x) return f[x]=find(f[x]); else return x;}int find2(int x) {  if (mt[x]!=T) mt[x]=T,p[x]=f[x];  if (p[x]!=x) return p[x]=find2(p[x]); else return x;}int main() {  scanf(&quot;%d%d&quot;,&amp;n,&amp;m);  rep(i,0,m) {    scanf(&quot;%d%d%d&quot;,u+i,v+i,w+i);    eg[w[i]].pb(i);  }  rep(i,1,n+1) f[i]=i;  scanf(&quot;%d&quot;,&amp;Q);  rep(i,0,Q) {    scanf(&quot;%d&quot;,&amp;k);    rep(j,0,k) {      scanf(&quot;%d&quot;,&amp;id);      --id;      qw[w[id]].pb(mp(i,id));    }  }  rep(i,1,500001) {    sort(all(qw[i]));    rep(j,0,SZ(qw[i])) {      int x=u[qw[i][j].se],y=v[qw[i][j].se];      find(x); find(y);    }    rep(j,0,SZ(qw[i])) {      if (j==0||qw[i][j].fi!=qw[i][j-1].fi) T++;      int x=u[qw[i][j].se],y=v[qw[i][j].se];      if (find2(x)==find2(y))    wa[qw[i][j].fi]=1;      p[find2(x)]=find2(y);    }    for (auto id:eg[i]) {      int x=u[id],y=v[id];      f[find(x)]=find(y);    }  }  rep(i,0,Q) puts(wa[i]?&quot;NO&quot;:&quot;YES&quot;);}</code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://codeforces.com/contest/892/problem/E" target="_blank" rel="noopener">题目</a></p><p><a href="http://codeforces.com/blog/entry/55841" target="_blank" rel="noopener">官方题解</a></p>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF Round440 Div2 E(Points, Lines and Ready-made Titles)</title>
      <link href="/Blog/2017-10-25-cfR440D2E/"/>
      <url>/Blog/2017-10-25-cfR440D2E/</url>
      
        <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给平面上n个点，在每个点可以，画一条竖直线，画一条横直线，什么都不画，也就是不能画十字</p><p>这样n个点一共能画出多少种图形</p><h1 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h1><p><code>n&lt;=100 000</code>,点的坐标范围<code>-1 000 000 000&lt;=x,y&lt;=1 000 000 000</code>，</p><p>时间空间(2s/256MB)</p><p>输出答案MOD <code>1 000 000 007</code></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>想了半天还想了递推，但是到横竖交叉我的递推就变得格外的复杂以至不可用。</p><p>我已经想到 如果有一群点可以通过横线和竖线连在一起，那么，我们只用考虑画出来的横线竖线的可能性</p><p>题解的意思是需要发现两个事实：</p><ol start="0"><li><p>如果 这一群点能够成环，那么方案数=<code>2^(横线数+竖线数)</code></p></li><li><p>如果 这一群点不能够成环，那么方案数=<code>2^(横线数+竖线数) - 1</code></p></li></ol><p>过程就是并查集之类的+找环就好了</p><p><code>所以我菜 就菜在 根本没有发现这两个 事实</code></p><p><a href="http://codeforces.com/contest/872/submission/31715440" target="_blank" rel="noopener">代码/280ms/14368KB</a></p><pre><code class="c++">typedef long long ll;#define shi5 100000+10#define MOD 1000000007#include &lt;bits/stdc++.h&gt;using namespace std;struct poi{  ll x;  ll y;  int color;};// int structcmp(const void *v1,const void *v2){return ((mystruct *)v1)-&gt;v - ((mystruct *)v2)-&gt;v;}int intcmp(const void *v1,const void *v2){return *(int *)v1-*(int *)v2;}long long minn(long long v1,long long v2){return v1&lt;v2?v1:v2;}long long maxx(long long v1,long long v2){return v1&gt;v2?v1:v2;}poi p[100010]={0};map&lt;ll,vector&lt;int&gt; &gt; x2index;map&lt;ll,vector&lt;int&gt; &gt; y2index;ll twopow(ll val){  if(val == 1)    return 2;  ll ret = twopow(val/2);  ret *= ret;  ret %= MOD;  if(val%2)    ret *= 2;  ret %= MOD;  return ret;}ll getnocircle(int v){  ll ret = twopow(v);  if(ret == 0)    return MOD-1;  else    return ret-1;}ll getcircle(int v){  return twopow(v);}ll dolink(int index,int c){  map&lt;ll,ll&gt; xlstartindex;  map&lt;ll,ll&gt; ylstartindex;  vector&lt;ll&gt; xlist;  vector&lt;ll&gt; ylist;  int xitr=0,yitr=0;  bool iscircle=false;  p[index].color=c;  xlist.push_back(p[index].x);  ylist.push_back(p[index].y);  xlstartindex[p[index].x] = index;  ylstartindex[p[index].y] = index;  while(xitr != xlist.size() or yitr != ylist.size()){    if(xitr != xlist.size()){      for(auto indexeach:x2index[xlist[xitr]]){        if(indexeach == xlstartindex[xlist[xitr]])          continue;        if(p[indexeach].color != 0)          iscircle = true;        else if(ylstartindex.count(p[indexeach].y)){          p[indexeach].color = c;          iscircle = true;        }else{          p[indexeach].color = c;          ylist.push_back(p[indexeach].y);          ylstartindex[p[indexeach].y] = indexeach;        }      }      xitr++;    }    if(yitr != ylist.size()){      for(auto indexeach:y2index[ylist[yitr]]){        if(indexeach == ylstartindex[ylist[yitr]])          continue;        if(p[indexeach].color != 0)          iscircle = true;        else if(xlstartindex.count(p[indexeach].x)){          p[indexeach].color = c;          iscircle = true;        }else{          p[indexeach].color = c;          xlist.push_back(p[indexeach].x);          xlstartindex[p[indexeach].x] = indexeach;        }      }      yitr++;    }  }  if(iscircle)    return getcircle(xlist.size()+ylist.size());  else    return getnocircle(xlist.size()+ylist.size());}int main(){  int n;  cin&gt;&gt;n;  int i;  for(i=0;i&lt;n;i++){    scanf(&quot;%lld %lld&quot;,&amp;p[i].x,&amp;p[i].y);    x2index[p[i].x].push_back(i);    y2index[p[i].y].push_back(i);  }  int nowcolor=1;  ll ans = 1;  for(i=0;i&lt;n;i++){    if(p[i].color == 0){      ans *= dolink(i,nowcolor);      ans %= MOD;    }    nowcolor++;  }  cout&lt;&lt;ans&lt;&lt;endl;  return 0;}</code></pre><p>依旧代码丑陋126行</p><p>大佬们都写得十分精简 低头</p><p><a href="http://codeforces.com/contest/872/submission/31348128" target="_blank" rel="noopener">oscillation</a></p><p><a href="http://codeforces.com/contest/872/submission/31353643" target="_blank" rel="noopener">wdmmsyf</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://codeforces.com/contest/872/problem/E" target="_blank" rel="noopener">题目</a></p><p><a href="http://codeforces.com/blog/entry/" target="_blank" rel="noopener">官方题解</a></p>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF Round442 Div2 E(Euler tour tree + Segment tree)</title>
      <link href="/Blog/2017-10-24-cfR442DIV2E/"/>
      <url>/Blog/2017-10-24-cfR442DIV2E/</url>
      
        <content type="html"><![CDATA[<h1 id="Danil-and-a-Part-time-Job"><a href="#Danil-and-a-Part-time-Job" class="headerlink" title="Danil and a Part-time Job"></a>Danil and a Part-time Job</h1><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给一个多叉树，根节点序号为1，树上每一个点是1或者0。</p><p>操作，对 一个树的节点以及这个节点的所有子节点进行 零 一 翻转(布尔非)。</p><p>询问，求 一个树的节点以及这个节点的所有子节点的 1的个数总和</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>树上的连接情况也就是边，输入每个点的初始状态</p><p>接下来是输入query，为操作或者询问</p><h1 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h1><p>树的点的个数<code>&lt;=200 000</code></p><p>query数量<code>&lt;=200 000</code></p><p>上限 2秒 256MB</p><h1 id="解答思路"><a href="#解答思路" class="headerlink" title="解答思路"></a>解答思路</h1><p>官方给的是<code>Euler-tour-tree</code>+<code>Segment tree</code> 具体讲解见下面的参考，很清晰了。下面的链接中介绍了三种ETT，这里用得是第二种</p><p>思路是首先对树 进行<code>Euler-tour-tree</code>展开，这样操作后上面的操作和询问 都变成了 展开后的区间操作和询问了。</p><p>这样变成区间后就可以用segment tree 来做了，加个lazytag减少点时间，目测不加lazy过不了，因为每次对整个操作区间的话，每次改动就是2n</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><a href="http://codeforces.com/contest/877/submission/31694632" target="_blank" rel="noopener">C++14/390ms/40 392KB</a></p><p>用了一下<code>C++14</code>的一些语法[虽然我记不清哪些在11就已经支持了]</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>也是很久没有写过线段树 更不要说lazytag，上一次写应该是四五年前。</p><p>感受0. 既可以向下面这样用线段树的节点来记录 表示的l和r。也可完全不记录，这样通过固定的函数之间递归调用，多传两个参数也可以，目前用前一种方法写下来就是有点乱的感觉，如果每次传参，脑补代码会看上去更简洁。</p><p>感受1. lazytag我最开始写的是再调用处理函数，但是最后改成了只对下一层改动，因为lazytag能有tag都是说明到这层已经是和这层的左右范围完全对应，所以向下也是完全对应，所以下层也就不会再往下传，所以直接改当前层和下一层就能把lazytag处理了。</p><p>实现0. 这里线段树我的节点上有一个switched来表示是否切换，所以如果一个节点以下的开启的个数，不是直接返回on的值，而是判断一下switched,所以我后面获取on和off见注释<code>fix o</code>下面的。。。没有具体分析这样写是把代码变复杂还是简单还是差不多。因为如果直接表示每次要直接转换，lazytag下发也要再加一些判断。<code>_(:з」∠)_</code></p><p>感受2. 总的来说我也调了半天，代码丑陋写了136行，看rank上排在前面的大佬 90行就写完了</p><pre><code class="c++">#include &lt;bits/stdc++.h&gt;#define NUM 200000+10#define o_l (o&lt;&lt;1)#define o_r (o_l+1)using namespace std;struct sgtnode{  int l,r;  int swiced;  int on,off;  sgtnode(){swiced=0;on=0;off=0;}  sgtnode(int s,int n,int f):    swiced(s),on(n),off(f){}};// --- input ---int n;vector&lt;int&gt; child[NUM];// --- Euler tour tree ---int ettIndex2ONorOFF[2*NUM];int ett_l[NUM]={0};int ett_r[NUM]={0};// --- Segment tree ---sgtnode sgmnttr[4*2*NUM];void lazydown(int o){  if(sgmnttr[o].swiced == 1){    sgmnttr[o].swiced = 0;    swap(sgmnttr[o].on,sgmnttr[o].off);    sgmnttr[o_l].swiced ^=1;    sgmnttr[o_r].swiced ^=1;  }}// --- Segment tree switch ---void segswi(int o,int l,int r){  if(sgmnttr[o].l == l and sgmnttr[o].r == r){    sgmnttr[o].swiced ^= 1;    return ;  }  lazydown(o);  int mid=(sgmnttr[o].l+sgmnttr[o].r)/2;  if(l &lt;= mid)    segswi(o_l,l,min(r,mid));  if(r &gt; mid)    segswi(o_r,max(l,mid+1),r);  // fix o  sgmnttr[o].on =    (sgmnttr[o_l].swiced?sgmnttr[o_l].off:sgmnttr[o_l].on)+    (sgmnttr[o_r].swiced?sgmnttr[o_r].off:sgmnttr[o_r].on);  sgmnttr[o].off =    (sgmnttr[o_l].swiced?sgmnttr[o_l].on:sgmnttr[o_l].off)+    (sgmnttr[o_r].swiced?sgmnttr[o_r].on:sgmnttr[o_r].off);}// --- Segment tree query ---int segqry(int o,int l,int r){  if(sgmnttr[o].l == l and sgmnttr[o].r == r)    return sgmnttr[o].swiced?sgmnttr[o].off:sgmnttr[o].on;  lazydown(o);  int mid=(sgmnttr[o].l+sgmnttr[o].r)/2;  int ret=0;  if(l &lt;= mid)    ret += segqry(o_l,l,min(r,mid));  if(r &gt; mid)    ret += segqry(o_r,max(l,mid+1),r);  return ret;}void build_segtree(int o,int l,int r){  sgmnttr[o].l = l;  sgmnttr[o].r = r;  if(l == r){    sgmnttr[o].off = 1^(sgmnttr[o].on = ettIndex2ONorOFF[l]);    return ;  }  int mid =(l+r)/2;  build_segtree(o_l,l,mid);  build_segtree(o_r,mid+1,r);  sgmnttr[o].on  = sgmnttr[o_l].on  + sgmnttr[o_r].on;  sgmnttr[o].off = sgmnttr[o_l].off + sgmnttr[o_r].off;}void qry(int index){  printf(&quot;%d\n&quot;,segqry(1,ett_l[index],ett_r[index])/2);}void swi(int index){  segswi(1,ett_l[index],ett_r[index]);}void build_ett(int tree_index){  static int ett_index = 0;  ett_l[tree_index] = ett_index++;  for(auto each_child : child[tree_index])    build_ett(each_child);  ett_r[tree_index] = ett_index++;}int main(){  cin&gt;&gt;n;  int i;  for(i=2;i&lt;=n;i++){    int tmp;    scanf(&quot;%d&quot;,&amp;tmp);    child[tmp].push_back(i);  }  build_ett(1);  // for(i=1;i&lt;=n;i++)  //   cout&lt;&lt;ett_l[i]&lt;&lt;&quot; &quot;&lt;&lt;ett_r[i]&lt;&lt;endl;  for(i=1;i&lt;=n;i++){    int tmp;    scanf(&quot;%d&quot;,&amp;tmp);    ettIndex2ONorOFF[ett_l[i]]=tmp;    ettIndex2ONorOFF[ett_r[i]]=tmp;  }  build_segtree(1,0,2*n-1);  // cout&lt;&lt;&quot;index\tswiced\tl\tr\ton\toff\n&quot;;  // for(i=1;i&lt;4*n;i++)  //   cout&lt;&lt;i&lt;&lt;&quot;\t&quot;&lt;&lt;sgmnttr[i].swiced&lt;&lt;&quot;\t&quot;&lt;&lt;sgmnttr[i].l&lt;&lt;&quot;\t&quot;&lt;&lt;sgmnttr[i].r&lt;&lt;&quot;\t&quot;&lt;&lt;sgmnttr[i].on&lt;&lt;&quot;\t&quot;&lt;&lt;sgmnttr[i].off&lt;&lt;endl;  int q;  cin&gt;&gt;q;  while(q--){    char s[10];    int tmp;    scanf(&quot;%s %d&quot;,s,&amp;tmp);    if(s[0]==&#39;g&#39;){      qry(tmp);    }else{      swi(tmp);    }  }  return 0;}</code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://codeforces.com/contest/877/problem/E" target="_blank" rel="noopener">Problem</a></p><p><a href="http://codeforces.com/blog/entry/55362" target="_blank" rel="noopener">Official editorial</a></p><p><a href="http://codeforces.com/blog/entry/18369" target="_blank" rel="noopener">Euler tour tree</a></p><p><a href="https://en.wikipedia.org/wiki/Segment_tree" target="_blank" rel="noopener">Segment tree</a></p>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> segment tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF439E</title>
      <link href="/Blog/2017-10-07-cfR439E/"/>
      <url>/Blog/2017-10-07-cfR439E/</url>
      
        <content type="html"><![CDATA[<h1 id="E-The-Untended-Antiquity"><a href="#E-The-Untended-Antiquity" class="headerlink" title="E. The Untended Antiquity"></a><a href="http://codeforces.com/contest/869/problem/E" target="_blank" rel="noopener">E. The Untended Antiquity</a></h1><table><thead><tr><th style="text-align:left">time limit per test</th><th style="text-align:center">2 seconds</th></tr></thead><tbody><tr><td style="text-align:left">memory limit per test</td><td style="text-align:center">512 megabytes</td></tr><tr><td style="text-align:left">input</td><td style="text-align:center">standard input</td></tr><tr><td style="text-align:left">output</td><td style="text-align:center">standard output</td></tr></tbody></table><p>Koyomi is helping Oshino, an acquaintance of his, to take care of an open space around the abandoned Eikou Cram School building, Oshino’s makeshift residence.</p><p>The space is represented by a rectangular grid of n × m cells, arranged into n rows and m columns. The c-th cell in the r-th row is denoted by (r, c).</p><p>Oshino places and removes barriers around rectangular areas of cells. Specifically, an action denoted by “1 $r_1$ $c_1$ $r_2$ $c_2$” means Oshino’s placing barriers around a rectangle with two corners being ($r_1$, $c_1$) and ($r_2$, $c_2$) and sides parallel to squares sides. Similarly, “2 $r_1$ $c_1$ $r_2$ $c_2$” means Oshino’s removing barriers around the rectangle. Oshino ensures that no barriers staying on the ground share any common points, nor do they intersect with boundaries of the n × m area.</p><p>Sometimes Koyomi tries to walk from one cell to another carefully without striding over barriers, in order to avoid damaging various items on the ground. “3 $r_1$ $c_1$ $r_2$ $c_2$” means that Koyomi tries to walk from ($r_1$, $c_1$) to ($r_2$, $c_2$) without crossing barriers.</p><p>And you’re here to tell Koyomi the feasibility of each of his attempts.</p><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>The first line of input contains three space-separated integers n, m and q (1 ≤ n, m ≤ 2 500, 1 ≤ q ≤ 100 000) — the number of rows and columns in the grid, and the total number of Oshino and Koyomi’s actions, respectively.</p><p>The following q lines each describes an action, containing five space-separated integers t, $r_1$, $c_1$, $r_2$, $c_2$ (1 ≤ t ≤ 3, 1 ≤ $r_1$, $r_2$ ≤ n, 1 ≤ $c_1$, $c_2$ ≤ m) — the type and two coordinates of an action. Additionally, the following holds depending on the value of t:</p><p>If t = 1: 2 ≤ $r_1$ ≤ $r_2$ ≤ n - 1, 2 ≤ $c_1$ ≤ $c_2$ ≤ m - 1;<br>If t = 2: 2 ≤ $r_1$ ≤ $r_2$ ≤ n - 1, 2 ≤ $c_1$ ≤ $c_2$ ≤ m - 1, the specified group of barriers exist on the ground before the removal.<br>If t = 3: no extra restrictions.</p><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>For each of Koyomi’s attempts (actions with t = 3), output one line — containing “Yes” (without quotes) if it’s feasible, and “No” (without quotes) otherwise.</p><h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h2><h3 id="input"><a href="#input" class="headerlink" title="input"></a>input</h3><pre><code>5 6 51 2 2 4 51 3 3 3 33 4 4 1 12 2 2 4 53 1 1 4 4</code></pre><h3 id="output"><a href="#output" class="headerlink" title="output"></a>output</h3><pre><code>NoYes</code></pre><h3 id="input-1"><a href="#input-1" class="headerlink" title="input"></a>input</h3><pre><code>2500 2500 81 549 1279 1263 21891 303 795 1888 24321 2227 622 2418 11613 771 2492 1335 14331 2017 2100 2408 21603 48 60 798 7291 347 708 1868 7923 1940 2080 377 1546</code></pre><h3 id="output-1"><a href="#output-1" class="headerlink" title="output"></a>output</h3><pre><code>NoYesNo</code></pre><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p><a href="http://codeforces.com/contest/869/submission/31084997" target="_blank" rel="noopener">二维线段树+set/vector/rand</a></p><p><a href="http://codeforces.com/contest/869/submission/31075785" target="_blank" rel="noopener">二维数状数组+rand+’+’</a></p><p><a href="http://codeforces.com/contest/869/submission/31069215" target="_blank" rel="noopener">二维数状数组+rand+’^’</a></p><p><a href="http://codeforces.com/blog/entry/55009" target="_blank" rel="noopener">官方解答</a></p><p>我读官方解答读下来，发现官方解答用的是一维线段树 只在左右方向进行划分，对于横坐标划分后保存 纵向的 启始和结束以及<code>_id</code> 这样看得话<code>_id</code>是否有点多余？？？ 但好像写出来比比较 <code>_u</code>和<code>_d</code> 看上去简洁 不过这个都不影响复杂度，然后我尝试了把 <code>_u</code>和<code>_d</code>进行编码 当作返回，结论是 不可以的，因为 可能目标两个的点所在的矩形 不是同一个，但 这两个矩形的上下的分化是一样的<code>:-)</code>僵硬，结论还是要<code>_id</code>的</p><p>我反正还没想到2D的线段树也就是 四叉树 加信息标注 要怎么做？？？？ need help 上面三个选手的代码都是带<code>rand()</code></p><p>然后官方题解用了 好多C++新的东西 比如 <code>auto</code> <code>and</code> 低头</p><p>以及看别人的代码发现 手工编码解码很少了，大家都用的makepair 甚至两重makepair</p>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rand </tag>
            
            <tag> Binary Indexed Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF438F</title>
      <link href="/Blog/2017-10-06-cfR438F/"/>
      <url>/Blog/2017-10-06-cfR438F/</url>
      
        <content type="html"><![CDATA[<h1 id="F-Yet-Another-Minimization-Problem"><a href="#F-Yet-Another-Minimization-Problem" class="headerlink" title="F. Yet Another Minimization Problem"></a><a href="http://codeforces.com/contest/868/problem/F" target="_blank" rel="noopener">F. Yet Another Minimization Problem</a></h1><table><thead><tr><th style="text-align:left">time limit per test</th><th style="text-align:center">2 seconds</th></tr></thead><tbody><tr><td style="text-align:left">memory limit per test</td><td style="text-align:center">256 megabytes</td></tr><tr><td style="text-align:left">input</td><td style="text-align:center">standard input</td></tr><tr><td style="text-align:left">output</td><td style="text-align:center">standard output</td></tr></tbody></table><p>You are given an array of <code>n</code> integers $a_1$ <code>...</code> $a_n$. The cost of a subsegment is the number of unordered pairs of distinct indices within the subsegment that contain equal elements. Split the given array into <code>k</code> non-intersecting non-empty subsegments so that the sum of their costs is minimum possible. Each element should be present in exactly one subsegment.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line contains two integers <code>n</code> and <code>k</code> ($2$ ≤ n ≤ $10^5$, 2 ≤ k ≤ min (n, 20))  — the length of the array and the number of segments you need to split the array into.</p><p>The next line contains <code>n</code> integers $a_1$, $a_2$, …, $a_n$ (1 ≤ $a_i$ ≤ n) — the elements of the array.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>Print single integer: the minimum possible total cost of resulting subsegments.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><h4 id="input"><a href="#input" class="headerlink" title="input"></a>input</h4><pre><code>7 31 1 3 3 3 2 1</code></pre><h4 id="output"><a href="#output" class="headerlink" title="output"></a>output</h4><pre><code>1</code></pre><h4 id="input-1"><a href="#input-1" class="headerlink" title="input"></a>input</h4><pre><code>10 21 2 1 2 1 2 1 2 1 2</code></pre><h4 id="output-1"><a href="#output-1" class="headerlink" title="output"></a>output</h4><pre><code>8</code></pre><h4 id="input-2"><a href="#input-2" class="headerlink" title="input"></a>input</h4><pre><code>13 31 2 2 2 1 2 1 1 1 2 2 1 1</code></pre><h4 id="output-2"><a href="#output-2" class="headerlink" title="output"></a>output</h4><pre><code>9</code></pre><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>In the first example it’s optimal to split the sequence into the following three subsegments: [1], [1, 3], [3, 3, 2, 1]. The costs are 0, 0 and 1, thus the answer is 1.</p><p>In the second example it’s optimal to split the sequence in two equal halves. The cost for each half is 4.</p><p>In the third example it’s optimal to split the sequence in the following way: [1, 2, 2, 2, 1], [2, 1, 1, 1, 2], [2, 1, 1]. The costs are 4, 4, 1.</p><hr><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>我开始还以为我做出来了，然而第6个点就爆了。下面用<code>|</code>表示分割<code>_</code>表示数字</p><p>我的最开始的想法是先随意将原数组随意分割为k组<code>______|____|_________|__________</code></p><p>然后对每一个分割进行左右调整,直到不可调为止，<code>______←|→____|_________|__________</code>，但这样局部最优并不能达到全局最优</p><pre><code class="c++">long long costn(long long n){  return (n-1)*n/2;}long long cost[100010]={0};void init(){  int i;  for(i=0;i&lt;=100000;i++)    cost[i]=costn(i);}int n,k;long long ans = 0;long long v[100010]={0};long long cnt[100010]={0};long long cntnow[100010]={0};int divk[30]={0}; // return indexvoid clear(){  int i;  for(i=0;i&lt;=n;i++){    cnt[i]=0;    cntnow[i]=0;  }}bool doaj(int index){  clear();  int l = index == 0?0:divk[index-1]+1;  int r = index == k-1?n-1:divk[index+1];  // cout&lt;&lt;index&lt;&lt;&quot;:&quot;&lt;&lt;l&lt;&lt;&quot;,&quot;&lt;&lt;r&lt;&lt;endl;  int i;  for(i=l;i&lt;=r;i++){    cnt[v[i]]++;    // cout&lt;&lt;v[i]&lt;&lt;&quot; &quot;&lt;&lt;cnt[v[i]]&lt;&lt;endl;  }  int ansi = l;  long long dermin = 100000000000;  long long dernow = 0;  long long derori = 100000000000;  for(i=l;i&lt;r;i++){    cntnow[v[i]]++;    long long oril = cntnow[v[i]]-1;    long long orir = cnt[v[i]] - oril;    long long oriv = cost[oril]+cost[orir];    long long nowl = oril+1;    long long nowr = orir-1;    long long nowv = cost[nowl]+cost[nowr];    dernow += -oriv+nowv;    if(i == divk[index]){      derori = dernow;    }    if(dernow &lt; dermin || (dernow==dermin &amp;&amp; i==divk[index])){      dermin = dernow;      ansi = i;    }  }  if(dermin &lt; derori){    if(ansi != divk[index]){      // cout&lt;&lt;index&lt;&lt;&quot;: [&quot;&lt;&lt;l&lt;&lt;&quot;,&quot;&lt;&lt;r&lt;&lt;&quot;]&quot;&lt;&lt;&quot;der:&quot;&lt;&lt;dermin-derori&lt;&lt;&quot; | &quot;&lt;&lt;divk[index]&lt;&lt;&quot; -&gt; &quot;&lt;&lt;ansi&lt;&lt;endl;      divk[index] = ansi;      ans += dermin-derori;      return true;    }  }  return false;}int main(){  init();  cin&gt;&gt;n&gt;&gt;k;  k--;  int i;  for(i=0;i&lt;n;i++)    scanf(&quot;%lld&quot;,&amp;v[i]);  for(i=0;i&lt;k;i++)    divk[i]=i;  for(i=k;i&lt;n;i++){    cnt[v[i]]++;  }  for(i=1;i&lt;=n;i++){    ans += cost[cnt[i]];  }  bool adjust=true;  while(adjust){    adjust=false;    for(i=0;i&lt;k;i++){      if(doaj(i))        adjust=true;    }  }  cout&lt;&lt;ans&lt;&lt;endl;  return 0;}</code></pre><hr><p>下一个想法是动态规划,<code>dp[p][k]</code>返回把<code>[0 , p-1]</code>分为<code>k</code>组的最小代价,则答案为<code>dp[n][k]</code></p><p>其中再进行划分<code>k组[0 , p-1] -&gt; k-1组[0 , j-1] + 1组[j,p-1]</code></p><p><code>dp[p][k] = min{dp[j][k-1] + cost[j,p-1]}</code></p><p>有了这个 时间复杂度在接近 $O(n^3)$ , 对一个固定的<code>k</code>遍历<code>p</code>需要<code>n</code>，对一个<code>p</code>遍历<code>j</code>需要<code>n</code>，对一个<code>j</code>计算<code>cost[j,p-1]</code>需要<code>n</code></p><h4 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h4><p><code>k</code>遍历<code>p</code> 最外层难优化</p><p>考虑最里层<code>cost[j,p-1]</code> 因为相邻的j的访问 会使这个函数左右范围变化不大，所以如果能用全局或者静态变量来维护左、右指向以及和，就能对这里的时间复杂度降低到<code>O(1)</code></p><pre><code class="c++">static long long cost(int l,int r){  static int _l = 0;  static int _r = -1;  static long long _ans = 0;  while(_r &lt; r) _ans += cnt[v[++_r]]++;  while(_l &gt; l) _ans += cnt[v[--_l]]++;  while(_r &gt; r) _ans -= --cnt[v[_r--]];  while(_l &lt; l) _ans -= --cnt[v[_l++]];  return _ans;}</code></pre><p>这样总的时间复杂度还是在<code>O(n^2)</code></p><p>如果可以对一个<code>p</code> 我们的<code>j</code>的范围不再是<code>[1~p-1]</code>，而能更小，那么时间复杂度也就还能下降</p><p>下面假设对给定<code>p</code>最小的分割为<code>m</code>，也就是<code>dp[p][k]</code>的最小值为<code>dp[m][k-1] + cost[m,p-1]</code></p><p><code>_____________m-1|m_________p-1|p___________</code></p><p><code>______n-1|n_____|__________p-1|p_____|_____</code></p><p><code>______n-1|n_____|_____________|___q-1|q____</code></p><p>对于一个<code>q&gt;p</code> 最小的分割为<code>n</code>，也就是<code>dp[q][k]</code>最小值为<code>dp[n][k-1] + cost[n,q-1]</code></p><pre><code>dp[n][k-1] + cost[n,q-1]= dp[n][k-1] + cost[n,p-1] + der[n-&gt;q)[p-&gt;q)&gt;= dp[p][k] + der[n-&gt;q)[p-&gt;q)= dp[m][k-1]+cost[m,p-1] + der[n-&gt;p)[p-&gt;q)&gt;= dp[m][k-1]+cost[m,p-1] + der[m-&gt;p)[p-&gt;q)</code></pre><p>以上,其中<code>der[base][add]</code>表示在<code>base</code>的基础上再增加<code>add</code>部分的 新增加的<code>cost</code></p><p>即是 在m左侧的最终划分都<code>&gt;=</code>m处的划分，因此 如果在<code>p</code>计算出了<code>m</code>，之后再计算<code>q</code>的分割点时遍历只需要从<code>m-&gt;q</code></p><p><strong>同理</strong>可证当<code>q&lt;p</code>时 更小的值只会在<code>m</code>左侧</p><p>因此 有了这个关系 就可以进行二分搜索,时间复杂度也就降到了<code>O(n log n)</code> [好像也不完全是个这个 估计比这个大一点 因为这样二分以后cost函数的均摊就不是<code>O(1)</code>的样子了]</p><p>实现如下</p><pre><code class="c++">#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define MAX 10000000000using namespace std;long long minn(long long v1,long long v2){return v1&lt;v2?v1:v2;}long long maxx(long long v1,long long v2){return v1&gt;v2?v1:v2;}long long v[100010]={0};long long cnt[100010]={0};long long dp[100010][30]={0};int n,k;static long long cost(int l,int r){  static int _l = 0;  static int _r = -1;  static long long _ans = 0;  while(_r &lt; r) _ans += cnt[v[++_r]]++;  while(_l &gt; l) _ans += cnt[v[--_l]]++;  while(_r &gt; r) _ans -= --cnt[v[_r--]];  while(_l &lt; l) _ans -= --cnt[v[_l++]];  // cout&lt;&lt;&quot;[&quot;&lt;&lt;_l&lt;&lt;&quot;,&quot;&lt;&lt;_r&lt;&lt;&quot;]&quot;&lt;&lt;_ans&lt;&lt;endl;  return _ans;}void solve(const int &amp; kk,int l,int r,int mathl,int mathr){  // cout&lt;&lt;&quot;---------------:&quot;&lt;&lt;l&lt;&lt;&quot; &quot;&lt;&lt;r&lt;&lt;&quot; &quot;&lt;&lt;mathl&lt;&lt;&quot; &quot;&lt;&lt;mathr&lt;&lt;&quot; &quot;&lt;&lt;endl;  if(l &gt; r)    return ;  int j = (l+r)/2;  int min_pos = mathl;  dp[j][kk] = MAX;  int maxi = minn(j,mathr);  int starti = maxx(kk-1,mathl);  int i;  for(i=starti;i&lt;=maxi;i++){    long long newv = dp[i][kk-1] + cost(i,j-1);    // cout&lt;&lt;l&lt;&lt;&quot; &quot;&lt;&lt;r&lt;&lt;&quot; &quot;&lt;&lt;j&lt;&lt;&quot; &quot;&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;newv&lt;&lt;endl;    if(newv &lt; dp[j][kk]){      dp[j][kk] = newv;      min_pos = i;    }  }  solve(kk, l  , j-1, mathl  , min_pos);  solve(kk, j+1, r  , min_pos, mathr);}int main(){  cin&gt;&gt;n&gt;&gt;k;  int i,j,o;  for(i=0;i&lt;n;i++)    scanf(&quot;%lld&quot;,&amp;v[i]);  dp[0][1] = 0;  for(i=1;i&lt;=n;i++)dp[i][1] = cost(0,i-1);  for(i=2;i&lt;=k;i++)    solve(i,1,n,1,n);  cout&lt;&lt;dp[n][k]&lt;&lt;endl;  return 0;}</code></pre><p><a href="http://codeforces.com/contest/868/submission/31040451" target="_blank" rel="noopener">AC</a></p><p><a href="http://codeforces.com/blog/entry/8219" target="_blank" rel="noopener">DP Optimizations</a></p>]]></content>
      
      
      <categories>
          
          <category> Codeforces </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
