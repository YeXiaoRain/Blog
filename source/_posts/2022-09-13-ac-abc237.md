---
title: Atcoder abc237
date: 2022-09-13
tags: [线段树,回文串,Dilworth定理,二分图]
category: [Atcoder,ABC]
description: G(线段树)Ex(回文串,Dilworth定理,二分图)
---

https://atcoder.jp/contests/abc237/tasks

# G - Range Sort Query

给你一个1-N的排列

Q次操作, 每次指定区间排成指定升序/降序

问所有操作结束后,X的位置

## 范围

n 2e5

q 2e5

8s

1024mb

## 我的思路

先考虑特殊情况

X=1

那么只用持续跟踪它的位置就好了, 每次有覆盖的区间,计算新位置

而如果X=2

会发现, 每次排序与,1是否在其中有关, 维护量变成2个位置

这样下去3,就是3个位置

x就是x个位置

---

但其实一想, 整个排序,对X位置有影响的可以只考虑< X的个数, 或者说只考虑> x的个数

那么每次对含X的排序 = [l...r] 变成 `< x的个数`,X,`> x的个数`

啊不就是区间查询和连续区间修改

segment tree + lazy tag 就可以了?

<!--more-->

## 代码

https://atcoder.jp/contests/abc237/submissions/34842993

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
#define rep(i,a,n) for (ll i=a;i<(ll)n;i++)

#define SEG_ROOT 1,0,n-1
#define SEG_L (o<<1)
#define SEG_R (o<<1|1)
#define mid (l+r)/2
#define SEG_L_CHILD SEG_L,l,mid
#define SEG_R_CHILD SEG_R,mid+1,r

ll read(){ll r;scanf("%lld",&r);return r;} // read


int a[200010];
struct node{
  int lazy = 0; // 0 no lazy, 1lazy 1, 2lazy2
  array<int,3> c = {0,0,0};
};

node seg[800010]; // seg[o] = []

array<int,3> add(const array<int,3> &a0,const array<int,3> &a1){
  return {a0[0]+a1[0],a0[1]+a1[1],a0[2]+a1[2]};
}

void build(int o,int l,int r){
  if(l == r){
    seg[o].c[a[l]]++;
    return;
  }
  build(SEG_L_CHILD);
  build(SEG_R_CHILD);
  seg[o].c = add(seg[SEG_L].c,seg[SEG_R].c);
}

void down(int o,int l,int r){
  if(seg[o].lazy == 0)return ;
  int v = seg[o].lazy;
  seg[SEG_L].lazy = v;
  seg[SEG_L].c = {0,0,0};
  seg[SEG_L].c[v] = (mid-l+1);

  seg[SEG_R].lazy = v;
  seg[SEG_R].c = {0,0,0};
  seg[SEG_R].c[v] = (r-mid);
  seg[o].lazy = 0;
}

array<int,3> query(int o,int l,int r,int ql,int qr){
  if(ql <= l && r <= qr) return seg[o].c;
  down(o,l,r);
  array<int,3> res = {0,0,0};
  if(ql <= mid) res = add(res,query(SEG_L_CHILD,ql,qr));
  if(qr >  mid) res = add(res,query(SEG_R_CHILD,ql,qr));
  return res;
}

void setRange(int o,int l,int r,int ql,int qr,int v){
  if(ql <= l && r <= qr) {
    seg[o].lazy = v;
    seg[o].c = {0,0,0};
    seg[o].c[v] = r-l+1;
    return ;
  }
  down(o,l,r);
  if(ql <= mid) setRange(SEG_L_CHILD,ql,qr,v);
  if(qr >  mid) setRange(SEG_R_CHILD,ql,qr,v);
  seg[o].c = add(seg[SEG_L].c,seg[SEG_R].c);
}

int find0(int o,int l,int r){
  if(l == r) return l;
  down(o,l,r);
  return seg[SEG_L].c[0]?find0(SEG_L_CHILD):find0(SEG_R_CHILD);
}

int main(){
  int n = read();
  int q = read();
  int x = read();
  rep(i,0,n) a[i] = read();
  rep(i,0,n) a[i] = a[i]==x?0: (a[i]<x?1:2); // <x:1,=x:0,>x:2
  build(SEG_ROOT);
  while(q--){
    int o = read();
    int l = read()-1;
    int r = read()-1;
    auto res = query(SEG_ROOT,l,r);
    if(o == 1){ // 1 0 2
      if(res[0]) setRange(SEG_ROOT,l+res[1]  ,l+res[1]  ,0);
      if(res[1]) setRange(SEG_ROOT,l         ,l+res[1]-1,1);
      if(res[2]) setRange(SEG_ROOT,r-res[2]+1,r         ,2);
    }else{ // 2 0 1
      if(res[0]) setRange(SEG_ROOT,l+res[2]  ,l+res[2]  ,0);
      if(res[1]) setRange(SEG_ROOT,r-res[1]+1,r         ,1);
      if(res[2]) setRange(SEG_ROOT,l         ,l+res[2]-1,2);
    }
  }
  printf("%d\n",find0(SEG_ROOT)+1);
  return 0;
}
```

# Ex - Hakata

小写字母的字符串S

连续子串 是回文串,且不是其它的连续子串的回文串的子串

问有多少种

## 范围

|S| 200

2s

1024mb

## 我的思路

显然可以先插入#号来不用分类奇偶,以每个点为中心的最长串才有可能是答案

这样我们可以暴力n^2 得到n个候选回文串

问题变成说其中一个是否是另一个的子串

暴力+kmp = n^3 ?

## 题解

因为每次考虑 S如果能有n个不同子串, 那么每次末尾增加一个字符,至多产生一个之前不存在的回文串

若未出现过, 则多了它自己

若该字符出现过, 那么本身不会是新的, 那么产生的是 [i0....n+1], [i1.....n+1], 这些回文串

注意到 最小的i,对应的[i....n+1] 包含了其余的[i...n+1]所以其余的都不会是新产生的,

因此一个字符串的不同回文串个数 <= |S| 得证

---

比如 A,B 都是C的子串,你可以选A,B不选C达到更多

所以看成把 N个回文看成点,建立DAG,问选最多的点,让任意两点之间没有直接路径

而对于这个DAG,如果有 i->j,j->k,那么必然存在i->k,(传递闭包), 所以根据Dilworth定理, 问题变成最小路径覆盖(选最少的路径, 覆盖所有点)

DAG的选点互斥需要满足 i->j,j->k 则i->k也可以比较大小(存在偏需)

然后可以用二分图最大匹配来做

---

具体操作

1. 求传递闭包就是如果i->j,j->k那么就要有i->k的边,(本题目本身处理时就有不需要额外求)
2. 拆点成入点 出点, 变成二分图

因为每个点的出入度在二分图最大匹配中为1或0, 所以对应原拓扑图一定是多个链

又因为可以看成原图每个点是一个链,每次连接就让链数量减一, 要尽可能多的减1

而这正好一个连接对应二分图的一个匹配, 所以

最小覆盖 = 点数 - 二分图最大匹配数

## Dilworth 定理(偏序集分解定理)

关于偏序集的极大极小的定理，该定理断言：对于任意有限偏序集，其最大反链中元素的数目必等于最小链划分中链的数目。

偏序集能划分成的最少的全序集个数等于最大反链的元素个数。

对偶也是真: 任意有限偏序集,最长链元素的数目必等于最小反链划分中反链的数目

---

一些定义

原点集 = V

偏序: 集合中一些元素可以比较大小

全序: 集合中元素两两可以比较大小

链: V的子集,是全序集

反链(antichain): V的子集,其任意元素之间都不可以比较大小

链覆盖: 若干个链的并 = V, 且任意两个链不包含重复点

反链覆盖: 若干个反链的并 = V, 且任意两个反链不包含重复点

最长链: 所有链中点个数最多的链

最长反链: 所有反链中点个数最多的链

偏序集高度 = 最长链的点的个数

偏序集宽度 = 最长反链的点的个数

---

定理: 最小(链的数量最少)链覆盖个数 = 最长反链点的个数 = 偏序集宽度

最小(反链的数量最少)反链覆盖 = 最长链的元素个数 = 偏序集的深度

---

证明:

归纳法

对于点集V, 最大反链集合A

d = |A|

显然A的最小链覆盖 >= d, (因为A中每个点覆盖的链一定两两不同, 其实要证的是等号

若任何V的真子集都满足 其最大反链集合大小=最小链覆盖

如果V中两两不可比较, 则 d = |V|, 正确性显然

---

如果 存在A != max(V), V中的最大元素构成的集合, 同时A != min(V), V中最小元素构成的集合

拆分V为 A和>=A的集合 V1, A和<=A的集合V2

显然V1,V2的元素个数都比V小

A依然是V1,V2 的最大反链集合, 因为首先不可能超过A, 否则同样的方案可以用在V上, 因此A是一个可达的上界

那么有V1,V2 都是最小d个链覆盖, 且每个A中的被一条链覆盖, 这样靠着把V1,V2的链通过A中的点一一对应拼接上, 则依然是d条链覆盖, 所以是存在=d的方案

---

如果 A == max(V), 如果A中存在一个独立的不能和其它点比较的点u, 则V\u的最大反链 = A\u, 归纳得证

否则A中 每个点都存在更小的点和它能比较的点

如果V\u 的最大反链集合的A0元素个数依然是d, 则这个方案 也可以用在V中, 满足A0 != max(V);

如果A0 != min(V), 则满足第一种情况可证

如果A0 == min(V), 则考虑A0中取一个能和u比较的点v, (V\u)\v , 如果这个最大反链集合A1 如果|A1|=d, 则A1 != max(V), A1 != min(V), 满足第一种情况,可证, 否则|A1| = d-1

---

|A0| = d-1 时, A\u 是一个A0的方案, 说明d-1链能覆盖 V\u, 多加一个u 能覆盖V,得证

A0 = min(V), |A1| = d-1 时, 说明 A0\v 是 A1的一个方案, 说明 d-1链能覆盖 V\u\v, 增加链{u,v},就是d能覆盖V

证毕

综上,归纳法有 最大反链集合的个数 = 最小链覆盖条数

## 代码

https://atcoder.jp/contests/abc237/submissions/34871954

```cpp
#include <bits/stdc++.h>
using namespace std;
#define rep(i, a, n) for (int i = a; i < (int)n; i++)
int read(){int r;scanf("%d",&r);return r;} // read

int vis[210]; // vis[右侧点]
int from[210]; // from[右侧点] = 左侧点
vector<string> a;
vector<int> p2[210];
bool dfs(int u,int now){ // bool 返回 0/1
  for(auto v:p2[u]) if(vis[v]!=now){ // 左侧u -> 右侧v
    vis[v]=now;
    if(from[v]==0 || dfs(from[v],now)) return from[v]=u;
  }
  return 0;
}
char s[210];
int main(){
  scanf("%s",s);
  int n = strlen(s);
  rep(i,0,n){ // 暴力n^3
    string t;
    rep(j,i,n){
      string t_ = t+=s[j];
      reverse(t_.begin(),t_.end());
      if(t==t_) a.push_back(t);
    }
  }
  sort(a.begin(),a.end(),[](const string&x,const string&y){return x.size()==y.size()?x<y:x.size()>y.size();});
  a.resize(unique(a.begin(),a.end()) - a.begin()); // 排序去重, 长度从大到小
  rep(i,0,a.size()) rep(j,i+1,a.size()) if(a[i].find(a[j]) != string::npos) p2[i+1].push_back(j+1);// 暴力 n^3
  int ans = 0;
  rep(i,1,a.size()+1) ans+=dfs(i,i);
  printf("%d\n",(int)a.size()-ans);
  return 0;
}
```

# 总结

G

线段树数据结构,没啥难的

Ex

1. 字符串与其不同回文串的个数关系 <= |S|
2. 偏序图中选两两无无法比较的点的最大点集的Dilworth定理
3. 偏序图的最小链覆盖和二分图的关系

emmmmm 二分图可以只做一侧点的vis吗?

# 参考

[官方题解](https://atcoder.jp/contests/arc237/editorial)

repub.eur.nl/pub/23112/EI2011-13.pdf

https://www.sciencedirect.com/science/article/pii/0012365X79901572
