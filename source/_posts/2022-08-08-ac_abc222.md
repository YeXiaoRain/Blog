---
title: Atcoder abc222
date: 2022-08-08 04:25:14
tags: [数学, 欧拉定理,phi,miller-robin,pollard-rho]
category: [Atcoder]
mathjax: true
---

G(数学, 欧拉定理,phi,miller-robin,pollard-rho)H()

# G - 222

https://atcoder.jp/contests/abc222/tasks/abc222_g

在数列2,22,222,2222,22222,....中

N个X, 首个是 Xi的倍数的下标是?, 或者不存在

## 范围

N 200

Xi [1,1e8]

## 我的思路

一眼看上去很数学, 很像Project Euler的题

$2222222 = 2 \* 1111111 = 2 \* \frac{(10^7 - 1)}{9}$

其实就是问对于x

是否 2 * (10^7 - 1) = 9 k x

首先x的2的幂次为0/1

---

好像有点绕

$kx = 1111111 = 10^0+10^1+10^2+\cdots$

右边虽然项数为合数时可以拆分, 例如$6 = 3 * 2$,  $111111 = 111 \cdot 1001 = 11 \cdot 10101$

但不知道是否能拆出所有

---

另一个就是对于比较小的`11111`的部分,可以`pollard-rho`分解

---

考虑长除法?

每次 除法取mod 乘10 加1

但1e8 不知道效率怎么样

---

[PE 129][PE129] 做过类似的, 但是问题是首个 让是它倍数的最小$111\cdots 111$长度超过百万的是哪个因子

而有一些可用的结论

除了上面$2,5$因子外$kx = 111\cdots 111$始终有解, 且$111\cdots 111$ 的长度不超过$n$ (因为模数随着长度变化成环)

因此 如果暴力的话, 期望值是在 $O(NAi)$ 的

---

想了下打表 超过1e6的记录下来, 未超过的现场算, 但很多 超过1e6的

```cpp
int two(int v){
  int c = 0;
  ll m = 0;
  do{
    m*=10;
    m+=2;
    c++;
    m%=v;
  }while(m!=0);
  return c;
}

void calc(){
  rep(i,1000000, 100000000+1){
    if(i % 1000000 == 0) printf("progress %lld\n",i/1000000);
    if(i % 4 == 0 || i % 5 == 0)continue;
    int res = two(i);
    if(res > 1000000) printf("ans[%lld] = %d\n",i,res);
  }
}
```

---

另一个就是根据PE129的证明过程, 反正有$\phi(n)$ 或者$\phi(9n)$ 是一个解

那么可以找$\phi(n) , \phi(9n)$的因子尝试, 但这样是否能保证是最小的呢????? 根据倍数, 显然最小的是这个解的因子

$\phi(n) = n \cdot (1-1/p1) \cdot (1-1/p2) \cdots$

似乎可做?

## 题解

题解说不需要这么多, 就欧拉定理+暴力找phi就够了

看来我用高级算法乱搞了太多

## 代码

https://atcoder.jp/contests/abc222/submissions/33867609

16ms 还不是最快的, 有人10ms

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
typedef __int128 lll;
#define rep(i,a,n) for (ll i=a;i<(ll)n;i++)
#define per(i,a,n) for (ll i=n;i-->(ll)a;)
#define pb push_back

ll read(){ll r;scanf("%lld",&r);return r;} // read


ll quick_p(ll b, ll p,ll mod){
  ll r = 1;
  while(p){
    if(p%2)(r*=b)%=mod;
    (b*=b)%=mod;
    assert(r>0);
    assert(b>0);
    p/=2;
  }
  return r%mod;
}

bool is_prime_32(ll v){
  if(v == 2)return true;
  if(v < 2)return false;
  if(v%2 == 0)return false;
  ll test_g[] = {2, 325, 9375, 28178, 450775, 9780504, 1795265022};
  ll startp = v-1;
  while(startp%2 == 0)startp>>=1;
  rep(i,0,7){
    ll p = startp;
    ll base = test_g[i];
    // don't break may cause 4033 bug
    if(base % v == 0)continue;
    bool find = false;
    ll r = quick_p(base,p,v);
    while(p != v-1){
      if(r == v-1){
        find = true;
        break;
      }
      // -1 开始的序列, 或全1序列
      if(r == 1){
        if(p == startp){
          find = true;
          break;
        }
        return false;
      }
      p*=2;
      (r*=r)%=v;
    }
    if(!find){
      return false;
    }
  }
  return true;
}

ll my_sqrt(ll v){
  assert(v > 1);
  ll l = 1;
  ll r = v; // care overflow
  ll ret = 1;
  while(l < r){
    ll m = (l+r)/2;
    ll m2 = m*m;
    if(m2 == v) return m;
    if(m2 < v) {
      ret = m;
      l = m + 1;
    } else {
      r = m - 1;
    }
  }
  return ret;
}

ll randint(ll low,ll hi){
  return low + (rand() % static_cast<int>(hi - low + 1));
}

ll Pollard_Rho(ll N) { // 返回一个> 1的因数
  assert(N > 1);
  if (N == 4) return 2;
  ll ret = my_sqrt(N); // 质数平方 效率低 提前判断
  if(ret * ret == N) return ret;
  while(true) {
    ll c = randint(1, N - 1); // 生成随机的c
    auto f = [=](ll x) { return ((lll)x * x + c) % N; }; // ll 表示__int128，防溢出
    ll t = 0, r = 0; // 初始两个相同
    do{
      t = f(t); // 1倍速度
      r = f(f(r)); // 2倍速度
      ll d = gcd(abs(t - r), N);
      if (d > 1 && d < N) return d;
    }while (t != r);
  }
}

// 分解x为质因数, sorted, {prime,power}
vector<pair<ll,int> > fenjie(ll x) {
  vector<int> res = {};
  deque <ll> arr = {x};
  while(arr.size()){
    ll v = arr.front();
    arr.pop_front();
    if(v == 1) continue;
    if(is_prime_32(v)) {
      res.pb(v);
      continue;
    }
    ll divisor = Pollard_Rho(v);
    arr.push_back(divisor);
    arr.push_back(v/divisor);
  }
  sort(res.begin(),res.end());
  vector<pair<ll,int> > ret;
  rep(i,0,res.size()){
    if(i == 0|| res[i] != res[i-1]) ret.push_back({res[i], 1});
    else ret.back().second++;
  }
  return ret;
}

ll phi(ll n){
  auto primes = fenjie(n);
  // printf("%lld =",n);
  // for(auto [v,pwr]:primes) printf("[%lld %d]",v,pwr);
  // printf("\n");
  ll ret = n;
  for(auto [v,pwr]:primes) ret = (ret/v)*(v-1);
  return ret;
}

// -------------------------- lib -------------------------- 

int n ;

void dfs(int idx, vector<pair<ll,int>> primes, ll mul, ll & ans){
  if(idx == (int)primes.size()){
    // test pwr 10^p = k 9v + 1,  10^p % 9v == 1
    if(quick_p(10,mul,9*n) == 1) ans = min(ans,mul);
    return ;
  }
  rep(pwr,0,primes[idx].second+1){
    if(mul > ans) return;
    dfs(idx+1,primes,mul,ans);
    mul *= primes[idx].first;
  }
}

void w(){
  n = read();
  if(n % 4 == 0 || n % 5 == 0){
    printf("-1\n");
    return ;
  }
  if(n % 2 == 0) n /= 2;
  ll phin = n % 3 == 0 ? phi(9*n) : phi(n);
  if(phin == 1){
    printf("1\n");
    return ;
  }
  auto primes = fenjie(phin);
  ll ans = phin;
  dfs(0, primes, 1, ans);
  printf("%lld\n",ans);
}


int main(){
  int t = read();
  while(t--) w();
  return 0;
}
```

# H - Beautiful Binary Tree

https://atcoder.jp/contests/abc222/tasks/abc222_h

# 总结

G

欧拉公式, $gcd(a,n) = 1$时$a^{\phi(n)} \equiv 1 \pmod n$

后面乱搞也行, 枚举算$\phi$也行

H

# 参考

[官方题解](https://atcoder.jp/contests/abc222/editorial)

[wikipedia repunits](https://en.wikipedia.org/wiki/Repunit)

[Project Euler 129 repunits][PE129]

[Project Euler 216 miller robin 质数判别](http://yexiaorain.github.io/Blog/2021-06-12-project-euler216/)

[pollard-rho质数拆分](http://yexiaorain.github.io/Blog/2022-06-03-pollard-rho/)

[PE129]: http://yexiaorain.github.io/Blog/2020-12-03-pe129/
