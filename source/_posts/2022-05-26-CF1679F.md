---
title: Codeforces 1679F(dp,bitmask,特殊表示,动归状态设计)
date: 2022-05-26 22:24:00
tags: [DP,bitset]
category: [Codeforces]
mathjax: true
---

# 题目

https://codeforces.com/contest/1679/problem/F

$[0..10^n)$的所有n位整数,不足的补前导零

给m个 (ui,vi) 数对, (ui不等于vi)

x 表示成十进制的数字数组 [d1,d2,...,dn]

一次操作可以交换相邻的d, 但需要满足 这两个数的 (di,di+1)或(di+1,di) 出现在 (ui,vi)中

如果一个数x能够通过上述转换变成y,那么认为它们是相等的, x和x自身相等

问题$[0..10^n)$ 有多少个不同的数, 答案mod 998244353

## 范围

n 5e4

m 45

u,v [0,9]

3s

256MB

# 题解

## 我的思路

先提取一下有用没用的信息,首先m没啥用因为实际就是所有数对的上限

如果x 中有两个数字 c0,c1 但是这两个数字没有在d中出现过, 那么这两个数字的相对前后关系不会改变

换句话说,如果两个相等的 它们互相可以转化,那么它们一定属于某个集合,集合里两两可以转化, 而有限集合一定有最小的, 我们用每个集合中数值最小的来表示一整个集合

于是 这个最小值值可以表示成 `[单调递增] [单调递增] [单调递增]` , 每两个单调递增之间 的值是不在数对里的

所以如果我们可以得到`[起始,结束,长度]`的方案数就可以考虑转移方程了

`f[i][j][len1] = sum{ f[i][k][len0] * inc[ < k][j][len1-len0] } + inc[i][j][len]`

看似复杂度没法搞,而实际上连逻辑也不一定对 `201`, 它允许 (0,1),(2,1) 那么显然`120`和它相等且更小

## 题解

思路是类似的, 也是集合的代表元, 但是并不是靠单调递增划分

而是说`[序列长度l]` 在后面加上mask中的数,它不会被移动到前面

那么,d会移动到前面的条件就是,序列的尾部的一串数都大于`d`,且都可以和d交换

`[x,d1,d2,d3,...,ds,y]`

其中 x > y, 且 y 可以和`x,d1,...,ds`交换

`dp[suff][mask]` 表示, suff个digits, 且只有mask中的digit可以被移到最左

---

考虑长度为s 的一个具体的串 等价最小串 `X=[d0,d1,d2,.....,ds]`

它**最长**的前缀`[d0,d1,d2,....dt]` 包含的digits **两两可换**, 我们把这样的digits变成mask, X 可以表示成贡献到 `dp[s][mask]` 中

那么现在如果左边放一个d, 变成`X1 = [d,d0,d1,d2,...,ds]`

一旦d和 mask 中某个值可换, 记为e, 且`d > e`

显然,因为mask中两两可换,所以`X1` 可以变成 `[d,e,d0,d1,d2,...,ds]`, 然后交换e,d 得到 `[e,d,d0,d1,d2,...,ds]`

因为`e < d` ,所以 这个值比`X1` 小

即是`X`前面不能插入`d`, 如果 mask 中存在比d小,且和d相连的任何一个e

这样可选的`d`的范围就出来了, 这部分可以预处理

> 从X而非mask的角度来看,就是说插入了d以后,得到的值依然是 集合表示的最小值(代表元)

---

mask的变化

如果d可以放,那么`X1 = [d,d0,d1,d2,...,ds]`, 显然,它的 最长两两可换前缀中有`d`, 且剩余的部分从`mask` 中取, 因为mask本身就是两两可换,所以只用考虑和d是否有边

所以新mask = d | mask 中和d有边的点

---

注意到mask 的意义是 mask 中的值两两可换, 又是X的最大前缀

所以这里其实会计算不少`无效的mask`, 但因为算次数,这些次数一定是0, 不影响答案

## 代码

https://codeforces.com/contest/1679/submission/158638333

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
#define MOD 998244353
#define rep(i,a,n) for (ll i=a;i<(ll)n;i++)
#define per(i,a,n) for (ll i=n;i-->(ll)a;)
#define pb push_back

namespace X{
  ll r(){ll r;scanf("%lld",&r);return r;} // read
  void add(ll &v0,ll &v1){(v0+=v1%MOD)%=MOD;} // add with MOD
};
using namespace X;

const int S = 10;

// mask 意义, mask中两两可换, 是X的最大前缀
// camp[mask0] = mask1, mask1任意一个bit 和 mask0 中的比它小的bit都没有链接
// 在 mask1中的digit 才能加入到 mask0
vector<int> camp(1<<S,(1<<S)-1);
bool conn[S][S]; // 连接状态
ll dp[2][1 << S];
int trans[1 << S][S]; // [mask][digit] = newmask,

int main() {
  int n = r();
  int m = r();
  rep(i,0,m) {
    int u = r();
    int v = r();
    conn[u][v] = conn[v][u] = 1;
  }
  // 计算 camp
  // O(S^2 * 2^S)
  rep(mask,0,1 << S){
    rep(c,0,S){ // c 在 mask 中
      if (!(mask & (1 << c))) continue;
      rep(j,c+1,S){ // j > c
        if (conn[c][j]) {
          camp[mask] &= ~(1 << j);
        }
      }
    }
  }
  // 计算trans
  // O(S^2 * 2^S)
  rep(mask,0,1 << S) {
    rep(c,0,S){
      trans[mask][c] = 1 << c;
      rep(j,0,S){
        // j 出现在mask 中, (c,j) 可以交换
        if ((mask & (1 << j)) && conn[c][j]) {// 和 mask 中存在相连
          trans[mask][c] |= 1 << j;
        }
      }
    }
  }
  // 滚动数组
  int cur = 0;
  dp[0][0] = 1;
  // O(n * S * 2^S)
  rep(i,0,n){
    // clear
    fill(dp[cur^1],dp[cur^1] + (1<<S),0);
    rep(mask,0,1<<S){
      if (dp[cur][mask] == 0) continue;
      rep(c,0,S){
        // 在camp[mask] 中的才能加
        if (!(camp[mask] & (1 << c))) continue;
        add(dp[cur ^ 1][trans[mask][c]] , dp[cur][mask]);
      }
    }
    cur ^= 1;
  }

  ll ans = 0;
  rep(mask,1,1<<S) add(ans,dp[cur][mask]);
  printf("%lld\n", ans);
}
```

# 总结

我的思路里关于 排序,代表元都有了, 这是好事,但是

其实这里一个核心 在于怎么把 最小值元素X,抽象的表示到一个dp的state中

这里给出的state的设计方案是最长两两可换的前缀的bitmask, 和长度来表示

换句话说如果有人告诉我怎么设计state,那么转移方程还是随便写的

# 参考

[官方](https://codeforces.com/blog/entry/102859)
