---
title: Atcoder abc280
date: 2022-12-03
tags: [切比雪夫距离,曼哈顿距离,TODO]
category: [Atcoder,ABC]
description: D(切比雪夫距离,曼哈顿距离)Ex(TODO)
---

https://atcoder.jp/contests/abc280/tasks

# G - Do Use Hexagon Grid 2

六边形地图

(i,j) 和 (i+-1,j), (i,j+-1), (i+1,j+1) ,(i-1,j-1) 相邻

给你n个点

问有多少种方案能选一个非空点集, 使点集中两两距离不大于D

## 范围

n 300

xi,yi, [-1e9,1e9]

d [1,1e10]

3s

1024mb

## 我的思路

先想 1维, 就是sort, 然后定必定要选的点从左到右, 找区间长d中的点个数的2的幂次 

然后不是六边形的 2维, 类似的定(左,下)角的点, 但问题是 其它点个数不能再2的幂次了

总觉得做过, 但是又完全不会

n=300 就可能 3次方的做法

## 题解

一样也是先考虑变形, dis(x=x0-x1,y=y0-y1) = max(|x|,|y|,|x-y|)

那么每个点也这样变形 (x,y,x-y), 问题变成点集 在一个 正方体 DxDxD中

---

然后怎么统计呢, 其实和一维一样的, 不过枚举的最小值,变成3个维度的最小(必选)

那么 所在的正方形就是 (x0..x0+D,y1..y1+D,z2...z2+D)

直接搞是O(n^4)

考虑 最后一个维度 滑窗 一下 就是O(n^3)

---

官方代码还搞了个cnt[8],花里胡哨的,感觉好复杂(如果真这样,就算我会写赛内也难调出), 通过指定点 而不是指定值 感觉会简单不少, 当两个点有坐标y相同时, 考虑用index更小的作为标识

## 代码

https://atcoder.jp/contests/abc280/submissions/37080844

```cpp
#include <bits/stdc++.h>
#include <atcoder/modint>
const int MOD=998244353;
using mint = atcoder::static_modint<MOD>;
using namespace std;
using ll=long long;
#define rep(i,a,n) for (ll i=a;i<(ll)n;i++)
ll read(){ll r;scanf("%lld",&r);return r;}
mint p2[310]={1}; // power 2
int main(){
  int n=read();
  ll d=read();
  rep(i,0,n) p2[i+1]=p2[i]*2;
  vector<array<ll,3> >a;
  rep(i,0,n){
    int x=read();
    int y=read();
    a.push_back({x,y,x-y});
  }
  sort(begin(a),end(a)); // 按照x排序

  mint ans=0;
  rep(iy,0,n) rep(iz,0,n) {// 最小y取i, 最小z取j 指定最小 y,z, 滑窗x, [y..y+d,z..z+d]
    auto ok=[&](int i,int j,int k)->bool{ // a[j][k] <= a[i][k] <= a[j][k]+d ?
      return (i>=j) ?
        (a[j][k]<=a[i][k] and a[i][k]<=a[j][k]+d):
        (a[j][k]< a[i][k] and a[i][k]<=a[j][k]+d); // 下标小于不能取等
    };
    auto oky=[&](int i){return ok(i,iy,1);};
    auto okz=[&](int i){return ok(i,iz,2);};
    if(!oky(iz) || !okz(iy)) continue;
    int cnt=0;
    int pos=0; // 双指针 后面的index
    rep(ix,0,n){ // 第i作为x最小
      auto okx=[&](int i){ return ok(i,ix,0); };
      while(pos<n&&a[pos][0]<=a[ix][0]+d){ // 双指针滑窗
        if(oky(pos)and okz(pos)) cnt++;
        pos++;
      }
      if(oky(ix) and okz(ix) and okx(iy) and okx(iz)) {
        int distinct=3-(int(ix==iy)+int(iy==iz)+int(iz==ix));
        if(distinct==0) distinct=1;
        ans+=p2[cnt-distinct];
      }
      if(oky(ix) and okz(ix))cnt--;
    }
  }
  printf("%d\n",ans.val());
  return 0;
}
```

# Ex - Substring Sort

TODO

# 总结

G

平面距离还是不熟,  正常的(x,y) 距离就是变成 max(|x+y|,|x-y|) 去算的, 这里应该要能想到, 一旦有了这个,那么 上面的变化也就显然了

然后这个枚举最小值的1维的思路其实也很好, 看到这里n这么小, 应该也要想到 枚举一个对小值点, 变成枚举3个维度的最小值点啊

Ex

TODO


# 参考

[官方题解](https://atcoder.jp/contests/abc280/editorial)
