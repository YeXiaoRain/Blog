---
title: Atcoder abc230
date: 2022-09-01
tags: [Möbius函数,Möbius function]
category: [Atcoder,ABC]
mathjax: true
---

G(Möbius函数)H()

https://atcoder.jp/contests/abc230/tasks

# G - GCD Permutation

给一个1~N的排列p

问有多少个有序对 (i,j), (i<=j), 满足 gcd(i,j) != 1, gcd(p[i],p[j]) != 1

## 范围

n 2e5

5s

1024mb

## 我的思路

有点想暴力 然后证明复杂度?

对于 (i,Pi), 取两个中较小的一个, 找所有包含它下标的, 用较大的去验证gcd

最多有6个不同质数因子, 最坏情况 1/2+1/3+1/5+1/7+1/11+1/13 = 1.3左右

所以最坏情况是 找n个坐标

先写个代码再说

https://atcoder.jp/contests/abc230/submissions/34500571

---

显然 有很多是2 的倍数的,它们如果每个都会去访问n/2, 那么已经就是n^2了, 肯定会超时

---

想法就是 如果 (2的倍数,3的倍数) 之类做容斥? 但是我容斥完全不会

## 题解

$\tilde{\mu}(n)= 1,-1,0$

1: 当n为奇数个不同的质数乘积

-1: 当n为偶数个不同的质数乘积

0: 其它

相当于 Möbius函数 取相反数,且 $\mu(1) = 0$

那么满足 $\sum_{d|n} \tilde{\mu}(d)=
\begin{cases}
0 & (\text{if }n=1)  \\\\
1 & (\text{if }n\geq 2)
\end{cases}$

这和Möbius函数 很像, `和= 1-Möbius的和`

---

定义函数

$f(a,b;i,j) = 1/0$, 表示 i,j是a的倍数且 pi,pj 是b的倍数

对于和$S=\sum_{1\leq i\leq j\leq N} \sum_{a=1}^N \sum_{b=1}^N  \tilde{\mu}(a) \tilde{\mu}(b)f(a,b;i,j).$

对于给定的$(i,j)$ 令$g=GCD(i,j),g'=GCD(p_i,p_j)$

考虑右侧f要为1, 那么需要同时a是g的约数,b是g'的约数

$\sum_{1\leq i\leq j\leq N} \sum_{a=1}^N \sum_{b=1}^N  \tilde{\mu}(a) \tilde{\mu}(b)f(a,b;i,j) = \sum_{1\leq i\leq j\leq N} \sum_{a|g} \sum_{b|g'}  \tilde{\mu}(a) \tilde{\mu}(b)$

$= \sum_{1\leq i\leq j\leq N} \sum_{a|g} \tilde{\mu}(a) \sum_{b|g'}  \tilde{\mu}(b)$

所以考虑右侧, 只要g,g' 同时大于等于2,则为1, 否则为0

$= \sum_{1\leq i\leq j\leq N} (g \ge 2 , g' \ge 2)$, 这里证明了和原题意等价, 因此S就是要求的答案

---

令$num(a,b) = (a|i,b|p_i)$ 的个数

对于给定$(a,b)$ 有 $\sum_{1\le i\le j\le N}f(a,b;i,j)=\frac{num(a,b)(num(a,b)+1)}{2}$, 相当于找出所有满足$(a|i,b|p_i)$ 的然后组成顺序对

因此又有$S=\sum_{a=1}^N \sum_{b=1}^N  \tilde{\mu}(a) \tilde{\mu}(b)
\frac{num(a,b)(num(a,b)+1)}{2}.$

这样你可以计算S了, 虽然是N^2
但是实际上, 对于a, 因为有$(a|i,b|p_i)$, 所以 b 的可选值很小

### 附加

讲了一下Möbius function 函数的定义,和约数和的结果, 提到了$\displaystyle\sum_{d|n} \tilde{\mu}(d)=1-\sum_{d|n}\mu(d)$

因此每个都可以被快速计算

## 正向思路?

其实从上面过程中还是能看见一点

本身是要求 $= \sum_{1\leq i\leq j\leq N} (GCD(i,j) \ge 2 , GCD(p_i,p_j) \ge 2)$

有莫比乌斯函数知识有 $[x = 1] = \sum_{i|x} \mu(i)$, 这里$\mu$是莫比乌斯函数

因此可以变形为

$= \sum_{1\leq i\leq j\leq N} (1-\sum_{t_0|GCD(i,j)} \mu(t_0))\cdot (1-\sum_{t_1|GCD(p_i,p_j)} \mu(t_1))$

$= \sum_{1\leq i\leq j\leq N} 1-(\sum_{1\leq i\leq j\leq N}\sum_{t_0|GCD(i,j)} \mu(t_0) + \sum_{1\leq i\leq j\leq N}\sum_{t_1|GCD(p_i,p_j)} \mu(t_1)) + \sum_{1\leq i\leq j\leq N}\sum_{t_0|GCD(i,j)} \mu(t_0) \sum_{t_1|GCD(p_i,p_j)} \mu(t_1)$

3部分

第一部分就是$i\le j$的个数

第二部分,对于$t_0,t_1$ 分别考虑,都是类似的,找都是$t_0 / t_1$的倍数

第三部分,从$t_0,t_1$ 的角度看, 就是上面所谓的num(a,b) 一样的想法

## 代码

map 850ms https://atcoder.jp/contests/abc230/submissions/34500944

vector+vis 270ms https://atcoder.jp/contests/abc230/submissions/34500900

```cpp
#include <bits/stdc++.h>
typedef long long ll;
#define rep(i,a,n) for (int i=a;i<(int)n;i++)
int read(){int r;scanf("%d",&r);return r;} // read

#define N 200000
int p[N+10]; // 读入,排列
bool pr[N+10]; // prime[i] = true/false
int mu[N+10]; // mu, 新定义的mu, mu(1) = 0, mu(i) = -莫比乌斯函数(i), i> 1
std::vector<int>d[N+10]; // d[v] = `v的mu不为0的因子`

int main() {
  int n = read();;
  ll ans = 0;
  rep(i,1,n+1) p[i] = read();
  std::fill(pr+2,pr+n+1,true);
  std::fill(mu+2,mu+n+1,-1);
  rep(i,2,n+1){
    if (pr[i]) {
      mu[i] *= -1;
      for (int j = 2*i; j <= n; j+=i) {
        pr[j] = false;
        mu[j] *= ((j/i)%i) ? -1 :0;
      }
    }
    if (mu[i] != 0) for (int j = i; j <= n; j += i) d[j].push_back(i);
  }
  rep(a,2,n+1) if(mu[a] != 0) { // mu(a) * mu(b) * (num(a,b)(num(a,b)+1))/2
    std::unordered_map<int, ll> b2c; // 对于给定a, 的b2c[b] = num(a,b)
    for (int i = a; i <= n; i += a) for (int b : d[p[i]]) b2c[b]++;// a|i, b|p[i]
    for (auto [b,c]: b2c) ans += mu[a] * mu[b] * (c * (c + 1)) / 2;
  }
  printf("%lld\n",ans);
  return 0;
}
```

# H - Bullion

无限数量的块分别重w1,w2,...,wk, 每个两两不同

无限数量包,重量1

包可以容纳 任意个非空包 和 任意个块

安排一辆卡车, 运载力W,

考虑 w=2..W 的每个情况

你需要 让最终外层包重量为w的打包方案数, 包可以嵌套,不能有空包

物品重量相同视为相同, 包内没有顺序,看成可重集合

输出对于每个w的方案数 mod 998244353

## 限制

w 2.5e5

8s

1024mb

## 我的思路

先考虑给定w

那么它的内容重量和=w-1

假设包的部分是重k, 那么剩余直接的块重量和为w-k-1

所以f(w) = sum g(k) h(w-k-1)

g(x) = 多个包裹总重量为x的方案数

h(x) = 多个块总重量为x的方案数

像生成函数, 但不会了

## 题解

这里也提到了上次的222H







# 总结

G

感觉还是莫比乌斯反演相关的知识点

这个S的定义 感觉凭空出现啊, 这题解有一点搞

但如果不知道这种定义, 还是可以从莫比乌斯函数推导出的

H


# 参考

[官方题解](https://atcoder.jp/contests/arc230/editorial)

[之前写的莫反笔记](https://yexiaorain.github.io/Blog/2019-01-06-MobiusInversionFormula/)

[莫反 CF 548 Div2 D](https://yexiaorain.github.io/Blog/2019-03-23-cfP1139D/)

[莫反NowCoder 8282 D](https://yexiaorain.github.io/Blog/2020-11-07-nowcoder8282D/)

[222H](http://localhost:4000/Blog/2022-08-08-ac_abc222/)
