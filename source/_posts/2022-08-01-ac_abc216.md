---
title: Atcoder abc216
date: 2022-08-01 04:25:14
tags: []
category: [Atcoder]
mathjax: true
---

G(贪心)H()

# G - 01Sequence

https://atcoder.jp/contests/abc216/tasks/abc216_g

## 代码

https://atcoder.jp/contests/abc216/submissions/33727628

```cpp
#include <bits/stdc++.h>
using namespace std;
 
#define rep(i,a,n) for (int i=a;i<(int)n;i++)
 
int read(){int r;scanf("%d",&r);return r;} // read
 
const int N=200000;
int a[N+10]; // a[空白个数] = 到右侧点, 之间全是1
int r[N+10]; // 读入
int y[N+10]; // 左侧0个数
vector<int> l2i[N+10]; // 左端点到第i个区间
 
int main() {
  int n = read();
  int m = read();
  rep(i,1,m+1){
    int l = read();
    r[i] = read();
    y[i] = (r[i]-l+1) - read(); // 左侧0个数 [[....yi],1,1,1,1,1,1]
    l2i[l].push_back(i);
  }
  int cnt = 0; // 遍历过程中 (<l) 0 的个数
  rep(pos,1,n+1){ // 下标
    for(auto i:l2i[pos]) a[y[i]+cnt] = max(a[y[i]+cnt],r[i]);// [pos.....r[i]]
    printf("%d ", a[cnt] >= pos); // 这一段全是1, 1尽量向右,贪心塞0
    cnt += (a[cnt] < pos); // 计数+1
  }
  return 0;
}
```

# H - Random Robots

数轴上k个机器人, 初始位置分别在xi

每次 每个机器人独立选择 移动(正向+1)或不动 1/2 概率

问经过N次,过程中没有任何两个robot 同时在同位置的概率

mod 998244353

## 限制

k [2,10]

n 1000

xi [0,1000], 严格单增提供

2s

1024mb

## 我的思路

一般来说 概率 = 次/总次数 可以互相转化

不相遇 可以 和相遇的容斥互相转化

k 10 的话可能和k的bitmask有关系

如果进行一次

而碰撞比不碰撞似乎好算一些

而且一般是相邻碰撞

pi 和pi+1 在t次时刻碰撞

意味着 t-1 次时距离1, t时 1/4 概率

0~t-1 时刻每次 1/4 +1, 1/4 -1, 1/2 不变

设原来距离 为d

那么 -1 次数 减去 +1 次数 = d-1, 且中间不能有负数情况

变成后缀个数统计问题

似乎可以强行算出t时刻 的概率, 实在组合排列不行, `dp[时刻1000][距离2000]` 来算也可以

---

那么无碰撞 = 所有 - 碰撞

所以想办法容斥掉碰撞



# 总结

G

贪心完全不会

题解说有个cow game

有一些 dj-di <= wij 的限制

寻找最大的 dT-dS, 可以变成最短路问题

http://poj.org/problem?id=3169

H

# 参考

[官方题解](https://atcoder.jp/contests/abc216/editorial)

