---
title: Atcoder abc224
date: 2022-08-10 04:25:14
tags: [概率论,二分]
category: [Atcoder]
mathjax: true
---

G(概率论,二分)H()

# G - Roll or Increment

https://atcoder.jp/contests/abc224/tasks/abc224_g

1~N 骰子

初始S, 得分f(X) = X

A元, 让得分+1

B元, 重新转

求最小期望代价, 让得分为T

## 范围

N 1e9

A,B [1,1e9]

2s

1024 mb

## 我的思路

日常不会概率论

猜一个

S < T

直接通过A, (T-S)A

转一次的期望 E

(N-T)/N * (B+E), 大于T 部分的贡献

1/N ( min(0,B+E) + min(A,B+E) + min(2A,B+E) + ... + min((T-1)A,B+E)),  $\le T$ 部分的贡献

$E = \frac{N-T}{N} \cdot (B+E) + \frac{1}{N} ( min(0,B+E) + min(A,B+E) + min(2A,B+E) + \cdots + min((T-1)A,B+E))$

若能求出E, 就做出来了

转化一下

$NB + \sum_{i=0}^{T-1} \text{min}(iA-(B+E),0) = 0$

只有E是变化的, 随着E 增大, 表示式变小, 单调, 可二分

---

好像还真就过了

## 代码

https://atcoder.jp/contests/abc224/submissions/33889681

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
typedef long double LD;
#define rep(i,a,n) for (ll i=a;i<(ll)n;i++)

ll read(){ll r;scanf("%lld",&r);return r;} // read


int main(){
  ll N = read();
  ll S = read();
  ll T = read();
  ll A = read();
  ll B = read();
  auto calc = [=](LD E){
    ll l = 0;
    ll r = T-1;
    if(r*A-B-E<=0){
      l = r;
    }else{
      while(l+1<r){
        ll m = (l+r)/2;
        if(m*A-B-E<=0) l = m;
        else r = m;
      }
    }
    // nb + sum min(iA-B - E,0), i = 0~T-1;
    return N * B+ A * l * (l+1) / 2 - (B+E) * (l+1) ;
  };
  LD LE = 0;
  LD RE = A * T;
  while(calc(RE) > 0) RE *= 2;
  rep(t,0,10000){ // E增, 和减
    LD E = (LE+RE)/2;
    (calc(E) > 0 ? LE : RE) = E;
  }
  LD ans = B + LE;
  if(S <= T) ans = min(ans,(LD)((T-S) * A));
  printf("%.15Lf",ans);
  return 0;
}
```

# H - Security Camera 2

https://atcoder.jp/contests/abc224/tasks/abc224_h

二分图, 左侧L个点,右侧R个点

在点i上每次安装摄像头, 有 Ai(左侧),Bj(右侧) 的代价, 一个点可安多次

目标 让 i上安装的个数 + j上安装的个数 >= Cij

一左一右侧

问最小安装代价

## 范围

L,R 100

Ai,Bi [1,10]

Cij, [0,100]

2s

1024mb

## 我的思路

这个数还不少, 而代价的范围还挺小的?

然后有点费用流又有点2sat的感觉

emmmm

---

TODO



# 总结

G

概率论, 竟然对了

H


# 参考

[官方题解](https://atcoder.jp/contests/abc224/editorial)

