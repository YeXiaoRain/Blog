---
title: Atcoder abc265
date: 2022-10-12
tags: [线段树]
category: [Atcoder,ABC]
description: G(线段树),Ex()
---

https://atcoder.jp/contests/abc265/tasks

# G - 012 Inversion

长n序列A, 元素只有0,1,2

q个询问

类型1, 输出A[l..r] 中逆序对个数

类型2, 同时 让A[l..r] 中 0->S,1->T,U->2

## 范围

n 1e5

q 1e5

5s

1024mb

## 我的思路

看起来, 就是 线段树 + 记录0,1,2个数 和逆需对个数

但是问题是, 虽然很容易计算 左侧选点 与右侧选点构成的逆需对个数

所以跨区间的容易计算

但是内部的 0,1,2 翻转 并不能只靠0,1,2个数就能得到

---

但如果记录 (0,1) (1,0) (0,2) (2,0) (1,2) (2,1) 个数

那么翻转就好计算了

甚至不需要记录逆对个数了, 直接统计(1,0) (2,0) (2,1) 个数即可

就过了..

<!--more-->

## 代码

https://atcoder.jp/contests/abc265/submissions/35597377

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define rep(i,a,n) for (ll i=a;i<(ll)n;i++)

#define SEG_ROOT 1,0,n-1
#define SEG_L (o<<1)
#define SEG_R (o<<1|1)
#define mid (l+r)/2
#define SEG_L_CHILD SEG_L,l,mid
#define SEG_R_CHILD SEG_R,mid+1,r

ll read(){ll r;scanf("%lld",&r);return r;}
using A3=array<ll,3>;
using A33=array<A3,3>;

struct Node{
  A3 a={0,0,0};
  A3 lazy={0,1,2}; // 未向下传递的(本层已经作用
  A33 c={{{{0,0,0}},{{0,0,0}},{{0,0,0}}}};
}seg[400010]; // seg[0] empty node
int a[100010];

template<class T>
T merge(const T&v0,const T&v1){
  T v;
  rep(i,0,3)v.a[i]=v0.a[i]+v1.a[i];
  rep(i,0,3)rep(j,0,3)v.c[i][j]=v0.c[i][j]+v1.c[i][j];
  rep(i,0,3)rep(j,0,3)if(i!=j) v.c[i][j] += v0.a[i]*v1.a[j];
  return v;
}

Node build(int o,int l,int r){
  if(l==r){
    seg[o].a[a[l]]=1;
    return seg[o];
  }
  return seg[o]=merge(build(SEG_L_CHILD),build(SEG_R_CHILD));
}

Node zotfn(int o,const A3&zot){ // zero one two
  Node newo=seg[0];
  rep(i,0,3)newo.a[zot[i]]+=seg[o].a[i];
  rep(i,0,3)newo.lazy[i] = zot[seg[o].lazy[i]];
  rep(i,0,3)rep(j,0,3)newo.c[zot[i]][zot[j]]+=seg[o].c[i][j];
  return seg[o]=newo;
}

void down(int o){
  zotfn(SEG_L,seg[o].lazy);
  zotfn(SEG_R,seg[o].lazy);
  seg[o].lazy={0,1,2};
}

Node query(int o,int l,int r,int ql,int qr){
  if(ql<=l&&r<=qr)return seg[o];
  down(o);
  return merge(
      ql<=mid?query(SEG_L_CHILD,ql,qr):seg[0],
      qr> mid?query(SEG_R_CHILD,ql,qr):seg[0]
  );
}

Node update(int o,int l,int r,int ql,int qr,const A3& zot){
  if(ql<=l&&r<=qr) return zotfn(o,zot);
  down(o);
  return seg[o]=merge(
    (ql<=mid?update(SEG_L_CHILD,ql,qr,zot):seg[SEG_L]),
    (qr> mid?update(SEG_R_CHILD,ql,qr,zot):seg[SEG_R])
  );
}

int main(){
  int n=read();
  int q=read();
  rep(i,0,n)a[i]=read();
  build(SEG_ROOT);
  while(q--){
    int op=read();
    int l=read()-1;
    int r=read()-1;
    if(op==1){
      auto x=query(SEG_ROOT,l,r).c;
      printf("%lld\n",x[1][0]+x[2][0]+x[2][1]);
    }else{
      A3 zot;
      rep(i,0,3)zot[i]=read();
      update(SEG_ROOT,l,r,zot);
    }
  }
  return 0;
}
```

# Ex - No-capture Lance Game

h行w列

初始 每行一个向右指着的属于先手玩家, 每行一个向左指着属于后手玩家,(两个棋子不能在同一个位置,但是两个的左右关系没有限制)

交替移动一次棋子,每次 不能跨越其它棋子,至少一步,不能超过棋盘

不能移动的人输掉

---

现在没有棋子, 有 (W(W-1))^H 种方式放

问先手赢的局面 有多少 mod 998244353

## 范围

h 8000

w 30

10s

1024mb

## 我的思路

很像nim的游戏, 但是 前提是 向右...向左, 这样摆放, 因为这样 两个人的移动操作就是让间距减少, 两个人是"公平的"

否则的话, 两个人独立的移动步数, 且尽量希望别人无法移动, 所以贪心, 盈余步数=多的减去少的

所以问题是, 有多少个是相对运动的, 盈余是多少

显然盈余>=1的话, 那么先手必胜

盈余<=-1的话后手必胜

盈余==0 的话, 才看相对运动的

而相对运动就是nim的的游戏+sg函数

---





# 总结

这场现场做了, 前面做得慢,没看G和Ex

G

有时间还是随便做的, 区间操作 太明显了

Ex


# 参考

[官方题解](https://atcoder.jp/contests/arc265/editorial)
