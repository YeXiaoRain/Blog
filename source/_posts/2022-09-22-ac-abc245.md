---
title: Atcoder abc245
date: 2022-09-22
tags: [dijkstra]
category: [Atcoder,ABC]
description: G(dijkstra)Ex()
---

https://atcoder.jp/contests/abc245/tasks

# G - Foreign Friends

N个点, 第i个人颜色是Ki

其中一些点是好的点

初始没有边

有m个可选边, 第i个可以花费 Ci 让ui和vi连一条边(无重边自环)

对于每个点, 独立的求最小代价 让它和一个异色好点连通, 或报告不可能

## 范围

N 1e5

M 1e5

## 我的思路

既然是每个到异色好点最短距离, 那么路径上一定都是同色或非好点

目前思路是 按一个颜色的个数能不能根号分治

另一个是记录到每个点最小代价不同色的两个最近点

考虑用Floyd+提前退出? 问题是 时间复杂度怎么估计和保证

## 题解

如果 忽略颜色

多源的好点做dij, 然后 每个点取最小, 然而这个肯定TLE

但如果增加一个点S, 然后它到所有好点距离都是0(单向边!), 那么就可以单源最短路在范围内了

---

再考虑颜色不同的限制

如果暴力,就是把上面的最短距离多一个维度 [首个好点的颜色], 然而这样也是复杂度超了

注意到, 第三小的颜色的距离永远不对答案有贡献, 所以只用记录最小的两个不同, (这个我倒是想到了)

## 代码

https://atcoder.jp/contests/abc245/submissions/35054327

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define rep(i,a,n) for (ll i=a;i<(ll)n;i++)
const ll INF = 0x3f3f3f3f3f3f3f3f;
template <typename T> using minPQ = priority_queue<T,vector<T>, greater<T>>; // 小根堆
ll read(){ll r;scanf("%lld",&r);return r;}

int main() {
  int n = read(); // 1e5, 0-index
  int m = read();
  int k = read(); // 颜色
  int l = read(); // 好点
  vector<int>a(n); // 颜色
  vector<vector<pair<int, ll> > >e(n); // e[u] = {v, cost}
  vector<int>used(n, 0); // 0 未访问, > 0 上一个访问的颜色, =-1 已经两个颜色访问了
  auto d2 = vector(n,map<int,ll>()); // [u][color] = dis;
  minPQ<tuple<ll, int, int> >pq; // 小根堆 { 距离, 点, 起始好点的颜色 }

  rep(i,0,n) a[i] = read(); // 颜色
  rep(i,0,l) { // 好点
    int u = read() - 1;
    pq.push({0,u,a[u]});
  }
  rep(i,0,m) {
    int u = read()-1;
    int v = read()-1;
    int c = read(); // 颜色1-index, 0 表示未确定
    e[u].push_back({v,c});
    e[v].push_back({u,c});
  }
  while (!pq.empty()) {
    auto [dis,u,c] = pq.top();
    pq.pop();
    if(d2[u].count(c) || d2[u].size() == 2)continue; // 没有更新
    d2[u][c] = dis;
    for(auto [v,len]:e[u]) pq.push({dis+len, v, c});
  }
  rep(u,0,n) {
    ll dis = INF;
    for(auto [c,d]:d2[u]) if(c != a[u]) dis=min(dis,d);
    printf("%lld%c",dis == INF?-1:dis," \n"[u==n-1]);
  }
  return 0;
}
```

# Ex - Product Modulo 2

长k的序列, 求满足要求的序列的个数mod 998244353





# 总结

G

第二次遇到 dij 中使用长0的边!!!, 第三大的颜色不会贡献 倒是我自己能想到

Ex


# 参考

[官方题解](https://atcoder.jp/contests/arc245/editorial)
