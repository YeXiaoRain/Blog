---
title: USACO 4.4.1最大流 最小割(最小数量下字典序最小割)
date: 2018-12-05 15:39:06
tags: [最大流 最小割]
category: [USACO]
mathjax: true
---

# [USACO4.4.1](http://train.usaco.org/usacoprob2?a=1dvqL35PdJZ&S=milk6)

> 输入

给你`n`(`2<=n<=32`)个点,`m`(`0<=m<=1'000`)条边,可包含重边,每条边权重`c`(`0<=c<=2'000'000`)

> 求/输出

最大流

让最小割被割的边数量最小,求该最小值

求在该最小值下,求字典序最小的最小割

> 解法

忽略0边[如果不忽略,可能在后面的问产生问题]

第一问最大流:最大流就增广路径

第二问:因为要求,让最小割的被割边的数量也最小,在进行最大流后,对所有满载且原始边不为0的边容量改为1,残余改为inf,再进行一次求最大流

第三问:在第二问基础上枚举删边,检查可能性,标记边.在原图上采取枚举删边,

# 关于此题

有看到[这样](https://github.com/perfect28/USACO/blob/a6d3ebbb0f9a31c58383bdb03bb62c436f3990c8/4.4/milk6/main.cpp)的解法来处理二三问,把所有边按容量降序排列依次删边尝试,据说能过USACO,然而有反例[USACO数据真弱2333]

```c++
3 5
1 2 1
1 2 1
1 2 4
2 3 3
2 3 3
```

很明显总流量是6,要让最小割的数量最小是点2到点3 的两条流量为3的边

---

[据说](http://train.usaco.org/usacoanal2?a=1dvqL35PdJZ&S=milk6),有人的方案是把边容量乘1001再加上边index来做为新容量,从而最小边取%1001,最大流取/1001

---

测试数据里似乎没有c=0的时候

---

第二问的操作inf,必要性,简单的反例解释

```
4 7
1 2 7
2 3 7
1 3 2
3 4 2
3 4 2
3 4 2
3 4 2
```

明显1到3的流量可以达到9,而3到4的流量只有8

所以最小割一定是3到4,但如果耗尽改为1的话,且1到2,2到3都被耗尽,则有1到2,2到3都改为流量1,进行做第二问

如果不把1到3的2 改为inf,则会 认为最少的割边数量为3,而不是4

---

同样第二问结果并不能直接用于第三问,进行尝试删边,样例

```
4 5
1 2 4
2 3 2
2 4 2
1 3 100
3 4 2
```

最小割应该为 2->4 和3->4,如果1->2耗尽,在第二问变更后的图做尝试删边操作,则会发现1->2会影响流量,认为1->2属于割边

# 代码

[code](https://github.com/CroMarmot/MyOICode/blob/master/USACO/Section4/4.4_Pollutant_Control.cpp)

