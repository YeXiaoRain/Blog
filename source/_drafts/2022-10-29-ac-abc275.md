---
title: Atcoder abc275
date: 2022-10-29
tags: [计算几何]
category: [Atcoder,ABC]
description: G(数学,计算几何)Ex()
---

https://atcoder.jp/contests/abc275/tasks

# G - Infinite Knapsack

n种物品, 每种无限多个

第i种, 重ai,体积bi,价值ci

f(X) = 总重量<=X,总体积<=X的最大价值

可证明 lim_{x->infty}f(X)/X 的极限存在, 求极限

## 范围

n 2e5

ai,bi,ci [1e8,1e9]

2s

1024mb

## 我的思路

感觉就一个很数学的题

考虑3元组, (a,b,c) 若 a >= b, 等价于a个(a/a,b/a,c/a)

若 a < b, 等价于a个(a/b,b/b,c/b)

于是分成两种

$(1,p\le1,c_0),p=b_0/a_0$

$(q\le1,1,c_1),q=a_0/b_0$

而实际上未来增长只会是 这两种按一个比例的和

$(t_0,pt_0,c_0t_0) + (qt_1,t_1,c_1t_1)$

$t_0 + qt_1 = pt_0+t_1 $

$t_0 = t_1 (1-q)/(1-p)$

$c_{0,1} = (c_0t_0 + c_1t_1)/(t_0 + qt_1)$

$= (c_0(1-q)/(1-p) + c_1)/((1-q)/(1-p)+ q)$

$= (c_0/(1-p)+c_1/(1-q))/(1/(1-p)+q/(1-q))$

$ans=\max(c_0,c_1,(c_0(1-q)+ (1-p)c_1)/((1-q)+ (1-p)q))$

问题是两两计算的话 为n^2

---

稍微改一下

$1,p < 1,c_0$

$1,q > 1,c_1$

$pt_0+qt_0=t_0+t_1$其中$t_0,t_1 > 0$ 即$t_0 = t_1 \frac{q-1}{1-p}$

$c_{0,1}=\frac{c_0t_0+c_1t_1}{t_0+t_1}$

$= \frac{c_0\frac{q-1}{1-p}+c_1}{\frac{q-1}{1-p}+1}$

$= \frac{\frac{c_0}{1-p}-\frac{c_1}{1-q}}{\frac{1}{1-p}-\frac{1}{1-q}}$

也就是 $(\frac{1}{1-\frac{b_i}{a_i}},\frac{\frac{c_i}{a_i}}{1-\frac{b_i}{a_i}})$ 这些点之间的最大斜率

---

n个点之间 找最大斜率

但注意到的是 是由第4向限和第1向限的点, 并不是两两之间, (因为两两之间的话 相当于$t <0)

直接考虑 分别两坨点的凸包

双指针???? 不会了

<!--more-->

## 题解

类似的, 变成达到价值为1, 需要的 max(weight,volume) 的最小值,每个可取非负实数个

所以考虑(A/C,B/C,C/C)

平面上画(A',B')

那么其实两点之间的线段 就是两点可以变成的点(加权平均数)

一个点对应的答案是max(x,y)

而一条线段MN 和 y=x 的交点O, 有性质MN上的点P, 在MO一侧和在NO一侧, 总有一个坐标大于$O_x,O_y$

所以就是求所有点与$x,y$的交

对所有点求凸包, 显然任意两点的线段在凸包中(凸包的性质)

因此求凸包上与y=x的交点,即可

## 代码

https://atcoder.jp/contests/abc275/submissions/36129413

```cpp
#include <bits/stdc++.h>
typedef long long ll;
#define rep(i,a,n) for (ll i=a;i<(ll)n;i++)
ll read(){ll r;scanf("%lld",&r);return r;}
template<class T>
using Point = std::pair<T, T>;

template<class T>
class ConvexHull{
public:
  std::vector<Point<T>> lower;
  std::vector<Point<T>> upper;
  Point<T> sub(const Point<T>&a,const Point<T>&b)const{ // return a-b
    return {a.first-b.first,a.second-b.second};
  }
  T cross(const Point<T>& a,const Point<T>& b,const Point<T>& c)const{ // (a-b) x (c-b)
    auto [x0,y0] = sub(a,b);
    auto [x1,y1] = sub(c,b);
    return x1*y0 -x0*y1;
  }
  ConvexHull(std::vector<Point<T>>&p) {
    sort(p.begin(),p.end());
    {
      std::vector<Point<T>> v=p; // 逆时针弧
      for(Point<T>p : v){
        while(lower.size() >= 2 && cross(lower.rbegin()[1], lower.back(), p) <= 0) lower.pop_back();
        lower.push_back(p);
      }
    }
    {
      std::vector<Point<T>> v=p; // 顺时针弧
      for(Point<T>p : v){
        while(upper.size() >= 2 && cross(upper.rbegin()[1], upper.back(), p) >= 0) upper.pop_back();
        upper.push_back(p);
      }
    }
  }
  T cxy(const std::vector<Point<T>>&v) const{
    T ret=20;
    rep(i,1,v.size()){
      auto [x0,y0]=v[i-1];
      auto [x1,y1]=v[i];
      auto dx=x1-x0;
      auto dy=y1-y0;
      if(std::abs(dx-dy)<0.001)continue; // 分母为0 平行y=x
      auto xy = (y0*dx-x0*dy)/(dx-dy);
      if((x0-xy)*(x1-xy) < 0) ret=std::min(ret,xy); // 在两点之间
    }
    return 1/ret;
  }
  T cut()const {
    return std::max(cxy(lower),cxy(upper));
  }
};

int main(){
  int n=read();
  std::vector<Point<double>>points;
  double ans=0;
  rep(i,0,n){
    ll a=read(); // [1e8,1e9]
    ll b=read();
    ll c=read();
    ans=std::max(ans,c*1.0/std::max(a,b));
    points.push_back(std::pair{a*1.0/c,b*1.0/c}); // [0.1,10]
  }
  ConvexHull<double> ch(points);
  if(n==1){
    printf("%.15lf\n",ans);
    return 0;
  }
  ans=std::max(ans,ch.cut());
  printf("%.15lf\n",ans);
  return 0;
}
```

# Ex - Monster

给定长N数组A

每次选区间 [l..r], 花费代价max(B[l..r]), 让A[l..r]-=1

让所有$A[i] <= 0$ 的最小代价和

## 范围

N 1e5

ai,bi [1,1e9]

2s

1024mb

## 我的思路

显然每次 全区间减一 是一个方案, 所以上限是 `max(Bi) * max(Ai)`

那么一个操作方案, 交换顺序 也会有同样的最终的A和代价, 所以顺序不影响 结果和代价

不会有 相邻的操作

`[a...b][b+1..c]`

这样的代价是`max(B[a..b])+max(B[b+1..c])`, 而直接`B[a..c]` 代价`=max(B[a..c])=max(max(B[a..b]),max(B[b+1..c]))`

`A[i] >= A[i+1], B[i] >= B[i+1]`, 那么必定每次选`i`的时候能白带上`i+1`, 因为至少`A[i]`次操作在`A[i]`上,且选的值`>=B[i]>=B[i+1]`, 所以如果没有选`i+1`,那么带上`i+1` 不会更差

因此 这种`i+1` 直接干掉, `A[i]>=A[i-1]`且`B[i]>=B[i-1]`同理

因此数组变成 若 `A[i] > A[i+1]` 则`B[i] < B[i+1]`

简而言之, 若A比相邻的大于, 则B比相邻的小于



## 题解


# 总结

G

计算几何 方向对了, 但是题意转化不尽人意, 搞出了需要找斜率的问题, 而题解里的转化成交点就显然很多了

Ex


# 参考

[官方题解](https://atcoder.jp/contests/abc275/editorial)

